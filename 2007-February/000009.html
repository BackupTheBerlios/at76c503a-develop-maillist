<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [at76c503a-develop] [patch] at76_usb wireless driver
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/at76c503a-develop/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:at76c503a-develop%40lists.berlios.de?Subject=Re%3A%20%5Bat76c503a-develop%5D%20%5Bpatch%5D%20at76_usb%20wireless%20driver&In-Reply-To=%3C20070223221230.GA9965%40bogon.ms20.nix%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[at76c503a-develop] [patch] at76_usb wireless driver</H1>
    <B>Guido Guenther</B> 
    <A HREF="mailto:at76c503a-develop%40lists.berlios.de?Subject=Re%3A%20%5Bat76c503a-develop%5D%20%5Bpatch%5D%20at76_usb%20wireless%20driver&In-Reply-To=%3C20070223221230.GA9965%40bogon.ms20.nix%3E"
       TITLE="[at76c503a-develop] [patch] at76_usb wireless driver">agx at sigxcpu.org
       </A><BR>
    <I>Fri Feb 23 23:12:30 CET 2007</I>
    <P><UL>
        
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9">[ date ]</a>
              <a href="thread.html#9">[ thread ]</a>
              <a href="subject.html#9">[ subject ]</a>
              <a href="author.html#9">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,
attached is a patch that adds the at76_usb wireless driver to
2.6.20. It supports the at76c503, at76c505 and at76c505a wireless
USB adapters.

Could you please comment on what needs to be adjusted to get the driver
included into the wireless linux git tree?

Please note that I'm not the author of the driver, the driver itself
lists these copyright holders (but none of them showed up on the
mailing list during the last couple of months):

Copyright (c) 2002 - 2003 Oliver Kurth
Copyright (c) 2004 Joerg Albert &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">joerg.albert at gmx.de</A>&gt;
Copyright (c) 2004 Nick Jones
Copyright (c) 2004 Balint Seeber &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">n0_5p4m_p13453 at hotmail.com</A>&gt;

Pavel Roskin, Maxim Grechkin and me were committing to CVS recently.

The projects homepage is:
    <A HREF="http://at76c503a.berlios.de/">http://at76c503a.berlios.de/</A>
I'm currently maintaining a (hopefully short lifed) git tree that
removes support for older kernels, older wireless extensions, C99 style
comments and commented out code. This is only done to ease reviewing -
there are no functional changes over the CVS archive:
    git-clone <A HREF="http://honk.sigxcpu.org/git/at76c503a.git/">http://honk.sigxcpu.org/git/at76c503a.git/</A>
The version in this repository is what's attached to this mail. The
driver was tested (and is in pracitical use) on at least i386, amd64 and
powerpc.
Cheers,
 -- Guido

Signed-Off-By: Guido Guenther &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">agx at sigxcpu.org</A>&gt;

diff --git a/MAINTAINERS b/MAINTAINERS
index 0ad8803..70dcecd 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -609,6 +609,12 @@ W:	<A HREF="http://www.thekelleys.org.uk/atmel">http://www.thekelleys.org.uk/atmel</A>
 W:	<A HREF="http://atmelwlandriver.sourceforge.net/">http://atmelwlandriver.sourceforge.net/</A>
 S:	Maintained
 
+ATMEL USB WIRELESS DRIVER
+M:	<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">at76c503a-develop at lists.berlios.de</A>
+L:	<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">at76c503a-user at lists.berlios.de</A>
+W:	<A HREF="http://at76c503a.berlios.de/">http://at76c503a.berlios.de/</A>
+S:	Maintained
+
 AUDIT SUBSYSTEM
 P:	David Woodhouse
 M:	<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">dwmw2 at infradead.org</A>
diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index ece3d9c..af482a2 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -394,6 +394,14 @@ config PCI_ATMEL
         Enable support for PCI and mini-PCI cards containing the
         Atmel at76c506 chip.
 
+config USB_ATMEL
+	tristate &quot;Atmel at76c503/at76c505/at76c505a USB cards&quot;
+	depends on NET_RADIO &amp;&amp; USB
+	select FW_LOADER
+	---help---
+	  Enable support for USB Wireless devices using Atmel at76c503,
+	  at76c505 or at76c505a chip.
+
 # If Pcmcia is compiled in, offer Pcmcia cards...
 comment &quot;Wireless 802.11b Pcmcia/Cardbus cards support&quot;
 	depends on NET_RADIO &amp;&amp; PCMCIA
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index c613af1..3ba079a 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -31,6 +31,9 @@ obj-$(CONFIG_AIRO_CS)		+= airo_cs.o airo.o
 obj-$(CONFIG_ATMEL)             += atmel.o
 obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
 obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
+obj-$(CONFIG_USB_ATMEL)	        += at76_usb.o
+
+at76_usb-objs := at76c503.o
 
 obj-$(CONFIG_PRISM54)		+= prism54/
 
diff --git a/drivers/net/wireless/at76c503.c b/drivers/net/wireless/at76c503.c
new file mode 100644
index 0000000..acb1634
--- /dev/null
+++ b/drivers/net/wireless/at76c503.c
@@ -0,0 +1,7122 @@
+/* -*- linux-c -*- */
+/*
+ * USB at76c503/at76c505 driver
+ *
+ * Copyright (c) 2002 - 2003 Oliver Kurth
+ * Copyright (c) 2004 Joerg Albert &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">joerg.albert at gmx.de</A>&gt;
+ * Copyright (c) 2004 Nick Jones
+ * Copyright (c) 2004 Balint Seeber &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">n0_5p4m_p13453 at hotmail.com</A>&gt;
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation; either version 2 of
+ *	the License, or (at your option) any later version.
+ *
+ * This file is part of the Berlios driver for WLAN USB devices based on the
+ * Atmel AT76C503A/505/505A. See at76c503.h for details.
+ *
+ * Some iw_handler code was taken from airo.c, (C) 1999 Benjamin Reed
+ */
+
+#ifndef AUTOCONF_INCLUDED
+#include &lt;linux/config.h&gt;
+#endif
+
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/version.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/poll.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/spinlock.h&gt;
+#include &lt;linux/list.h&gt;
+#include &lt;linux/usb.h&gt;
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/if_arp.h&gt;
+#include &lt;linux/etherdevice.h&gt;
+#include &lt;linux/ethtool.h&gt;
+#include &lt;linux/wireless.h&gt;
+#include &lt;net/iw_handler.h&gt;
+#include &lt;linux/rtnetlink.h&gt;  /* for rtnl_lock() */
+#include &lt;linux/firmware.h&gt;
+
+#ifdef CONFIG_IPAQ_HANDHELD
+#include &lt;asm/mach-types.h&gt;
+#include &lt;asm/arch/ipaq.h&gt;
+#include &lt;asm/arch-pxa/h5400-asic.h&gt;
+#include &lt;asm/arch-sa1100/h3600.h&gt;
+#endif
+
+#include &quot;at76c503.h&quot;
+
+/* timeout in seconds for the usb_control_msg in get_cmd_status
+ * and set_card_command
+ */
+#ifndef USB_CTRL_GET_TIMEOUT
+# define USB_CTRL_GET_TIMEOUT 5
+#endif
+
+/* number of endpoints of an interface */
+#define NUM_EP(intf) (intf)-&gt;altsetting[0].desc.bNumEndpoints
+#define EP(intf,nr) (intf)-&gt;altsetting[0].endpoint[(nr)].desc
+
+#define set_eth_hdr(s,p) (s)-&gt;mac.raw=(unsigned char *)(p)
+
+/* wireless extension level this source currently supports */
+#define WIRELESS_EXT_SUPPORTED	21
+
+#define FILL_BULK_URB(a,b,c,d,e,f,g) usb_fill_bulk_urb(a,b,c,d,e,f,g)
+
+int at76_debug = DBG_DEFAULTS;
+
+/* uncond. debug output */
+#define dbg_uc(format, arg...) \
+  printk(KERN_DEBUG __FILE__ &quot;: &quot; format &quot;\n&quot; , ## arg)
+
+#define assert(x) \
+  do {\
+   if (!(x)) \
+     err(&quot;%d: assertion &quot; #x &quot; failed&quot;, __LINE__);\
+  } while (0)
+
+/* how often do we re-try these packets ? */
+#define AUTH_RETRIES  3
+#define ASSOC_RETRIES 3
+#define DISASSOC_RETRIES 3
+
+
+static unsigned long spin_l_istate_flags;
+#define LOCK_ISTATE()   spin_lock_irqsave(&amp;dev-&gt;istate_spinlock,spin_l_istate_flags);
+#define UNLOCK_ISTATE() spin_unlock_irqrestore(&amp;dev-&gt;istate_spinlock,spin_l_istate_flags);
+
+
+#define NEW_STATE(dev,newstate) \
+  do {\
+    scan_hook(newstate == SCANNING);		\
+    LOCK_ISTATE()				\
+    dbg(DBG_PROGRESS, &quot;%s: state %d -&gt; %d (&quot; #newstate &quot;)&quot;,\
+        dev-&gt;netdev-&gt;name, dev-&gt;istate, newstate);\
+    dev-&gt;istate = newstate;\
+    UNLOCK_ISTATE()	  \
+  } while (0)
+
+/* the beacon timeout in infra mode when we are connected (in seconds) */
+#define BEACON_TIMEOUT 10
+
+/* the interval in ticks we poll if scan is completed */
+#define SCAN_POLL_INTERVAL (HZ/4)
+
+
+/* Version Information */
+#define DRIVER_NAME &quot;at76_usb&quot;
+#define DRIVER_AUTHOR \
+&quot;Oliver Kurth &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">oku at masqmail.cx</A>&gt;, Joerg Albert &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">joerg.albert at gmx.de</A>&gt;, &quot; \
+&quot;Alex &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">alex at foogod.com</A>&gt;, Nick Jones, Balint Seeber &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">n0_5p4m_p13453 at hotmail.com</A>&gt;&quot;
+#define DRIVER_DESC &quot;Atmel at76c50x USB Wireless LAN Driver&quot;
+
+
+/* Module paramaters */
+module_param_named(debug, at76_debug, int, 0600);
+MODULE_PARM_DESC(debug, &quot;Debugging level&quot;);
+
+static int rx_copybreak = 200;
+module_param(rx_copybreak, int, 0400);
+MODULE_PARM_DESC(rx_copybreak, &quot;rx packet copy threshold&quot;);
+
+static int scan_min_time = 10;
+module_param(scan_min_time, int, 0400);
+MODULE_PARM_DESC(scan_min_time, &quot;scan min channel time (default: 10)&quot;);
+
+static int scan_max_time = 120;
+module_param(scan_max_time, int, 0400);
+MODULE_PARM_DESC(scan_max_time, &quot;scan max channel time (default: 120)&quot;);
+
+static int scan_mode = SCAN_TYPE_ACTIVE;
+module_param(scan_mode, int, 0400);
+MODULE_PARM_DESC(scan_mode, &quot;scan mode: 0 active (with ProbeReq, default), 1 passive&quot;);
+
+static int preamble_type = PREAMBLE_TYPE_LONG;
+module_param(preamble_type, int, 0400);
+MODULE_PARM_DESC(preamble_type, &quot;preamble type: 0 long (default), 1 short&quot;);
+
+static int auth_mode = 0;
+module_param(auth_mode, int, 0400);
+MODULE_PARM_DESC(auth_mode, &quot;authentication mode: 0 open system (default), &quot;
+		 &quot;1 shared secret&quot;);
+
+static int pm_mode = PM_ACTIVE;
+module_param(pm_mode, int, 0400);
+MODULE_PARM_DESC(pm_mode, &quot;power management mode: 1 active (def.), 2 powersave, 3 smart save&quot;);
+
+static int pm_period = 0;
+module_param(pm_period, int, 0400);
+MODULE_PARM_DESC(pm_period, &quot;period of waking up the device in usec&quot;);
+
+static int international_roaming = IR_OFF;
+module_param(international_roaming, int, 0400);
+MODULE_PARM_DESC(international_roaming, &quot;enable international roaming: 0 (no, default), 1 (yes)&quot;);
+
+static int default_iw_mode = IW_MODE_INFRA;
+module_param(default_iw_mode, int, 0400);
+MODULE_PARM_DESC(default_iw_mode, &quot;default IW mode for a new device: &quot;
+		 &quot;1 (ad-hoc), 2 (infrastructure, def.), 6 (monitor mode)&quot;);
+
+static int monitor_scan_min_time = 50;
+module_param(monitor_scan_min_time, int, 0400);
+MODULE_PARM_DESC(monitor_scan_min_time, &quot;scan min channel time in MONITOR MODE (default: 50)&quot;);
+
+static int monitor_scan_max_time = 600;
+module_param(monitor_scan_max_time, int, 0400);
+MODULE_PARM_DESC(monitor_scan_max_time, &quot;scan max channel time in MONITOR MODE (default: 600)&quot;);
+
+static char* netdev_name = &quot;wlan%d&quot;;
+module_param(netdev_name, charp, 0400);
+MODULE_PARM_DESC(netdev_name, &quot;network device name (default is wlan%d)&quot;);
+
+
+#define DEF_RTS_THRESHOLD 1536
+#define DEF_FRAG_THRESHOLD 1536
+#define DEF_SHORT_RETRY_LIMIT 8
+#define DEF_CHANNEL 10
+
+#define MAX_RTS_THRESHOLD (MAX_FRAG_THRESHOLD + 1)
+
+/* The frequency of each channel in MHz */
+static const long channel_frequency[] = {
+        2412, 2417, 2422, 2427, 2432, 2437, 2442,
+        2447, 2452, 2457, 2462, 2467, 2472, 2484
+};
+#define NUM_CHANNELS ( sizeof(channel_frequency) / sizeof(channel_frequency[0]) )
+
+/* the broadcast address */
+static const u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+static const u8 off_addr[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+/* the supported rates of this hardware, bit7 marks a basic rate */
+static const u8 hw_rates[4] = {0x82,0x84,0x0b,0x16};
+
+/* the max padding size for tx in bytes (see calc_padding)*/
+#define MAX_PADDING_SIZE 53
+
+/* the size of the ieee802.11 header (excl. the at76c503 tx header) */
+#define IEEE802_11_MGMT_HEADER_SIZE offsetof(struct ieee80211_hdr_3addr, payload)
+
+#define BEACON_MAX_DATA_LENGTH 1500
+/* beacon in ieee80211_hdr_3addr.payload */
+struct ieee802_11_beacon_data {
+	u8	timestamp[8];           /* TSFTIMER */
+	__le16	beacon_interval;        /* Kms between TBTTs (Target Beacon Transmission Times) */
+	__le16	capability_information;
+	u8	data[BEACON_MAX_DATA_LENGTH]; /* contains: SSID (tag,length,value), 
+						 Supported Rates (tlv), channel */
+} __attribute__ ((packed));
+
+/* disassoc frame in ieee80211_hdr_3addr.payload */
+struct ieee802_11_disassoc_frame {
+	__le16 reason;
+} __attribute__ ((packed));
+#define DISASSOC_FRAME_SIZE \
+  (AT76C503_TX_HDRLEN + IEEE802_11_MGMT_HEADER_SIZE +\
+   sizeof(struct ieee802_11_disassoc_frame))
+
+/* assoc request in ieee80211_hdr_3addr.payload */
+struct ieee802_11_assoc_req {
+	__le16	capability;
+	__le16	listen_interval;
+	u8	data[1]; /* variable number of bytes for SSID 
+			 and supported rates (tlv coded) */
+};
+/* the maximum size of an AssocReq packet */
+#define ASSOCREQ_MAX_SIZE \
+  (AT76C503_TX_HDRLEN + IEEE802_11_MGMT_HEADER_SIZE +\
+   offsetof(struct ieee802_11_assoc_req,data) +\
+   1+1+IW_ESSID_MAX_SIZE + 1+1+4)
+
+/* reassoc request in ieee80211_hdr_3addr.payload */
+struct ieee802_11_reassoc_req {
+	__le16	capability;
+	__le16	listen_interval;
+	u8	curr_ap[ETH_ALEN]; /* the bssid of the AP we are
+				   currently associated to */
+	u8	data[1]; /* variable number of bytes for SSID 
+			 and supported rates (tlv coded) */
+} __attribute__ ((packed));
+
+/* the maximum size of an AssocReq packet */
+#define REASSOCREQ_MAX_SIZE \
+  (AT76C503_TX_HDRLEN + IEEE802_11_MGMT_HEADER_SIZE +\
+   offsetof(struct ieee802_11_reassoc_req,data) +\
+   1+1+IW_ESSID_MAX_SIZE + 1+1+4)
+
+
+/* assoc/reassoc response */
+struct ieee802_11_assoc_resp {
+	__le16	capability;
+	__le16	status;
+	__le16	assoc_id;
+	u8	data[1]; /* variable number of bytes for 
+			 supported rates (tlv coded) */
+} __attribute__ ((packed));
+
+/* auth. request/response in ieee80211_hdr_3addr.payload */
+struct ieee802_11_auth_frame {
+	__le16 algorithm;
+	__le16 seq_nr;
+	__le16 status;
+	u8 challenge[0];
+} __attribute__ ((packed));
+/* for shared secret auth, add the challenge text size */
+#define AUTH_FRAME_SIZE \
+  (AT76C503_TX_HDRLEN + IEEE802_11_MGMT_HEADER_SIZE +\
+   sizeof(struct ieee802_11_auth_frame))
+
+/* deauth frame in ieee80211_hdr_3addr.payload */
+struct ieee802_11_deauth_frame {
+	__le16 reason;
+} __attribute__ ((packed));
+#define DEAUTH_FRAME_SIZE \
+  (AT76C503_TX_HDRLEN + IEEE802_11_MGMT_HEADER_SIZE +\
+   sizeof(struct ieee802_11_disauth_frame))
+
+
+#define KEVENT_CTRL_HALT 1
+#define KEVENT_NEW_BSS 2
+#define KEVENT_SET_PROMISC 3
+#define KEVENT_MGMT_TIMEOUT 4
+#define KEVENT_SCAN 5 
+#define KEVENT_JOIN 6
+#define KEVENT_STARTIBSS 7
+#define KEVENT_SUBMIT_RX 8
+#define KEVENT_RESTART 9 /* restart the device */
+#define KEVENT_ASSOC_DONE  10 /* execute the power save settings:
+			     listen interval, pm mode, assoc id */
+#define KEVENT_EXTERNAL_FW  11
+#define KEVENT_INTERNAL_FW  12
+#define KEVENT_RESET_DEVICE 13
+
+
+static u8 snapsig[] = {0xaa, 0xaa, 0x03};
+/* RFC 1042 encapsulates Ethernet frames in 802.2 SNAP (0xaa, 0xaa, 0x03) with
+ * a SNAP OID of 0 (0x00, 0x00, 0x00) */
+static u8 rfc1042sig[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+
+/* local function prototypes */
+static void iwspy_update(struct at76c503 *dev, struct at76c503_rx_buffer *buf);
+
+static void at76c503_read_bulk_callback (struct urb *urb);
+static void at76c503_write_bulk_callback(struct urb *urb);
+static void defer_kevent (struct at76c503 *dev, int flag);
+static struct bss_info *find_matching_bss(struct at76c503 *dev,
+					  struct bss_info *curr);
+static int auth_req(struct at76c503 *dev, struct bss_info *bss, int seq_nr,
+		    u8 *challenge);
+static int disassoc_req(struct at76c503 *dev, struct bss_info *bss);
+static int assoc_req(struct at76c503 *dev, struct bss_info *bss);
+static int reassoc_req(struct at76c503 *dev, struct bss_info *curr,
+		       struct bss_info *new);
+static void dump_bss_table(struct at76c503 *dev, int force_output);
+static int submit_rx_urb(struct at76c503 *dev);
+static int startup_device(struct at76c503 *dev);
+
+static int set_iroaming(struct at76c503 *dev, int onoff);
+static void set_monitor_mode(struct at76c503 *dev, int use_prism);
+
+/* second step of initialization (after fw download) */
+static int init_new_device(struct at76c503 *dev);
+
+/* DFU states */
+#define STATE_IDLE  			0x00
+#define STATE_DETACH			0x01
+#define STATE_DFU_IDLE			0x02
+#define STATE_DFU_DOWNLOAD_SYNC		0x03
+#define STATE_DFU_DOWNLOAD_BUSY		0x04
+#define STATE_DFU_DOWNLOAD_IDLE		0x05
+#define STATE_DFU_MANIFEST_SYNC		0x06
+#define STATE_DFU_MANIFEST		0x07
+#define STATE_DFU_MANIFEST_WAIT_RESET	0x08
+#define STATE_DFU_UPLOAD_IDLE		0x09
+#define STATE_DFU_ERROR			0x0a
+
+/* DFU commands */
+#define DFU_DETACH			0
+#define DFU_DNLOAD			1
+#define DFU_UPLOAD			2
+#define DFU_GETSTATUS			3
+#define DFU_CLRSTATUS			4
+#define DFU_GETSTATE			5
+#define DFU_ABORT			6
+
+#define DFU_PACKETSIZE 1024
+
+#define USB_SUCCESS(a) ((a) &gt;= 0)
+
+struct dfu_status {
+	unsigned char bStatus;
+	unsigned char bwPollTimeout[3];
+	unsigned char bState;
+	unsigned char iString;
+} __attribute__ ((packed));
+
+/* driver independent download context */
+struct dfu_ctx {
+	struct usb_device *udev;
+	u8 dfu_state;
+	struct dfu_status dfu_status;
+	u8 *buf;
+};
+
+
+static
+int dfu_download_block(struct dfu_ctx *ctx, u8 *buffer,
+		       int bytes, int block)
+{
+	int result;
+	u8 *tmpbuf = ctx-&gt;buf;
+	struct usb_device *udev = ctx-&gt;udev;
+
+	dbg(DBG_DFU, &quot;dfu_download_block(): buffer=%p, bytes=%d, block=%d&quot;, buffer, bytes, block);
+
+	if(tmpbuf == NULL)
+		return -ENOMEM;
+
+	memcpy(tmpbuf, buffer, bytes);
+
+	result = usb_control_msg(udev, usb_sndctrlpipe(udev,0),
+				 DFU_DNLOAD,
+				 USB_TYPE_CLASS | USB_DIR_OUT | USB_RECIP_INTERFACE,
+				 block,	/* Value */
+				 0,	/* Index */
+				 tmpbuf,	/* Buffer */
+				 bytes,	/* Size */
+				 HZ);
+	return result;
+}
+
+static
+int dfu_get_status(struct dfu_ctx *ctx, struct dfu_status *status)
+{
+	int result;
+	struct usb_device *udev = ctx-&gt;udev;
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+				 DFU_GETSTATUS,
+				 USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,
+				 0,	/* Value */
+				 0,	/* Index */
+				 status,	/* Buffer */
+				 sizeof(struct dfu_status),	/* Size */
+				 HZ);
+
+	return result;
+}
+
+static
+u8 dfu_get_state(struct usb_device *udev, u8 *state)
+{
+	int result;
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+				 DFU_GETSTATE,	/* Request */
+				 USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,
+				 0,	/* Value */
+				 0,	/* Index */
+				 state,	/* Buffer */
+				 1,	/* Size */
+				 HZ);
+
+	return result;
+}
+
+static inline
+u32 __get_timeout(struct dfu_status *s)
+{
+	unsigned long ret = 0;
+
+	ret  = (unsigned long) (s-&gt;bwPollTimeout[2] &lt;&lt; 16);
+	ret |= (unsigned long) (s-&gt;bwPollTimeout[1] &lt;&lt; 8);
+	ret |= (unsigned long) (s-&gt;bwPollTimeout[0]);
+
+	return ret;
+}
+
+static
+struct dfu_ctx *dfu_alloc_ctx(struct usb_device *udev)
+{
+	struct dfu_ctx *ctx;
+
+	ctx = kmalloc(sizeof(struct dfu_ctx) + DFU_PACKETSIZE, GFP_KERNEL|GFP_DMA);
+	if(ctx){
+		ctx-&gt;udev = udev;
+		ctx-&gt;buf = (u8 *)&amp;(ctx[1]);
+	}
+	return ctx;
+}
+
+/* == PROC usbdfu_download ==
+   if manifest_sync_timeout &gt; 0 use this timeout (in msec) instead of the
+   one reported by the device in state MANIFEST_SYNC */
+static int usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
+			   u32 dfu_len, int manifest_sync_timeout)
+{
+	struct dfu_ctx *ctx;
+	struct dfu_status *dfu_stat_buf;
+	int status = 0;
+	int need_dfu_state = 1;
+	int is_done = 0;
+	u8 dfu_state = 0;
+	u32 dfu_timeout = 0;
+	int dfu_block_bytes = 0, dfu_bytes_left = dfu_len, dfu_buffer_offset = 0;
+	int dfu_block_cnt = 0;
+
+	dbg(DBG_DFU, &quot;%s( %p, %u, %d)&quot;, __FUNCTION__, dfu_buffer, 
+	    dfu_len, manifest_sync_timeout);
+
+	if (dfu_len == 0) {
+		err(&quot;FW Buffer length invalid!&quot;);
+		return -EINVAL;
+	}
+
+	ctx = dfu_alloc_ctx(udev);
+	if(ctx == NULL)
+		return -ENOMEM;
+
+	dfu_stat_buf = &amp;ctx-&gt;dfu_status;
+
+	do {
+		if (need_dfu_state) {
+			status = dfu_get_state(ctx-&gt;udev, &amp;ctx-&gt;dfu_state);
+			if (!USB_SUCCESS(status)) {
+				err(&quot;DFU: Failed to get DFU state: %d&quot;, status);
+				goto exit;
+			}
+			dfu_state = ctx-&gt;dfu_state;
+			need_dfu_state = 0;
+		}
+
+		switch (dfu_state) {
+		case STATE_DFU_DOWNLOAD_SYNC:
+			dbg(DBG_DFU, &quot;STATE_DFU_DOWNLOAD_SYNC&quot;);
+			status = dfu_get_status(ctx, dfu_stat_buf);
+			if (USB_SUCCESS(status)) {
+				dfu_state = dfu_stat_buf-&gt;bState;
+				dfu_timeout = __get_timeout(dfu_stat_buf);
+				need_dfu_state = 0;
+			} else
+				err(&quot;dfu_get_status failed with %d&quot;, status);
+			break;
+
+		case STATE_DFU_DOWNLOAD_BUSY:
+			dbg(DBG_DFU, &quot;STATE_DFU_DOWNLOAD_BUSY&quot;);
+			need_dfu_state = 1;
+
+			if (dfu_timeout &gt;= 0){
+				dbg(DBG_DFU, &quot;DFU: Resetting device&quot;);
+				set_current_state( TASK_INTERRUPTIBLE );
+				schedule_timeout(1+dfu_timeout*HZ/1000);
+			}else
+				dbg(DBG_DFU, &quot;DFU: In progress&quot;);
+
+			break;
+
+		case STATE_DFU_DOWNLOAD_IDLE:
+			dbg(DBG_DFU, &quot;DOWNLOAD...&quot;);
+			/* fall through */
+		case STATE_DFU_IDLE:
+			dbg(DBG_DFU, &quot;DFU IDLE&quot;);
+
+			if (dfu_bytes_left &lt;= DFU_PACKETSIZE)
+				dfu_block_bytes = dfu_bytes_left;
+			else
+				dfu_block_bytes = DFU_PACKETSIZE;
+
+			dfu_bytes_left -= dfu_block_bytes;
+			status = dfu_download_block(ctx,
+					      dfu_buffer +
+					      dfu_buffer_offset,
+					      dfu_block_bytes,
+					      dfu_block_cnt);
+			dfu_buffer_offset += dfu_block_bytes;
+			dfu_block_cnt++;
+
+			if (!USB_SUCCESS(status))
+				err(&quot;dfu_download_block failed with %d&quot;, status);
+			need_dfu_state = 1;
+			break;
+
+		case STATE_DFU_MANIFEST_SYNC:
+			dbg(DBG_DFU, &quot;STATE_DFU_MANIFEST_SYNC&quot;);
+
+			status = dfu_get_status(ctx, dfu_stat_buf);
+
+			if (USB_SUCCESS(status)) {
+				dfu_state = dfu_stat_buf-&gt;bState;
+				dfu_timeout = __get_timeout(dfu_stat_buf);
+				need_dfu_state = 0;
+
+				/* override the timeout from the status response,
+				   needed for AT76C505A */
+				if (manifest_sync_timeout &gt; 0)
+					dfu_timeout = manifest_sync_timeout;
+
+				if (dfu_timeout &gt;= 0){
+					dbg(DBG_DFU, &quot;DFU: Waiting for manifest phase&quot;);
+
+					set_current_state( TASK_INTERRUPTIBLE );
+					schedule_timeout((dfu_timeout*HZ+999)/1000);
+				}else
+					dbg(DBG_DFU, &quot;DFU: In progress&quot;);
+			}
+			break;
+
+		case STATE_DFU_MANIFEST:
+			dbg(DBG_DFU, &quot;STATE_DFU_MANIFEST&quot;);
+			is_done = 1;
+			break;
+
+		case STATE_DFU_MANIFEST_WAIT_RESET:
+			dbg(DBG_DFU, &quot;STATE_DFU_MANIFEST_WAIT_RESET&quot;);
+			is_done = 1;
+			break;
+
+		case STATE_DFU_UPLOAD_IDLE:
+			dbg(DBG_DFU, &quot;STATE_DFU_UPLOAD_IDLE&quot;);
+			break;
+
+		case STATE_DFU_ERROR:
+			dbg(DBG_DFU, &quot;STATE_DFU_ERROR&quot;);
+			status = -EPIPE;
+			break;
+
+		default:
+			dbg(DBG_DFU, &quot;DFU UNKNOWN STATE (%d)&quot;, dfu_state);
+			status = -EINVAL;
+			break;
+		}
+	} while (!is_done &amp;&amp; USB_SUCCESS(status));
+
+ exit:
+	kfree(ctx);
+	if (status &lt; 0)
+		return status;
+	else
+		return 0;
+}
+
+/* some abbrev. for wireless events */
+static inline void iwevent_scan_complete(struct net_device *dev)
+{
+	union iwreq_data wrqu;
+	wrqu.data.length = 0;
+	wrqu.data.flags = 0;
+	wireless_send_event(dev, SIOCGIWSCAN, &amp;wrqu, NULL);
+	dbg(DBG_WE_EVENTS, &quot;%s: SIOCGIWSCAN sent&quot;, dev-&gt;name);
+}
+static inline void iwevent_bss_connect(struct net_device *dev, u8 *bssid)
+{
+	union iwreq_data wrqu;
+	wrqu.data.length = 0;
+	wrqu.data.flags = 0;
+	memcpy(wrqu.ap_addr.sa_data, bssid, ETH_ALEN);
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	wireless_send_event(dev, SIOCGIWAP, &amp;wrqu, NULL);
+	dbg(DBG_WE_EVENTS, &quot;%s: %s: SIOCGIWAP sent&quot;, dev-&gt;name, __FUNCTION__);
+}
+
+static inline void iwevent_bss_disconnect(struct net_device *dev)
+{
+	union iwreq_data wrqu;
+	wrqu.data.length = 0;
+	wrqu.data.flags = 0;
+	memset(wrqu.ap_addr.sa_data, '\0', ETH_ALEN);
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	wireless_send_event(dev, SIOCGIWAP, &amp;wrqu, NULL);
+	dbg(DBG_WE_EVENTS, &quot;%s: %s: SIOCGIWAP sent&quot;, dev-&gt;name, __FUNCTION__);
+}
+
+
+/* hexdump len many bytes from buf into obuf, separated by delim,
+   add a trailing \0 into obuf */
+static char *hex2str(char *obuf, u8 *buf, int len, char delim)
+{
+#define BIN2HEX(x) ((x) &lt; 10 ? '0'+(x) : (x)+'A'-10)
+
+  char *ret = obuf;
+  while (len--) {
+    *obuf++ = BIN2HEX(*buf&gt;&gt;4);
+    *obuf++ = BIN2HEX(*buf&amp;0xf);
+    if (delim != '\0')
+      *obuf++ = delim;
+    buf++;
+  }
+  if (delim != '\0' &amp;&amp; obuf &gt; ret)
+	  obuf--; /* remove last inserted delimiter */
+  *obuf = '\0';
+
+  return ret;
+}
+
+/* == PROC is_cloaked_ssid ==
+   returns != 0, if the given SSID is a cloaked one:
+   - length 0
+   - length &gt; 0, all bytes are \0
+   - length == 1, SSID ' '
+*/
+static inline int is_cloaked_ssid(u8 *ssid, int length)
+{
+	static const u8 zeros[32];
+
+	return (length == 0) || 
+		(length == 1 &amp;&amp; *ssid == ' ') ||
+		(length &gt; 0 &amp;&amp; !memcmp(ssid,zeros,length));
+}
+
+static inline void free_bss_list(struct at76c503 *dev)
+{
+	struct list_head *next, *ptr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;dev-&gt;bss_list_spinlock, flags);
+
+	dev-&gt;curr_bss = dev-&gt;new_bss = NULL;
+
+	list_for_each_safe(ptr, next, &amp;dev-&gt;bss_list) {
+		list_del(ptr);
+		kfree(list_entry(ptr, struct bss_info, list));
+	}
+
+	spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
+}
+
+static inline char *mac2str(u8 *mac)
+{
+	static char str [6*3];
+  
+	sprintf(str, &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,
+		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	return str;
+}
+
+static void scan_hook(int blink)
+{
+#ifdef CONFIG_IPAQ_HANDHELD
+	if (machine_is_h5400()) {
+		if (blink)
+			ipaq_led_blink (RED_LED, 1, 2);
+		else
+			ipaq_led_off (RED_LED);
+	}
+#endif
+}
+
+
+static int at76c503_remap(struct usb_device *udev)
+{
+	int ret;
+	ret = usb_control_msg(udev, usb_sndctrlpipe(udev,0),
+			      0x0a, INTERFACE_VENDOR_REQUEST_OUT,
+			      0, 0,
+			      NULL, 0, HZ * USB_CTRL_GET_TIMEOUT);
+	if (ret &lt; 0)
+		return ret;
+
+	return 0;
+}
+
+
+static int get_op_mode(struct usb_device *udev)
+{
+	int ret;
+	u8 op_mode;
+
+	ret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+			      0x33, INTERFACE_VENDOR_REQUEST_IN,
+			      0x01, 0,
+			      &amp;op_mode, 1, HZ * USB_CTRL_GET_TIMEOUT);
+	if(ret &lt; 0)
+		return ret;
+	return op_mode;
+}
+
+/* this loads a block of the second part of the firmware */
+static inline int load_ext_fw_block(struct usb_device *udev,
+		      int i, unsigned char *buf, int bsize)
+{
+	return usb_control_msg(udev, usb_sndctrlpipe(udev,0),
+			       0x0e, DEVICE_VENDOR_REQUEST_OUT,
+			       0x0802, i,
+			       buf, bsize, HZ * USB_CTRL_GET_TIMEOUT);
+}
+
+static inline int get_hw_cfg_rfmd(struct usb_device *udev,
+	       unsigned char *buf, int buf_size)
+{
+	return usb_control_msg(udev, usb_rcvctrlpipe(udev,0),
+			       0x33, INTERFACE_VENDOR_REQUEST_IN,
+			       ((0x0a &lt;&lt; 8) | 0x02), 0,
+			       buf, buf_size, HZ * USB_CTRL_GET_TIMEOUT);
+}
+
+/* Intersil boards use a different &quot;value&quot; for GetHWConfig requests */
+static inline
+int get_hw_cfg_intersil(struct usb_device *udev,
+	       unsigned char *buf, int buf_size)
+{
+	return usb_control_msg(udev, usb_rcvctrlpipe(udev,0),
+			       0x33, INTERFACE_VENDOR_REQUEST_IN,
+			       ((0x09 &lt;&lt; 8) | 0x02), 0,
+			       buf, buf_size, HZ * USB_CTRL_GET_TIMEOUT);
+}
+
+/* Get the hardware configuration for the adapter and place the appropriate
+ * data in the appropriate fields of 'dev' (the GetHWConfig request and
+ * interpretation of the result depends on the type of board we're dealing
+ * with) */
+static int get_hw_config(struct at76c503 *dev)
+{
+	int ret;
+	union {
+		struct hwcfg_intersil i;
+		struct hwcfg_rfmd     r3;
+		struct hwcfg_r505     r5;
+	} *hwcfg = kmalloc(sizeof(*hwcfg), GFP_KERNEL);
+
+	if (!hwcfg)
+		return -ENOMEM;
+
+	switch (dev-&gt;board_type) {
+
+	  case BOARDTYPE_503_INTERSIL_3861:
+	  case BOARDTYPE_503_INTERSIL_3863:
+		ret = get_hw_cfg_intersil(dev-&gt;udev, (unsigned char *)&amp;hwcfg-&gt;i, sizeof(hwcfg-&gt;i));
+		if (ret &lt; 0) break;
+		memcpy(dev-&gt;mac_addr, hwcfg-&gt;i.mac_addr, ETH_ALEN);
+		memcpy(dev-&gt;cr31_values, hwcfg-&gt;i.cr31_values, 14);
+		memcpy(dev-&gt;cr58_values, hwcfg-&gt;i.cr58_values, 14);
+		memcpy(dev-&gt;pidvid, hwcfg-&gt;i.pidvid, 4);
+		dev-&gt;regulatory_domain = hwcfg-&gt;i.regulatory_domain;
+		break;
+
+	  case BOARDTYPE_503_RFMD:
+	  case BOARDTYPE_503_RFMD_ACC:
+		ret = get_hw_cfg_rfmd(dev-&gt;udev, (unsigned char *)&amp;hwcfg-&gt;r3, sizeof(hwcfg-&gt;r3));
+		if (ret &lt; 0) break;
+		memcpy(dev-&gt;cr20_values, hwcfg-&gt;r3.cr20_values, 14);
+		memcpy(dev-&gt;cr21_values, hwcfg-&gt;r3.cr21_values, 14);
+		memcpy(dev-&gt;bb_cr, hwcfg-&gt;r3.bb_cr, 14);
+		memcpy(dev-&gt;pidvid, hwcfg-&gt;r3.pidvid, 4);
+		memcpy(dev-&gt;mac_addr, hwcfg-&gt;r3.mac_addr, ETH_ALEN);
+		dev-&gt;regulatory_domain = hwcfg-&gt;r3.regulatory_domain;
+		memcpy(dev-&gt;low_power_values, hwcfg-&gt;r3.low_power_values, 14);
+		memcpy(dev-&gt;normal_power_values, hwcfg-&gt;r3.normal_power_values, 14);
+		break;
+
+	  case BOARDTYPE_505_RFMD:
+	  case BOARDTYPE_505_RFMD_2958:
+	  case BOARDTYPE_505A_RFMD_2958:
+		ret = get_hw_cfg_rfmd(dev-&gt;udev, (unsigned char *)&amp;hwcfg-&gt;r5, sizeof(hwcfg-&gt;r5));
+		if (ret &lt; 0) break;
+		memcpy(dev-&gt;cr39_values, hwcfg-&gt;r5.cr39_values, 14);
+		memcpy(dev-&gt;bb_cr, hwcfg-&gt;r5.bb_cr, 14);
+		memcpy(dev-&gt;pidvid, hwcfg-&gt;r5.pidvid, 4);
+		memcpy(dev-&gt;mac_addr, hwcfg-&gt;r5.mac_addr, ETH_ALEN);
+		dev-&gt;regulatory_domain = hwcfg-&gt;r5.regulatory_domain;
+		memcpy(dev-&gt;cr15_values, hwcfg-&gt;r5.cr15_values, 14);
+		break;
+
+	  default:
+		err(&quot;Bad board type set (%d).  Unable to get hardware config.&quot;, dev-&gt;board_type);
+		ret = -EINVAL;
+	}
+
+	kfree(hwcfg);
+
+	if (ret &lt; 0) {
+		err(&quot;Get HW Config failed (%d)&quot;, ret);
+	}
+	return ret;
+}
+
+/* == PROC getRegDomain == */
+static struct reg_domain const *getRegDomain(u16 code)
+{
+	static struct reg_domain const fd_tab[] = {
+		{0x10, &quot;FCC (U.S)&quot;, 0x7ff}, /* ch 1-11 */
+		{0x20, &quot;IC (Canada)&quot;, 0x7ff}, /* ch 1-11 */
+		{0x30, &quot;ETSI (Europe - (Spain+France)&quot;, 0x1fff},  /* ch 1-13 */
+		{0x31, &quot;Spain&quot;, 0x600},    /* ch 10,11 */
+		{0x32, &quot;France&quot;, 0x1e00},  /* ch 10-13 */
+		{0x40, &quot;MKK (Japan)&quot;, 0x2000},  /* ch 14 */
+		{0x41, &quot;MKK1 (Japan)&quot;, 0x3fff},  /* ch 1-14 */
+		{0x50, &quot;Israel&quot;, 0x3fc},  /* ch 3-9 */
+	};
+	static int const tab_len = sizeof(fd_tab) / sizeof(struct reg_domain);
+
+	/* use this if an unknown code comes in */
+	static struct reg_domain const unknown = 
+		{0, &quot;&lt;unknown&gt;&quot;, 0xffffffff};
+  
+	int i;
+
+	for(i=0; i &lt; tab_len; i++)
+		if (code == fd_tab[i].code)
+			break;
+  
+	return (i &gt;= tab_len) ? &amp;unknown : &amp;fd_tab[i];
+} /* getFreqDomain */
+
+static inline int get_mib(struct usb_device *udev,
+	    u16 mib, u8 *buf, int buf_size)
+{
+	return usb_control_msg(udev, usb_rcvctrlpipe(udev,0),
+			       0x33, INTERFACE_VENDOR_REQUEST_IN,
+			       mib &lt;&lt; 8, 0,
+			       buf, buf_size, HZ * USB_CTRL_GET_TIMEOUT);
+}
+
+static inline int get_cmd_status(struct usb_device *udev,
+		   u8 cmd, u8 *cmd_status)
+{
+	return usb_control_msg(udev, usb_rcvctrlpipe(udev,0),
+			       0x22, INTERFACE_VENDOR_REQUEST_IN,
+			       cmd, 0,
+			       cmd_status, 40, HZ * USB_CTRL_GET_TIMEOUT);
+}
+
+#define EXT_FW_BLOCK_SIZE 1024
+static int download_external_fw(struct usb_device *udev, u8 *buf, int size)
+{
+	int i = 0, ret = 0;
+	u8 *block;
+
+	if (size &lt; 0) return -EINVAL;
+	if ((size &gt; 0) &amp;&amp; (buf == NULL)) return -EFAULT;
+
+	block = kmalloc(EXT_FW_BLOCK_SIZE, GFP_KERNEL);
+	if (block == NULL) return -ENOMEM;
+
+	dbg(DBG_DEVSTART, &quot;downloading external firmware&quot;);
+
+	while(size &gt; 0){
+		int bsize = size &gt; EXT_FW_BLOCK_SIZE ? EXT_FW_BLOCK_SIZE : size;
+
+		memcpy(block, buf, bsize);
+		dbg(DBG_DEVSTART,
+		    &quot;ext fw, size left = %5d, bsize = %4d, i = %2d&quot;, size, bsize, i);
+		if((ret = load_ext_fw_block(udev, i, block, bsize)) &lt; 0){
+			err(&quot;load_ext_fw_block failed: %d, i = %d&quot;, ret, i);
+			goto exit;
+		}
+		buf += bsize;
+		size -= bsize;
+		i++;
+	}
+
+	/* for fw &gt;= 0.100, the device needs
+	   an extra empty block: */
+	if((ret = load_ext_fw_block(udev, i, block, 0)) &lt; 0){
+		err(&quot;load_ext_fw_block failed: %d, i = %d&quot;, ret, i);
+		goto exit;
+	}
+
+ exit:
+	kfree(block);
+	return ret;
+}
+
+static int set_card_command(struct usb_device *udev, int cmd,
+		    unsigned char *buf, int buf_size)
+{
+	int ret;
+	struct at76c503_command *cmd_buf =
+		(struct at76c503_command *)kmalloc(
+			sizeof(struct at76c503_command) + buf_size,
+			GFP_KERNEL);
+
+	if(cmd_buf){
+		cmd_buf-&gt;cmd = cmd;
+		cmd_buf-&gt;reserved = 0;
+		cmd_buf-&gt;size = cpu_to_le16(buf_size);
+		if(buf_size &gt; 0)
+			memcpy(&amp;(cmd_buf[1]), buf, buf_size);
+		ret = usb_control_msg(udev, usb_sndctrlpipe(udev,0),
+				      0x0e, DEVICE_VENDOR_REQUEST_OUT,
+				      0, 0,
+				      cmd_buf,
+				      sizeof(struct at76c503_command) + buf_size,
+				      HZ * USB_CTRL_GET_TIMEOUT);
+		kfree(cmd_buf);
+		return ret;
+	}
+
+	return -ENOMEM;
+}
+
+#define MAKE_CMD_STATUS_CASE(c)	case (c): return #c
+
+static const char* get_cmd_status_string(u8 cmd_status)
+{
+	switch (cmd_status)
+	{
+		MAKE_CMD_STATUS_CASE(CMD_STATUS_IDLE);
+		MAKE_CMD_STATUS_CASE(CMD_STATUS_COMPLETE);
+		MAKE_CMD_STATUS_CASE(CMD_STATUS_UNKNOWN);
+		MAKE_CMD_STATUS_CASE(CMD_STATUS_INVALID_PARAMETER);
+		MAKE_CMD_STATUS_CASE(CMD_STATUS_FUNCTION_NOT_SUPPORTED);
+		MAKE_CMD_STATUS_CASE(CMD_STATUS_TIME_OUT);
+		MAKE_CMD_STATUS_CASE(CMD_STATUS_IN_PROGRESS);
+		MAKE_CMD_STATUS_CASE(CMD_STATUS_HOST_FAILURE);
+		MAKE_CMD_STATUS_CASE(CMD_STATUS_SCAN_FAILED);
+	}
+
+	return &quot;UNKNOWN&quot;;
+}
+
+/* TODO: should timeout */
+static int wait_completion(struct at76c503 *dev, int cmd)
+{
+	u8 *cmd_status = kmalloc(40, GFP_KERNEL);
+	struct net_device *netdev = dev-&gt;netdev;
+	int ret = 0;
+
+	do{
+		ret = get_cmd_status(dev-&gt;udev, cmd, cmd_status);
+		if(ret &lt; 0){
+			err(&quot;%s: get_cmd_status failed: %d&quot;, netdev-&gt;name, ret);
+			break;
+		}
+
+		dbg(DBG_WAIT_COMPLETE, &quot;%s: Waiting on cmd %d, cmd_status[5] = %d (%s)&quot;,
+		    dev-&gt;netdev-&gt;name, cmd, cmd_status[5], get_cmd_status_string(cmd_status[5]));
+
+		if(cmd_status[5] == CMD_STATUS_IN_PROGRESS ||
+		   cmd_status[5] == CMD_STATUS_IDLE){
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10); /* 100 ms */
+		}else break;
+	}while(1);
+
+	if (ret &gt;= 0)
+		/* if get_cmd_status did not fail, return the status
+		   retrieved */
+		ret = cmd_status[5];
+	kfree(cmd_status);
+	return ret;
+}
+
+static int set_mib(struct at76c503 *dev, struct set_mib_buffer *buf)
+{
+	struct usb_device *udev = dev-&gt;udev;
+	int ret;
+	struct at76c503_command *cmd_buf =
+		(struct at76c503_command *)kmalloc(
+			sizeof(struct at76c503_command) + buf-&gt;size + 4,
+			GFP_KERNEL);
+
+	if(cmd_buf){
+		cmd_buf-&gt;cmd = CMD_SET_MIB;
+		cmd_buf-&gt;reserved = 0;
+		cmd_buf-&gt;size = cpu_to_le16(buf-&gt;size + 4);
+		memcpy(&amp;(cmd_buf[1]), buf, buf-&gt;size + 4);
+		ret = usb_control_msg(udev, usb_sndctrlpipe(udev,0),
+				      0x0e, DEVICE_VENDOR_REQUEST_OUT,
+				      0, 0,
+				      cmd_buf,
+				      sizeof(struct at76c503_command) + buf-&gt;size + 4,
+				      HZ * USB_CTRL_GET_TIMEOUT);
+		if (ret &gt;= 0)
+			if ((ret=wait_completion(dev, CMD_SET_MIB)) != 
+			    CMD_STATUS_COMPLETE) {
+				info(&quot;%s: set_mib: wait_completion failed with %d&quot;,
+				     dev-&gt;netdev-&gt;name, ret);
+				ret = -156; /* ??? */
+			}
+		kfree(cmd_buf);
+		return ret;
+	}
+
+	return -ENOMEM;
+}
+
+/* return &lt; 0 on error, == 0 if no command sent, == 1 if cmd sent */
+static int set_radio(struct at76c503 *dev, int on_off)
+{
+	int ret;
+
+	if(dev-&gt;radio_on != on_off){
+		ret = set_card_command(dev-&gt;udev, CMD_RADIO, NULL, 0);
+		if(ret &lt; 0){
+			err(&quot;%s: set_card_command(CMD_RADIO) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		} else
+			ret = 1;
+		dev-&gt;radio_on = on_off;
+	} else
+		ret = 0;
+	return ret;
+}
+
+
+/* == PROC set_pm_mode ==
+   sets power save modi (PM_ACTIVE/PM_SAVE/PM_SMART_SAVE) */
+static int set_pm_mode(struct at76c503 *dev, u8 mode)
+{
+	int ret = 0;
+
+	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev-&gt;mib_buf.type = MIB_MAC_MGMT;
+	dev-&gt;mib_buf.size = 1;
+	dev-&gt;mib_buf.index = POWER_MGMT_MODE_OFFSET;
+
+	dev-&gt;mib_buf.data[0] = mode;
+
+	ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+	if(ret &lt; 0){
+		err(&quot;%s: set_mib (pm_mode) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+	return ret;
+}
+
+/* == PROC set_associd ==
+   sets the assoc id for power save mode */
+static int set_associd(struct at76c503 *dev, u16 id)
+{
+	int ret = 0;
+
+	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev-&gt;mib_buf.type = MIB_MAC_MGMT;
+	dev-&gt;mib_buf.size = 2;
+	dev-&gt;mib_buf.index = STATION_ID_OFFSET;
+
+	dev-&gt;mib_buf.data[0] = id &amp; 0xff;
+	dev-&gt;mib_buf.data[1] = id &gt;&gt; 8;
+
+	ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+	if(ret &lt; 0){
+		err(&quot;%s: set_mib (associd) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+	return ret;
+}
+
+/* == PROC set_listen_interval ==
+   sets the listen interval for power save mode.
+   really needed, as we have a similar parameter in the assocreq ??? */
+static int set_listen_interval(struct at76c503 *dev, u16 interval)
+{
+	int ret = 0;
+
+	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev-&gt;mib_buf.type = MIB_MAC;
+	dev-&gt;mib_buf.size = 2;
+	dev-&gt;mib_buf.index = STATION_ID_OFFSET;
+
+	dev-&gt;mib_buf.data[0] = interval &amp; 0xff;
+	dev-&gt;mib_buf.data[1] = interval &gt;&gt; 8;
+
+	ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+	if(ret &lt; 0){
+		err(&quot;%s: set_mib (listen_interval) failed: %d&quot;,
+		    dev-&gt;netdev-&gt;name, ret);
+	}
+	return ret;
+}
+
+static int set_preamble(struct at76c503 *dev, u8 type)
+{
+	int ret = 0;
+
+	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev-&gt;mib_buf.type = MIB_LOCAL;
+	dev-&gt;mib_buf.size = 1;
+	dev-&gt;mib_buf.index = PREAMBLE_TYPE_OFFSET;
+	dev-&gt;mib_buf.data[0] = type;
+	ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+	if(ret &lt; 0){
+		err(&quot;%s: set_mib (preamble) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+	return ret;
+}
+
+static int set_frag(struct at76c503 *dev, u16 size)
+{
+	int ret = 0;
+
+	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev-&gt;mib_buf.type = MIB_MAC;
+	dev-&gt;mib_buf.size = 2;
+	dev-&gt;mib_buf.index = FRAGMENTATION_OFFSET;
+	*(__le16*)dev-&gt;mib_buf.data = cpu_to_le16(size);
+	ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+	if(ret &lt; 0){
+		err(&quot;%s: set_mib (frag threshold) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+	return ret;
+}
+
+static int set_rts(struct at76c503 *dev, u16 size)
+{
+	int ret = 0;
+
+	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev-&gt;mib_buf.type = MIB_MAC;
+	dev-&gt;mib_buf.size = 2;
+	dev-&gt;mib_buf.index = RTS_OFFSET;
+	*(__le16*)dev-&gt;mib_buf.data = cpu_to_le16(size);
+	ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+	if(ret &lt; 0){
+		err(&quot;%s: set_mib (rts) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+	return ret;
+}
+
+static int set_autorate_fallback(struct at76c503 *dev, int onoff)
+{
+	int ret = 0;
+
+	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev-&gt;mib_buf.type = MIB_LOCAL;
+	dev-&gt;mib_buf.size = 1;
+	dev-&gt;mib_buf.index = TX_AUTORATE_FALLBACK_OFFSET;
+	dev-&gt;mib_buf.data[0] = onoff;
+	ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+	if(ret &lt; 0){
+		err(&quot;%s: set_mib (autorate fallback) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+	return ret;
+}
+
+static int set_mac_address(struct at76c503 *dev, void *addr)
+{
+        int ret = 0;
+
+        memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+        dev-&gt;mib_buf.type = MIB_MAC_ADD;
+        dev-&gt;mib_buf.size = ETH_ALEN;
+        dev-&gt;mib_buf.index = offsetof(struct mib_mac_addr, mac_addr);
+        memcpy(dev-&gt;mib_buf.data, addr, ETH_ALEN);
+        ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+        if(ret &lt; 0){
+                err(&quot;%s: set_mib (MAC_ADDR, mac_addr) failed: %d&quot;,
+                    dev-&gt;netdev-&gt;name, ret);
+        }
+        return ret;
+}
+
+#if 0
+/* implemented to get promisc. mode working, but does not help.
+   May still be useful for multicast eventually. */
+static int set_group_address(struct at76c503 *dev, u8 *addr, int n)
+{
+        int ret = 0;
+
+        memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+        dev-&gt;mib_buf.type = MIB_MAC_ADD;
+        dev-&gt;mib_buf.size = ETH_ALEN;
+        dev-&gt;mib_buf.index = offsetof(struct mib_mac_addr, group_addr) + n*ETH_ALEN;
+        memcpy(dev-&gt;mib_buf.data, addr, ETH_ALEN);
+        ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+        if(ret &lt; 0){
+                err(&quot;%s: set_mib (MIB_MAC_ADD, group_addr) failed: %d&quot;,
+                    dev-&gt;netdev-&gt;name, ret);
+        }
+
+#if 1
+	/* I do not know anything about the group_addr_status field... (oku) */
+        memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+        dev-&gt;mib_buf.type = MIB_MAC_ADD;
+        dev-&gt;mib_buf.size = 1;
+        dev-&gt;mib_buf.index = offsetof(struct mib_mac_addr, group_addr_status) + n;
+        dev-&gt;mib_buf.data[0] = 1;
+        ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+        if(ret &lt; 0){
+                err(&quot;%s: set_mib (MIB_MAC_ADD, group_addr_status) failed: %d&quot;,
+                    dev-&gt;netdev-&gt;name, ret);
+        }
+#endif
+        return ret;
+}
+#endif
+
+static int set_promisc(struct at76c503 *dev, int onoff)
+{
+	int ret = 0;
+
+	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev-&gt;mib_buf.type = MIB_LOCAL;
+	dev-&gt;mib_buf.size = 1;
+	dev-&gt;mib_buf.index = offsetof(struct mib_local, promiscuous_mode);
+	dev-&gt;mib_buf.data[0] = onoff ? 1 : 0;
+	ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+	if(ret &lt; 0){
+		err(&quot;%s: set_mib (promiscuous_mode) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+	return ret;
+}
+
+static int dump_mib_mac_addr(struct at76c503 *dev)
+{
+	int ret = 0;
+	struct mib_mac_addr *mac_addr =
+		kmalloc(sizeof(struct mib_mac_addr), GFP_KERNEL);
+
+	if(!mac_addr){
+		ret = -ENOMEM;
+		goto exit;
+	}
+	
+	ret = get_mib(dev-&gt;udev, MIB_MAC_ADD,
+		      (u8*)mac_addr, sizeof(struct mib_mac_addr));
+	if(ret &lt; 0){
+		err(&quot;%s: get_mib (MAC_ADDR) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		goto err;
+	}
+
+	dbg_uc(&quot;%s: MIB MAC_ADDR: mac_addr %s res 0x%x 0x%x group_addr %s status %d %d %d %d&quot;, 
+	       dev-&gt;netdev-&gt;name, mac2str(mac_addr-&gt;mac_addr),
+		   mac_addr-&gt;res[0], mac_addr-&gt;res[1],
+	       hex2str(dev-&gt;obuf, (u8 *)mac_addr-&gt;group_addr, 
+		       min((int)(sizeof(dev-&gt;obuf)-1)/2, 4*ETH_ALEN), '\0'),
+	       mac_addr-&gt;group_addr_status[0], mac_addr-&gt;group_addr_status[1],
+	       mac_addr-&gt;group_addr_status[2], mac_addr-&gt;group_addr_status[3]);
+
+ err:
+	kfree(mac_addr);
+ exit:
+	return ret;
+}
+
+static int dump_mib_mac_wep(struct at76c503 *dev)
+{
+	int ret = 0;
+	struct mib_mac_wep *mac_wep =
+		kmalloc(sizeof(struct mib_mac_wep), GFP_KERNEL);
+
+	if(!mac_wep){
+		ret = -ENOMEM;
+		goto exit;
+	}
+	
+	ret = get_mib(dev-&gt;udev, MIB_MAC_WEP,
+		      (u8*)mac_wep, sizeof(struct mib_mac_wep));
+	if(ret &lt; 0){
+		err(&quot;%s: get_mib (MAC_WEP) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		goto err;
+	}
+
+	dbg_uc(&quot;%s: MIB MAC_WEP: priv_invoked %u def_key_id %u key_len %u &quot;
+	    &quot;excl_unencr %u wep_icv_err %u wep_excluded %u encr_level %u key %d: %s&quot;,
+	    dev-&gt;netdev-&gt;name, mac_wep-&gt;privacy_invoked,
+	    mac_wep-&gt;wep_default_key_id, mac_wep-&gt;wep_key_mapping_len,
+	    mac_wep-&gt;exclude_unencrypted,le32_to_cpu( mac_wep-&gt;wep_icv_error_count),
+	    le32_to_cpu(mac_wep-&gt;wep_excluded_count),
+	    mac_wep-&gt;encryption_level, mac_wep-&gt;wep_default_key_id,
+	    mac_wep-&gt;wep_default_key_id &lt; 4 ?
+	    hex2str(dev-&gt;obuf,
+		    mac_wep-&gt;wep_default_keyvalue[mac_wep-&gt;wep_default_key_id],
+		    min((int)(sizeof(dev-&gt;obuf)-1)/2,
+			mac_wep-&gt;encryption_level == 2 ? 13 : 5), '\0') :
+	       &quot;&lt;invalid key id&gt;&quot;);
+
+ err:
+	kfree(mac_wep);
+ exit:
+	return ret;
+}
+
+static int dump_mib_mac_mgmt(struct at76c503 *dev)
+{
+	int ret = 0;
+	struct mib_mac_mgmt *mac_mgmt =
+		kmalloc(sizeof(struct mib_mac_mgmt), GFP_KERNEL);
+	char country_string[4];
+
+	if(!mac_mgmt){
+		ret = -ENOMEM;
+		goto exit;
+	}
+	
+	ret = get_mib(dev-&gt;udev, MIB_MAC_MGMT,
+		      (u8*)mac_mgmt, sizeof(struct mib_mac_mgmt));
+	if(ret &lt; 0){
+		err(&quot;%s: get_mib failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		goto err;
+	}
+
+	memcpy(&amp;country_string, mac_mgmt-&gt;country_string, 3);
+	country_string[3] = '\0';
+
+	dbg_uc(&quot;%s: MIB MAC_MGMT: beacon_period %d CFP_max_duration %d &quot;
+	       &quot;medium_occupancy_limit %d station_id 0x%x ATIM_window %d &quot;
+	       &quot;CFP_mode %d privacy_opt_impl %d DTIM_period %d CFP_period %d &quot;
+	       &quot;current_bssid %s current_essid %s current_bss_type %d &quot;
+	       &quot;pm_mode %d ibss_change %d res %d &quot;
+	       &quot;multi_domain_capability_implemented %d &quot;
+	       &quot;international_roaming %d country_string %s&quot;,
+	       dev-&gt;netdev-&gt;name,
+	       le16_to_cpu(mac_mgmt-&gt;beacon_period),
+	       le16_to_cpu(mac_mgmt-&gt;CFP_max_duration),
+	       le16_to_cpu(mac_mgmt-&gt;medium_occupancy_limit),
+	       le16_to_cpu(mac_mgmt-&gt;station_id),
+	       le16_to_cpu(mac_mgmt-&gt;ATIM_window),
+	       mac_mgmt-&gt;CFP_mode,
+	       mac_mgmt-&gt;privacy_option_implemented,
+	       mac_mgmt-&gt;DTIM_period,
+	       mac_mgmt-&gt;CFP_period,
+	       mac2str(mac_mgmt-&gt;current_bssid),
+	       hex2str(dev-&gt;obuf, (u8 *)mac_mgmt-&gt;current_essid, 
+		       min((int)(sizeof(dev-&gt;obuf)-1)/2, 
+			   IW_ESSID_MAX_SIZE), '\0'),
+	       mac_mgmt-&gt;current_bss_type,
+	       mac_mgmt-&gt;power_mgmt_mode,
+	       mac_mgmt-&gt;ibss_change,
+	       mac_mgmt-&gt;res,
+	       mac_mgmt-&gt;multi_domain_capability_implemented,
+	       mac_mgmt-&gt;multi_domain_capability_enabled,
+	       country_string);
+ err:
+	kfree(mac_mgmt);
+ exit:
+	return ret;
+}
+
+static int dump_mib_mac(struct at76c503 *dev)
+{
+	int ret = 0;
+	struct mib_mac *mac =
+		kmalloc(sizeof(struct mib_mac), GFP_KERNEL);
+
+	if(!mac){
+		ret = -ENOMEM;
+		goto exit;
+	}
+	
+	ret = get_mib(dev-&gt;udev, MIB_MAC,
+		      (u8*)mac, sizeof(struct mib_mac));
+	if(ret &lt; 0){
+		err(&quot;%s: get_mib failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		goto err;
+	}
+
+	dbg_uc(&quot;%s: MIB MAC: max_tx_msdu_lifetime %d max_rx_lifetime %d &quot;
+	       &quot;frag_threshold %d rts_threshold %d cwmin %d cwmax %d &quot;
+	       &quot;short_retry_time %d long_retry_time %d scan_type %d &quot;
+	       &quot;scan_channel %d probe_delay %u min_channel_time %d &quot;
+	       &quot;max_channel_time %d listen_int %d desired_ssid %s &quot;
+	       &quot;desired_bssid %s desired_bsstype %d&quot;,
+	       dev-&gt;netdev-&gt;name,
+	       le32_to_cpu(mac-&gt;max_tx_msdu_lifetime),
+	       le32_to_cpu(mac-&gt;max_rx_lifetime),
+	       le16_to_cpu(mac-&gt;frag_threshold),
+	       le16_to_cpu(mac-&gt;rts_threshold),
+	       le16_to_cpu(mac-&gt;cwmin),
+	       le16_to_cpu(mac-&gt;cwmax),
+	       mac-&gt;short_retry_time,
+	       mac-&gt;long_retry_time,
+	       mac-&gt;scan_type,
+	       mac-&gt;scan_channel,
+	       le16_to_cpu(mac-&gt;probe_delay),
+	       le16_to_cpu(mac-&gt;min_channel_time),
+	       le16_to_cpu(mac-&gt;max_channel_time),
+	       le16_to_cpu(mac-&gt;listen_interval),
+	       hex2str(dev-&gt;obuf, mac-&gt;desired_ssid, 
+		       min((int)(sizeof(dev-&gt;obuf)-1)/2, 
+			   IW_ESSID_MAX_SIZE), '\0'),
+	       mac2str(mac-&gt;desired_bssid),
+	       mac-&gt;desired_bsstype);
+ err:
+	kfree(mac);
+ exit:
+	return ret;
+}
+
+static int dump_mib_phy(struct at76c503 *dev)
+{
+	int ret = 0;
+	struct mib_phy *phy =
+		kmalloc(sizeof(struct mib_phy), GFP_KERNEL);
+
+	if(!phy){
+		ret = -ENOMEM;
+		goto exit;
+	}
+	
+	ret = get_mib(dev-&gt;udev, MIB_PHY,
+		      (u8*)phy, sizeof(struct mib_phy));
+	if(ret &lt; 0){
+		err(&quot;%s: get_mib failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		goto err;
+	}
+
+	dbg_uc(&quot;%s: MIB PHY: ed_threshold %d slot_time %d sifs_time %d &quot;
+	       &quot;preamble_length %d plcp_header_length %d mpdu_max_length %d &quot;
+	       &quot;cca_mode_supported %d operation_rate_set &quot;
+	       &quot;0x%x 0x%x 0x%x 0x%x channel_id %d current_cca_mode %d &quot;
+	       &quot;phy_type %d current_reg_domain %d&quot;,
+	       dev-&gt;netdev-&gt;name,
+	       le32_to_cpu(phy-&gt;ed_threshold),
+	       le16_to_cpu(phy-&gt;slot_time),
+	       le16_to_cpu(phy-&gt;sifs_time),
+	       le16_to_cpu(phy-&gt;preamble_length),
+	       le16_to_cpu(phy-&gt;plcp_header_length),
+	       le16_to_cpu(phy-&gt;mpdu_max_length),
+	       le16_to_cpu(phy-&gt;cca_mode_supported),
+	       phy-&gt;operation_rate_set[0], phy-&gt;operation_rate_set[1],
+	       phy-&gt;operation_rate_set[2], phy-&gt;operation_rate_set[3],
+	       phy-&gt;channel_id,
+	       phy-&gt;current_cca_mode,
+	       phy-&gt;phy_type,
+	       phy-&gt;current_reg_domain);
+ err:
+	kfree(phy);
+ exit:
+	return ret;
+}
+
+static int dump_mib_local(struct at76c503 *dev)
+{
+	int ret = 0;
+	struct mib_local *local =
+		kmalloc(sizeof(struct mib_phy), GFP_KERNEL);
+
+	if(!local){
+		ret = -ENOMEM;
+		goto exit;
+	}
+	
+	ret = get_mib(dev-&gt;udev, MIB_LOCAL,
+		      (u8*)local, sizeof(struct mib_local));
+	if(ret &lt; 0){
+		err(&quot;%s: get_mib failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		goto err;
+	}
+
+	dbg_uc(&quot;%s: MIB PHY: beacon_enable %d txautorate_fallback %d &quot;
+	       &quot;ssid_size %d promiscuous_mode %d preamble_type %d&quot;,
+	       dev-&gt;netdev-&gt;name,
+	       local-&gt;beacon_enable,
+	       local-&gt;txautorate_fallback,
+	       local-&gt;ssid_size,
+	       local-&gt;promiscuous_mode,
+	       local-&gt;preamble_type);
+ err:
+	kfree(local);
+ exit:
+	return ret;
+}
+
+
+static int get_mib_mdomain(struct at76c503 *dev, struct mib_mdomain *val)
+{
+	int ret = 0;
+	struct mib_mdomain *mdomain =
+		kmalloc(sizeof(struct mib_mdomain), GFP_KERNEL);
+
+	if(!mdomain){
+		ret = -ENOMEM;
+		goto exit;
+	}
+	
+	ret = get_mib(dev-&gt;udev, MIB_MDOMAIN,
+		      (u8*)mdomain, sizeof(struct mib_mdomain));
+	if(ret &lt; 0){
+		err(&quot;%s: get_mib failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		goto err;
+	}
+
+	memcpy(val, mdomain, sizeof(*val));
+
+ err:
+	kfree(mdomain);
+ exit:
+	return ret;
+}
+
+static void dump_mib_mdomain(struct at76c503 *dev)
+{
+	char obuf1[2*14+1], obuf2[2*14+1]; /* to hexdump tx_powerlevel, 
+					      channel_list */
+	int ret;
+	struct mib_mdomain mdomain;
+
+	if ((ret=get_mib_mdomain(dev, &amp;mdomain)) &lt; 0) {
+		err(&quot;%s: get_mib_mdomain returned %d&quot;, __FUNCTION__, ret);
+		return;
+	}
+	
+	dbg(DBG_MIB, &quot;%s: MIB MDOMAIN: channel_list %s tx_powerlevel %s&quot;,
+	    dev-&gt;netdev-&gt;name,
+	    hex2str(obuf1, mdomain.channel_list,
+		    (sizeof(obuf1)-1)/2,'\0'),
+	    hex2str(obuf2, mdomain.tx_powerlevel,
+		    (sizeof(obuf2)-1)/2,'\0'));
+}
+
+static
+int get_current_bssid(struct at76c503 *dev)
+{
+	int ret = 0;
+	struct mib_mac_mgmt *mac_mgmt =
+		kmalloc(sizeof(struct mib_mac_mgmt), GFP_KERNEL);
+
+	if(!mac_mgmt){
+		ret = -ENOMEM;
+		goto exit;
+	}
+	
+	ret = get_mib(dev-&gt;udev, MIB_MAC_MGMT,
+		      (u8*)mac_mgmt, sizeof(struct mib_mac_mgmt));
+	if(ret &lt; 0){
+		err(&quot;%s: get_mib failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		goto err;
+	}
+	memcpy(dev-&gt;bssid, mac_mgmt-&gt;current_bssid, ETH_ALEN);
+	info(&quot;using BSSID %s&quot;, mac2str(dev-&gt;bssid));
+ err:
+	kfree(mac_mgmt);
+ exit:
+	return ret;
+}
+
+static int get_current_channel(struct at76c503 *dev)
+{
+	int ret = 0;
+	struct mib_phy *phy =
+		kmalloc(sizeof(struct mib_phy), GFP_KERNEL);
+
+	if(!phy){
+		ret = -ENOMEM;
+		goto exit;
+	}
+	ret = get_mib(dev-&gt;udev, MIB_PHY, (u8*)phy,
+		      sizeof(struct mib_phy));
+	if(ret &lt; 0){
+		err(&quot;%s: get_mib(MIB_PHY) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		goto err;
+	}
+	dev-&gt;channel = phy-&gt;channel_id;
+ err:
+	kfree(phy);
+ exit:
+	return ret;
+}
+
+/* == PROC start_scan ==
+  start a scan. use_essid is != 0 if any probe_delay (if scan mode is not 
+  passive) should contain the ESSID configured. ir_step describes the
+  international roaming step (0, 1) */
+static int start_scan(struct at76c503 *dev, int use_essid, int ir_step)
+{
+	struct at76c503_start_scan scan;
+
+	memset(&amp;scan, 0, sizeof(struct at76c503_start_scan));
+	memset(scan.bssid, 0xff, ETH_ALEN);
+
+	if (use_essid) {
+		memcpy(scan.essid, dev-&gt;essid, IW_ESSID_MAX_SIZE);
+		scan.essid_size = dev-&gt;essid_size;
+	} else
+		scan.essid_size = 0;
+
+	/* jal: why should we start at a certain channel? we do scan the whole range
+	   allowed by reg domain. */
+	scan.channel = dev-&gt;channel;
+
+	/* atmelwlandriver differs between scan type 0 and 1 (active/passive)
+	   For ad-hoc mode, it uses type 0 only.*/
+	if ((dev-&gt;international_roaming == IR_ON &amp;&amp; ir_step == 0) ||
+		dev-&gt;iw_mode == IW_MODE_MONITOR)
+		scan.scan_type = SCAN_TYPE_PASSIVE;
+	else
+		scan.scan_type = dev-&gt;scan_mode;
+
+	/* INFO: For probe_delay, not multiplying by 1024 as this will be 
+	   slightly less than min_channel_time
+	   (per spec: probe delay &lt; min. channel time) */
+	LOCK_ISTATE()
+	if (dev-&gt;istate == MONITORING) {
+		scan.min_channel_time = cpu_to_le16(dev-&gt;monitor_scan_min_time);
+		scan.max_channel_time = cpu_to_le16(dev-&gt;monitor_scan_max_time);
+		scan.probe_delay = cpu_to_le16(dev-&gt;monitor_scan_min_time * 1000);
+	} else {
+		scan.min_channel_time = cpu_to_le16(dev-&gt;scan_min_time);
+		scan.max_channel_time = cpu_to_le16(dev-&gt;scan_max_time);
+		scan.probe_delay = cpu_to_le16(dev-&gt;scan_min_time * 1000);
+	}
+	UNLOCK_ISTATE()
+	if (dev-&gt;international_roaming == IR_ON &amp;&amp; ir_step == 1)
+		scan.international_scan = 0;
+	else
+		scan.international_scan = dev-&gt;international_roaming;
+
+	/* other values are set to 0 for type 0 */
+
+	dbg(DBG_PROGRESS, &quot;%s: start_scan (use_essid = %d, intl = %d, &quot;
+	    &quot;channel = %d, probe_delay = %d, scan_min_time = %d, &quot;
+	    &quot;scan_max_time = %d)&quot;,
+	    dev-&gt;netdev-&gt;name, use_essid,
+	    scan.international_scan, scan.channel,
+	    le16_to_cpu(scan.probe_delay),
+	    le16_to_cpu(scan.min_channel_time),
+	    le16_to_cpu(scan.max_channel_time));
+
+	return set_card_command(dev-&gt;udev, CMD_SCAN,
+				(unsigned char*)&amp;scan, sizeof(scan));
+}
+
+static int start_ibss(struct at76c503 *dev)
+{
+	struct at76c503_start_bss bss;
+
+	memset(&amp;bss, 0, sizeof(struct at76c503_start_bss));
+	memset(bss.bssid, 0xff, ETH_ALEN);
+	memcpy(bss.essid, dev-&gt;essid, IW_ESSID_MAX_SIZE);
+	bss.essid_size = dev-&gt;essid_size;
+	bss.bss_type = ADHOC_MODE;
+	bss.channel = dev-&gt;channel;
+
+	return set_card_command(dev-&gt;udev, CMD_START_IBSS,
+				(unsigned char*)&amp;bss, sizeof(struct at76c503_start_bss));
+}
+
+/* idx points into dev-&gt;bss */
+static int join_bss(struct at76c503 *dev, struct bss_info *ptr)
+{
+	struct at76c503_join join;
+
+	assert(ptr != NULL);
+
+	memset(&amp;join, 0, sizeof(struct at76c503_join));
+	memcpy(join.bssid, ptr-&gt;bssid, ETH_ALEN);
+	memcpy(join.essid, ptr-&gt;ssid, ptr-&gt;ssid_len);
+	join.essid_size = ptr-&gt;ssid_len;
+	join.bss_type = (dev-&gt;iw_mode == IW_MODE_ADHOC ? 1 : 2);
+	join.channel = ptr-&gt;channel;
+	join.timeout = cpu_to_le16(2000);
+
+	dbg(DBG_PROGRESS, &quot;%s join addr %s ssid %s type %d ch %d timeout %d&quot;,
+	    dev-&gt;netdev-&gt;name, mac2str(join.bssid), 
+	    join.essid, join.bss_type, join.channel, le16_to_cpu(join.timeout));
+	return set_card_command(dev-&gt;udev, CMD_JOIN,
+				(unsigned char*)&amp;join,
+				sizeof(struct at76c503_join));
+} /* join_bss */
+
+/* the firmware download timeout (after remap) */
+static void fw_dl_timeout(unsigned long par)
+{
+	struct at76c503 *dev = (struct at76c503 *)par;
+	defer_kevent(dev, KEVENT_RESET_DEVICE);
+}
+
+
+/* the restart timer timed out */
+static void restart_timeout(unsigned long par)
+{
+	struct at76c503 *dev = (struct at76c503 *)par;
+	defer_kevent(dev, KEVENT_RESTART);
+}
+
+/* we got to check the bss_list for old entries */
+static void bss_list_timeout(unsigned long par)
+{
+	struct at76c503 *dev = (struct at76c503 *)par;
+	unsigned long flags;
+	struct list_head *lptr, *nptr;
+	struct bss_info *ptr;
+
+	spin_lock_irqsave(&amp;dev-&gt;bss_list_spinlock, flags);
+
+	list_for_each_safe(lptr, nptr, &amp;dev-&gt;bss_list) {
+
+		ptr = list_entry(lptr, struct bss_info, list);
+
+		if (ptr != dev-&gt;curr_bss &amp;&amp; ptr != dev-&gt;new_bss &amp;&amp;
+		    time_after(jiffies, ptr-&gt;last_rx+BSS_LIST_TIMEOUT)) {
+			dbg(DBG_BSS_TABLE_RM,
+			    &quot;%s: bss_list: removing old BSS %s ch %d&quot;,
+			    dev-&gt;netdev-&gt;name, mac2str(ptr-&gt;bssid), ptr-&gt;channel);
+			list_del(&amp;ptr-&gt;list);
+			kfree(ptr);
+		}
+	}
+	spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
+	/* restart the timer */
+	mod_timer(&amp;dev-&gt;bss_list_timer, jiffies+BSS_LIST_TIMEOUT);
+	
+}
+
+/* we got a timeout for a infrastructure mgmt packet */
+static void mgmt_timeout(unsigned long par)
+{
+	struct at76c503 *dev = (struct at76c503 *)par;
+	defer_kevent(dev, KEVENT_MGMT_TIMEOUT);
+}
+
+/* == PROC handle_mgmt_timeout_scan == */
+/* called in istate SCANNING on expiry of the mgmt_timer, when a scan was run before
+   (dev-&gt;scan_runs &gt; 0) */
+static void handle_mgmt_timeout_scan(struct at76c503 *dev)
+{
+
+	u8 *cmd_status;
+	int ret;
+	struct mib_mdomain mdomain;
+
+	cmd_status = kmalloc(40, GFP_KERNEL);
+	if (cmd_status == NULL) {
+		err(&quot;%s: %s: cmd_status kmalloc returned NULL&quot;, 
+		    dev-&gt;netdev-&gt;name, __FUNCTION__);
+		return;
+	}
+
+	
+	if ((ret=get_cmd_status(dev-&gt;udev, CMD_SCAN, cmd_status)) &lt; 0) {
+		err(&quot;%s: %s: get_cmd_status failed with %d&quot;,
+		    dev-&gt;netdev-&gt;name, __FUNCTION__, ret);
+		cmd_status[5] = CMD_STATUS_IN_PROGRESS;	
+                /* INFO: Hope it was a one off error - if not, scanning 
+		   further down the line and stop this cycle */
+	}
+	LOCK_ISTATE()
+	dbg(DBG_PROGRESS, &quot;%s %s:%d got cmd_status %d (istate %d, &quot;
+	    &quot;scan_runs %d)&quot;,
+	    dev-&gt;netdev-&gt;name, __FUNCTION__, __LINE__, cmd_status[5],
+	    dev-&gt;istate, dev-&gt;scan_runs);
+	UNLOCK_ISTATE()
+	if (cmd_status[5] == CMD_STATUS_COMPLETE) {
+		LOCK_ISTATE()
+		if (dev-&gt;istate == SCANNING) {
+			UNLOCK_ISTATE()
+			dump_bss_table(dev,0);
+			switch (dev-&gt;scan_runs) {
+
+			case 1:
+				assert(dev-&gt;international_roaming);
+				if ((ret=get_mib_mdomain(dev, &amp;mdomain)) &lt; 0) {
+					err(&quot;get_mib_mdomain returned %d&quot;, ret);
+				} else {
+					char obuf1[2*14+1], obuf2[2*14+1];
+					
+					dbg(DBG_MIB, &quot;%s: MIB MDOMAIN: channel_list %s &quot;
+					    &quot;tx_powerlevel %s&quot;,
+					    dev-&gt;netdev-&gt;name,
+					    hex2str(obuf1, mdomain.channel_list,
+						    (sizeof(obuf1)-1)/2,'\0'),
+					    hex2str(obuf2, mdomain.tx_powerlevel,
+						    (sizeof(obuf2)-1)/2,'\0'));
+				}
+				if ((ret = start_scan(dev, 0, 1)) &lt; 0) {
+					err(&quot;%s: %s: start_scan (ANY) failed with %d&quot;, 
+					    dev-&gt;netdev-&gt;name, __FUNCTION__, ret);
+				}
+				dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer for %d ticks&quot;,
+				    __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+				mod_timer(&amp;dev-&gt;mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+				break;
+
+			case 2:
+				if ((ret = start_scan(dev, 1, 1)) &lt; 0) {
+					err(&quot;%s: %s: start_scan (SSID) failed with %d&quot;, 
+					    dev-&gt;netdev-&gt;name, __FUNCTION__, ret);
+				}
+				dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer for %d ticks&quot;,
+				    __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+				mod_timer(&amp;dev-&gt;mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+				break;
+
+			case 3:
+				dev-&gt;site_survey_state = SITE_SURVEY_COMPLETED;
+				/* report the end of scan to user space */
+				iwevent_scan_complete(dev-&gt;netdev);
+				NEW_STATE(dev,JOINING);
+#if 0
+				assert(dev-&gt;curr_bss == NULL); /* done in free_bss_list, 
+								  find_bss will start with first bss */
+#endif
+				/* call join_bss immediately after
+				   re-run of all other threads in kevent */
+				defer_kevent(dev,KEVENT_JOIN);
+				break;
+
+			default:
+				err(&quot;unexpected dev-&gt;scan_runs %d&quot;, dev-&gt;scan_runs);
+			} /* switch (dev-&gt;scan_runs)*/
+			dev-&gt;scan_runs++;
+		} else {
+			
+			assert(dev-&gt;istate == MONITORING);
+			UNLOCK_ISTATE()
+			dbg(DBG_MONITOR_MODE, &quot;%s: MONITOR MODE: restart scan&quot;,
+			    dev-&gt;netdev-&gt;name);
+			start_scan(dev, 0, 0);
+			dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer for %d ticks&quot;,
+			    __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+			mod_timer(&amp;dev-&gt;mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		}
+
+	} else { 
+		if ((cmd_status[5] != CMD_STATUS_IN_PROGRESS) &amp;&amp;
+		    (cmd_status[5] != CMD_STATUS_IDLE))
+			err(&quot;%s: %s: Bad scan status: %s&quot;, 
+			    dev-&gt;netdev-&gt;name, __FUNCTION__, 
+			    get_cmd_status_string(cmd_status[5]));
+
+		/* the first cmd status after scan start is always a IDLE -&gt;
+		   start the timer to poll again until COMPLETED */
+		dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer for %d ticks&quot;,
+		    __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+		mod_timer(&amp;dev-&gt;mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+	}
+
+	kfree(cmd_status);
+}
+
+/* the deferred procedure called from kevent() */
+static void handle_mgmt_timeout(struct at76c503 *dev)
+{
+	LOCK_ISTATE()
+	if ((dev-&gt;istate != SCANNING &amp;&amp; dev-&gt;istate != MONITORING) || 
+	     (at76_debug &amp; DBG_MGMT_TIMER))
+		/* this is normal behavior in states MONITORING, SCANNING ... */
+		dbg(DBG_PROGRESS, &quot;%s: timeout, state %d&quot;, dev-&gt;netdev-&gt;name,
+		    dev-&gt;istate);
+
+	switch(dev-&gt;istate) {
+
+	case MONITORING:
+	case SCANNING: 
+		UNLOCK_ISTATE()
+		handle_mgmt_timeout_scan(dev);
+		break;
+
+	case JOINING:
+		UNLOCK_ISTATE()
+		assert(0);
+		break;
+
+	case CONNECTED: /* we haven't received the beacon of this BSS for 
+			   BEACON_TIMEOUT seconds */
+		UNLOCK_ISTATE()
+		info(&quot;%s: lost beacon bssid %s&quot;,
+		     dev-&gt;netdev-&gt;name, mac2str(dev-&gt;curr_bss-&gt;bssid));
+		/* jal: starting mgmt_timer in ad-hoc mode is questionable, 
+		   but I'll leave it here to track down another lockup problem */
+		if (dev-&gt;iw_mode != IW_MODE_ADHOC) {
+			netif_carrier_off(dev-&gt;netdev);
+			netif_stop_queue(dev-&gt;netdev);
+			iwevent_bss_disconnect(dev-&gt;netdev);
+			NEW_STATE(dev,SCANNING);
+			defer_kevent(dev,KEVENT_SCAN);
+		}
+		break;
+
+	case AUTHENTICATING:
+		UNLOCK_ISTATE()
+		if (dev-&gt;retries-- &gt;= 0) {
+			auth_req(dev, dev-&gt;curr_bss, 1, NULL);
+			dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer + HZ&quot;,
+			    __FUNCTION__, __LINE__);
+			mod_timer(&amp;dev-&gt;mgmt_timer, jiffies+HZ);
+		} else {
+			/* try to get next matching BSS */
+			NEW_STATE(dev,JOINING);
+			defer_kevent(dev,KEVENT_JOIN);
+		}
+		break;
+
+	case ASSOCIATING:
+		UNLOCK_ISTATE()
+		if (dev-&gt;retries-- &gt;= 0) {
+			assoc_req(dev,dev-&gt;curr_bss);
+			dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer + HZ&quot;,
+			    __FUNCTION__, __LINE__);
+			mod_timer(&amp;dev-&gt;mgmt_timer, jiffies+HZ);
+		} else {
+			/* jal: TODO: we may be authenticated to several
+			   BSS and may try to associate to the next of them here
+			   in the future ... */
+
+			/* try to get next matching BSS */
+			NEW_STATE(dev,JOINING);
+			defer_kevent(dev,KEVENT_JOIN);
+		}
+		break;
+
+	case REASSOCIATING:
+		UNLOCK_ISTATE()
+		if (dev-&gt;retries-- &gt;= 0)
+			reassoc_req(dev, dev-&gt;curr_bss, dev-&gt;new_bss);
+		else {
+			/* we disassociate from the curr_bss and
+			   scan again ... */
+			NEW_STATE(dev,DISASSOCIATING);
+			dev-&gt;retries = DISASSOC_RETRIES;
+			disassoc_req(dev, dev-&gt;curr_bss);
+		}
+		dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer + HZ&quot;,
+		    __FUNCTION__, __LINE__);
+		mod_timer(&amp;dev-&gt;mgmt_timer, jiffies+HZ);
+		break;
+
+	case DISASSOCIATING:
+		UNLOCK_ISTATE()
+		if (dev-&gt;retries-- &gt;= 0) {
+			disassoc_req(dev, dev-&gt;curr_bss);
+			dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer + HZ&quot;,
+			    __FUNCTION__, __LINE__);
+			mod_timer(&amp;dev-&gt;mgmt_timer,jiffies+HZ);
+		} else {
+			/* we scan again ... */
+			NEW_STATE(dev,SCANNING);
+			defer_kevent(dev,KEVENT_SCAN);
+		}
+		break;
+
+	case INIT:
+		UNLOCK_ISTATE()
+		break;
+
+	default:
+		UNLOCK_ISTATE()
+		assert(0);
+	} /* switch (dev-&gt;istate) */
+
+}/* handle_mgmt_timeout */
+
+/* calc. the padding from txbuf-&gt;wlength (which excludes the USB TX header) 
+   guess this is needed to compensate a flaw in the AT76C503A USB part ... */
+static inline int calc_padding(int wlen)
+{
+	/* add the USB TX header */
+	wlen += AT76C503_TX_HDRLEN;
+
+	wlen = wlen % 64;
+
+	if (wlen &lt; 50)
+		return 50 - wlen;
+
+	if (wlen &gt;=61)
+		return 64 + 50 - wlen;
+
+	return 0;
+}
+
+/* send a management frame on bulk-out.
+   txbuf-&gt;wlength must be set (in LE format !) */
+static int send_mgmt_bulk(struct at76c503 *dev, struct at76c503_tx_buffer *txbuf)
+{
+	unsigned long flags;
+	int ret = 0;
+	int urb_status;
+	void *oldbuf = NULL;
+
+	netif_carrier_off(dev-&gt;netdev); /* disable running netdev watchdog */
+	netif_stop_queue(dev-&gt;netdev); /* stop tx data packets */
+
+	spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock, flags);
+
+	if ((urb_status=dev-&gt;write_urb-&gt;status) == -EINPROGRESS) {
+		oldbuf=dev-&gt;next_mgmt_bulk; /* to kfree below */
+		dev-&gt;next_mgmt_bulk = txbuf;
+		txbuf = NULL;
+	}
+	spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock, flags);
+
+	if (oldbuf) {
+		/* a data/mgmt tx is already pending in the URB -
+		   if this is no error in some situations we must
+		   implement a queue or silently modify the old msg */
+		err(&quot;%s: %s removed pending mgmt buffer %s&quot;,
+		    dev-&gt;netdev-&gt;name, __FUNCTION__,
+		    hex2str(dev-&gt;obuf, (u8 *)dev-&gt;next_mgmt_bulk,
+			    min((int)(sizeof(dev-&gt;obuf))/3, 64),' '));
+		kfree(dev-&gt;next_mgmt_bulk);
+	}
+
+	if (txbuf) {
+
+		txbuf-&gt;tx_rate = 0;
+		txbuf-&gt;padding = calc_padding(le16_to_cpu(txbuf-&gt;wlength));
+
+		if (dev-&gt;next_mgmt_bulk) {
+			err(&quot;%s: %s URB status %d, but mgmt is pending&quot;,
+			    dev-&gt;netdev-&gt;name, __FUNCTION__, urb_status);
+		}
+
+		dbg(DBG_TX_MGMT, &quot;%s: tx mgmt: wlen %d tx_rate %d pad %d %s&quot;,
+		    dev-&gt;netdev-&gt;name, le16_to_cpu(txbuf-&gt;wlength),
+		    txbuf-&gt;tx_rate, txbuf-&gt;padding,
+		    hex2str(dev-&gt;obuf, txbuf-&gt;packet,
+			    min((sizeof(dev-&gt;obuf)-1)/2,
+				(size_t)le16_to_cpu(txbuf-&gt;wlength)),'\0'));
+
+		/* txbuf was not consumed above -&gt; send mgmt msg immediately */
+		memcpy(dev-&gt;bulk_out_buffer, txbuf,
+		       le16_to_cpu(txbuf-&gt;wlength) + AT76C503_TX_HDRLEN);
+		FILL_BULK_URB(dev-&gt;write_urb, dev-&gt;udev,
+			      usb_sndbulkpipe(dev-&gt;udev, 
+					      dev-&gt;bulk_out_endpointAddr),
+			      dev-&gt;bulk_out_buffer,
+			      le16_to_cpu(txbuf-&gt;wlength) + 
+			      txbuf-&gt;padding +
+			      AT76C503_TX_HDRLEN,
+			      (usb_complete_t)at76c503_write_bulk_callback, dev);
+		ret = usb_submit_urb(dev-&gt;write_urb, GFP_ATOMIC);
+		if (ret) {
+			err(&quot;%s: %s error in tx submit urb: %d&quot;,
+			    dev-&gt;netdev-&gt;name, __FUNCTION__, ret);
+		}
+		kfree(txbuf);
+	} /* if (txbuf) */
+
+	return ret;
+
+} /* send_mgmt_bulk */
+
+static int disassoc_req(struct at76c503 *dev, struct bss_info *bss)
+{
+	struct at76c503_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee802_11_disassoc_frame *req;
+
+	assert(bss != NULL);
+	if (bss == NULL)
+		return -EFAULT;
+
+	tx_buffer = kmalloc(DISASSOC_FRAME_SIZE + MAX_PADDING_SIZE,
+			    GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	mgmt = (struct ieee80211_hdr_3addr *)&amp;(tx_buffer-&gt;packet);
+	req  = (struct ieee802_11_disassoc_frame *)&amp;(mgmt-&gt;payload);
+
+	/* make wireless header */
+	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_AUTH);
+	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt-&gt;addr1, bss-&gt;bssid, ETH_ALEN);
+	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
+	memcpy(mgmt-&gt;addr3, bss-&gt;bssid, ETH_ALEN);
+	mgmt-&gt;seq_ctl = cpu_to_le16(0);
+
+	req-&gt;reason = 0;
+
+	/* init. at76c503 tx header */
+	tx_buffer-&gt;wlength = cpu_to_le16(DISASSOC_FRAME_SIZE -
+		AT76C503_TX_HDRLEN);
+	
+	dbg(DBG_TX_MGMT, &quot;%s: DisAssocReq bssid %s&quot;,
+	    dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3));
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return send_mgmt_bulk(dev, tx_buffer); 
+
+} /* disassoc_req */
+
+/* challenge is the challenge string (in TLV format) 
+   we got with seq_nr 2 for shared secret authentication only and
+   send in seq_nr 3 WEP encrypted to prove we have the correct WEP key;
+   otherwise it is NULL */
+static int auth_req(struct at76c503 *dev, struct bss_info *bss, int seq_nr, u8 *challenge)
+{
+	struct at76c503_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee802_11_auth_frame *req;
+	
+	int buf_len = (seq_nr != 3 ? AUTH_FRAME_SIZE : 
+		       AUTH_FRAME_SIZE + 1 + 1 + challenge[1]);
+
+	assert(bss != NULL);
+	assert(seq_nr != 3 || challenge != NULL);
+	
+	tx_buffer = kmalloc(buf_len + MAX_PADDING_SIZE, GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	mgmt = (struct ieee80211_hdr_3addr *)&amp;(tx_buffer-&gt;packet);
+	req  = (struct ieee802_11_auth_frame *)&amp;(mgmt-&gt;payload);
+
+	/* make wireless header */
+	/* first auth msg is not encrypted, only the second (seq_nr == 3) */
+	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH |
+		(seq_nr == 3 ? IEEE80211_FCTL_PROTECTED : 0));
+
+	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt-&gt;addr1, bss-&gt;bssid, ETH_ALEN);
+	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
+	memcpy(mgmt-&gt;addr3, bss-&gt;bssid, ETH_ALEN);
+	mgmt-&gt;seq_ctl = cpu_to_le16(0);
+
+	req-&gt;algorithm = cpu_to_le16(dev-&gt;auth_mode);
+	req-&gt;seq_nr = cpu_to_le16(seq_nr);
+	req-&gt;status = cpu_to_le16(0);
+
+	if (seq_nr == 3)
+		memcpy(req-&gt;challenge, challenge, 1+1+challenge[1]);
+
+	/* init. at76c503 tx header */
+	tx_buffer-&gt;wlength = cpu_to_le16(buf_len - AT76C503_TX_HDRLEN);
+	
+	dbg(DBG_TX_MGMT, &quot;%s: AuthReq bssid %s alg %d seq_nr %d&quot;,
+	    dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3),
+	    le16_to_cpu(req-&gt;algorithm), le16_to_cpu(req-&gt;seq_nr));
+	if (seq_nr == 3) {
+		dbg(DBG_TX_MGMT, &quot;%s: AuthReq challenge: %s ...&quot;,
+		    dev-&gt;netdev-&gt;name,
+		    hex2str(dev-&gt;obuf, req-&gt;challenge, 
+			    min((int)sizeof(dev-&gt;obuf)/3, 18),' '));
+	}
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return send_mgmt_bulk(dev, tx_buffer); 
+
+} /* auth_req */
+
+static int assoc_req(struct at76c503 *dev, struct bss_info *bss)
+{
+	struct at76c503_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee802_11_assoc_req *req;
+	u8 *tlv;
+
+	assert(bss != NULL);
+
+	tx_buffer = kmalloc(ASSOCREQ_MAX_SIZE + MAX_PADDING_SIZE,
+			    GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	mgmt = (struct ieee80211_hdr_3addr *)&amp;(tx_buffer-&gt;packet);
+	req  = (struct ieee802_11_assoc_req *)&amp;(mgmt-&gt;payload);
+	tlv = req-&gt;data;
+
+	/* make wireless header */
+	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_ASSOC_REQ);
+
+	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt-&gt;addr1, bss-&gt;bssid, ETH_ALEN);
+	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
+	memcpy(mgmt-&gt;addr3, bss-&gt;bssid, ETH_ALEN);
+	mgmt-&gt;seq_ctl = cpu_to_le16(0);
+
+	/* we must set the Privacy bit in the capabilities to assure an
+	   Agere-based AP with optional WEP transmits encrypted frames
+	   to us.  AP only set the Privacy bit in their capabilities
+	   if WEP is mandatory in the BSS! */
+	req-&gt;capability = cpu_to_le16(bss-&gt;capa | 
+				      (dev-&gt;wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
+				      (dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT ?
+				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+
+	req-&gt;listen_interval = cpu_to_le16(2 * bss-&gt;beacon_interval);
+	
+	/* write TLV data elements */
+
+	*tlv++ = MFIE_TYPE_SSID;
+	*tlv++ = bss-&gt;ssid_len;
+	memcpy(tlv, bss-&gt;ssid, bss-&gt;ssid_len);
+	tlv += bss-&gt;ssid_len;
+
+	*tlv++ = MFIE_TYPE_RATES;
+	*tlv++ = sizeof(hw_rates);
+	memcpy(tlv, hw_rates, sizeof(hw_rates));
+	tlv += sizeof(hw_rates); /* tlv points behind the supp_rates field */
+
+	/* init. at76c503 tx header */
+	tx_buffer-&gt;wlength = cpu_to_le16(tlv-(u8 *)mgmt);
+	
+	{
+		/* output buffer for ssid and rates */
+		char orates[4*2+1];
+		int len;
+
+		tlv = req-&gt;data;
+		len = min(IW_ESSID_MAX_SIZE, (int)*(tlv+1));
+		memcpy(dev-&gt;obuf, tlv+2, len);
+		dev-&gt;obuf[len] = '\0';
+		tlv += (1 + 1 + *(tlv+1)); /* points to IE of rates now */
+		dbg(DBG_TX_MGMT, &quot;%s: AssocReq bssid %s capa x%04x ssid %s rates %s&quot;,
+		    dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3),
+		    le16_to_cpu(req-&gt;capability), dev-&gt;obuf,
+		    hex2str(orates,tlv+2,min((sizeof(orates)-1)/2,(size_t)*(tlv+1)),
+			    '\0'));
+	}
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return send_mgmt_bulk(dev, tx_buffer); 
+
+} /* assoc_req */
+
+/* we are currently associated to curr_bss and
+   want to reassoc to new_bss */
+static int reassoc_req(struct at76c503 *dev, struct bss_info *curr_bss,
+		struct bss_info *new_bss)
+{
+	struct at76c503_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee802_11_reassoc_req *req;
+	
+	u8 *tlv;
+
+	assert(curr_bss != NULL);
+	assert(new_bss != NULL);
+	if (curr_bss == NULL || new_bss == NULL)
+		return -EFAULT;
+
+	tx_buffer = kmalloc(REASSOCREQ_MAX_SIZE + MAX_PADDING_SIZE,
+			    GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	mgmt = (struct ieee80211_hdr_3addr *)&amp;(tx_buffer-&gt;packet);
+	req  = (struct ieee802_11_reassoc_req *)&amp;(mgmt-&gt;payload);
+	tlv = req-&gt;data;
+
+	/* make wireless header */
+	/* jal: encrypt this packet if wep_enabled is TRUE ??? */
+	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_REASSOC_REQ);
+	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt-&gt;addr1, new_bss-&gt;bssid, ETH_ALEN);
+	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
+	memcpy(mgmt-&gt;addr3, new_bss-&gt;bssid, ETH_ALEN);
+	mgmt-&gt;seq_ctl = cpu_to_le16(0);
+
+	/* we must set the Privacy bit in the capabilities to assure an
+	   Agere-based AP with optional WEP transmits encrypted frames
+	   to us.  AP only set the Privacy bit in their capabilities
+	   if WEP is mandatory in the BSS! */
+	req-&gt;capability = cpu_to_le16(new_bss-&gt;capa | 
+				      (dev-&gt;wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
+				      (dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT ?
+				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+
+	req-&gt;listen_interval = cpu_to_le16(2 * new_bss-&gt;beacon_interval);
+	
+	memcpy(req-&gt;curr_ap, curr_bss-&gt;bssid, ETH_ALEN);
+
+	/* write TLV data elements */
+
+	*tlv++ = MFIE_TYPE_SSID;
+	*tlv++ = new_bss-&gt;ssid_len;
+	memcpy(tlv,new_bss-&gt;ssid, new_bss-&gt;ssid_len);
+	tlv += new_bss-&gt;ssid_len;
+
+	*tlv++ = MFIE_TYPE_RATES;
+	*tlv++ = sizeof(hw_rates);
+	memcpy(tlv, hw_rates, sizeof(hw_rates));
+	tlv += sizeof(hw_rates); /* tlv points behind the supp_rates field */
+
+	/* init. at76c503 tx header */
+	tx_buffer-&gt;wlength = cpu_to_le16(tlv-(u8 *)mgmt);
+	
+	{
+		/* output buffer for rates and bssid */
+		char orates[4*2+1];
+		char ocurr[6*3+1];
+		tlv = req-&gt;data;
+		memcpy(dev-&gt;obuf, tlv+2, min(sizeof(dev-&gt;obuf),(size_t)*(tlv+1)));
+		dev-&gt;obuf[IW_ESSID_MAX_SIZE] = '\0';
+		tlv += (1 + 1 + *(tlv+1)); /* points to IE of rates now */
+		dbg(DBG_TX_MGMT, &quot;%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s&quot;,
+		    dev-&gt;netdev-&gt;name,
+		    hex2str(ocurr, req-&gt;curr_ap, ETH_ALEN, ':'),
+		    mac2str(mgmt-&gt;addr3), le16_to_cpu(req-&gt;capability), dev-&gt;obuf,
+		    hex2str(orates,tlv+2,min((sizeof(orates)-1)/2,(size_t)*(tlv+1)),
+			    '\0'));
+	}
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return send_mgmt_bulk(dev, tx_buffer); 
+
+} /* reassoc_req */
+
+
+/* shamelessly copied from usbnet.c (oku) */
+static void defer_kevent (struct at76c503 *dev, int flag)
+{
+	set_bit (flag, &amp;dev-&gt;kevent_flags);
+	if (!schedule_work (&amp;dev-&gt;kevent))
+		dbg(DBG_KEVENT, &quot;%s: kevent %d may have been dropped&quot;,
+		     dev-&gt;netdev-&gt;name, flag);
+	else
+		dbg(DBG_KEVENT, &quot;%s: kevent %d scheduled&quot;,
+		    dev-&gt;netdev-&gt;name, flag);
+}
+
+static void kevent(struct work_struct *work)
+{
+	struct at76c503 *dev = container_of(work, struct at76c503, kevent);
+	int ret;
+	unsigned long flags;
+
+	/* on errors, bits aren't cleared, but no reschedule
+	   is done. So work will be done next time something
+	   else has to be done. This is ugly. TODO! (oku) */
+
+	dbg(DBG_KEVENT, &quot;%s: kevent entry flags: 0x%lx&quot;, dev-&gt;netdev-&gt;name,
+	    dev-&gt;kevent_flags);
+
+	down(&amp;dev-&gt;sem);
+
+	if(test_bit(KEVENT_CTRL_HALT, &amp;dev-&gt;kevent_flags)){
+		/* this never worked... but it seems
+		   that it's rarely necessary, if at all (oku) */
+		ret = usb_clear_halt(dev-&gt;udev,
+				     usb_sndctrlpipe (dev-&gt;udev, 0));
+		if(ret &lt; 0)
+			err(&quot;usb_clear_halt() failed: %d&quot;, ret);
+		else{
+			clear_bit(KEVENT_CTRL_HALT, &amp;dev-&gt;kevent_flags);
+			info(&quot;usb_clear_halt() successful&quot;);
+		}
+	}
+	if(test_bit(KEVENT_NEW_BSS, &amp;dev-&gt;kevent_flags)){
+		struct net_device *netdev = dev-&gt;netdev;
+		struct mib_mac_mgmt *mac_mgmt = kmalloc(sizeof(struct mib_mac_mgmt), GFP_KERNEL);
+
+		ret = get_mib(dev-&gt;udev, MIB_MAC_MGMT, (u8*)mac_mgmt,
+			      sizeof(struct mib_mac_mgmt));
+		if(ret &lt; 0){
+			err(&quot;%s: get_mib failed: %d&quot;, netdev-&gt;name, ret);
+			goto new_bss_clean;
+		}
+
+		dbg(DBG_PROGRESS, &quot;ibss_change = 0x%2x&quot;, mac_mgmt-&gt;ibss_change);
+		memcpy(dev-&gt;bssid, mac_mgmt-&gt;current_bssid, ETH_ALEN);
+		dbg(DBG_PROGRESS, &quot;using BSSID %s&quot;, mac2str(dev-&gt;bssid));
+    
+		iwevent_bss_connect(dev-&gt;netdev, dev-&gt;bssid);
+
+		memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+		dev-&gt;mib_buf.type = MIB_MAC_MGMT;
+		dev-&gt;mib_buf.size = 1;
+		dev-&gt;mib_buf.index = IBSS_CHANGE_OK_OFFSET;
+		ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+		if(ret &lt; 0){
+			err(&quot;%s: set_mib (ibss change ok) failed: %d&quot;, netdev-&gt;name, ret);
+			goto new_bss_clean;
+		}
+		clear_bit(KEVENT_NEW_BSS, &amp;dev-&gt;kevent_flags);
+	new_bss_clean:
+		kfree(mac_mgmt);
+	}
+
+	if(test_bit(KEVENT_SET_PROMISC, &amp;dev-&gt;kevent_flags)){
+		info(&quot;%s: KEVENT_SET_PROMISC&quot;, dev-&gt;netdev-&gt;name);
+
+		set_promisc(dev, dev-&gt;promisc);
+		clear_bit(KEVENT_SET_PROMISC, &amp;dev-&gt;kevent_flags);
+	}
+
+	/* check this _before_ KEVENT_JOIN, 'cause _JOIN sets _STARTIBSS bit */
+	if (test_bit(KEVENT_STARTIBSS, &amp;dev-&gt;kevent_flags)) {
+		clear_bit(KEVENT_STARTIBSS, &amp;dev-&gt;kevent_flags);
+		LOCK_ISTATE()
+		assert(dev-&gt;istate == STARTIBSS);
+		UNLOCK_ISTATE()
+		ret = start_ibss(dev);
+		if(ret &lt; 0){
+			err(&quot;%s: start_ibss failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+			goto end_startibss;
+		}
+
+		ret = wait_completion(dev, CMD_START_IBSS);
+		if (ret != CMD_STATUS_COMPLETE) {
+			err(&quot;%s start_ibss failed to complete,%d&quot;,
+			    dev-&gt;netdev-&gt;name, ret);
+			goto end_startibss;
+		}
+
+		ret = get_current_bssid(dev);
+		if(ret &lt; 0) goto end_startibss;
+
+		ret = get_current_channel(dev);
+		if(ret &lt; 0) goto end_startibss;
+
+		/* not sure what this is good for ??? */
+		memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+		dev-&gt;mib_buf.type = MIB_MAC_MGMT;
+		dev-&gt;mib_buf.size = 1;
+		dev-&gt;mib_buf.index = IBSS_CHANGE_OK_OFFSET;
+		ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+		if(ret &lt; 0){
+			err(&quot;%s: set_mib (ibss change ok) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+			goto end_startibss;
+		}
+
+		netif_carrier_on(dev-&gt;netdev);
+		netif_start_queue(dev-&gt;netdev);
+	}
+end_startibss:
+
+	/* check this _before_ KEVENT_SCAN, 'cause _SCAN sets _JOIN bit */
+	if (test_bit(KEVENT_JOIN, &amp;dev-&gt;kevent_flags)) {
+		clear_bit(KEVENT_JOIN, &amp;dev-&gt;kevent_flags);
+		LOCK_ISTATE()
+		if (dev-&gt;istate == INIT){
+			UNLOCK_ISTATE()	
+			goto end_join;
+		}
+		assert(dev-&gt;istate == JOINING);
+		UNLOCK_ISTATE()
+		/* dev-&gt;curr_bss == NULL signals a new round,
+		   starting with list_entry(dev-&gt;bss_list.next, ...) */
+
+		/* secure the access to dev-&gt;curr_bss ! */
+		spin_lock_irqsave(&amp;dev-&gt;bss_list_spinlock, flags);
+		dev-&gt;curr_bss=find_matching_bss(dev, dev-&gt;curr_bss);
+		spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
+
+		if (dev-&gt;curr_bss != NULL) {
+			if ((ret=join_bss(dev,dev-&gt;curr_bss)) &lt; 0) {
+				err(&quot;%s: join_bss failed with %d&quot;,
+				    dev-&gt;netdev-&gt;name, ret);
+				goto end_join;
+			}
+			
+			ret=wait_completion(dev,CMD_JOIN);
+			if (ret != CMD_STATUS_COMPLETE) {
+				if (ret != CMD_STATUS_TIME_OUT)
+					err(&quot;%s join_bss completed with %d&quot;,
+					    dev-&gt;netdev-&gt;name, ret);
+				else
+					info(&quot;%s join_bss ssid %s timed out&quot;,
+						     dev-&gt;netdev-&gt;name,
+					     mac2str(dev-&gt;curr_bss-&gt;bssid));
+
+				/* retry next BSS immediately */
+				defer_kevent(dev,KEVENT_JOIN);
+				goto end_join;
+			}
+
+			/* here we have joined the (I)BSS */
+			if (dev-&gt;iw_mode == IW_MODE_ADHOC) {
+				struct bss_info *bptr = dev-&gt;curr_bss;
+				NEW_STATE(dev,CONNECTED);
+				/* get ESSID, BSSID and channel for dev-&gt;curr_bss */
+				dev-&gt;essid_size = bptr-&gt;ssid_len;
+				memcpy(dev-&gt;essid, bptr-&gt;ssid, bptr-&gt;ssid_len);
+				memcpy(dev-&gt;bssid, bptr-&gt;bssid, ETH_ALEN);
+				dev-&gt;channel = bptr-&gt;channel;
+				iwevent_bss_connect(dev-&gt;netdev,bptr-&gt;bssid);
+				netif_carrier_on(dev-&gt;netdev);
+				netif_start_queue(dev-&gt;netdev);
+				/* just to be sure */
+				del_timer_sync(&amp;dev-&gt;mgmt_timer);
+			} else {
+				/* send auth req */
+				NEW_STATE(dev,AUTHENTICATING);
+				auth_req(dev, dev-&gt;curr_bss, 1, NULL);
+				dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer + HZ&quot;,
+				    __FUNCTION__, __LINE__);
+				mod_timer(&amp;dev-&gt;mgmt_timer, jiffies+HZ);
+			}
+			goto end_join;
+		} /* if (dev-&gt;curr_bss != NULL) */
+
+		/* here we haven't found a matching (i)bss ... */
+		if (dev-&gt;iw_mode == IW_MODE_ADHOC) {
+			NEW_STATE(dev,STARTIBSS);
+			defer_kevent(dev,KEVENT_STARTIBSS);
+			goto end_join;
+		}
+		/* haven't found a matching BSS in infra mode - try again */
+		NEW_STATE(dev,SCANNING);
+		defer_kevent(dev, KEVENT_SCAN);
+	} /* if (test_bit(KEVENT_JOIN, &amp;dev-&gt;kevent_flags)) */
+end_join:
+
+	if(test_bit(KEVENT_MGMT_TIMEOUT, &amp;dev-&gt;kevent_flags)){
+		clear_bit(KEVENT_MGMT_TIMEOUT, &amp;dev-&gt;kevent_flags);
+		handle_mgmt_timeout(dev);
+	}
+
+	if (test_bit(KEVENT_SCAN, &amp;dev-&gt;kevent_flags)) {
+		clear_bit(KEVENT_SCAN, &amp;dev-&gt;kevent_flags);
+		LOCK_ISTATE()
+		assert(dev-&gt;istate == SCANNING);
+
+		/* only clear the bss list when a scan is actively initiated,
+		 * otherwise simply rely on bss_list_timeout */
+		if( dev-&gt;site_survey_state == SITE_SURVEY_IN_PROGRESS)
+			free_bss_list(dev);
+		UNLOCK_ISTATE()
+
+		dev-&gt;scan_runs=3;
+		if ((ret=start_scan(dev, 0, 1)) &lt; 0) {
+			err(&quot;%s: %s: start_scan failed with %d&quot;,
+			    dev-&gt;netdev-&gt;name, __FUNCTION__, ret);
+		} else {
+			dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer for %d ticks&quot;,
+			    __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+			mod_timer(&amp;dev-&gt;mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		}
+
+	} /* if (test_bit(KEVENT_SCAN, &amp;dev-&gt;kevent_flags)) */
+
+
+	if (test_bit(KEVENT_SUBMIT_RX, &amp;dev-&gt;kevent_flags)) {
+		clear_bit(KEVENT_SUBMIT_RX, &amp;dev-&gt;kevent_flags);
+		submit_rx_urb(dev);
+	}
+
+
+	if (test_bit(KEVENT_RESTART, &amp;dev-&gt;kevent_flags)) {
+		clear_bit(KEVENT_RESTART, &amp;dev-&gt;kevent_flags);
+		LOCK_ISTATE()
+#if 0
+		assert(dev-&gt;istate == INIT);
+#endif
+		UNLOCK_ISTATE()
+		startup_device(dev);
+
+		/* call it here for default_iw_mode == IW_MODE_MONITOR and
+		   no subsequent  &quot;iwconfig wlanX mode monitor&quot; or
+		   &quot;iwpriv wlanX monitor 1|2 C&quot; to set dev-&gt;netdev-&gt;type 
+		   correctly */
+		set_monitor_mode(dev, dev-&gt;monitor_prism_header);
+
+
+		netif_carrier_off(dev-&gt;netdev); /* disable running netdev watchdog */
+		netif_stop_queue(dev-&gt;netdev); /* stop tx data packets */
+		if (dev-&gt;iw_mode != IW_MODE_MONITOR) {
+			NEW_STATE(dev,SCANNING);
+			defer_kevent(dev,KEVENT_SCAN);
+		} else {
+			NEW_STATE(dev,MONITORING);
+			start_scan(dev,0,0);
+			dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer for %d ticks&quot;,
+			    __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+			mod_timer(&amp;dev-&gt;mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		}
+	}
+
+	if (test_bit(KEVENT_ASSOC_DONE, &amp;dev-&gt;kevent_flags)) {
+		clear_bit(KEVENT_ASSOC_DONE, &amp;dev-&gt;kevent_flags);
+		LOCK_ISTATE()
+		assert(dev-&gt;istate == ASSOCIATING ||
+		       dev-&gt;istate == REASSOCIATING);
+		UNLOCK_ISTATE()
+		if (dev-&gt;iw_mode == IW_MODE_INFRA) {
+			assert(dev-&gt;curr_bss != NULL);
+			if (dev-&gt;curr_bss != NULL &amp;&amp; 
+			    dev-&gt;pm_mode != PM_ACTIVE) {
+				/* calc the listen interval in units of
+				   beacon intervals of the curr_bss */
+			       dev-&gt;pm_period_beacon = (dev-&gt;pm_period_us &gt;&gt; 10) / 
+					dev-&gt;curr_bss-&gt;beacon_interval;
+
+#ifdef DEBUG /* only to check if we need to set the listen interval here
+             or could do it in the (re)assoc_req parameter */
+				dump_mib_mac(dev);
+#endif
+
+				if (dev-&gt;pm_period_beacon &lt; 2)
+					dev-&gt;pm_period_beacon = 2;
+				else
+					if ( dev-&gt;pm_period_beacon &gt; 0xffff)
+						dev-&gt;pm_period_beacon = 0xffff;
+
+				dbg(DBG_PM, &quot;%s: pm_mode %d assoc id x%x listen int %d&quot;,
+				    dev-&gt;netdev-&gt;name, dev-&gt;pm_mode,
+				    dev-&gt;curr_bss-&gt;assoc_id, dev-&gt;pm_period_beacon);
+
+				set_associd(dev, dev-&gt;curr_bss-&gt;assoc_id);
+				set_listen_interval(dev, (u16)dev-&gt;pm_period_beacon);
+				set_pm_mode(dev, dev-&gt;pm_mode);
+#ifdef DEBUG
+				dump_mib_mac(dev);
+				dump_mib_mac_mgmt(dev);
+#endif
+			}
+		}
+
+		netif_carrier_on(dev-&gt;netdev);
+		netif_wake_queue(dev-&gt;netdev); /* _start_queue ??? */
+		NEW_STATE(dev,CONNECTED);
+		iwevent_bss_connect(dev-&gt;netdev,dev-&gt;curr_bss-&gt;bssid);
+		dbg(DBG_PROGRESS, &quot;%s: connected to BSSID %s&quot;,
+		    dev-&gt;netdev-&gt;name, mac2str(dev-&gt;curr_bss-&gt;bssid));
+	}
+
+
+	if (test_bit(KEVENT_RESET_DEVICE, &amp;dev-&gt;kevent_flags)) {
+
+		clear_bit(KEVENT_RESET_DEVICE, &amp;dev-&gt;kevent_flags);
+
+		dbg(DBG_DEVSTART, &quot;resetting the device&quot;);
+
+		usb_reset_device(dev-&gt;udev);
+
+		NEW_STATE(dev, WAIT_FOR_DISCONNECT);
+	}
+
+	if (test_bit(KEVENT_EXTERNAL_FW, &amp;dev-&gt;kevent_flags)) {
+		u8 op_mode;
+
+		clear_bit(KEVENT_EXTERNAL_FW, &amp;dev-&gt;kevent_flags);
+
+		op_mode = get_op_mode(dev-&gt;udev);
+		dbg(DBG_DEVSTART, &quot;opmode %d&quot;, op_mode);
+	
+		if (op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {
+			err(&quot;unexpected opmode %d&quot;, op_mode);
+			goto end_external_fw;
+		}
+
+		if (dev-&gt;extfw &amp;&amp; dev-&gt;extfw_size) {
+			ret = download_external_fw(dev-&gt;udev, dev-&gt;extfw,
+						   dev-&gt;extfw_size);
+			if (ret &lt; 0) {
+				err(&quot;Downloading external firmware failed: %d&quot;, ret);
+				goto end_external_fw;
+			}
+			if (dev-&gt;board_type == BOARDTYPE_505A_RFMD_2958) {
+				info(&quot;200 ms delay for board type 7&quot;);
+				/* jal: can I do this in kevent ??? */
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(HZ/5+1);
+			}
+		}
+		NEW_STATE(dev,INIT);
+		init_new_device(dev);
+	}
+end_external_fw:
+
+	if (test_bit(KEVENT_INTERNAL_FW, &amp;dev-&gt;kevent_flags)) {
+		clear_bit(KEVENT_INTERNAL_FW, &amp;dev-&gt;kevent_flags);
+
+		dbg(DBG_DEVSTART, &quot;downloading internal firmware&quot;);
+
+		ret=usbdfu_download(dev-&gt;udev, dev-&gt;intfw,
+				    dev-&gt;intfw_size,
+				    dev-&gt;board_type == BOARDTYPE_505A_RFMD_2958 ? 2000: 0);
+
+		if (ret &lt; 0) {
+			err(&quot;downloading internal fw failed with %d&quot;,ret);
+			goto end_internal_fw;
+		}
+ 
+		dbg(DBG_DEVSTART, &quot;sending REMAP&quot;);
+
+		/* no REMAP for 505A (see SF driver) */
+		if (dev-&gt;board_type != BOARDTYPE_505A_RFMD_2958)
+			if ((ret=at76c503_remap(dev-&gt;udev)) &lt; 0) {
+				err(&quot;sending REMAP failed with %d&quot;,ret);
+				goto end_internal_fw;
+			}
+
+		dbg(DBG_DEVSTART, &quot;sleeping for 2 seconds&quot;);
+		NEW_STATE(dev,EXTFW_DOWNLOAD);
+		mod_timer(&amp;dev-&gt;fw_dl_timer, jiffies+2*HZ+1);
+	}
+end_internal_fw:
+
+	up(&amp;dev-&gt;sem);
+
+	dbg(DBG_KEVENT, &quot;%s: kevent exit flags: 0x%lx&quot;, dev-&gt;netdev-&gt;name,
+	    dev-&gt;kevent_flags);
+
+	return;
+}
+
+static int essid_matched(struct at76c503 *dev, struct bss_info *ptr)
+{
+	/* common criteria for both modi */
+
+	int retval = (dev-&gt;essid_size == 0  /* ANY ssid */ ||
+		      (dev-&gt;essid_size == ptr-&gt;ssid_len &amp;&amp;
+		       !memcmp(dev-&gt;essid, ptr-&gt;ssid, ptr-&gt;ssid_len)));
+	if (!retval)
+		dbg(DBG_BSS_MATCH, &quot;%s bss table entry %p: essid didn't match&quot;,
+		    dev-&gt;netdev-&gt;name, ptr);
+	return retval;
+}
+
+static inline int mode_matched(struct at76c503 *dev, struct bss_info *ptr)
+{
+	int retval;
+
+	if (dev-&gt;iw_mode == IW_MODE_ADHOC)
+		retval =  ptr-&gt;capa &amp; WLAN_CAPABILITY_IBSS;
+	else
+		retval =  ptr-&gt;capa &amp; WLAN_CAPABILITY_ESS;
+	if (!retval)
+		dbg(DBG_BSS_MATCH, &quot;%s bss table entry %p: mode didn't match&quot;,
+		    dev-&gt;netdev-&gt;name, ptr);
+	return retval;
+}
+
+static int rates_matched(struct at76c503 *dev, struct bss_info *ptr)
+{
+	int i;
+	u8 *rate;
+
+	for(i=0,rate=ptr-&gt;rates; i &lt; ptr-&gt;rates_len; i++,rate++)
+		if (*rate &amp; 0x80) {
+			/* this is a basic rate we have to support
+			   (see IEEE802.11, ch. 7.3.2.2) */
+			if (*rate != (0x80|hw_rates[0]) &amp;&amp; *rate != (0x80|hw_rates[1]) &amp;&amp;
+			    *rate != (0x80|hw_rates[2]) &amp;&amp; *rate != (0x80|hw_rates[3])) {
+				dbg(DBG_BSS_MATCH,
+				    &quot;%s: bss table entry %p: basic rate %02x not supported&quot;,
+				     dev-&gt;netdev-&gt;name, ptr, *rate);
+				return 0;
+			}
+		}
+	/* if we use short preamble, the bss must support it */
+	if (dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT &amp;&amp;
+	    !(ptr-&gt;capa &amp; WLAN_CAPABILITY_SHORT_PREAMBLE)) {
+		dbg(DBG_BSS_MATCH, &quot;%s: %p does not support short preamble&quot;,
+		    dev-&gt;netdev-&gt;name, ptr);
+		return 0;
+	} else
+		return 1;
+}
+
+static inline int wep_matched(struct at76c503 *dev, struct bss_info *ptr)
+{
+	if (!dev-&gt;wep_enabled &amp;&amp; 
+	    ptr-&gt;capa &amp; WLAN_CAPABILITY_PRIVACY) {
+		/* we have disabled WEP, but the BSS signals privacy */
+		dbg(DBG_BSS_MATCH, &quot;%s: bss table entry %p: requires encryption&quot;,
+		    dev-&gt;netdev-&gt;name, ptr);
+		return 0;
+	}
+	/* otherwise if the BSS does not signal privacy it may well
+	   accept encrypted packets from us ... */
+	return 1;
+}
+
+static inline int bssid_matched(struct at76c503 *dev, struct bss_info *ptr)
+{
+	if (!dev-&gt;wanted_bssid_valid ||
+		!memcmp(ptr-&gt;bssid, dev-&gt;wanted_bssid, ETH_ALEN)) {
+		return 1;
+	} else {
+		if (at76_debug &amp; DBG_BSS_MATCH) {
+			dbg_uc(&quot;%s: requested bssid - %s does not match&quot;, 
+				dev-&gt;netdev-&gt;name, mac2str(dev-&gt;wanted_bssid));
+			dbg_uc(&quot;       AP bssid - %s of bss table entry %p&quot;, 
+				mac2str(ptr-&gt;bssid), ptr);
+		}
+		return 0;
+	}
+}
+
+static void dump_bss_table(struct at76c503 *dev, int force_output)
+{
+	struct bss_info *ptr;
+	/* hex dump output buffer for debug */
+	unsigned long flags;
+	struct list_head *lptr;
+
+	if ((at76_debug &amp; DBG_BSS_TABLE) || (force_output)) {
+		spin_lock_irqsave(&amp;dev-&gt;bss_list_spinlock, flags);
+
+		dbg_uc(&quot;%s BSS table (curr=%p, new=%p):&quot;, dev-&gt;netdev-&gt;name,
+		       dev-&gt;curr_bss, dev-&gt;new_bss);
+
+		list_for_each(lptr, &amp;dev-&gt;bss_list) {
+			ptr = list_entry(lptr, struct bss_info, list);
+			dbg_uc(&quot;0x%p: bssid %s channel %d ssid %s (%s)&quot;
+			    &quot; capa x%04x rates %s rssi %d link %d noise %d&quot;,
+			    ptr, mac2str(ptr-&gt;bssid),
+			    ptr-&gt;channel,
+			    ptr-&gt;ssid,
+			    hex2str(dev-&gt;obuf, ptr-&gt;ssid,
+				    min((sizeof(dev-&gt;obuf)-1)/2,
+					(size_t)ptr-&gt;ssid_len),'\0'),
+			    ptr-&gt;capa,
+			    hex2str(dev-&gt;obuf_s, ptr-&gt;rates, 
+				    min(sizeof(dev-&gt;obuf_s)/3,
+					(size_t)ptr-&gt;rates_len), ' '),
+			       ptr-&gt;rssi, ptr-&gt;link_qual, ptr-&gt;noise_level);
+		}
+
+		spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
+	}
+}
+
+/* try to find a matching bss in dev-&gt;bss, starting at position start.
+   returns the ptr to a matching bss in the list or
+   NULL if none found */
+/* last is the last bss tried, last == NULL signals a new round,
+   starting with list_entry(dev-&gt;bss_list.next, ...) */
+/* this proc must be called inside an acquired dev-&gt;bss_list_spinlock
+   otherwise the timeout on bss may remove the newly chosen entry ! */
+static struct bss_info *find_matching_bss(struct at76c503 *dev,
+					  struct bss_info *last)
+{
+	struct bss_info *ptr = NULL;
+	struct list_head *curr;
+
+	curr  = last != NULL ? last-&gt;list.next : dev-&gt;bss_list.next;
+	while (curr != &amp;dev-&gt;bss_list) {
+		ptr = list_entry(curr, struct bss_info, list);
+		if (essid_matched(dev,ptr) &amp;&amp;
+		    mode_matched(dev,ptr)  &amp;&amp;
+		    wep_matched(dev,ptr)   &amp;&amp;
+		    rates_matched(dev,ptr) &amp;&amp;
+		    bssid_matched(dev,ptr))
+			break;
+		curr = curr-&gt;next;
+	}
+
+	if (curr == &amp;dev-&gt;bss_list)
+		ptr = NULL;
+	/* otherwise ptr points to the struct bss_info we have chosen */
+
+	dbg(DBG_BSS_TABLE, &quot;%s %s: returned %p&quot;, dev-&gt;netdev-&gt;name,
+	    __FUNCTION__, ptr);
+	return ptr;
+} /* find_matching_bss */
+
+
+/* we got an association response */
+static void rx_mgmt_assoc(struct at76c503 *dev,
+			   struct at76c503_rx_buffer *buf)
+{
+	struct ieee80211_hdr_3addr *mgmt =
+		(struct ieee80211_hdr_3addr *)buf-&gt;packet;
+	struct ieee802_11_assoc_resp *resp = 
+		(struct ieee802_11_assoc_resp *)mgmt-&gt;payload;
+	u16 assoc_id = le16_to_cpu(resp-&gt;assoc_id);
+	u16 status = le16_to_cpu(resp-&gt;status);
+	u16 capa = le16_to_cpu(resp-&gt;capability); 
+	dbg(DBG_RX_MGMT, &quot;%s: rx AssocResp bssid %s capa x%04x status x%04x &quot;
+	    &quot;assoc_id x%04x rates %s&quot;,
+	    dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3), capa, status, assoc_id,
+	    hex2str(dev-&gt;obuf, resp-&gt;data+2,
+		    min((size_t)*(resp-&gt;data+1),(sizeof(dev-&gt;obuf)-1)/2), '\0'));
+	LOCK_ISTATE()
+	if (dev-&gt;istate == ASSOCIATING) {
+		UNLOCK_ISTATE()
+		assert(dev-&gt;curr_bss != NULL);
+		if (dev-&gt;curr_bss == NULL)
+			return;
+
+		if (status == WLAN_STATUS_SUCCESS) {
+			struct bss_info *ptr = dev-&gt;curr_bss;
+			ptr-&gt;assoc_id = assoc_id &amp; 0x3fff;
+			/* update iwconfig params */
+			memcpy(dev-&gt;bssid, ptr-&gt;bssid, ETH_ALEN);
+			memcpy(dev-&gt;essid, ptr-&gt;ssid, ptr-&gt;ssid_len);
+			dev-&gt;essid_size = ptr-&gt;ssid_len;
+			dev-&gt;channel = ptr-&gt;channel;
+			defer_kevent(dev,KEVENT_ASSOC_DONE);
+		} else {
+			NEW_STATE(dev,JOINING);
+			defer_kevent(dev,KEVENT_JOIN);
+		}
+		del_timer_sync(&amp;dev-&gt;mgmt_timer);
+	} else {
+		UNLOCK_ISTATE()
+		info(&quot;%s: AssocResp in state %d ignored&quot;,
+		     dev-&gt;netdev-&gt;name, dev-&gt;istate);
+	}
+} /* rx_mgmt_assoc */
+
+static void rx_mgmt_reassoc(struct at76c503 *dev,
+			   struct at76c503_rx_buffer *buf)
+{
+	struct ieee80211_hdr_3addr *mgmt =
+		(struct ieee80211_hdr_3addr *)buf-&gt;packet;
+	struct ieee802_11_assoc_resp *resp = 
+		(struct ieee802_11_assoc_resp *)mgmt-&gt;payload;
+	unsigned long flags;
+	u16 capa = le16_to_cpu(resp-&gt;capability);
+	u16 status = le16_to_cpu(resp-&gt;status);
+	u16 assoc_id = le16_to_cpu(resp-&gt;assoc_id);
+
+	dbg(DBG_RX_MGMT, &quot;%s: rx ReAssocResp bssid %s capa x%04x status x%04x &quot;
+	    &quot;assoc_id x%04x rates %s&quot;,
+	    dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3), capa, status, assoc_id,
+	    hex2str(dev-&gt;obuf, resp-&gt;data+2,
+		    min((size_t)*(resp-&gt;data+1),(sizeof(dev-&gt;obuf)-1)/2), '\0'));
+	LOCK_ISTATE()
+	if (dev-&gt;istate == REASSOCIATING) {
+		UNLOCK_ISTATE()
+		assert(dev-&gt;new_bss != NULL);
+		if (dev-&gt;new_bss == NULL)
+			return;
+
+		if (status == WLAN_STATUS_SUCCESS) {
+			struct bss_info *bptr = dev-&gt;new_bss;
+			bptr-&gt;assoc_id = assoc_id;
+			NEW_STATE(dev,CONNECTED);
+
+			iwevent_bss_connect(dev-&gt;netdev,bptr-&gt;bssid);
+
+			spin_lock_irqsave(&amp;dev-&gt;bss_list_spinlock, flags);
+			dev-&gt;curr_bss = dev-&gt;new_bss;
+			dev-&gt;new_bss = NULL;
+			spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
+
+			/* get ESSID, BSSID and channel for dev-&gt;curr_bss */
+			dev-&gt;essid_size = bptr-&gt;ssid_len;
+			memcpy(dev-&gt;essid, bptr-&gt;ssid, bptr-&gt;ssid_len);
+			memcpy(dev-&gt;bssid, bptr-&gt;bssid, ETH_ALEN);
+			dev-&gt;channel = bptr-&gt;channel;
+			dbg(DBG_PROGRESS, &quot;%s: reassociated to BSSID %s&quot;,
+			    dev-&gt;netdev-&gt;name, mac2str(dev-&gt;bssid));
+			defer_kevent(dev, KEVENT_ASSOC_DONE);
+		} else {
+			del_timer_sync(&amp;dev-&gt;mgmt_timer);
+			NEW_STATE(dev,JOINING);
+			defer_kevent(dev,KEVENT_JOIN);
+		}
+	} else {
+		info(&quot;%s: ReAssocResp in state %d ignored&quot;,
+		     dev-&gt;netdev-&gt;name, dev-&gt;istate);
+		UNLOCK_ISTATE()
+	}
+} /* rx_mgmt_reassoc */
+
+static void rx_mgmt_disassoc(struct at76c503 *dev,
+			   struct at76c503_rx_buffer *buf)
+{
+	struct ieee80211_hdr_3addr *mgmt =
+		(struct ieee80211_hdr_3addr *)buf-&gt;packet;
+	struct ieee802_11_disassoc_frame *resp = 
+		(struct ieee802_11_disassoc_frame *)mgmt-&gt;payload;
+
+	dbg(DBG_RX_MGMT, &quot;%s: rx DisAssoc bssid %s reason x%04x destination %s&quot;,
+	    dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3),
+	    le16_to_cpu(resp-&gt;reason),
+	    hex2str(dev-&gt;obuf, mgmt-&gt;addr1, 
+		    min((int)sizeof(dev-&gt;obuf)/3, ETH_ALEN), ':'));
+	LOCK_ISTATE()
+	if (dev-&gt;istate == SCANNING || dev-&gt;istate == INIT) {
+		UNLOCK_ISTATE()
+		return;
+	}
+	UNLOCK_ISTATE()
+
+	assert(dev-&gt;curr_bss != NULL);
+	if (dev-&gt;curr_bss == NULL)
+		return;
+	LOCK_ISTATE()
+	if (dev-&gt;istate == REASSOCIATING) {
+		UNLOCK_ISTATE()
+		assert(dev-&gt;new_bss != NULL);
+		if (dev-&gt;new_bss == NULL)
+			return;
+	} else
+		UNLOCK_ISTATE()
+	if (!memcmp(mgmt-&gt;addr3, dev-&gt;curr_bss-&gt;bssid, ETH_ALEN) &amp;&amp;
+		(!memcmp(dev-&gt;netdev-&gt;dev_addr, mgmt-&gt;addr1, ETH_ALEN) ||
+			!memcmp(bc_addr, mgmt-&gt;addr1, ETH_ALEN))) {
+		/* this is a DisAssoc from the BSS we are connected or
+		   trying to connect to, directed to us or broadcasted */
+		/* jal: TODO: can the DisAssoc also come from the BSS
+		   we've sent a ReAssocReq to (i.e. from dev-&gt;new_bss) ? */
+		LOCK_ISTATE()
+		if (dev-&gt;istate == DISASSOCIATING ||
+		    dev-&gt;istate == ASSOCIATING  ||
+		    dev-&gt;istate == REASSOCIATING  ||
+		    dev-&gt;istate == CONNECTED  ||
+		    dev-&gt;istate == JOINING)
+		{
+			if (dev-&gt;istate == CONNECTED) {
+				UNLOCK_ISTATE()
+				netif_carrier_off(dev-&gt;netdev);
+				netif_stop_queue(dev-&gt;netdev);
+				iwevent_bss_disconnect(dev-&gt;netdev);
+			} else UNLOCK_ISTATE()
+			del_timer_sync(&amp;dev-&gt;mgmt_timer);
+			NEW_STATE(dev,JOINING);
+			defer_kevent(dev,KEVENT_JOIN);
+		} else {
+			
+		/* ignore DisAssoc in states AUTH, ASSOC */
+			info(&quot;%s: DisAssoc in state %d ignored&quot;,
+			     dev-&gt;netdev-&gt;name, dev-&gt;istate);
+			UNLOCK_ISTATE()
+		}
+	}
+	/* ignore DisAssoc to other STA or from other BSSID */
+} /* rx_mgmt_disassoc */
+
+static void rx_mgmt_auth(struct at76c503 *dev,
+			   struct at76c503_rx_buffer *buf)
+{
+	struct ieee80211_hdr_3addr *mgmt =
+		(struct ieee80211_hdr_3addr *)buf-&gt;packet;
+	struct ieee802_11_auth_frame *resp = 
+		(struct ieee802_11_auth_frame *)mgmt-&gt;payload;
+	int seq_nr = le16_to_cpu(resp-&gt;seq_nr);
+	int alg = le16_to_cpu(resp-&gt;algorithm);
+	int status = le16_to_cpu(resp-&gt;status);
+
+	dbg(DBG_RX_MGMT, &quot;%s: rx AuthFrame bssid %s alg %d seq_nr %d status %d &quot; 
+	    &quot;destination %s&quot;,
+	    dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3),
+	    alg, seq_nr, status,
+	    hex2str(dev-&gt;obuf, mgmt-&gt;addr1,
+		    min((int)sizeof(dev-&gt;obuf)/3, ETH_ALEN), ':'));
+
+	if (alg == WLAN_AUTH_SHARED_KEY &amp;&amp;
+	    seq_nr == 2) {
+		dbg(DBG_RX_MGMT, &quot;%s: AuthFrame challenge %s ...&quot;,
+		    dev-&gt;netdev-&gt;name,
+		    hex2str(dev-&gt;obuf, resp-&gt;challenge,
+			    min((int)sizeof(dev-&gt;obuf)/3,18), ' '));
+	}
+	LOCK_ISTATE()
+	if (dev-&gt;istate != AUTHENTICATING) {
+		info(&quot;%s: ignored AuthFrame in state %d&quot;,
+		     dev-&gt;netdev-&gt;name, dev-&gt;istate);
+		UNLOCK_ISTATE()
+		return;
+	}
+	UNLOCK_ISTATE()
+	if (dev-&gt;auth_mode != alg) {
+		info(&quot;%s: ignored AuthFrame for alg %d&quot;,
+		     dev-&gt;netdev-&gt;name, alg);
+		return;
+	}
+
+	assert(dev-&gt;curr_bss != NULL);
+	if (dev-&gt;curr_bss == NULL)
+		return;
+
+	if (!memcmp(mgmt-&gt;addr3, dev-&gt;curr_bss-&gt;bssid, ETH_ALEN) &amp;&amp;
+	    !memcmp(dev-&gt;netdev-&gt;dev_addr, mgmt-&gt;addr1, ETH_ALEN)) {
+		/* this is a AuthFrame from the BSS we are connected or
+		   trying to connect to, directed to us */
+		if (status != WLAN_STATUS_SUCCESS) {
+			del_timer_sync(&amp;dev-&gt;mgmt_timer);
+			/* try to join next bss */
+			NEW_STATE(dev,JOINING);
+			defer_kevent(dev,KEVENT_JOIN);
+			return;
+		}
+
+		if (dev-&gt;auth_mode == WLAN_AUTH_OPEN ||
+			seq_nr == 4) {
+			dev-&gt;retries = ASSOC_RETRIES;
+			NEW_STATE(dev,ASSOCIATING);
+			assoc_req(dev, dev-&gt;curr_bss);
+			dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer + HZ&quot;,
+			    __FUNCTION__, __LINE__);
+			mod_timer(&amp;dev-&gt;mgmt_timer,jiffies+HZ);
+			return;
+		}
+
+		assert(seq_nr == 2);
+		auth_req(dev, dev-&gt;curr_bss, seq_nr+1, resp-&gt;challenge);
+		dbg(DBG_MGMT_TIMER, &quot;%s:%d: starting mgmt_timer + HZ&quot;,
+		    __FUNCTION__, __LINE__);
+		mod_timer(&amp;dev-&gt;mgmt_timer,jiffies+HZ);
+	}
+	/* else: ignore AuthFrames to other recipients */
+} /* rx_mgmt_auth */
+
+static void rx_mgmt_deauth(struct at76c503 *dev,
+			   struct at76c503_rx_buffer *buf)
+{
+	struct ieee80211_hdr_3addr *mgmt =
+		(struct ieee80211_hdr_3addr *)buf-&gt;packet;
+	struct ieee802_11_deauth_frame *resp = 
+		(struct ieee802_11_deauth_frame *)mgmt-&gt;payload;
+
+	dbg(DBG_RX_MGMT|DBG_PROGRESS,
+	    &quot;%s: rx DeAuth bssid %s reason x%04x destination %s&quot;,
+	    dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3),
+	    le16_to_cpu(resp-&gt;reason),
+	    hex2str(dev-&gt;obuf, mgmt-&gt;addr1,
+		    min((int)sizeof(dev-&gt;obuf)/3,ETH_ALEN), ':'));
+	LOCK_ISTATE()
+	if (dev-&gt;istate == DISASSOCIATING ||
+	    dev-&gt;istate == AUTHENTICATING ||
+	    dev-&gt;istate == ASSOCIATING ||
+	    dev-&gt;istate == REASSOCIATING  ||
+	    dev-&gt;istate == CONNECTED) {
+		UNLOCK_ISTATE()
+		assert(dev-&gt;curr_bss != NULL);
+		if (dev-&gt;curr_bss == NULL)
+			return;
+
+		if (!memcmp(mgmt-&gt;addr3, dev-&gt;curr_bss-&gt;bssid, ETH_ALEN) &amp;&amp;
+		(!memcmp(dev-&gt;netdev-&gt;dev_addr, mgmt-&gt;addr1, ETH_ALEN) ||
+		 !memcmp(bc_addr, mgmt-&gt;addr1, ETH_ALEN))) {
+			/* this is a DeAuth from the BSS we are connected or
+			   trying to connect to, directed to us or broadcasted */
+			LOCK_ISTATE()
+			if (dev-&gt;istate == CONNECTED) {
+				UNLOCK_ISTATE()
+				iwevent_bss_disconnect(dev-&gt;netdev);
+			} else UNLOCK_ISTATE()
+			NEW_STATE(dev,JOINING);
+			defer_kevent(dev,KEVENT_JOIN);
+			del_timer_sync(&amp;dev-&gt;mgmt_timer);
+		}
+		/* ignore DeAuth to other STA or from other BSSID */
+	} else {
+		/* ignore DeAuth in states SCANNING */
+		info(&quot;%s: DeAuth in state %d ignored&quot;,
+		     dev-&gt;netdev-&gt;name, dev-&gt;istate);
+		UNLOCK_ISTATE()
+	}
+} /* rx_mgmt_deauth */
+
+static void rx_mgmt_beacon(struct at76c503 *dev,
+			   struct at76c503_rx_buffer *buf)
+{
+	struct ieee80211_hdr_3addr *mgmt =
+		(struct ieee80211_hdr_3addr *)buf-&gt;packet;
+
+	/* beacon content */
+	struct ieee802_11_beacon_data *bdata = 
+		(struct ieee802_11_beacon_data *)mgmt-&gt;payload;
+
+	/* length of var length beacon parameters */
+	int varpar_len = min(le16_to_cpu(buf-&gt;wlength) -
+			     (int)(IEEE802_11_MGMT_HEADER_SIZE +
+			      offsetof(struct ieee802_11_beacon_data, data)),
+			     BEACON_MAX_DATA_LENGTH);
+
+	struct list_head *lptr;
+	struct bss_info *match; /* entry matching addr3 with its bssid */
+	int new_entry = 0;
+	int len;
+	struct data_element {
+		u8 type;
+		u8 length;
+		u8 data_head;
+	} *element;
+	int have_ssid = 0;
+	int have_rates = 0;
+	int have_channel = 0;
+	int keep_going = 1;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&amp;dev-&gt;bss_list_spinlock, flags);
+	LOCK_ISTATE()	
+	if (dev-&gt;istate == CONNECTED) {
+		UNLOCK_ISTATE()
+		/* in state CONNECTED we use the mgmt_timer to control
+		   the beacon of the BSS */
+		assert(dev-&gt;curr_bss != NULL);
+		if (dev-&gt;curr_bss == NULL)
+			goto rx_mgmt_beacon_end;
+		if (!memcmp(dev-&gt;curr_bss-&gt;bssid, mgmt-&gt;addr3, ETH_ALEN)) {
+			mod_timer(&amp;dev-&gt;mgmt_timer, jiffies+BEACON_TIMEOUT*HZ);
+			dev-&gt;curr_bss-&gt;rssi = buf-&gt;rssi;
+			dev-&gt;beacons_received++;
+			goto rx_mgmt_beacon_end;
+		}
+	} else 
+	    UNLOCK_ISTATE()
+
+	/* look if we have this BSS already in the list */
+	match = NULL;
+
+	if (!list_empty(&amp;dev-&gt;bss_list)) {
+		list_for_each(lptr, &amp;dev-&gt;bss_list) {
+			struct bss_info *bss_ptr = 
+				list_entry(lptr, struct bss_info, list);
+			if (!memcmp(bss_ptr-&gt;bssid, mgmt-&gt;addr3, ETH_ALEN)) {
+				match = bss_ptr;
+				break;
+			}
+		}
+	}
+
+	if (match == NULL) {
+		/* haven't found the bss in the list */
+		if ((match=kmalloc(sizeof(struct bss_info), GFP_ATOMIC)) == NULL) {
+			dbg(DBG_BSS_TABLE, &quot;%s: cannot kmalloc new bss info (%zd byte)&quot;,
+			    dev-&gt;netdev-&gt;name, sizeof(struct bss_info));
+			goto rx_mgmt_beacon_end;
+		}
+		memset(match,0,sizeof(*match));
+		new_entry = 1;
+		/* append new struct into list */
+		list_add_tail(&amp;match-&gt;list, &amp;dev-&gt;bss_list);
+	}
+	
+	/* we either overwrite an existing entry or append a new one
+	   match points to the entry in both cases */
+	
+	match-&gt;capa = le16_to_cpu(bdata-&gt;capability_information);
+	
+	/* while beacon_interval is not (!) */
+	match-&gt;beacon_interval = le16_to_cpu(bdata-&gt;beacon_interval);
+	
+	match-&gt;rssi = buf-&gt;rssi;
+	match-&gt;link_qual = buf-&gt;link_quality;
+	match-&gt;noise_level = buf-&gt;noise_level;
+	
+	memcpy(match-&gt;mac,mgmt-&gt;addr2,ETH_ALEN); /* just for info */
+	memcpy(match-&gt;bssid,mgmt-&gt;addr3,ETH_ALEN);
+	dbg(DBG_RX_BEACON, &quot;%s: bssid %s&quot;, dev-&gt;netdev-&gt;name, 
+			mac2str(match-&gt;bssid));
+	
+	element = (struct data_element*)bdata-&gt;data;
+	
+#define data_end(element) (&amp;(element-&gt;data_head) + element-&gt;length)
+	
+	/* This routine steps through the bdata-&gt;data array to try and get 
+	 * some useful information about the access point.
+	 * Currently, this implementation supports receipt of: SSID, 
+	 * supported transfer rates and channel, in any order, with some 
+	 * tolerance for intermittent unknown codes (although this 
+	 * functionality may not be necessary as the useful information will 
+	 * usually arrive in consecutively, but there have been some 
+	 * reports of some of the useful information fields arriving in a 
+	 * different order).
+	 * It does not support any more IE types although MFIE_TYPE_TIM may 
+	 * be supported (on my AP at least).  
+	 * The bdata-&gt;data array is about 1500 bytes long but only ~36 of those 
+	 * bytes are useful, hence the have_ssid etc optimizations. */
+
+	while (keep_going &amp;&amp;
+	       ((int)(data_end(element) - bdata-&gt;data) &lt;= varpar_len)) {
+
+		switch (element-&gt;type) {
+		
+		case MFIE_TYPE_SSID:
+			len = min(IW_ESSID_MAX_SIZE, (int)element-&gt;length);
+			if (!have_ssid &amp;&amp; ((new_entry) || 
+                                           !is_cloaked_ssid(&amp;(element-&gt;data_head), len))) {
+			/* we copy only if this is a new entry,
+			   or the incoming SSID is not a cloaked SSID. This 
+			   will protect us from overwriting a real SSID read 
+			   in a ProbeResponse with a cloaked one from a 
+			   following beacon. */
+			
+				match-&gt;ssid_len = len;
+				memcpy(match-&gt;ssid, &amp;(element-&gt;data_head), len);
+				match-&gt;ssid[len] = '\0'; /* terminate the 
+							    string for 
+							    printing */
+				dbg(DBG_RX_BEACON, &quot;%s: SSID - %s&quot;, 
+					dev-&gt;netdev-&gt;name, match-&gt;ssid);
+			}
+			have_ssid = 1;
+			break;
+		
+		case MFIE_TYPE_RATES:
+			if (!have_rates) {
+				match-&gt;rates_len = 
+					min((int)sizeof(match-&gt;rates), 
+						(int)element-&gt;length);
+				memcpy(match-&gt;rates, &amp;(element-&gt;data_head), 
+					match-&gt;rates_len);
+				have_rates = 1;
+				dbg(DBG_RX_BEACON, 
+				    &quot;%s: SUPPORTED RATES %s&quot;, 
+				    dev-&gt;netdev-&gt;name,
+				    hex2str(dev-&gt;obuf, &amp;(element-&gt;data_head),
+					    min((sizeof(dev-&gt;obuf)-1)/2,
+						(size_t)element-&gt;length), '\0'));
+			}
+			break;
+		
+		case MFIE_TYPE_DS_SET:
+			if (!have_channel) {
+				match-&gt;channel = element-&gt;data_head;
+				have_channel = 1;
+				dbg(DBG_RX_BEACON, &quot;%s: CHANNEL - %d&quot;, 
+					dev-&gt;netdev-&gt;name, match-&gt;channel);
+			}
+			break;
+		
+		case MFIE_TYPE_CF_SET:
+		case MFIE_TYPE_TIM:
+		case MFIE_TYPE_IBSS_SET:
+		default:
+		{
+			dbg(DBG_RX_BEACON, &quot;%s: beacon IE id %d len %d %s&quot;,
+			    dev-&gt;netdev-&gt;name, element-&gt;type, element-&gt;length,
+			    hex2str(dev-&gt;obuf,&amp;(element-&gt;data_head),
+				    min((sizeof(dev-&gt;obuf)-1)/2,
+					(size_t)element-&gt;length),'\0'));
+			break;
+		}
+
+		} /* switch (element-&gt;type) */
+		
+		/*  advance to the next 'element' of data */
+		element = (struct data_element*)data_end(element);
+
+		/* Optimization: after all, the bdata-&gt;data array is  
+		 * varpar_len bytes long, whereas we get all of the useful 
+		 * information after only ~36 bytes, this saves us a lot of 
+		 * time (and trouble as the remaining portion of the array 
+		 * could be full of junk)
+		 * Comment this out if you want to see what other information
+		 * comes from the AP - although little of it may be useful */
+	}
+	
+	dbg(DBG_RX_BEACON, &quot;%s: Finished processing beacon data&quot;, 
+		dev-&gt;netdev-&gt;name);
+	
+	match-&gt;last_rx = jiffies; /* record last rx of beacon */
+	
+rx_mgmt_beacon_end:
+	spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
+} /* rx_mgmt_beacon */
+
+
+/* calc the link level from a given rx_buffer */
+static void calc_level(struct at76c503 *dev, struct at76c503_rx_buffer *buf, struct iw_quality* qual)
+{	int max_rssi = 42; /* just a gues for now, might be different for other chips */
+
+    	qual-&gt;level = (buf-&gt;rssi * 100 / max_rssi);
+	if (qual-&gt;level &gt; 100)
+		qual-&gt;level = 100;
+	qual-&gt;updated |= IW_QUAL_LEVEL_UPDATED; 
+}
+
+
+/* calc the link quality from a given rx_buffer */
+static void calc_qual(struct at76c503 *dev, struct at76c503_rx_buffer *buf, struct iw_quality* qual)
+{
+	if((dev-&gt;board_type == BOARDTYPE_503_INTERSIL_3861) ||
+	   (dev-&gt;board_type == BOARDTYPE_503_INTERSIL_3863)) {
+	    qual-&gt;qual=buf-&gt;link_quality;
+	} else {
+	    qual-&gt;qual = qual-&gt;level * dev-&gt;beacons_received *
+	    		        dev-&gt;beacon_period /
+	                        (jiffies_to_msecs(jiffies) - dev-&gt;beacons_last_qual);
+		
+	    dev-&gt;beacons_last_qual = jiffies_to_msecs(jiffies);
+	    dev-&gt;beacons_received = 0;
+	}
+	qual-&gt;qual = (qual-&gt;qual &gt; 100) ? 100 : qual-&gt;qual;
+	qual-&gt;updated |= IW_QUAL_QUAL_UPDATED;
+}
+
+
+/* calc the noise quality from a given rx_buffer */
+static void calc_noise(struct at76c503 *dev, struct at76c503_rx_buffer *buf, struct iw_quality* qual)
+{
+	qual-&gt;noise = 0;
+	qual-&gt;updated |= IW_QUAL_NOISE_INVALID;
+}
+
+
+static void update_wstats(struct at76c503 *dev, struct at76c503_rx_buffer *buf)
+{
+	struct iw_quality *qual = &amp;dev-&gt;wstats.qual;
+
+	if (buf-&gt;rssi &amp;&amp; dev-&gt;istate == CONNECTED) {
+		qual-&gt;updated = 0;
+		calc_level(dev, buf, qual);
+		calc_qual(dev, buf, qual);
+		calc_noise(dev, buf, qual);
+	} else {
+		qual-&gt;qual = 0;
+		qual-&gt;level = 0;
+		qual-&gt;noise = 0;
+		qual-&gt;updated = IW_QUAL_ALL_INVALID;
+	}
+}
+
+static void rx_mgmt(struct at76c503 *dev, struct at76c503_rx_buffer *buf)
+{
+	struct ieee80211_hdr_3addr *mgmt =
+		(struct ieee80211_hdr_3addr *)buf-&gt;packet;
+	u16 subtype = le16_to_cpu(mgmt-&gt;frame_ctl) &amp; IEEE80211_FCTL_STYPE;
+
+	/* update wstats */
+	LOCK_ISTATE()
+	if (dev-&gt;istate != INIT &amp;&amp; dev-&gt;istate != SCANNING) {
+		UNLOCK_ISTATE()
+		/* jal: this is a dirty hack needed by Tim in ad-hoc mode */
+		if (dev-&gt;iw_mode == IW_MODE_ADHOC ||
+		    (dev-&gt;curr_bss != NULL &amp;&amp;
+		     !memcmp(mgmt-&gt;addr3, dev-&gt;curr_bss-&gt;bssid, ETH_ALEN))) {
+			/* Data packets always seem to have a 0 link level, so we
+			   only read link quality info from management packets.
+			   Atmel driver actually averages the present, and previous
+			   values, we just present the raw value at the moment - TJS */
+			
+			update_wstats(dev, buf);
+		}
+	} else UNLOCK_ISTATE()
+
+	if (at76_debug &amp; DBG_RX_MGMT_CONTENT) {
+		dbg_uc(&quot;%s rx mgmt subtype x%x %s&quot;,
+		       dev-&gt;netdev-&gt;name, subtype,
+		       hex2str(dev-&gt;obuf, (u8 *)mgmt, 
+			       min((sizeof(dev-&gt;obuf)-1)/2,
+				   (size_t)le16_to_cpu(buf-&gt;wlength)), '\0'));
+	}
+
+	switch (subtype) {
+	case IEEE80211_STYPE_BEACON:
+	case IEEE80211_STYPE_PROBE_RESP:
+		rx_mgmt_beacon(dev,buf);
+		break;
+
+	case IEEE80211_STYPE_ASSOC_RESP:
+		rx_mgmt_assoc(dev,buf);
+		break;
+
+	case IEEE80211_STYPE_REASSOC_RESP:
+		rx_mgmt_reassoc(dev,buf);
+		break;
+
+	case IEEE80211_STYPE_DISASSOC:
+		rx_mgmt_disassoc(dev,buf);
+		break;
+
+	case IEEE80211_STYPE_AUTH:
+		rx_mgmt_auth(dev,buf);
+		break;
+
+	case IEEE80211_STYPE_DEAUTH:
+		rx_mgmt_deauth(dev,buf);
+		break;
+
+	default:
+		info(&quot;%s: mgmt, but not beacon, subtype = %x&quot;,
+		     dev-&gt;netdev-&gt;name, subtype);
+	}
+
+	return;
+}
+
+static void dbg_dumpbuf(const char *tag, const u8 *buf, int size)
+{
+	int i;
+
+	if (!at76_debug) return;
+
+	for (i=0; i&lt;size; i++) {
+		if ((i % 8) == 0) {
+			if (i) printk(&quot;\n&quot;);
+			printk(KERN_DEBUG __FILE__ &quot;: %s: &quot;, tag);
+		}
+		printk(&quot;%02x &quot;, buf[i]);
+	}
+	printk(&quot;\n&quot;);
+}
+
+/* A short overview on Ethernet-II, 802.2, 802.3 and SNAP
+   (taken from <A HREF="http://www.geocities.com/billalexander/ethernet.html">http://www.geocities.com/billalexander/ethernet.html</A>):
+
+Ethernet Frame Formats:
+
+Ethernet (a.k.a. Ethernet II)
+
+        +---------+---------+---------+----------
+        |   Dst   |   Src   |  Type   |  Data... 
+        +---------+---------+---------+----------
+
+         &lt;-- 6 --&gt; &lt;-- 6 --&gt; &lt;-- 2 --&gt; &lt;-46-1500-&gt;
+
+         Type 0x80 0x00 = TCP/IP
+         Type 0x06 0x00 = XNS
+         Type 0x81 0x37 = Novell NetWare
+         
+
+802.3
+
+        +---------+---------+---------+----------
+        |   Dst   |   Src   | Length  | Data...  
+        +---------+---------+---------+----------
+
+         &lt;-- 6 --&gt; &lt;-- 6 --&gt; &lt;-- 2 --&gt; &lt;-46-1500-&gt;
+
+802.2 (802.3 with 802.2 header)
+
+        +---------+---------+---------+-------+-------+-------+----------
+        |   Dst   |   Src   | Length  | DSAP  | SSAP  |Control| Data...  
+        +---------+---------+---------+-------+-------+-------+----------
+
+                                       &lt;- 1 -&gt; &lt;- 1 -&gt; &lt;- 1 -&gt; &lt;-43-1497-&gt;
+
+SNAP (802.3 with 802.2 and SNAP headers) 
+
+        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
+        |   Dst   |   Src   | Length  | 0xAA  | 0xAA  | 0x03  |  Org Code |   Type  | Data...   
+        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
+
+                                                               &lt;--  3  --&gt; &lt;-- 2 --&gt; &lt;-38-1492-&gt;
+
+*/
+
+/* Convert the 802.11 header on a packet into an ethernet-style header
+ * (basically, pretend we're an ethernet card receiving ethernet packets)
+ *
+ * This routine returns with the skbuff pointing to the actual data (just past
+ * the end of the newly-created ethernet header).
+ */
+static void ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
+{
+	struct ieee80211_hdr_3addr *i802_11_hdr;
+	struct ethhdr *eth_hdr_p;
+	u8 *src_addr;
+	u8 *dest_addr;
+	__be16 proto = 0;
+	int build_ethhdr = 1;
+
+	i802_11_hdr = (struct ieee80211_hdr_3addr *)skb-&gt;data;
+
+#ifdef DEBUG
+	{
+		dbg_uc(&quot;%s: ENTRY skb len %d data %s&quot;, __FUNCTION__,
+		       skb-&gt;len, hex2str(dev-&gt;obuf, skb-&gt;data,
+					 min((int)sizeof(dev-&gt;obuf)/3,64), ' '));
+	}
+#endif
+
+	skb_pull(skb, sizeof(struct ieee80211_hdr_3addr));
+
+	src_addr = iw_mode == IW_MODE_ADHOC ? i802_11_hdr-&gt;addr2
+	       				    : i802_11_hdr-&gt;addr3;
+	dest_addr = i802_11_hdr-&gt;addr1;
+
+	eth_hdr_p = (struct ethhdr *)skb-&gt;data;
+	if (!memcmp(eth_hdr_p-&gt;h_source, src_addr, ETH_ALEN) &amp;&amp;
+	    !memcmp(eth_hdr_p-&gt;h_dest, dest_addr, ETH_ALEN)) {
+		/* An ethernet frame is encapsulated within the data portion.
+		 * Just use its header instead. */
+		skb_pull(skb, sizeof(struct ethhdr));
+		build_ethhdr = 0;
+	} else if (!memcmp(skb-&gt;data, snapsig, sizeof(snapsig))) {
+		/* SNAP frame - collapse it */
+		skb_pull(skb, sizeof(rfc1042sig)+2);
+		proto = *(__be16 *)(skb-&gt;data - 2);
+	} else {
+#ifdef IEEE_STANDARD
+		/* According to all standards, we should assume the data
+		 * portion contains 802.2 LLC information, so we should give it
+		 * an 802.3 header (which has the same implications) */
+		proto = htons(skb-&gt;len);
+#else /* IEEE_STANDARD */
+		/* Unfortunately, it appears no actual 802.11 implementations
+		 * follow any standards specs.  They all appear to put a
+		 * 16-bit ethertype after the 802.11 header instead, so we take
+		 * that value and make it into an Ethernet-II packet. */
+		/* Note that this means we can never support non-SNAP 802.2
+		 * frames (because we can't tell when we get one) */
+
+		/* jal: This isn't true. My WRT54G happily sends SNAP.
+		   Difficult to speak for all APs, so I don't dare to define
+		   IEEE_STANDARD ... */
+		proto = *(__be16 *)(skb-&gt;data);
+		skb_pull(skb, 2);
+#endif /* IEEE_STANDARD */
+	}
+
+	eth_hdr_p = (struct ethhdr *)(skb-&gt;data-sizeof(struct ethhdr));
+	set_eth_hdr(skb, eth_hdr_p);
+	if (build_ethhdr) {
+		/* This needs to be done in this order (eth_hdr_p-&gt;h_dest may
+		 * overlap src_addr) */
+		memcpy(eth_hdr_p-&gt;h_source, src_addr, ETH_ALEN);
+		memcpy(eth_hdr_p-&gt;h_dest, dest_addr, ETH_ALEN);
+		/* make an 802.3 header (proto = length) */
+		eth_hdr_p-&gt;h_proto = proto;
+	}
+
+	if (ntohs(eth_hdr_p-&gt;h_proto) &gt; 1518) {
+		skb-&gt;protocol = eth_hdr_p-&gt;h_proto;
+	} else if (*(unsigned short *)skb-&gt;data == 0xFFFF) {
+		/* Magic hack for Novell IPX-in-802.3 packets */
+		skb-&gt;protocol = htons(ETH_P_802_3);
+	} else {
+		/* Assume it's an 802.2 packet (it should be, and we have no
+		 * good way to tell if it isn't) */
+		skb-&gt;protocol = htons(ETH_P_802_2);
+	}
+
+#ifdef DEBUG
+	{
+		char da[3*ETH_ALEN], sa[3*ETH_ALEN];
+		dbg_uc(&quot;%s: EXIT skb da %s sa %s proto x%04x len %d data %s&quot;, __FUNCTION__,
+		       hex2str(da, eth_hdr(skb)-&gt;h_dest, ETH_ALEN, ':'),
+		       hex2str(sa, eth_hdr(skb)-&gt;h_source, ETH_ALEN, ':'),
+		       ntohs(skb-&gt;protocol), skb-&gt;len,
+		       hex2str(dev-&gt;obuf, skb-&gt;data, 
+			       min((int)sizeof(dev-&gt;obuf)/3,64), ' '));
+	}
+#endif
+
+}
+
+/* Adjust the skb to trim the hardware header and CRC, and set up skb-&gt;mac,
+ * skb-&gt;protocol, etc.
+ */ 
+static void ieee80211_fixup(struct sk_buff *skb, int iw_mode)
+{
+	struct ieee80211_hdr_3addr *i802_11_hdr;
+	struct ethhdr *eth_hdr_p;
+	u8 *src_addr;
+	u8 *dest_addr;
+	__be16 proto = 0;
+
+	i802_11_hdr = (struct ieee80211_hdr_3addr *)skb-&gt;data;
+	skb_pull(skb, sizeof(struct ieee80211_hdr_3addr));
+
+	src_addr = iw_mode == IW_MODE_ADHOC ? i802_11_hdr-&gt;addr2
+	       				    : i802_11_hdr-&gt;addr3;
+	dest_addr = i802_11_hdr-&gt;addr1;
+
+	skb-&gt;mac.raw = (unsigned char *)i802_11_hdr;
+
+	eth_hdr_p = (struct ethhdr *)skb-&gt;data;
+	if (!memcmp(eth_hdr_p-&gt;h_source, src_addr, ETH_ALEN) &amp;&amp;
+	    !memcmp(eth_hdr_p-&gt;h_dest, dest_addr, ETH_ALEN)) {
+		/* There's an ethernet header encapsulated within the data
+		 * portion, count it as part of the hardware header */
+		skb_pull(skb, sizeof(struct ethhdr));
+		proto = eth_hdr_p-&gt;h_proto;
+	} else if (!memcmp(skb-&gt;data, snapsig, sizeof(snapsig))) {
+		/* SNAP frame - collapse it */
+		/* RFC1042/802.1h encapsulated packet.  Treat the SNAP header
+		 * as part of the HW header and note the protocol. */
+		/* NOTE: prism2 doesn't collapse Appletalk frames (why?). */
+		skb_pull(skb, sizeof(rfc1042sig) + 2);
+		proto = *(__be16 *)(skb-&gt;data - 2);
+	}
+
+	if (ntohs(proto) &gt; 1518) {
+		skb-&gt;protocol = proto;
+	} else {
+#ifdef IEEE_STANDARD
+		/* According to all standards, we should assume the data
+		 * portion contains 802.2 LLC information */
+		skb-&gt;protocol = htons(ETH_P_802_2);
+#else /* IEEE_STANDARD */
+		/* Unfortunately, it appears no actual 802.11 implementations
+		 * follow any standards specs.  They all appear to put a
+		 * 16-bit ethertype after the 802.11 header instead, so we'll
+		 * use that (and consider it part of the hardware header). */
+		/* Note that this means we can never support non-SNAP 802.2
+		 * frames (because we can't tell when we get one) */
+		skb-&gt;protocol = *(__be16 *)skb-&gt;data;
+		skb_pull(skb, 2);
+#endif /* IEEE_STANDARD */
+	}
+}
+
+/* check for fragmented data in dev-&gt;rx_skb. If the packet was no fragment
+   or it was the last of a fragment set a skb containing the whole packet
+   is returned for further processing. Otherwise we get NULL and are
+   done and the packet is either stored inside the fragment buffer
+   or thrown away. The check for rx_copybreak is moved here.
+   Every returned skb starts with the ieee802_11 header and contains
+   _no_ FCS at the end */
+static struct sk_buff *check_for_rx_frags(struct at76c503 *dev)
+{	
+	struct sk_buff *skb = (struct sk_buff *)dev-&gt;rx_skb;
+	struct at76c503_rx_buffer *buf = (struct at76c503_rx_buffer *)skb-&gt;data;
+	struct ieee80211_hdr_3addr *i802_11_hdr =
+		(struct ieee80211_hdr_3addr *)buf-&gt;packet;
+	/* seq_ctrl, fragment_number, sequence number of new packet */
+	u16 sctl = le16_to_cpu(i802_11_hdr-&gt;seq_ctl);
+	u16 fragnr = sctl &amp; 0xf;
+	u16 seqnr = sctl&gt;&gt;4;
+	u16 frame_ctl = le16_to_cpu(i802_11_hdr-&gt;frame_ctl);
+
+	/* length including the IEEE802.11 header, excl. the trailing FCS,
+	   excl. the struct at76c503_rx_buffer */
+	int length = le16_to_cpu(buf-&gt;wlength) - dev-&gt;rx_data_fcs_len;
+	
+	/* where does the data payload start in skb-&gt;data ? */
+	u8 *data = (u8 *)i802_11_hdr + sizeof(struct ieee80211_hdr_3addr);
+
+	/* length of payload, excl. the trailing FCS */
+	int data_len = length - (data - (u8 *)i802_11_hdr);
+
+	int i;
+	struct rx_data_buf *bptr, *optr;
+	unsigned long oldest = ~0UL;
+
+	dbg(DBG_RX_FRAGS, &quot;%s: rx data frame_ctl %04x addr2 %s seq/frag %d/%d &quot;
+	    &quot;length %d data %d: %s ...&quot;,
+	    dev-&gt;netdev-&gt;name, frame_ctl,
+	    mac2str(i802_11_hdr-&gt;addr2),
+	    seqnr, fragnr, length, data_len,
+	    hex2str(dev-&gt;obuf, data,
+		    min((int)(sizeof(dev-&gt;obuf)-1)/2,32), '\0'));
+
+	dbg(DBG_RX_FRAGS_SKB, &quot;%s: incoming skb: head %p data %p &quot;
+	    &quot;tail %p end %p len %d&quot;,
+	    dev-&gt;netdev-&gt;name, skb-&gt;head, skb-&gt;data, skb-&gt;tail,
+	    skb-&gt;end, skb-&gt;len);
+
+	if (data_len &lt;= 0) {
+		/* buffers contains no data */
+		info(&quot;%s: rx skb without data&quot;, dev-&gt;netdev-&gt;name);
+		return NULL;
+	}
+
+	if (fragnr == 0 &amp;&amp; !(frame_ctl &amp; IEEE80211_FCTL_MOREFRAGS)) {
+		/* unfragmented packet received */
+		if (length &lt; rx_copybreak &amp;&amp; (skb = dev_alloc_skb(length)) != NULL) {
+			memcpy(skb_put(skb, length),
+			       dev-&gt;rx_skb-&gt;data + AT76C503_RX_HDRLEN, length);
+		} else {
+			skb_pull(skb, AT76C503_RX_HDRLEN);
+			skb_trim(skb, length);
+			/* Use a new skb for the next receive */
+			dev-&gt;rx_skb = NULL;
+		}
+
+		dbg(DBG_RX_FRAGS, &quot;%s: unfragmented&quot;, dev-&gt;netdev-&gt;name);
+
+		return skb;
+	}
+
+	/* remove the at76c503_rx_buffer header - we don't need it anymore */
+	/* we need the IEEE802.11 header (for the addresses) if this packet
+	   is the first of a chain */
+
+	assert(length  &gt; AT76C503_RX_HDRLEN);
+	skb_pull(skb, AT76C503_RX_HDRLEN);
+	/* remove FCS at end */
+	skb_trim(skb, length);
+
+	dbg(DBG_RX_FRAGS_SKB, &quot;%s: trimmed skb: head %p data %p tail %p &quot;
+	    &quot;end %p len %d data %p data_len %d&quot;,
+	    dev-&gt;netdev-&gt;name, skb-&gt;head, skb-&gt;data, skb-&gt;tail,
+	    skb-&gt;end, skb-&gt;len, data, data_len);
+
+	/* look if we've got a chain for the sender address.
+	   afterwards optr points to first free or the oldest entry,
+	   or, if i &lt; NR_RX_DATA_BUF, bptr points to the entry for the
+	   sender address */
+	/* determining the oldest entry doesn't cope with jiffies wrapping
+	   but I don't care to delete a young entry at these rare moments ... */
+
+	for(i=0,bptr=dev-&gt;rx_data,optr=NULL; i &lt; NR_RX_DATA_BUF; i++,bptr++) {
+		if (bptr-&gt;skb != NULL) {
+			if (!memcmp(i802_11_hdr-&gt;addr2, bptr-&gt;sender,ETH_ALEN))
+				break;
+			else
+				if (optr == NULL) {
+					optr = bptr;
+					oldest = bptr-&gt;last_rx;
+				} else {
+					if (bptr-&gt;last_rx &lt; oldest)
+						optr = bptr;
+				}
+		} else {
+			optr = bptr;
+			oldest = 0UL;
+		}
+	}
+	
+	if (i &lt; NR_RX_DATA_BUF) {
+
+		dbg(DBG_RX_FRAGS, &quot;%s: %d. cacheentry (seq/frag=%d/%d) &quot;
+		    &quot;matched sender addr&quot;,
+		    dev-&gt;netdev-&gt;name, i, bptr-&gt;seqnr, bptr-&gt;fragnr);
+
+		/* bptr points to an entry for the sender address */
+		if (bptr-&gt;seqnr == seqnr) {
+			int left;
+			/* the fragment has the current sequence number */
+			if (((bptr-&gt;fragnr+1)&amp;0xf) == fragnr) {
+				bptr-&gt;last_rx = jiffies;
+				/* the next following fragment number -&gt;
+				    add the data at the end */
+				/* is &amp; 0xf necessary above ??? */
+
+				/* for test only ??? */
+				if ((left=skb_tailroom(bptr-&gt;skb)) &lt; data_len) {
+					info(&quot;%s: only %d byte free (need %d)&quot;,
+					    dev-&gt;netdev-&gt;name, left, data_len);
+				} else 
+					memcpy(skb_put(bptr-&gt;skb, data_len),
+					       data, data_len);
+				bptr-&gt;fragnr = fragnr;
+				if (!(frame_ctl &amp;
+				      IEEE80211_FCTL_MOREFRAGS)) {
+					/* this was the last fragment - send it */
+					skb = bptr-&gt;skb;
+					bptr-&gt;skb = NULL; /* free the entry */
+					dbg(DBG_RX_FRAGS, &quot;%s: last frag of seq %d&quot;,
+					    dev-&gt;netdev-&gt;name, seqnr);
+					return skb;
+				} else
+					return NULL;
+			} else {
+				/* wrong fragment number -&gt; ignore it */
+				dbg(DBG_RX_FRAGS, &quot;%s: frag nr does not match: %d+1 != %d&quot;,
+				    dev-&gt;netdev-&gt;name, bptr-&gt;fragnr, fragnr);
+				return NULL;
+			}
+		} else {
+			/* got another sequence number */
+			if (fragnr == 0) {
+				/* it's the start of a new chain - replace the
+				   old one by this */
+				/* bptr-&gt;sender has the correct value already */
+				dbg(DBG_RX_FRAGS, &quot;%s: start of new seq %d, &quot;
+				    &quot;removing old seq %d&quot;, dev-&gt;netdev-&gt;name,
+				    seqnr, bptr-&gt;seqnr);
+				bptr-&gt;seqnr = seqnr;
+				bptr-&gt;fragnr = 0;
+				bptr-&gt;last_rx = jiffies;
+				/* swap bptr-&gt;skb and dev-&gt;rx_skb */
+				skb = bptr-&gt;skb;
+				bptr-&gt;skb = dev-&gt;rx_skb;
+				dev-&gt;rx_skb = skb;
+			} else {
+				/* it from the middle of a new chain -&gt;
+				   delete the old entry and skip the new one */
+				dbg(DBG_RX_FRAGS, &quot;%s: middle of new seq %d (%d) &quot;
+				    &quot;removing old seq %d&quot;, dev-&gt;netdev-&gt;name,
+				    seqnr, fragnr, bptr-&gt;seqnr);
+				dev_kfree_skb(bptr-&gt;skb);
+				bptr-&gt;skb = NULL;
+			}
+			return NULL;
+		}
+	} else {
+		/* if we didn't find a chain for the sender address optr
+		   points either to the first free or the oldest entry */
+
+		if (fragnr != 0) {
+			/* this is not the begin of a fragment chain ... */
+			dbg(DBG_RX_FRAGS, &quot;%s: no chain for non-first fragment (%d)&quot;,
+			    dev-&gt;netdev-&gt;name, fragnr);
+			return NULL;
+		}
+		assert(optr != NULL);
+		if (optr == NULL)
+			return NULL;
+
+		if (optr-&gt;skb != NULL) {
+			/* swap the skb's */
+			skb = optr-&gt;skb;
+			optr-&gt;skb = dev-&gt;rx_skb;
+			dev-&gt;rx_skb = skb;
+
+			dbg(DBG_RX_FRAGS, &quot;%s: free old contents: sender %s seq/frag %d/%d&quot;,
+			    dev-&gt;netdev-&gt;name, mac2str(optr-&gt;sender),
+			    optr-&gt;seqnr, optr-&gt;fragnr); 
+
+		} else {
+			/* take the skb from dev-&gt;rx_skb */
+			optr-&gt;skb = dev-&gt;rx_skb;
+			dev-&gt;rx_skb = NULL; /* let submit_rx_urb() allocate a new skb */
+
+			dbg(DBG_RX_FRAGS, &quot;%s: use a free entry&quot;, dev-&gt;netdev-&gt;name);
+		}
+		memcpy(optr-&gt;sender, i802_11_hdr-&gt;addr2, ETH_ALEN);
+		optr-&gt;seqnr = seqnr;
+		optr-&gt;fragnr = 0;
+		optr-&gt;last_rx = jiffies;
+		
+		return NULL;
+	}
+} /* check_for_rx_frags */
+
+/* rx interrupt: we expect the complete data buffer in dev-&gt;rx_skb */
+static void rx_data(struct at76c503 *dev)
+{
+	struct net_device *netdev = (struct net_device *)dev-&gt;netdev;
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	struct sk_buff *skb = dev-&gt;rx_skb;
+	struct at76c503_rx_buffer *buf = (struct at76c503_rx_buffer *)skb-&gt;data;
+	struct ieee80211_hdr_3addr *i802_11_hdr;
+	int length = le16_to_cpu(buf-&gt;wlength);
+
+	if (at76_debug &amp; DBG_RX_DATA) {
+		dbg_uc(&quot;%s received data packet:&quot;, netdev-&gt;name);
+		dbg_dumpbuf(&quot; rxhdr&quot;, skb-&gt;data, AT76C503_RX_HDRLEN);
+	}
+	if (at76_debug &amp; DBG_RX_DATA_CONTENT)
+		dbg_dumpbuf(&quot;packet&quot;, skb-&gt;data + AT76C503_RX_HDRLEN,
+			    length);
+
+	if ((skb=check_for_rx_frags(dev)) == NULL)
+		return;
+
+	/* if an skb is returned, the at76c503a_rx_header and the FCS is already removed */
+	i802_11_hdr = (struct ieee80211_hdr_3addr *)skb-&gt;data;
+
+	skb-&gt;dev = netdev;
+	skb-&gt;ip_summed = CHECKSUM_NONE; /* TODO: should check CRC */
+
+	if (i802_11_hdr-&gt;addr1[0] &amp; 1) {
+		if (!memcmp(i802_11_hdr-&gt;addr1, netdev-&gt;broadcast, ETH_ALEN))
+			skb-&gt;pkt_type = PACKET_BROADCAST;
+		else
+			skb-&gt;pkt_type = PACKET_MULTICAST;
+	} else if (memcmp(i802_11_hdr-&gt;addr1, netdev-&gt;dev_addr, ETH_ALEN)) {
+		skb-&gt;pkt_type=PACKET_OTHERHOST;
+	}
+
+	if (netdev-&gt;type == ARPHRD_ETHER) {
+		ieee80211_to_eth(skb, dev-&gt;iw_mode);
+	} else {
+		ieee80211_fixup(skb, dev-&gt;iw_mode);
+	}
+
+	netdev-&gt;last_rx = jiffies;
+	netif_rx(skb);
+	stats-&gt;rx_packets++;
+	stats-&gt;rx_bytes += length;
+
+	return;
+}
+
+static int submit_rx_urb(struct at76c503 *dev)
+{
+	int ret, size;
+	struct sk_buff *skb = dev-&gt;rx_skb;
+	
+	if (dev-&gt;read_urb == NULL) {
+		err(&quot;%s: dev-&gt;read_urb is NULL&quot;, __FUNCTION__);
+		return -EFAULT;
+	}
+
+	if (skb == NULL) {
+		skb = dev_alloc_skb(sizeof(struct at76c503_rx_buffer));
+		if (skb == NULL) {
+			err(&quot;%s: unable to allocate rx skbuff.&quot;, dev-&gt;netdev-&gt;name);
+			ret = -ENOMEM;
+			goto exit;
+		}
+		dev-&gt;rx_skb = skb;
+	} else {
+		skb_push(skb, skb_headroom(skb));
+		skb_trim(skb, 0);
+	}
+
+	size = skb_tailroom(skb);
+	FILL_BULK_URB(dev-&gt;read_urb, dev-&gt;udev,
+		usb_rcvbulkpipe(dev-&gt;udev, dev-&gt;bulk_in_endpointAddr),
+		skb_put(skb, size), size,
+		(usb_complete_t)at76c503_read_bulk_callback, dev);
+	ret = usb_submit_urb(dev-&gt;read_urb, GFP_ATOMIC);
+	if (ret &lt; 0) { 
+		if (ret == -ENODEV) 
+			dbg(DBG_DEVSTART, &quot;usb_submit_urb returned -ENODEV&quot;);
+		else
+			err(&quot;%s: rx, usb_submit_urb failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+
+exit:
+	if (ret &lt; 0) {
+		if (ret != -ENODEV) {
+			/* If we can't submit the URB, the adapter becomes completely
+		 	* useless, so try again later */
+			if (--dev-&gt;nr_submit_rx_tries &gt; 0)
+				defer_kevent(dev, KEVENT_SUBMIT_RX);
+			else {
+				err(&quot;%s: giving up to submit rx urb after %d failures -&quot;
+			    	    &quot; please unload the driver and/or power cycle the device&quot;,
+			    	    dev-&gt;netdev-&gt;name, NR_SUBMIT_RX_TRIES);
+			}
+		}
+	} else
+		/* reset counter to initial value */
+		dev-&gt;nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;
+	return ret;
+}
+
+
+/* we are doing a lot of things here in an interrupt. Need
+   a bh handler (Watching TV with a TV card is probably
+   a good test: if you see flickers, we are doing too much.
+   Currently I do see flickers... even with our tasklet :-( )
+   Maybe because the bttv driver and usb-uhci use the same interrupt
+*/
+/* Or maybe because our BH handler is preempting bttv's BH handler.. BHs don't
+ * solve everything.. (alex) */
+static void at76c503_read_bulk_callback (struct urb *urb)
+{
+	struct at76c503 *dev = (struct at76c503 *)urb-&gt;context;
+
+	dev-&gt;rx_urb = urb;
+	tasklet_schedule(&amp;dev-&gt;tasklet);
+
+	return;
+}
+
+static void rx_monitor_mode(struct at76c503 *dev)
+{
+	struct net_device *netdev = (struct net_device *)dev-&gt;netdev;
+	struct at76c503_rx_buffer *buf = 
+		(struct at76c503_rx_buffer *)dev-&gt;rx_skb-&gt;data;
+	/* length including the IEEE802.11 header, excl. the trailing FCS,
+		excl. the struct at76c503_rx_buffer */
+	int length = le16_to_cpu(buf-&gt;wlength) - dev-&gt;rx_data_fcs_len;
+	struct sk_buff *skb = dev-&gt;rx_skb;
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	struct iw_statistics *wstats = &amp;dev-&gt;wstats;
+
+	update_wstats(dev, buf);
+
+	if (length &lt; 0) {
+		/* buffer contains no data */
+		dbg(DBG_MONITOR_MODE, &quot;%s: MONITOR MODE: rx skb without data&quot;,
+		    dev-&gt;netdev-&gt;name);
+		return;
+	}
+
+	if (netdev-&gt;type == ARPHRD_IEEE80211_PRISM) {
+		int skblen = sizeof(p80211msg_lnxind_wlansniffrm_t) + length;
+		p80211msg_lnxind_wlansniffrm_t *prism;
+		u8* payload;
+
+		if ((skb = dev_alloc_skb(skblen)) == NULL) {
+			err(&quot;%s: MONITOR MODE: dev_alloc_skb for Prism header &quot;
+			    &quot;returned NULL&quot;, dev-&gt;netdev-&gt;name);
+			return;
+		}
+
+		skb_put(skb, skblen);
+
+		prism = (p80211msg_lnxind_wlansniffrm_t*)skb-&gt;data;
+		payload = skb-&gt;data + sizeof(p80211msg_lnxind_wlansniffrm_t);
+
+		prism-&gt;msgcode = DIDmsg_lnxind_wlansniffrm;
+		prism-&gt;msglen = sizeof(p80211msg_lnxind_wlansniffrm_t);
+		strcpy(prism-&gt;devname, netdev-&gt;name);
+
+		prism-&gt;hosttime.did = DIDmsg_lnxind_wlansniffrm_hosttime;
+		prism-&gt;hosttime.status = 0;
+		prism-&gt;hosttime.len = 4;
+		prism-&gt;hosttime.data = jiffies;
+
+		prism-&gt;mactime.did = DIDmsg_lnxind_wlansniffrm_mactime;
+		prism-&gt;mactime.status = 0;
+		prism-&gt;mactime.len = 4;
+		memcpy(&amp;prism-&gt;mactime.data, buf-&gt;rx_time, 4);
+
+		prism-&gt;channel.did = DIDmsg_lnxind_wlansniffrm_channel;
+		prism-&gt;channel.status = P80211ENUM_msgitem_status_no_value;
+		prism-&gt;channel.len = 4;
+		/* INFO: The channel is encoded in the beacon info. 
+		   (Kismet can figure it out, so less processing here) */
+		prism-&gt;channel.data = 0;
+
+		prism-&gt;rssi.did = DIDmsg_lnxind_wlansniffrm_rssi;
+		prism-&gt;rssi.status = 0;
+		prism-&gt;rssi.len = 4;
+		prism-&gt;rssi.data = buf-&gt;rssi;
+
+		prism-&gt;sq.did = DIDmsg_lnxind_wlansniffrm_sq;
+		prism-&gt;sq.status = 0;
+		prism-&gt;sq.len = 4;
+		prism-&gt;sq.data = wstats-&gt;qual.qual;
+
+		prism-&gt;signal.did = DIDmsg_lnxind_wlansniffrm_signal;
+		prism-&gt;signal.status = 0;
+		prism-&gt;signal.len = 4;
+		prism-&gt;signal.data = wstats-&gt;qual.level;
+
+		prism-&gt;noise.did = DIDmsg_lnxind_wlansniffrm_noise;
+		prism-&gt;noise.status = 0;
+		prism-&gt;noise.len = 4;
+		prism-&gt;noise.data = wstats-&gt;qual.noise;
+
+		prism-&gt;rate.did = DIDmsg_lnxind_wlansniffrm_rate;
+		prism-&gt;rate.status = 0;
+		prism-&gt;rate.len = 4;
+		prism-&gt;rate.data = hw_rates[buf-&gt;rx_rate] &amp; (~0x80);
+
+		prism-&gt;istx.did = DIDmsg_lnxind_wlansniffrm_istx;
+		prism-&gt;istx.status = 0;
+		prism-&gt;istx.len = 4;
+		prism-&gt;istx.data = P80211ENUM_truth_false;
+
+		prism-&gt;frmlen.did = DIDmsg_lnxind_wlansniffrm_frmlen;
+		prism-&gt;frmlen.status = 0;
+		prism-&gt;frmlen.len = 4;
+		prism-&gt;frmlen.data = length;
+
+		memcpy(payload, buf-&gt;packet, length);
+	} else {
+		/* netdev-&gt;type != ARPHRD_IEEE80211_PRISM */
+		skb_pull(skb, AT76C503_RX_HDRLEN);
+		skb_trim(skb, length);
+		dev-&gt;rx_skb = NULL;
+	}
+
+	skb-&gt;dev = netdev;
+	skb-&gt;ip_summed = CHECKSUM_NONE;
+	skb-&gt;mac.raw = skb-&gt;data;
+	skb-&gt;pkt_type = PACKET_OTHERHOST;
+	skb-&gt;protocol = htons(ETH_P_80211_RAW);
+
+	netdev-&gt;last_rx = jiffies;
+	netif_rx(skb);
+	stats-&gt;rx_packets++;
+	stats-&gt;rx_bytes += length;
+} /* end of rx_monitor_mode */
+
+
+static void rx_tasklet(unsigned long param)
+{
+	struct at76c503 *dev = (struct at76c503 *)param;
+	struct urb *urb;
+	struct net_device *netdev;
+	struct at76c503_rx_buffer *buf;
+	struct ieee80211_hdr_3addr *i802_11_hdr;
+	u16 frame_ctl;
+
+	if (!dev) return;
+	urb = dev-&gt;rx_urb;
+	netdev = (struct net_device *)dev-&gt;netdev;
+
+	if (dev-&gt;device_unplugged) {
+		dbg(DBG_DEVSTART, &quot;device unplugged&quot;);
+		if (urb)
+			dbg(DBG_DEVSTART, &quot;urb status %d&quot;, urb-&gt;status);
+		return;
+	}
+
+
+	if(!urb || !dev-&gt;rx_skb || !netdev || !dev-&gt;rx_skb-&gt;data) return;
+
+	buf = (struct at76c503_rx_buffer *)dev-&gt;rx_skb-&gt;data;
+
+	if (!buf) return;
+
+	i802_11_hdr = (struct ieee80211_hdr_3addr *)buf-&gt;packet;
+	if (!i802_11_hdr) return;
+
+	frame_ctl = le16_to_cpu(i802_11_hdr-&gt;frame_ctl);
+
+	if(urb-&gt;status != 0){
+		if ((urb-&gt;status != -ENOENT) &amp;&amp; 
+		    (urb-&gt;status != -ECONNRESET)) {
+			dbg(DBG_URB,&quot;%s %s: - nonzero read bulk status received: %d&quot;,
+			    __FUNCTION__, netdev-&gt;name, urb-&gt;status);
+			goto no_more_urb;
+		}
+		return;
+	}
+
+	if (at76_debug &amp; DBG_RX_ATMEL_HDR) {
+		dbg_uc(&quot;%s: rx frame: rate %d rssi %d noise %d link %d %s&quot;,
+		    dev-&gt;netdev-&gt;name,
+		    buf-&gt;rx_rate, buf-&gt;rssi, buf-&gt;noise_level,
+		    buf-&gt;link_quality,
+		    hex2str(dev-&gt;obuf,(u8 *)i802_11_hdr,
+			    min((int)(sizeof(dev-&gt;obuf)-1)/2,48),'\0'));
+	}
+	LOCK_ISTATE()
+	if (dev-&gt;istate == MONITORING) {
+		UNLOCK_ISTATE()
+		rx_monitor_mode(dev);
+		goto finish;
+	}
+	UNLOCK_ISTATE()
+
+	/* there is a new bssid around, accept it: */
+	if(buf-&gt;newbss &amp;&amp; dev-&gt;iw_mode == IW_MODE_ADHOC) {
+		dbg(DBG_PROGRESS, &quot;%s: rx newbss&quot;, netdev-&gt;name);
+		defer_kevent(dev, KEVENT_NEW_BSS);
+	}
+
+	switch (frame_ctl &amp; IEEE80211_FCTL_FTYPE) {
+	case IEEE80211_FTYPE_DATA:
+		rx_data(dev);
+		break;
+
+	case IEEE80211_FTYPE_MGMT:
+		/* jal: TODO: find out if we can update iwspy also on
+		   other frames than management (might depend on the
+		   radio chip / firmware version !) */
+
+		iwspy_update(dev, buf);
+
+		rx_mgmt(dev, buf);
+		break;
+
+	case IEEE80211_FTYPE_CTL:
+		dbg(DBG_RX_CTRL, &quot;%s: ignored ctrl frame: %04x&quot;, dev-&gt;netdev-&gt;name,
+		    frame_ctl);
+		break;
+
+	default:
+		info(&quot;%s: it's a frame from mars: %2x&quot;, dev-&gt;netdev-&gt;name,
+		     frame_ctl);
+	} /* switch (frame_ctl &amp; IEEE80211_FCTL_FTYPE) */
+finish:
+	submit_rx_urb(dev);
+ no_more_urb:
+	return;
+}
+
+static void at76c503_write_bulk_callback (struct urb *urb)
+{
+	struct at76c503 *dev = (struct at76c503 *)urb-&gt;context;
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	unsigned long flags;
+	struct at76c503_tx_buffer *mgmt_buf;
+	int ret;
+
+	if(urb-&gt;status != 0){
+		if((urb-&gt;status != -ENOENT) &amp;&amp; 
+		   (urb-&gt;status != -ECONNRESET)) {
+			dbg(DBG_URB, &quot;%s - nonzero write bulk status received: %d&quot;,
+			    __FUNCTION__, urb-&gt;status);
+		}else
+			return; /* urb has been unlinked */
+		stats-&gt;tx_errors++;
+	}else
+		stats-&gt;tx_packets++;
+
+	spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock, flags);
+	mgmt_buf = dev-&gt;next_mgmt_bulk;
+	dev-&gt;next_mgmt_bulk = NULL;
+	spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock, flags);
+
+	if (mgmt_buf) {
+		/* we don't copy the padding bytes, but add them
+		   to the length */
+		memcpy(dev-&gt;bulk_out_buffer, mgmt_buf,
+		       le16_to_cpu(mgmt_buf-&gt;wlength) +
+		       offsetof(struct at76c503_tx_buffer,packet));
+		FILL_BULK_URB(dev-&gt;write_urb, dev-&gt;udev,
+			      usb_sndbulkpipe(dev-&gt;udev, 
+					      dev-&gt;bulk_out_endpointAddr),
+			      dev-&gt;bulk_out_buffer,
+			      le16_to_cpu(mgmt_buf-&gt;wlength) + 
+			      mgmt_buf-&gt;padding + AT76C503_TX_HDRLEN,
+			      (usb_complete_t)at76c503_write_bulk_callback, dev);
+		ret = usb_submit_urb(dev-&gt;write_urb, GFP_ATOMIC);
+		if (ret) {
+			err(&quot;%s: %s error in tx submit urb: %d&quot;,
+			    dev-&gt;netdev-&gt;name, __FUNCTION__, ret);
+		}
+		kfree(mgmt_buf);
+	} else
+		netif_wake_queue(dev-&gt;netdev);
+
+}
+
+#ifdef CONFIG_IPAQ_HANDHELD
+
+static struct timer_list led_timer;
+
+static void
+ipaq_clear_led (unsigned long time)
+{
+	ipaq_led_off (RED_LED_2);
+}
+
+static void
+ipaq_blink_led (void)
+{
+	ipaq_led_on (RED_LED_2);
+
+	mod_timer (&amp;led_timer, jiffies + (HZ / 25));
+}
+
+static void
+ipaq_init_led (void)
+{
+	led_timer.function = ipaq_clear_led;
+
+	init_timer (&amp;led_timer);
+}
+
+#endif
+
+static int at76c503_tx(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct at76c503 *dev = (struct at76c503 *)(netdev-&gt;priv);
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	int ret = 0;
+	int wlen;
+	int submit_len;
+	struct at76c503_tx_buffer *tx_buffer =
+		(struct at76c503_tx_buffer *)dev-&gt;bulk_out_buffer;
+	struct ieee80211_hdr_3addr *i802_11_hdr =
+		(struct ieee80211_hdr_3addr *)&amp;(tx_buffer-&gt;packet);
+	u8 *payload = tx_buffer-&gt;packet + sizeof(struct ieee80211_hdr_3addr);
+
+	if (netif_queue_stopped(netdev)) {
+		err(&quot;%s: %s called while netdev is stopped&quot;, netdev-&gt;name,
+		    __FUNCTION__);
+		/* skip this packet */
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	if (dev-&gt;write_urb-&gt;status == -EINPROGRESS) {
+		err(&quot;%s: %s called while dev-&gt;write_urb is pending for tx&quot;,
+		    netdev-&gt;name, __FUNCTION__);
+		/* skip this packet */
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	if (skb-&gt;len &lt; 2*ETH_ALEN) {
+		err(&quot;%s: %s: skb too short (%d)&quot;, dev-&gt;netdev-&gt;name,
+		    __FUNCTION__, skb-&gt;len);
+			dev_kfree_skb(skb);
+			return 0;
+	}
+
+#ifdef CONFIG_IPAQ_HANDHELD
+	if (machine_is_h5400 ())
+		ipaq_blink_led ();
+#endif
+
+	/* we can get rid of memcpy, if we set netdev-&gt;hard_header_len
+	   to 8 + sizeof(struct ieee80211_hdr_3addr), because then we have
+	   enough space 
+	  dbg(DBG_TX, &quot;skb-&gt;data - skb-&gt;head = %d&quot;, skb-&gt;data - skb-&gt;head); */
+
+	if (ntohs(*(__be16 *)(skb-&gt;data + 2*ETH_ALEN)) &lt;= 1518) {
+		/* this is a 802.3 packet */
+		if (skb-&gt;data[2*ETH_ALEN+2] == rfc1042sig[0] &amp;&amp;
+		    skb-&gt;data[2*ETH_ALEN+2+1] == rfc1042sig[1]) {
+			/* higher layer delivered SNAP header - keep it */
+			memcpy(payload, skb-&gt;data + 2*ETH_ALEN+2, skb-&gt;len - 2*ETH_ALEN -2);
+			wlen = sizeof(struct ieee80211_hdr_3addr) + skb-&gt;len - 2*ETH_ALEN -2;
+		} else {
+			err(&quot;%s: %s: no support for non-SNAP 802.2 packets &quot;
+			    &quot;(DSAP x%02x SSAP x%02x cntrl x%02x)&quot;,
+			    dev-&gt;netdev-&gt;name, __FUNCTION__,
+			    skb-&gt;data[2*ETH_ALEN+2], skb-&gt;data[2*ETH_ALEN+2+1],
+			    skb-&gt;data[2*ETH_ALEN+2+2]);
+			dev_kfree_skb(skb);
+			return 0;
+		}
+	} else {
+		/* add RFC 1042 header in front */
+		memcpy(payload, rfc1042sig, sizeof(rfc1042sig));
+		memcpy(payload + sizeof(rfc1042sig),
+		       skb-&gt;data + 2*ETH_ALEN, skb-&gt;len - 2*ETH_ALEN);
+		wlen = sizeof(struct ieee80211_hdr_3addr) + sizeof(rfc1042sig) + 
+			skb-&gt;len - 2*ETH_ALEN;
+	}
+
+	/* make wireless header */
+	i802_11_hdr-&gt;frame_ctl =
+		cpu_to_le16(IEEE80211_FTYPE_DATA |
+			    (dev-&gt;wep_enabled ? IEEE80211_FCTL_PROTECTED : 0) |
+			    (dev-&gt;iw_mode == IW_MODE_INFRA ? IEEE80211_FCTL_TODS : 0));
+
+	if(dev-&gt;iw_mode == IW_MODE_ADHOC){
+		memcpy(i802_11_hdr-&gt;addr1, skb-&gt;data, ETH_ALEN); /* destination */
+		memcpy(i802_11_hdr-&gt;addr2, skb-&gt;data+ETH_ALEN, ETH_ALEN); /* source */
+		memcpy(i802_11_hdr-&gt;addr3, dev-&gt;bssid, ETH_ALEN);
+	}else if(dev-&gt;iw_mode == IW_MODE_INFRA){
+		memcpy(i802_11_hdr-&gt;addr1, dev-&gt;bssid, ETH_ALEN);
+		memcpy(i802_11_hdr-&gt;addr2, skb-&gt;data+ETH_ALEN, ETH_ALEN); /* source */
+		memcpy(i802_11_hdr-&gt;addr3, skb-&gt;data, ETH_ALEN); /* destination */
+	}
+
+	i802_11_hdr-&gt;duration_id = cpu_to_le16(0);
+	i802_11_hdr-&gt;seq_ctl = cpu_to_le16(0);
+
+	/* setup 'Atmel' header */
+	tx_buffer-&gt;wlength = cpu_to_le16(wlen);
+	tx_buffer-&gt;tx_rate = dev-&gt;txrate; 
+        /* for broadcast destination addresses, the firmware 0.100.x 
+	   seems to choose the highest rate set with CMD_STARTUP in
+	   basic_rate_set replacing this value */
+	
+	memset(tx_buffer-&gt;reserved, 0, 4);
+
+	tx_buffer-&gt;padding = calc_padding(wlen);
+	submit_len = wlen + AT76C503_TX_HDRLEN + tx_buffer-&gt;padding;
+
+	{
+		dbg(DBG_TX_DATA_CONTENT, &quot;%s skb-&gt;data %s&quot;, dev-&gt;netdev-&gt;name,
+		    hex2str(dev-&gt;obuf, skb-&gt;data, 
+			    min((int)(sizeof(dev-&gt;obuf)-1)/2,32),'\0'));
+		dbg(DBG_TX_DATA, &quot;%s tx  wlen x%x pad x%x rate %d hdr %s&quot;,
+		    dev-&gt;netdev-&gt;name,
+		    le16_to_cpu(tx_buffer-&gt;wlength),
+		    tx_buffer-&gt;padding, tx_buffer-&gt;tx_rate, 
+		    hex2str(dev-&gt;obuf, (u8 *)i802_11_hdr, 
+			    min((sizeof(dev-&gt;obuf)-1)/2, 
+				sizeof(struct ieee80211_hdr_3addr)),'\0'));
+		dbg(DBG_TX_DATA_CONTENT, &quot;%s payload %s&quot;, dev-&gt;netdev-&gt;name,
+		    hex2str(dev-&gt;obuf, payload, 
+			    min((int)(sizeof(dev-&gt;obuf)-1)/2,48),'\0'));
+	}
+
+	/* send stuff */
+	netif_stop_queue(netdev);
+	netdev-&gt;trans_start = jiffies;
+
+	FILL_BULK_URB(dev-&gt;write_urb, dev-&gt;udev,
+		      usb_sndbulkpipe(dev-&gt;udev, dev-&gt;bulk_out_endpointAddr),
+		      tx_buffer, submit_len,
+		      (usb_complete_t)at76c503_write_bulk_callback, dev);
+	ret = usb_submit_urb(dev-&gt;write_urb, GFP_ATOMIC);
+	if(ret){
+		stats-&gt;tx_errors++;
+		err(&quot;%s: error in tx submit urb: %d&quot;, netdev-&gt;name, ret);
+		if (ret == -EINVAL)
+			err(&quot;-EINVAL: urb %p urb-&gt;hcpriv %p urb-&gt;complete %p&quot;,
+			    dev-&gt;write_urb,
+			    dev-&gt;write_urb ? dev-&gt;write_urb-&gt;hcpriv : (void *)-1,
+			    dev-&gt;write_urb ? dev-&gt;write_urb-&gt;complete : (void *)-1);
+		goto err;
+	}
+
+	stats-&gt;tx_bytes += skb-&gt;len;
+
+	dev_kfree_skb(skb);
+	return 0;
+
+ err:
+	return ret;
+}
+
+
+static void at76c503_tx_timeout(struct net_device *netdev)
+{
+	struct at76c503 *dev = (struct at76c503 *)(netdev-&gt;priv);
+
+	if (!dev)
+		return;
+	warn(&quot;%s: tx timeout.&quot;, netdev-&gt;name);
+
+	usb_unlink_urb(dev-&gt;write_urb);
+	dev-&gt;stats.tx_errors++;
+}
+
+static int startup_device(struct at76c503 *dev)
+{
+	struct at76c503_card_config *ccfg = &amp;dev-&gt;card_config;
+	int ret;
+
+	if (at76_debug &amp; DBG_PARAMS) {
+		char ossid[IW_ESSID_MAX_SIZE+1];
+
+		/* make dev-&gt;essid printable */
+		assert(dev-&gt;essid_size &lt;= IW_ESSID_MAX_SIZE);
+		memcpy(ossid, dev-&gt;essid, dev-&gt;essid_size);
+		ossid[dev-&gt;essid_size] = '\0';
+
+		dbg_uc(&quot;%s param: ssid %s (%s) mode %s ch %d wep %s key %d keylen %d&quot;,
+		       dev-&gt;netdev-&gt;name, ossid, 
+		       hex2str(dev-&gt;obuf, dev-&gt;essid,
+			       min((int)(sizeof(dev-&gt;obuf)-1)/2,
+				   IW_ESSID_MAX_SIZE), '\0'),
+		       dev-&gt;iw_mode == IW_MODE_ADHOC ? &quot;adhoc&quot; : &quot;infra&quot;,
+		       dev-&gt;channel,
+		       dev-&gt;wep_enabled ? &quot;enabled&quot; : &quot;disabled&quot;,
+		       dev-&gt;wep_key_id, dev-&gt;wep_keys_len[dev-&gt;wep_key_id]);
+		dbg_uc(&quot;%s param: preamble %s rts %d retry %d frag %d &quot;
+		       &quot;txrate %s auth_mode %d&quot;,
+		       dev-&gt;netdev-&gt;name,		       
+		       dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT ? &quot;short&quot; : &quot;long&quot;,
+		       dev-&gt;rts_threshold, dev-&gt;short_retry_limit, 
+		       dev-&gt;frag_threshold,
+		       dev-&gt;txrate == TX_RATE_1MBIT ? &quot;1MBit&quot; :
+		       dev-&gt;txrate == TX_RATE_2MBIT ? &quot;2MBit&quot; :
+		       dev-&gt;txrate == TX_RATE_5_5MBIT ? &quot;5.5MBit&quot; :
+		       dev-&gt;txrate == TX_RATE_11MBIT ? &quot;11MBit&quot; :
+		       dev-&gt;txrate == TX_RATE_AUTO ? &quot;auto&quot; : &quot;&lt;invalid&gt;&quot;,
+		       dev-&gt;auth_mode);
+		dbg_uc(&quot;%s param: pm_mode %d pm_period %d auth_mode %s &quot;
+		       &quot;scan_times %d %d scan_mode %s international_roaming %d&quot;,
+		       dev-&gt;netdev-&gt;name,		       
+		       dev-&gt;pm_mode, dev-&gt;pm_period_us,
+		       dev-&gt;auth_mode == WLAN_AUTH_OPEN ?
+		       &quot;open&quot; : &quot;shared_secret&quot;,
+		       dev-&gt;scan_min_time, dev-&gt;scan_max_time,
+		       dev-&gt;scan_mode == SCAN_TYPE_ACTIVE ? &quot;active&quot; : &quot;passive&quot;,
+		       dev-&gt;international_roaming);
+	}
+
+	memset(ccfg, 0, sizeof(struct at76c503_card_config));
+	ccfg-&gt;promiscuous_mode = 0;
+	ccfg-&gt;short_retry_limit = dev-&gt;short_retry_limit;
+
+	if (dev-&gt;wep_enabled) {
+	    if (dev-&gt;wep_keys_len[dev-&gt;wep_key_id] &gt; WEP_SMALL_KEY_LEN)
+			ccfg-&gt;encryption_type = 2;
+		else
+			ccfg-&gt;encryption_type = 1;
+
+		/* jal: always exclude unencrypted if WEP is active */
+		ccfg-&gt;exclude_unencrypted = 1;
+	} else {
+		ccfg-&gt;exclude_unencrypted = 0;
+		ccfg-&gt;encryption_type = 0;
+	}
+
+	ccfg-&gt;rts_threshold = cpu_to_le16(dev-&gt;rts_threshold);
+	ccfg-&gt;fragmentation_threshold = cpu_to_le16(dev-&gt;frag_threshold);
+
+	memcpy(ccfg-&gt;basic_rate_set, hw_rates, 4);
+	/* jal: really needed, we do a set_mib for autorate later ??? */
+	ccfg-&gt;auto_rate_fallback = (dev-&gt;txrate == TX_RATE_AUTO ? 1 : 0);
+	ccfg-&gt;channel = dev-&gt;channel;
+	ccfg-&gt;privacy_invoked = dev-&gt;wep_enabled;
+	memcpy(ccfg-&gt;current_ssid, dev-&gt;essid, IW_ESSID_MAX_SIZE);
+	ccfg-&gt;ssid_len = dev-&gt;essid_size;
+
+	ccfg-&gt;wep_default_key_id = dev-&gt;wep_key_id;
+	memcpy(ccfg-&gt;wep_default_key_value, dev-&gt;wep_keys, 4 * WEP_KEY_LEN);
+
+	ccfg-&gt;short_preamble = dev-&gt;preamble_type;
+	ccfg-&gt;beacon_period = cpu_to_le16(dev-&gt;beacon_period);
+
+	ret = set_card_command(dev-&gt;udev, CMD_STARTUP, (unsigned char *)&amp;dev-&gt;card_config,
+			       sizeof(struct at76c503_card_config));
+	if(ret &lt; 0){
+		err(&quot;%s: set_card_command failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		return ret;
+	}
+
+	wait_completion(dev, CMD_STARTUP);
+
+	/* remove BSSID from previous run */
+	memset(dev-&gt;bssid, 0, ETH_ALEN);
+	
+	if (set_radio(dev, 1) == 1)
+		wait_completion(dev, CMD_RADIO);
+
+	if ((ret=set_preamble(dev, dev-&gt;preamble_type)) &lt; 0)
+		return ret;
+	if ((ret=set_frag(dev, dev-&gt;frag_threshold)) &lt; 0)
+		return ret;
+
+	if ((ret=set_rts(dev, dev-&gt;rts_threshold)) &lt; 0)
+		return ret;
+	
+	if ((ret=set_autorate_fallback(dev, dev-&gt;txrate == TX_RATE_AUTO ? 1 : 0)) &lt; 0)
+		return ret;
+
+	if ((ret=set_pm_mode(dev, dev-&gt;pm_mode)) &lt; 0)
+		return ret;
+	
+	if ((ret=set_iroaming(dev, dev-&gt;international_roaming)) &lt; 0)
+		return ret;
+
+	if (at76_debug &amp; DBG_MIB)
+	{
+		dump_mib_mac(dev);
+		dump_mib_mac_addr(dev);
+		dump_mib_mac_mgmt(dev);
+		dump_mib_mac_wep(dev);
+		dump_mib_mdomain(dev);
+		dump_mib_phy(dev);
+		dump_mib_local(dev);
+	}
+
+	return 0;
+}
+
+static int at76c503_open(struct net_device *netdev)
+{
+	struct at76c503 *dev = (struct at76c503 *)(netdev-&gt;priv);
+	int ret = 0;
+
+	dbg(DBG_PROC_ENTRY, &quot;at76c503_open entry&quot;);
+
+	if(down_interruptible(&amp;dev-&gt;sem))
+	   return -EINTR;
+
+	/* if netdev-&gt;dev_addr != dev-&gt;mac_addr we must
+	   set the mac address in the device ! */
+	if (memcmp(netdev-&gt;dev_addr, dev-&gt;mac_addr, ETH_ALEN)) {
+		if (set_mac_address(dev,netdev-&gt;dev_addr) &gt;= 0)
+			dbg(DBG_PROGRESS, &quot;%s: set new MAC addr %s&quot;,
+			    netdev-&gt;name, mac2str(netdev-&gt;dev_addr));
+	}
+
+#ifdef DEBUG
+	dump_mib_mac_addr(dev);
+#endif
+
+	dev-&gt;site_survey_state=SITE_SURVEY_IDLE;
+	dev-&gt;last_survey = jiffies;
+	dev-&gt;nr_submit_rx_tries = NR_SUBMIT_RX_TRIES; /* init counter */
+
+	if((ret=submit_rx_urb(dev)) &lt; 0){
+		err(&quot;%s: open: submit_rx_urb failed: %d&quot;, netdev-&gt;name, ret);
+		goto err;
+	}
+
+	dev-&gt;open_count++;
+
+	defer_kevent(dev, KEVENT_RESTART);
+
+	dbg(DBG_PROC_ENTRY, &quot;at76c503_open end&quot;);
+ err:
+	up(&amp;dev-&gt;sem);
+	return ret &lt; 0 ? ret : 0;
+}
+
+static int at76c503_stop(struct net_device *netdev)
+{
+	struct at76c503 *dev = (struct at76c503 *)(netdev-&gt;priv);
+	unsigned long flags;
+
+	dbg(DBG_DEVSTART, &quot;%s: ENTER&quot;, __FUNCTION__);
+
+	if (down_interruptible(&amp;dev-&gt;sem))
+		return -EINTR;
+
+	netif_stop_queue(netdev);
+
+  	NEW_STATE(dev,INIT);
+
+	if (!(dev-&gt;device_unplugged)) {
+		/* we are called by &quot;ifconfig wlanX down&quot;, not because the
+		   device isn't avail. anymore */	
+		set_radio(dev, 0);
+
+		/* we unlink the read urb, because the _open()
+		   submits it again. _delete_device() takes care of the
+		   read_urb otherwise. */
+		usb_kill_urb(dev-&gt;read_urb);
+	}
+
+	del_timer_sync(&amp;dev-&gt;mgmt_timer);
+
+	spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock,flags);
+	if (dev-&gt;next_mgmt_bulk) {
+		kfree(dev-&gt;next_mgmt_bulk);
+		dev-&gt;next_mgmt_bulk = NULL;
+	}
+	spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock,flags);
+
+	/* free the bss_list */
+	free_bss_list(dev);
+
+	assert(dev-&gt;open_count &gt; 0);
+	dev-&gt;open_count--;
+
+	up(&amp;dev-&gt;sem);
+
+	dbg(DBG_DEVSTART, &quot;%s: EXIT&quot;, __FUNCTION__);
+
+	return 0;
+}
+
+static struct net_device_stats *at76c503_get_stats(struct net_device *netdev)
+{
+	struct at76c503 *dev = (struct at76c503 *)netdev-&gt;priv;
+
+	return &amp;dev-&gt;stats;
+}
+
+static struct iw_statistics *at76c503_get_wireless_stats(struct net_device *netdev)
+{
+	struct at76c503 *dev = (struct at76c503 *)netdev-&gt;priv;
+
+	dbg(DBG_IOCTL, &quot;RETURN qual %d level %d noise %d updated %d&quot;,
+	    dev-&gt;wstats.qual.qual, dev-&gt;wstats.qual.level,
+	    dev-&gt;wstats.qual.noise, dev-&gt;wstats.qual.updated);
+ 
+	return &amp;dev-&gt;wstats;
+}
+
+static void at76c503_set_multicast(struct net_device *netdev)
+{
+	struct at76c503 *dev = (struct at76c503 *)netdev-&gt;priv;
+	int promisc;
+
+	promisc = ((netdev-&gt;flags &amp; IFF_PROMISC) != 0);
+	if(promisc != dev-&gt;promisc){
+		/* grmbl. This gets called in interrupt. */
+		dev-&gt;promisc = promisc;
+		defer_kevent(dev, KEVENT_SET_PROMISC);
+	}
+}
+
+/* we only store the new mac address in netdev struct,
+   it got set when the netdev gets opened. */
+static int at76c503_set_mac_address(struct net_device *netdev, void *addr)
+{
+	struct sockaddr *mac = addr;
+	memcpy(netdev-&gt;dev_addr, mac-&gt;sa_data, ETH_ALEN);
+	return 1;
+}
+
+/* == PROC iwspy_update == 
+  check if we spy on the sender address of buf and update statistics */
+static void iwspy_update(struct at76c503 *dev, struct at76c503_rx_buffer *buf)
+{
+	struct ieee80211_hdr_3addr *hdr = (struct ieee80211_hdr_3addr *)buf-&gt;packet;
+	struct iw_quality qual;
+
+	/* We can only set the level here */
+	qual.updated = IW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;
+        qual.level = 0;
+        qual.noise = 0;
+	calc_level(dev, buf, &amp;qual);
+
+	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
+	
+	if (dev-&gt;spy_data.spy_number &gt; 0) {
+		wireless_spy_update(dev-&gt;netdev, hdr-&gt;addr2, &amp;qual);
+	}
+	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
+} /* iwspy_update */
+
+
+/*******************************************************************************
+ * structure that describes the private ioctls/iw handlers of this driver
+ */
+static const struct iw_priv_args at76c503_priv_args[] = {
+	{ PRIV_IOCTL_SET_SHORT_PREAMBLE,
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	  &quot;short_preamble&quot; }, /* 0 - long, 1 -short */
+	
+	{ PRIV_IOCTL_SET_DEBUG, 
+	  /* we must pass the new debug mask as a string,
+	   * 'cause iwpriv cannot parse hex numbers
+	   * starting with 0x :-(  */
+	  IW_PRIV_TYPE_CHAR | 10, 0,
+	  &quot;set_debug&quot;}, /* set debug value */
+	
+	{ PRIV_IOCTL_SET_POWERSAVE_MODE, 
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	  &quot;powersave_mode&quot;}, /* 1 -  active, 2 - power save,
+			        3 - smart power save */
+	{ PRIV_IOCTL_SET_SCAN_TIMES, 
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0,
+	  &quot;scan_times&quot;}, /* min_channel_time,
+			    max_channel_time */
+	{ PRIV_IOCTL_SET_SCAN_MODE, 
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	  &quot;scan_mode&quot;}, /* 0 - active, 1 - passive scan */
+
+	{ PRIV_IOCTL_SET_INTL_ROAMING,
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	  &quot;intl_roaming&quot;},
+
+	/* needed for Kismet, orinoco mode */
+	{ PRIV_IOCTL_SET_MONITOR_MODE,
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0,
+	  &quot;monitor&quot;}, /* param1: monitor mode: 0 (off), 1 (on,Prism header), 
+			                       2 (on, no Prism header)
+			 param2: channel (to start scan at) */
+};
+
+
+/*******************************************************************************
+ * at76c503 implementations of iw_handler functions:
+ */
+static int at76c503_iw_handler_commit(struct net_device *netdev,
+			       struct iw_request_info *info,
+			       void *null,
+			       char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	unsigned long flags;
+	
+	dbg(DBG_IOCTL, &quot;%s %s: restarting the device&quot;, netdev-&gt;name,
+		__FUNCTION__);
+	
+	/* stop any pending tx bulk urb
+	   TODO */
+	
+	/* jal: TODO: protect access to dev-&gt;istate by a spinlock
+	   (ISR's on other processors may read/write it) */
+	LOCK_ISTATE()
+	if (dev-&gt;istate != INIT) {
+		UNLOCK_ISTATE()
+		NEW_STATE(dev,INIT);
+		/* stop pending management stuff */
+		del_timer_sync(&amp;dev-&gt;mgmt_timer);
+
+		spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock,flags);
+		if (dev-&gt;next_mgmt_bulk) {
+			kfree(dev-&gt;next_mgmt_bulk);
+			dev-&gt;next_mgmt_bulk = NULL;
+		}
+		spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock,flags);
+
+		netif_carrier_off(dev-&gt;netdev);
+		netif_stop_queue(dev-&gt;netdev);
+	} else UNLOCK_ISTATE()
+
+	/* do the restart after two seconds to catch
+	 * following ioctl's (from more params of iwconfig)
+	 * in _one_ restart */
+	mod_timer(&amp;dev-&gt;restart_timer, jiffies+2*HZ);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_get_name(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 char *name,
+				 char *extra)
+{
+	strcpy(name, &quot;IEEE 802.11b&quot;);
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWNAME - name %s&quot;, netdev-&gt;name, name);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_set_freq(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 struct iw_freq *freq,
+				 char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int chan = -1;
+	int ret = -EIWCOMMIT;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWFREQ - freq.m %d freq.e %d&quot;, netdev-&gt;name, 
+		freq-&gt;m, freq-&gt;e);
+	
+	/* modelled on orinoco.c */
+	if ((freq-&gt;e == 0) &amp;&amp; (freq-&gt;m &lt;= 1000))
+	{
+		/* Setting by channel number */
+		chan = freq-&gt;m;
+	}
+	else
+	{
+		/* Setting by frequency - search the table */
+		int mult = 1;
+		int i;
+		
+		for (i = 0; i &lt; (6 - freq-&gt;e); i++) {
+			mult *= 10;
+		}
+		
+		for (i = 0; i &lt; NUM_CHANNELS; i++) {
+			if (freq-&gt;m == (channel_frequency[i] * mult))
+				chan = i + 1;
+		}
+	}
+	
+	if (chan &lt; 1 || !dev-&gt;domain ) {
+		/* non-positive channels are invalid
+		 * we need a domain info to set the channel
+		 * either that or an invalid frequency was 
+		 * provided by the user */
+		ret =  -EINVAL;
+	} else if (!dev-&gt;international_roaming) {
+		if (!(dev-&gt;domain-&gt;channel_map &amp; (1 &lt;&lt; (chan-1)))) {
+			info(&quot;%s: channel %d not allowed for domain %s &quot;
+			     &quot;(and international_roaming is OFF)&quot;,
+			     dev-&gt;netdev-&gt;name, chan, dev-&gt;domain-&gt;name);
+			ret = -EINVAL;
+		}
+	}
+	
+	if (ret == -EIWCOMMIT) {
+		dev-&gt;channel = chan;
+		dbg(DBG_IOCTL, &quot;%s: SIOCSIWFREQ - ch %d&quot;, netdev-&gt;name, chan);
+	}
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_get_freq(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 struct iw_freq *freq,
+				 char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	freq-&gt;m = dev-&gt;channel;
+	freq-&gt;e = 0;
+	
+	if (dev-&gt;channel)
+	{
+		dbg(DBG_IOCTL, &quot;%s: SIOCGIWFREQ - freq %ld x 10e%d&quot;, netdev-&gt;name, 
+			channel_frequency[dev-&gt;channel - 1], 6);
+	}
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWFREQ - ch %d&quot;, netdev-&gt;name, dev-&gt;channel);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_set_mode(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 __u32 *mode,
+				 char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int ret = -EIWCOMMIT;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWMODE - %d&quot;, netdev-&gt;name, *mode);
+	
+	if ((*mode != IW_MODE_ADHOC) &amp;&amp; (*mode != IW_MODE_INFRA) &amp;&amp;
+	    (*mode != IW_MODE_MONITOR)) {
+		ret = -EINVAL;
+	} else {
+		dev-&gt;iw_mode = *mode;
+	}
+	return ret;
+}
+
+static int at76c503_iw_handler_get_mode(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 __u32 *mode,
+				 char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	*mode = dev-&gt;iw_mode;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWMODE - %d&quot;, netdev-&gt;name, *mode);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_get_range(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  struct iw_point *data,
+				  char *extra)
+{
+	/* inspired by atmel.c */
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	struct iw_range *range = (struct iw_range*)extra;
+	int i;
+	
+	data-&gt;length = sizeof(struct iw_range);
+	memset(range, 0, sizeof(struct iw_range));
+	
+	
+	/* TODO: range-&gt;throughput = xxxxxx; */
+	
+	range-&gt;min_nwid = 0x0000;
+	range-&gt;max_nwid = 0x0000;
+	
+	/* this driver doesn't maintain sensitivity information */
+	range-&gt;sensitivity = 0;
+	
+	range-&gt;max_qual.qual = 100;
+	range-&gt;max_qual.level = 100;
+	range-&gt;max_qual.noise = 0;
+	range-&gt;max_qual.updated = IW_QUAL_NOISE_INVALID;
+	
+	range-&gt;avg_qual.qual = 50;
+	range-&gt;avg_qual.level = 50;
+	range-&gt;avg_qual.noise = 0;
+	range-&gt;avg_qual.updated = IW_QUAL_NOISE_INVALID;
+	
+	range-&gt;bitrate[0] = 1000000;
+	range-&gt;bitrate[1] = 2000000;
+	range-&gt;bitrate[2] = 5500000;
+	range-&gt;bitrate[3] = 11000000;
+	range-&gt;num_bitrates = 4;
+	
+	
+	range-&gt;min_rts = 0;
+	range-&gt;max_rts = MAX_RTS_THRESHOLD;
+	
+	range-&gt;min_frag = MIN_FRAG_THRESHOLD;
+	range-&gt;max_frag = MAX_FRAG_THRESHOLD;
+	
+	
+	/* TODO: find out what values we can use to describe PM capabilities */
+	range-&gt;pmp_flags = IW_POWER_ON;
+	range-&gt;pmt_flags = IW_POWER_ON;
+	range-&gt;pm_capa = 0;
+	
+	
+	range-&gt;encoding_size[0] = WEP_SMALL_KEY_LEN;
+	range-&gt;encoding_size[1] = WEP_LARGE_KEY_LEN;
+	range-&gt;num_encoding_sizes = 2;
+	range-&gt;max_encoding_tokens = WEP_KEYS;
+	/* TODO: do we need this?  what is a valid value if we don't support?
+	  range-&gt;encoding_login_index = -1; */
+	
+	/* both WL-240U and Linksys WUSB11 v2.6 specify 15 dBm as output power
+	   - take this for all (ignore antenna gains) */
+	range-&gt;txpower[0] = 15;
+	range-&gt;num_txpower = 1;
+	range-&gt;txpower_capa = IW_TXPOW_DBM;
+
+	range-&gt;we_version_source = WIRELESS_EXT_SUPPORTED;
+	range-&gt;we_version_compiled = WIRELESS_EXT;
+	
+	/* same as the values used in atmel.c */
+	range-&gt;retry_capa = IW_RETRY_LIMIT ;
+	range-&gt;retry_flags = IW_RETRY_LIMIT;
+	range-&gt;r_time_flags = 0;
+	range-&gt;min_retry = 1;
+	range-&gt;max_retry = 255;
+	
+	
+	range-&gt;num_channels = NUM_CHANNELS;
+	range-&gt;num_frequency = 0;
+	
+	for (i = 0; 
+		i &lt; 32; /* number of bits in reg_domain.channel_map */
+		i++)
+	{
+		/* test if channel map bit is raised */
+		if (dev-&gt;domain-&gt;channel_map &amp; (0x1 &lt;&lt; i))
+		{
+			range-&gt;num_frequency += 1;
+			
+			range-&gt;freq[i].i = i + 1;
+			range-&gt;freq[i].m = channel_frequency[i] * 100000;
+			range-&gt;freq[i].e = 1; /* channel frequency*100000 * 10^1 */
+		}
+	}
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWRANGE&quot;, netdev-&gt;name);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_set_spy(struct net_device *netdev,
+				struct iw_request_info *info,
+				struct iw_point *data,
+				char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int ret = 0;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWSPY - number of addresses %d&quot;,
+		netdev-&gt;name, data-&gt;length);
+	
+	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
+	ret = iw_handler_set_spy(dev-&gt;netdev, info, (union iwreq_data *)data, 
+		extra);
+	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_get_spy(struct net_device *netdev,
+				struct iw_request_info *info,
+				struct iw_point *data,
+				char *extra)
+{
+
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int ret = 0;
+	
+	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
+	ret = iw_handler_get_spy(dev-&gt;netdev, info, 
+		(union iwreq_data *)data, extra);
+	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWSPY - number of addresses %d&quot;,
+		netdev-&gt;name, data-&gt;length);
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_set_thrspy(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_point *data,
+				   char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int ret;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWTHRSPY - number of addresses %d)&quot;,
+		netdev-&gt;name, data-&gt;length);
+	
+	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
+	ret = iw_handler_set_thrspy(netdev, info, (union iwreq_data *)data, 
+		extra);
+	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_get_thrspy(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_point *data,
+				   char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int ret;
+	
+	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
+	ret = iw_handler_get_thrspy(netdev, info, (union iwreq_data *)data, 
+		extra);
+	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWTHRSPY - number of addresses %d)&quot;,
+		netdev-&gt;name, data-&gt;length);
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_set_wap(struct net_device *netdev,
+				struct iw_request_info *info,
+				struct sockaddr *ap_addr,
+				char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWAP - wap/bssid %s&quot;, netdev-&gt;name, 
+		mac2str(ap_addr-&gt;sa_data));
+	
+	/* if the incoming address == ff:ff:ff:ff:ff:ff, the user has 
+	   chosen any or auto AP preference */
+	if (!memcmp(ap_addr-&gt;sa_data, bc_addr, ETH_ALEN)
+		|| !memcmp(ap_addr-&gt;sa_data, off_addr, ETH_ALEN)) {
+		dev-&gt;wanted_bssid_valid = 0;
+	} else {
+		/* user wants to set a preferred AP address */
+		dev-&gt;wanted_bssid_valid = 1;
+		memcpy(dev-&gt;wanted_bssid, ap_addr-&gt;sa_data, ETH_ALEN);
+	}
+	
+	return -EIWCOMMIT;
+}
+
+static int at76c503_iw_handler_get_wap(struct net_device *netdev,
+				struct iw_request_info *info,
+				struct sockaddr *ap_addr,
+				char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	ap_addr-&gt;sa_family = ARPHRD_ETHER;
+	memcpy(ap_addr-&gt;sa_data, dev-&gt;bssid, ETH_ALEN);
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWAP - wap/bssid %s&quot;, netdev-&gt;name, 
+		mac2str(ap_addr-&gt;sa_data));
+	
+	return 0;
+}
+
+
+static int at76c503_iw_handler_set_scan(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu,
+				 char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	unsigned long flags;
+	int ret = 0;
+	struct iw_scan_req *req = NULL;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWSCAN&quot;, netdev-&gt;name);
+
+	if (!netif_running(netdev))
+		return -ENETDOWN;
+
+	/* jal: we don't allow &quot;iwlist wlanX scan&quot; while we are
+	   in monitor mode */
+	if (dev-&gt;iw_mode == IW_MODE_MONITOR)
+		return -EBUSY;
+
+	/* Timeout old surveys. */
+	if ((jiffies - dev-&gt;last_survey) &gt; (20 * HZ))
+		dev-&gt;site_survey_state = SITE_SURVEY_IDLE;
+	dev-&gt;last_survey = jiffies;
+
+	/* Initiate a scan command */
+	if (dev-&gt;site_survey_state == SITE_SURVEY_IN_PROGRESS)
+		return -EBUSY;
+
+	dev-&gt;site_survey_state = SITE_SURVEY_IN_PROGRESS;
+
+	/* stop pending management stuff */
+	del_timer_sync(&amp;(dev-&gt;mgmt_timer));
+	
+	spin_lock_irqsave(&amp;(dev-&gt;mgmt_spinlock), flags);
+	if (dev-&gt;next_mgmt_bulk) {
+		kfree(dev-&gt;next_mgmt_bulk);
+		dev-&gt;next_mgmt_bulk = NULL;
+	}
+	spin_unlock_irqrestore(&amp;(dev-&gt;mgmt_spinlock), flags);
+	
+	if (netif_running(dev-&gt;netdev)) {
+		/* pause network activity */
+		netif_carrier_off(dev-&gt;netdev);
+		netif_stop_queue(dev-&gt;netdev);
+	}
+	/* Try to do passive or active scan if WE asks as. */
+	if (wrqu-&gt;data.length
+	    &amp;&amp; wrqu-&gt;data.length == sizeof(struct iw_scan_req)) {
+		req = (struct iw_scan_req *)extra;
+
+		if (req-&gt;scan_type == IW_SCAN_TYPE_PASSIVE)
+			dev-&gt;scan_mode = SCAN_TYPE_PASSIVE;
+		else if (req-&gt;scan_type == IW_SCAN_TYPE_ACTIVE)
+			dev-&gt;scan_mode = SCAN_TYPE_ACTIVE;
+
+		/* Sanity check values? */
+		LOCK_ISTATE()
+		if (req-&gt;min_channel_time &gt; 0) {
+			if (dev-&gt;istate == MONITORING)
+				dev-&gt;monitor_scan_min_time = req-&gt;min_channel_time;
+			else
+				dev-&gt;scan_min_time = req-&gt;min_channel_time;
+		}
+		if (req-&gt;max_channel_time &gt; 0) {
+			if (dev-&gt;istate == MONITORING)
+				dev-&gt;monitor_scan_max_time = req-&gt;max_channel_time;
+			else
+				dev-&gt;scan_max_time = req-&gt;max_channel_time;
+		}
+		UNLOCK_ISTATE()
+	} 
+	
+	/* change to scanning state */
+	NEW_STATE(dev, SCANNING);
+	defer_kevent(dev, KEVENT_SCAN);
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_get_scan(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 struct iw_point *data,
+				 char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	unsigned long flags;
+	struct list_head *lptr, *nptr;
+	struct bss_info *curr_bss;
+	struct iw_event *iwe = kmalloc(sizeof(struct iw_event), GFP_KERNEL);
+	char *curr_val, *curr_pos = extra;
+	int i;
+
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWSCAN&quot;, netdev-&gt;name);
+
+	if (!iwe)
+		return -ENOMEM;
+
+	if (dev-&gt;site_survey_state != SITE_SURVEY_COMPLETED)
+		/* scan not yet finished */
+		return -EAGAIN;
+
+	spin_lock_irqsave(&amp;(dev-&gt;bss_list_spinlock), flags);
+	
+	list_for_each_safe(lptr, nptr, &amp;(dev-&gt;bss_list)) {
+		curr_bss = list_entry(lptr, struct bss_info, list);
+		
+		iwe-&gt;cmd = SIOCGIWAP;
+		iwe-&gt;u.ap_addr.sa_family = ARPHRD_ETHER;
+		memcpy(iwe-&gt;u.ap_addr.sa_data, curr_bss-&gt;bssid, 6);
+		curr_pos = iwe_stream_add_event(curr_pos, 
+			extra + IW_SCAN_MAX_DATA, iwe, IW_EV_ADDR_LEN);
+		
+		iwe-&gt;u.data.length = curr_bss-&gt;ssid_len;
+		iwe-&gt;cmd = SIOCGIWESSID;
+		iwe-&gt;u.data.flags = 1;
+		
+		curr_pos = iwe_stream_add_point(curr_pos, 
+			extra + IW_SCAN_MAX_DATA, iwe, curr_bss-&gt;ssid);
+		
+		iwe-&gt;cmd = SIOCGIWMODE;
+		iwe-&gt;u.mode = (curr_bss-&gt;capa &amp; WLAN_CAPABILITY_IBSS) ? 
+			IW_MODE_ADHOC :
+			(curr_bss-&gt;capa &amp; WLAN_CAPABILITY_ESS) ? 
+			IW_MODE_MASTER :
+			IW_MODE_AUTO;
+			/* IW_MODE_AUTO = 0 which I thought is 
+			 * the most logical value to return in this case */
+		curr_pos = iwe_stream_add_event(curr_pos, 
+			extra + IW_SCAN_MAX_DATA, iwe, IW_EV_UINT_LEN);
+		
+		iwe-&gt;cmd = SIOCGIWFREQ;
+		iwe-&gt;u.freq.m = curr_bss-&gt;channel;
+		iwe-&gt;u.freq.e = 0;
+		curr_pos = iwe_stream_add_event(curr_pos, 
+			extra + IW_SCAN_MAX_DATA, iwe, IW_EV_FREQ_LEN);
+		
+		iwe-&gt;cmd = SIOCGIWENCODE;
+		if (curr_bss-&gt;capa &amp; WLAN_CAPABILITY_PRIVACY) {
+			iwe-&gt;u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+		} else {
+			iwe-&gt;u.data.flags = IW_ENCODE_DISABLED;
+		}
+		iwe-&gt;u.data.length = 0;
+		curr_pos = iwe_stream_add_point(curr_pos, 
+			extra + IW_SCAN_MAX_DATA, iwe, NULL);
+
+		/* Add quality statistics */
+		iwe-&gt;cmd = IWEVQUAL;
+		iwe-&gt;u.qual.noise=0;
+		iwe-&gt;u.qual.updated=IW_QUAL_NOISE_INVALID | IW_QUAL_LEVEL_UPDATED;
+    		iwe-&gt;u.qual.level = (curr_bss-&gt;rssi * 100 / 42);
+		if (iwe-&gt;u.qual.level &gt; 100)
+			iwe-&gt;u.qual.level = 100;
+		if((dev-&gt;board_type == BOARDTYPE_503_INTERSIL_3861) ||
+	   		(dev-&gt;board_type == BOARDTYPE_503_INTERSIL_3863)) {
+	    		iwe-&gt;u.qual.qual=curr_bss-&gt;link_qual;
+		} else {
+	    		iwe-&gt;u.qual.qual=0;
+		        iwe-&gt;u.qual.updated |= IW_QUAL_QUAL_INVALID;
+		}
+		/* Add new value to event */
+		curr_pos = iwe_stream_add_event(curr_pos, 
+			extra + IW_SCAN_MAX_DATA, iwe, IW_EV_QUAL_LEN);
+
+		/* Rate : stuffing multiple values in a single event require a bit
+		 * more of magic - Jean II */
+		curr_val = curr_pos + IW_EV_LCP_LEN;
+
+		iwe-&gt;cmd = SIOCGIWRATE;
+		/* Those two flags are ignored... */
+		iwe-&gt;u.bitrate.fixed = iwe-&gt;u.bitrate.disabled = 0;
+		/* Max 8 values */
+		for(i=0; i &lt; curr_bss-&gt;rates_len; i++) {
+			/* Bit rate given in 500 kb/s units (+ 0x80) */
+			iwe-&gt;u.bitrate.value = 
+				((curr_bss-&gt;rates[i] &amp; 0x7f) * 500000);
+			/* Add new value to event */
+			curr_val = iwe_stream_add_value(curr_pos, curr_val, 
+							extra + IW_SCAN_MAX_DATA,
+							iwe, IW_EV_PARAM_LEN);
+		}
+
+		/* Check if we added any event */
+		if ((curr_val - curr_pos) &gt; IW_EV_LCP_LEN)
+			curr_pos = curr_val;
+
+
+		/* more information may be sent back using IWECUSTOM */
+
+	}
+	
+	spin_unlock_irqrestore(&amp;(dev-&gt;bss_list_spinlock), flags);
+	
+	data-&gt;length = (curr_pos - extra);
+	data-&gt;flags = 0;
+	
+	kfree(iwe);
+	return 0;
+}
+
+
+static int at76c503_iw_handler_set_essid(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  struct iw_point *data,
+				  char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWESSID - %s&quot;, netdev-&gt;name, extra);
+	
+	if (data-&gt;flags) {
+		memcpy(dev-&gt;essid, extra, data-&gt;length);
+		dev-&gt;essid_size = data-&gt;length;
+	}
+	else {
+		/* Use any SSID */
+		dev-&gt;essid_size = 0;
+	}
+	
+	return -EIWCOMMIT;
+}
+
+static int at76c503_iw_handler_get_essid(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  struct iw_point *data,
+				  char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	if (dev-&gt;essid_size) {
+		/* not the ANY ssid in dev-&gt;essid */
+		data-&gt;flags = 1;
+		data-&gt;length = dev-&gt;essid_size;
+		memcpy(extra, dev-&gt;essid, data-&gt;length);
+		extra[data-&gt;length] = '\0';
+		data-&gt;length += 1;
+	} else {
+		/* the ANY ssid was specified */
+		LOCK_ISTATE()
+		if (dev-&gt;istate == CONNECTED &amp;&amp;
+		    dev-&gt;curr_bss != NULL) {
+			UNLOCK_ISTATE()
+			/* report the SSID we have found */
+			data-&gt;flags = 1;
+			data-&gt;length = dev-&gt;curr_bss-&gt;ssid_len;
+			memcpy(extra, dev-&gt;curr_bss-&gt;ssid, data-&gt;length);
+			extra[dev-&gt;curr_bss-&gt;ssid_len] = '\0';
+			data-&gt;length += 1;
+		} else {
+			UNLOCK_ISTATE()
+			/* report ANY back */
+			data-&gt;flags=0;
+			data-&gt;length=0;
+		}
+	}
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWESSID - %s&quot;, netdev-&gt;name, extra);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_set_nickname(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_point *data,
+				     char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWNICKN - %s&quot;, netdev-&gt;name, extra);
+	
+	/* iwconfig gives length including 0 byte like in the case of essid */
+	memcpy(dev-&gt;nickn, extra, data-&gt;length);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_get_nickname(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_point *data,
+				     char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	data-&gt;length = strlen(dev-&gt;nickn);
+	memcpy(extra, dev-&gt;nickn, data-&gt;length);
+	extra[data-&gt;length] = '\0';
+	data-&gt;length += 1;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWNICKN - %s&quot;, netdev-&gt;name, extra);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_set_rate(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 struct iw_param *bitrate,
+				 char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int ret = -EIWCOMMIT;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWRATE - %d&quot;, netdev-&gt;name, 
+		bitrate-&gt;value);
+	
+	switch (bitrate-&gt;value)
+	{
+		case -1: 	dev-&gt;txrate = TX_RATE_AUTO; break; /* auto rate */
+		case 1000000: 	dev-&gt;txrate = TX_RATE_1MBIT; break;
+		case 2000000: 	dev-&gt;txrate = TX_RATE_2MBIT; break;
+		case 5500000: 	dev-&gt;txrate = TX_RATE_5_5MBIT; break;
+		case 11000000: 	dev-&gt;txrate = TX_RATE_11MBIT; break;
+		default:	ret = -EINVAL;
+	}
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_get_rate(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 struct iw_param *bitrate,
+				 char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int ret = 0;
+	
+	switch (dev-&gt;txrate)
+	{
+		/* return max rate if RATE_AUTO */
+		case TX_RATE_AUTO: 	bitrate-&gt;value = 11000000; break; 
+		case TX_RATE_1MBIT: 	bitrate-&gt;value = 1000000; break;
+		case TX_RATE_2MBIT: 	bitrate-&gt;value = 2000000; break;
+		case TX_RATE_5_5MBIT: 	bitrate-&gt;value = 5500000; break;
+		case TX_RATE_11MBIT: 	bitrate-&gt;value = 11000000; break;
+		default:		ret = -EINVAL;
+	}
+	
+	bitrate-&gt;fixed = (dev-&gt;txrate != TX_RATE_AUTO);
+	bitrate-&gt;disabled = 0;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWRATE - %d&quot;, netdev-&gt;name, 
+		bitrate-&gt;value);
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_set_rts(struct net_device *netdev,
+				struct iw_request_info *info,
+				struct iw_param *rts,
+				char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int ret = -EIWCOMMIT;
+	int rthr = rts-&gt;value;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWRTS - value %d disabled %s&quot;,
+		netdev-&gt;name, rts-&gt;value, 
+		(rts-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
+	
+	if (rts-&gt;disabled)
+		rthr = MAX_RTS_THRESHOLD;
+	
+	if ((rthr &lt; 0) || (rthr &gt; MAX_RTS_THRESHOLD)) {
+		ret = -EINVAL;
+	} else {
+		dev-&gt;rts_threshold = rthr;
+	}
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_get_rts(struct net_device *netdev,
+				struct iw_request_info *info,
+				struct iw_param *rts,
+				char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	rts-&gt;value = dev-&gt;rts_threshold;
+	rts-&gt;disabled = (rts-&gt;value &gt;= MAX_RTS_THRESHOLD);
+	rts-&gt;fixed = 1;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWRTS - value %d disabled %s&quot;,
+		netdev-&gt;name, rts-&gt;value, 
+		(rts-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_set_frag(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 struct iw_param *frag,
+				 char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int ret = -EIWCOMMIT;
+	int fthr = frag-&gt;value;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWFRAG - value %d, disabled %s&quot;,
+		netdev-&gt;name, frag-&gt;value, 
+		(frag-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
+	
+	if(frag-&gt;disabled)
+		fthr = MAX_FRAG_THRESHOLD;
+	
+	if ((fthr &lt; MIN_FRAG_THRESHOLD) || (fthr &gt; MAX_FRAG_THRESHOLD)) {
+		ret = -EINVAL;
+	} else {
+		dev-&gt;frag_threshold = fthr &amp; ~0x1; /* get an even value */
+	}
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_get_frag(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 struct iw_param *frag,
+				 char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	frag-&gt;value = dev-&gt;frag_threshold;
+	frag-&gt;disabled = (frag-&gt;value &gt;= MAX_FRAG_THRESHOLD);
+	frag-&gt;fixed = 1;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWFRAG - value %d, disabled %s&quot;,
+		netdev-&gt;name, frag-&gt;value, 
+		(frag-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_get_txpow(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  struct iw_param *power,
+				  char *extra)
+{
+	power-&gt;value = 15;
+	power-&gt;fixed = 1;	/* No power control */
+	power-&gt;disabled = 0;
+	power-&gt;flags = IW_TXPOW_DBM;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWTXPOW - txpow %d dBm&quot;, netdev-&gt;name, 
+		power-&gt;value);
+	
+	return 0;
+}
+
+/* jal: short retry is handled by the firmware (at least 0.90.x),
+   while long retry is not (?) */
+static int at76c503_iw_handler_set_retry(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  struct iw_param *retry,
+				  char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int ret = -EIWCOMMIT;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWRETRY disabled %d  flags x%x val %d&quot;,
+	    netdev-&gt;name, retry-&gt;disabled, retry-&gt;flags, retry-&gt;value);
+	
+	if(!retry-&gt;disabled &amp;&amp; (retry-&gt;flags &amp; IW_RETRY_LIMIT)) {
+		if ((retry-&gt;flags &amp; IW_RETRY_MIN) || 
+		    !(retry-&gt;flags &amp; IW_RETRY_MAX)) {
+			dev-&gt;short_retry_limit = retry-&gt;value;
+		} else
+			ret = -EINVAL;
+	} else {
+		ret = -EINVAL;
+	}
+	
+	return ret;
+}
+
+/* adapted (ripped) from atmel.c */
+static int at76c503_iw_handler_get_retry(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  struct iw_param *retry,
+				  char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWRETRY&quot;, netdev-&gt;name);
+	
+	retry-&gt;disabled = 0;      /* Can't be disabled */
+	
+
+	retry-&gt;flags = IW_RETRY_LIMIT;
+	retry-&gt;value = dev-&gt;short_retry_limit;
+		
+	return 0;
+}
+
+static int at76c503_iw_handler_set_encode(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_point *encoding,
+				   char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int index = (encoding-&gt;flags &amp; IW_ENCODE_INDEX) - 1;
+	int len = encoding-&gt;length;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWENCODE - enc.flags %08x &quot;
+		&quot;pointer %p len %d&quot;, netdev-&gt;name, encoding-&gt;flags, 
+		encoding-&gt;pointer, encoding-&gt;length);
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWENCODE - old wepstate: enabled %s key_id %d &quot;
+	       &quot;auth_mode %s&quot;,
+	       netdev-&gt;name, (dev-&gt;wep_enabled) ? &quot;true&quot; : &quot;false&quot;, 
+	       dev-&gt;wep_key_id, 
+	       (dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ? 
+			&quot;restricted&quot; : &quot;open&quot;);
+	
+	/* take the old default key if index is invalid */
+	if ((index &lt; 0) || (index &gt;= WEP_KEYS))
+		index = dev-&gt;wep_key_id;
+	
+	if (len &gt; 0)
+	{
+		if (len &gt; WEP_LARGE_KEY_LEN)
+			len = WEP_LARGE_KEY_LEN;
+		
+		memset(dev-&gt;wep_keys[index], 0, WEP_KEY_LEN);
+		memcpy(dev-&gt;wep_keys[index], extra, len);
+		dev-&gt;wep_keys_len[index] = (len &lt;= WEP_SMALL_KEY_LEN) ?
+			WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN;
+		dev-&gt;wep_enabled = 1;
+	}
+	
+	dev-&gt;wep_key_id = index;
+	dev-&gt;wep_enabled = ((encoding-&gt;flags &amp; IW_ENCODE_DISABLED) == 0);
+	
+	if (encoding-&gt;flags &amp; IW_ENCODE_RESTRICTED)
+		dev-&gt;auth_mode = WLAN_AUTH_SHARED_KEY;
+	if (encoding-&gt;flags &amp; IW_ENCODE_OPEN)
+		dev-&gt;auth_mode = WLAN_AUTH_OPEN;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWENCODE - new wepstate: enabled %s key_id %d &quot;
+		&quot;key_len %d auth_mode %s&quot;,
+		netdev-&gt;name, (dev-&gt;wep_enabled) ? &quot;true&quot; : &quot;false&quot;, 
+		dev-&gt;wep_key_id + 1, dev-&gt;wep_keys_len[dev-&gt;wep_key_id],
+		(dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ? 
+			&quot;restricted&quot; : &quot;open&quot;);
+	
+	return -EIWCOMMIT;
+}
+
+static int at76c503_iw_handler_get_encode(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_point *encoding,
+				   char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int index = (encoding-&gt;flags &amp; IW_ENCODE_INDEX) - 1;
+	
+	if ((index &lt; 0) || (index &gt;= WEP_KEYS))
+		index = dev-&gt;wep_key_id;
+	
+	encoding-&gt;flags = 
+		(dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ? 
+		  IW_ENCODE_RESTRICTED : IW_ENCODE_OPEN;
+	
+	if (!dev-&gt;wep_enabled)
+		encoding-&gt;flags |= IW_ENCODE_DISABLED;
+	
+	if (encoding-&gt;pointer)
+	{
+		encoding-&gt;length = dev-&gt;wep_keys_len[index];
+		
+		memcpy(extra, dev-&gt;wep_keys[index], dev-&gt;wep_keys_len[index]);
+		
+		encoding-&gt;flags |= (index + 1);
+	}
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWENCODE - enc.flags %08x &quot;
+		&quot;pointer %p len %d&quot;, netdev-&gt;name, encoding-&gt;flags, 
+		encoding-&gt;pointer, encoding-&gt;length);
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWENCODE - wepstate: enabled %s key_id %d &quot;
+		&quot;key_len %d auth_mode %s&quot;,
+		netdev-&gt;name, (dev-&gt;wep_enabled) ? &quot;true&quot; : &quot;false&quot;, 
+		dev-&gt;wep_key_id + 1, dev-&gt;wep_keys_len[dev-&gt;wep_key_id],
+		(dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ? 
+			&quot;restricted&quot; : &quot;open&quot;);
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_set_power(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  struct iw_param *power,
+				  char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCSIWPOWER - disabled %s flags x%x value x%x&quot;, 
+		netdev-&gt;name, (power-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;, 
+		power-&gt;flags, power-&gt;value);
+	
+	if (power-&gt;disabled)
+	{
+		dev-&gt;pm_mode = PM_ACTIVE;
+	}
+	else
+	{
+		/* we set the listen_interval based on the period given
+		   no idea how to handle the timeout of iwconfig ??? */
+		if (power-&gt;flags &amp; IW_POWER_PERIOD)
+		{
+			dev-&gt;pm_period_us = power-&gt;value;
+		}
+		
+		dev-&gt;pm_mode = PM_SAVE; /* use iw_priv to select SMART_SAVE */
+	}
+	
+	return -EIWCOMMIT;
+}
+
+static int at76c503_iw_handler_get_power(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  struct iw_param *power,
+				  char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	
+	power-&gt;disabled = dev-&gt;pm_mode == PM_ACTIVE;
+	
+	if ((power-&gt;flags &amp; IW_POWER_TYPE) == IW_POWER_TIMEOUT)
+	{
+		power-&gt;flags = IW_POWER_TIMEOUT;
+		power-&gt;value = 0;
+	}
+	else
+	{
+		unsigned long flags;
+		u16 beacon_int; /* of the current bss */
+		
+		power-&gt;flags = IW_POWER_PERIOD;
+
+		spin_lock_irqsave(&amp;dev-&gt;bss_list_spinlock, flags);
+		beacon_int = dev-&gt;curr_bss != NULL ?
+			dev-&gt;curr_bss-&gt;beacon_interval : 0;
+		spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
+		
+		if (beacon_int != 0)
+		{
+			power-&gt;value =
+				(beacon_int * dev-&gt;pm_period_beacon) &lt;&lt; 10;
+		}
+		else
+		{
+			power-&gt;value = dev-&gt;pm_period_us;
+		}
+	}
+	
+	power-&gt;flags |= IW_POWER_ALL_R;
+	
+	dbg(DBG_IOCTL, &quot;%s: SIOCGIWPOWER - disabled %s flags x%x value x%x&quot;, 
+		netdev-&gt;name, (power-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;, 
+		power-&gt;flags, power-&gt;value);
+	
+	return 0;
+}
+
+
+/*******************************************************************************
+ * Private IOCTLS
+ */
+static int at76c503_iw_handler_PRIV_IOCTL_SET_SHORT_PREAMBLE
+	(struct net_device *netdev, struct iw_request_info *info, 
+	 char *name, char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
+	
+	dbg(DBG_IOCTL, &quot;%s: PRIV_IOCTL_SET_SHORT_PREAMBLE, %d&quot;,
+		netdev-&gt;name, val);
+	
+	if (val &lt; 0 || val &gt; 2) {
+		/* allow value of 2 - in the win98 driver it stands
+		   for &quot;auto preamble&quot; ...? */
+		ret = -EINVAL;
+	} else {
+		dev-&gt;preamble_type = val;
+	}
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_PRIV_IOCTL_SET_DEBUG
+	(struct net_device *netdev, struct iw_request_info *info, 
+	 struct iw_point *data, char *extra)
+{
+	char *ptr;
+	u32 val;
+	
+	if (data-&gt;length &gt; 0) {
+		val = simple_strtol(extra, &amp;ptr, 0);
+		
+		if (ptr == extra) {
+			val = DBG_DEFAULTS;
+		}
+		
+		dbg_uc(&quot;%s: PRIV_IOCTL_SET_DEBUG input %d: %s -&gt; x%x&quot;,
+		       netdev-&gt;name, data-&gt;length, extra, val);
+	} else {
+		val = DBG_DEFAULTS;
+	}
+	
+	dbg_uc(&quot;%s: PRIV_IOCTL_SET_DEBUG, old 0x%x  new 0x%x&quot;,
+			netdev-&gt;name, at76_debug, val);
+	
+	/* jal: some more output to pin down lockups */
+	dbg_uc(&quot;%s: netif running %d queue_stopped %d carrier_ok %d&quot;,
+			netdev-&gt;name, 
+			netif_running(netdev),
+			netif_queue_stopped(netdev),
+			netif_carrier_ok(netdev));
+	
+	at76_debug = val;
+	
+	return 0;
+}
+
+static int at76c503_iw_handler_PRIV_IOCTL_SET_POWERSAVE_MODE
+	(struct net_device *netdev, struct iw_request_info *info, 
+	 char *name, char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
+	
+	dbg(DBG_IOCTL, &quot;%s: PRIV_IOCTL_SET_POWERSAVE_MODE, %d (%s)&quot;,
+		netdev-&gt;name, val,
+		val == PM_ACTIVE ? &quot;active&quot; : val == PM_SAVE ? &quot;save&quot; :
+		val == PM_SMART_SAVE ? &quot;smart save&quot; : &quot;&lt;invalid&gt;&quot;);
+	if (val &lt; PM_ACTIVE || val &gt; PM_SMART_SAVE) {
+		ret = -EINVAL;
+	} else {
+		dev-&gt;pm_mode = val;
+	}
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_PRIV_IOCTL_SET_SCAN_TIMES
+	(struct net_device *netdev, struct iw_request_info *info, 
+	 char *name, char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int mint = *((int *)name);
+	int maxt = *((int *)name + 1);
+	int ret = -EIWCOMMIT;
+	
+	dbg(DBG_IOCTL, &quot;%s: PRIV_IOCTL_SET_SCAN_TIMES - min %d max %d&quot;,
+		netdev-&gt;name, mint, maxt);
+	if (mint &lt;= 0 || maxt &lt;= 0 || mint &gt; maxt) {
+		ret = -EINVAL;
+	} else {
+		LOCK_ISTATE()
+		if (dev-&gt;istate == MONITORING) {
+			dev-&gt;monitor_scan_min_time = mint;
+			dev-&gt;monitor_scan_max_time = maxt;
+			ret = 0;
+		} else {
+			dev-&gt;scan_min_time = mint;
+			dev-&gt;scan_max_time = maxt;
+		}
+		UNLOCK_ISTATE()
+	}
+	
+	return ret;
+}
+
+static int at76c503_iw_handler_PRIV_IOCTL_SET_SCAN_MODE
+	(struct net_device *netdev, struct iw_request_info *info, 
+	 char *name, char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
+	
+	dbg(DBG_IOCTL, &quot;%s: PRIV_IOCTL_SET_SCAN_MODE - mode %s&quot;,
+		netdev-&gt;name, (val = SCAN_TYPE_ACTIVE) ? &quot;active&quot; : 
+		(val = SCAN_TYPE_PASSIVE) ? &quot;passive&quot; : &quot;&lt;invalid&gt;&quot;);
+	
+	if (val != SCAN_TYPE_ACTIVE &amp;&amp; val != SCAN_TYPE_PASSIVE) {
+		ret = -EINVAL;
+	} else {
+		dev-&gt;scan_mode = val;
+	}
+	
+	return ret;
+}
+
+static int set_iroaming(struct at76c503 *dev, int onoff)
+{
+	int ret = 0;
+
+	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev-&gt;mib_buf.type = MIB_MAC_MGMT;
+	dev-&gt;mib_buf.size = 1;
+	dev-&gt;mib_buf.index = IROAMING_OFFSET;
+	dev-&gt;mib_buf.data[0] = (dev-&gt;international_roaming ? 1 : 0);
+	ret = set_mib(dev, &amp;dev-&gt;mib_buf);
+	if(ret &lt; 0){
+		err(&quot;%s: set_mib (intl_roaming_enable) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+
+	return ret;
+}
+
+static int at76c503_iw_handler_PRIV_IOCTL_SET_INTL_ROAMING
+	(struct net_device *netdev, struct iw_request_info *info, 
+	 char *name, char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
+
+	dbg(DBG_IOCTL, &quot;%s: PRIV_IOCTL_SET_INTL_ROAMING - mode %s&quot;,
+		netdev-&gt;name, (val == IR_OFF) ? &quot;off&quot; : 
+		(val == IR_ON) ? &quot;on&quot; : &quot;&lt;invalid&gt;&quot;);
+
+	if (val != IR_OFF &amp;&amp; val != IR_ON) {
+		ret = -EINVAL;
+	} else {
+		if (dev-&gt;international_roaming != val) {
+			dev-&gt;international_roaming = val;
+			set_iroaming(dev, val);
+		}
+	}
+
+	return ret;
+}
+
+/* == PROC set_monitor_mode == 
+   sets dev-&gt;netdev-&gt;type */
+static void set_monitor_mode(struct at76c503 *dev, int use_prism)
+{
+	if (dev-&gt;iw_mode == IW_MODE_MONITOR) {
+		if (use_prism) {
+			dbg(DBG_MONITOR_MODE, &quot;%s: MONITOR MODE ON: &quot;
+			    &quot;Prism headers ARE used&quot;, dev-&gt;netdev-&gt;name);
+			dev-&gt;netdev-&gt;type = ARPHRD_IEEE80211_PRISM;
+		} else {
+			dbg(DBG_MONITOR_MODE, &quot;%s: MONITOR MODE ON: &quot;
+			    &quot;Prism headers NOT used&quot;, dev-&gt;netdev-&gt;name);
+			dev-&gt;netdev-&gt;type = ARPHRD_IEEE80211;
+		}
+	} else {
+		dbg(DBG_MONITOR_MODE, &quot;%s: MONITOR MODE OFF&quot;, 
+		    dev-&gt;netdev-&gt;name);
+		dev-&gt;netdev-&gt;type = ARPHRD_ETHER;
+	}
+} /* set_monitor_mode */
+
+static int at76c503_iw_handler_PRIV_IOCTL_SET_MONITOR_MODE
+	(struct net_device *netdev, struct iw_request_info *info, 
+	 char *name, char *extra)
+{
+	struct at76c503 *dev = (struct at76c503*)netdev-&gt;priv;
+	int *params = ((int *)name);
+	int mode = params[0];
+	int channel = params[1];
+	int ret = 0;
+
+	dbg(DBG_IOCTL, &quot;%s: PRIV_IOCTL_SET_MONITOR_MODE - mode %d ch %d&quot;, 
+	    netdev-&gt;name, mode, channel);
+
+	if (mode != MM_OFF &amp;&amp; mode != MM_ON &amp;&amp; mode != MM_ON_NO_PRISM)
+		ret = -EINVAL;
+	else {
+		if (mode != MM_OFF) {
+			if ((channel &gt;= 1) &amp;&amp; 
+			    (channel &lt;= (sizeof(channel_frequency) / 
+				 sizeof(channel_frequency[0]))))
+			/* INFO: This doesn't actually affect the scan */
+			dev-&gt;channel = channel;
+
+			dev-&gt;monitor_prism_header = (mode == MM_ON);
+
+			if (dev-&gt;iw_mode != IW_MODE_MONITOR) {
+				ret = -EIWCOMMIT;
+				dev-&gt;iw_mode = IW_MODE_MONITOR;
+			}
+		} else {
+			/* mode == MM_OFF */
+			if (dev-&gt;iw_mode == IW_MODE_MONITOR) {
+				ret = -EIWCOMMIT;
+				dev-&gt;iw_mode = IW_MODE_INFRA;
+			}
+		}
+		set_monitor_mode(dev, dev-&gt;monitor_prism_header);
+	}
+
+	return ret;
+}
+
+/*******************************************************************************
+ * structure that advertises the iw handlers of this driver
+ */
+static const iw_handler	at76c503_handlers[] =
+{
+        [SIOCSIWCOMMIT-SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_commit,
+        [SIOCGIWNAME  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_name,
+        [SIOCSIWFREQ  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_freq,
+        [SIOCGIWFREQ  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_freq,
+        [SIOCSIWMODE  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_mode,
+        [SIOCGIWMODE  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_mode,
+        [SIOCGIWRANGE -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_range,
+        [SIOCSIWSPY   -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_spy,
+        [SIOCGIWSPY   -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_spy,
+        [SIOCSIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_thrspy,
+        [SIOCGIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_thrspy,
+        [SIOCSIWAP    -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_wap,
+        [SIOCGIWAP    -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_wap,
+        [SIOCSIWSCAN  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_scan,
+        [SIOCGIWSCAN  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_scan,
+        [SIOCSIWESSID -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_essid,
+        [SIOCGIWESSID -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_essid,
+        [SIOCSIWNICKN -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_nickname,
+        [SIOCGIWNICKN -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_nickname,
+        [SIOCSIWRATE  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_rate,
+        [SIOCGIWRATE  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_rate,
+        [SIOCSIWRTS   -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_rts,
+        [SIOCGIWRTS   -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_rts,
+        [SIOCSIWFRAG  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_frag,
+        [SIOCGIWFRAG  -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_frag,
+        [SIOCGIWTXPOW -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_txpow,
+        [SIOCSIWRETRY -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_retry,
+        [SIOCGIWRETRY -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_retry,
+        [SIOCSIWENCODE-SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_encode,
+        [SIOCGIWENCODE-SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_encode,
+        [SIOCSIWPOWER -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_set_power,
+        [SIOCGIWPOWER -SIOCIWFIRST] = (iw_handler) at76c503_iw_handler_get_power,
+};
+
+/*******************************************************************************
+ * structure that advertises the private iw handlers of this driver
+ */
+static const iw_handler	at76c503_priv_handlers[] =
+{
+	(iw_handler) at76c503_iw_handler_PRIV_IOCTL_SET_SHORT_PREAMBLE,
+	(iw_handler) NULL,
+	(iw_handler) at76c503_iw_handler_PRIV_IOCTL_SET_DEBUG,
+	(iw_handler) NULL,
+	(iw_handler) at76c503_iw_handler_PRIV_IOCTL_SET_POWERSAVE_MODE,
+	(iw_handler) NULL,
+	(iw_handler) at76c503_iw_handler_PRIV_IOCTL_SET_SCAN_TIMES,
+	(iw_handler) NULL,
+	(iw_handler) at76c503_iw_handler_PRIV_IOCTL_SET_SCAN_MODE,
+	(iw_handler) NULL,
+	(iw_handler) at76c503_iw_handler_PRIV_IOCTL_SET_INTL_ROAMING,
+	(iw_handler) NULL,
+	(iw_handler) at76c503_iw_handler_PRIV_IOCTL_SET_MONITOR_MODE,
+	(iw_handler) NULL,
+};
+
+static const struct iw_handler_def at76c503_handler_def =
+{
+	.num_standard	= sizeof(at76c503_handlers)/sizeof(iw_handler),
+	.num_private	= sizeof(at76c503_priv_handlers)/sizeof(iw_handler),
+	.num_private_args = sizeof(at76c503_priv_args)/
+				sizeof(struct iw_priv_args),
+	.standard	= (iw_handler *) at76c503_handlers,
+	.private	= (iw_handler *) at76c503_priv_handlers,
+	.private_args	= (struct iw_priv_args *) at76c503_priv_args,
+ 	.get_wireless_stats = at76c503_get_wireless_stats,
+};
+
+
+static void at76c503_ethtool_get_drvinfo(struct net_device *netdev,
+				         struct ethtool_drvinfo *info)
+{
+	struct at76c503 *dev = (struct at76c503 *)netdev-&gt;priv;
+
+	strncpy(info-&gt;driver, DRIVER_NAME, sizeof(info-&gt;driver) - 1);
+
+	strncpy(info-&gt;version, DRIVER_VERSION, sizeof(info-&gt;version));
+	info-&gt;version[sizeof(info-&gt;version)-1] = '\0';
+
+	snprintf(info-&gt;bus_info, sizeof(info-&gt;bus_info) - 1, &quot;usb%d:%d&quot;,
+		 dev-&gt;udev-&gt;bus-&gt;busnum, dev-&gt;udev-&gt;devnum);
+
+	snprintf(info-&gt;fw_version, sizeof(info-&gt;fw_version) - 1,
+		 &quot;%d.%d.%d-%d&quot;,
+		 dev-&gt;fw_version.major, dev-&gt;fw_version.minor,
+		 dev-&gt;fw_version.patch, dev-&gt;fw_version.build);
+}
+
+static u32 at76c503_ethtool_get_link(struct net_device *netdev)
+{
+	struct at76c503 *dev = netdev-&gt;priv;
+	return dev-&gt;istate == CONNECTED;
+}
+
+static struct ethtool_ops at76c503_ethtool_ops = {
+	.get_drvinfo = at76c503_ethtool_get_drvinfo,
+	.get_link = at76c503_ethtool_get_link,
+};
+
+
+static void at76c503_delete_device(struct at76c503 *dev)
+{
+	int i;
+
+	if (!dev) 
+		return;
+
+	/* signal to _stop() that the device is gone */
+	dev-&gt;device_unplugged = 1;
+
+	dbg(DBG_PROC_ENTRY, &quot;%s: ENTER&quot;,__FUNCTION__);
+
+	if (dev-&gt;netdev_registered) {
+		if (rtnl_trylock() == 0) {
+			info(&quot;%s: rtnl_sem already down'ed&quot;, __FUNCTION__);
+		} else {
+			/* synchronously calls at76c503_stop() */
+			unregister_netdevice(dev-&gt;netdev);
+			rtnl_unlock();
+		}
+	}
+
+	usb_put_dev(dev-&gt;udev);
+
+	/* assuming we used keventd, it must quiesce too */
+	flush_scheduled_work ();
+
+	if(dev-&gt;bulk_out_buffer != NULL)
+		kfree(dev-&gt;bulk_out_buffer);
+
+	kfree(dev-&gt;ctrl_buffer);
+
+	if(dev-&gt;write_urb != NULL) {
+		usb_kill_urb(dev-&gt;write_urb);
+		usb_free_urb(dev-&gt;write_urb);
+	}
+	if(dev-&gt;read_urb != NULL) {
+		usb_kill_urb(dev-&gt;read_urb);
+		usb_free_urb(dev-&gt;read_urb);
+	}
+	if(dev-&gt;ctrl_buffer != NULL) {
+		usb_kill_urb(dev-&gt;ctrl_urb);
+		usb_free_urb(dev-&gt;ctrl_urb);
+	}
+
+	dbg(DBG_PROC_ENTRY,&quot;%s: unlinked urbs&quot;,__FUNCTION__);
+
+	if(dev-&gt;rx_skb != NULL)
+		kfree_skb(dev-&gt;rx_skb);
+
+	free_bss_list(dev);
+	del_timer_sync(&amp;dev-&gt;bss_list_timer);
+
+	LOCK_ISTATE()
+	if (dev-&gt;istate == CONNECTED) {
+		UNLOCK_ISTATE()
+		iwevent_bss_disconnect(dev-&gt;netdev); 
+	} else UNLOCK_ISTATE()
+
+	for(i=0; i &lt; NR_RX_DATA_BUF; i++)
+		if (dev-&gt;rx_data[i].skb != NULL) {
+			dev_kfree_skb(dev-&gt;rx_data[i].skb);
+			dev-&gt;rx_data[i].skb = NULL;
+		}
+	dbg(DBG_PROC_ENTRY, &quot;%s: before freeing dev/netdev&quot;, __FUNCTION__);
+	free_netdev(dev-&gt;netdev); /* dev is in net_dev */ 
+#ifdef CONFIG_IPAQ_HANDHELD
+	if (machine_is_h5400()) {
+		ipaq_led_off (RED_LED);
+		ipaq_led_off (RED_LED_2);
+	}
+#endif
+	dbg(DBG_PROC_ENTRY, &quot;%s: EXIT&quot;, __FUNCTION__);
+}
+
+static int at76c503_alloc_urbs(struct at76c503 *dev)
+{
+	struct usb_interface *interface = dev-&gt;interface;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_device *udev = dev-&gt;udev;
+	int i, buffer_size;
+
+	dbg(DBG_PROC_ENTRY, &quot;%s: ENTER&quot;, __FUNCTION__);
+
+	dbg(DBG_URB, &quot;%s: NumEndpoints %d &quot;, __FUNCTION__, NUM_EP(interface));
+
+	for(i = 0; i &lt; NUM_EP(interface); i++) {
+		endpoint = &amp;EP(interface,i);
+
+		dbg(DBG_URB, &quot;%s: %d. endpoint: addr x%x attr x%x&quot;,
+		    __FUNCTION__,
+		    i,
+		    endpoint-&gt;bEndpointAddress,
+		    endpoint-&gt;bmAttributes);
+
+		if ((endpoint-&gt;bEndpointAddress &amp; 0x80) &amp;&amp;
+		    ((endpoint-&gt;bmAttributes &amp; 3) == 0x02)) {
+			/* we found a bulk in endpoint */
+
+			dev-&gt;read_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!dev-&gt;read_urb) {
+				err(&quot;No free urbs available&quot;);
+				return -1;
+			}
+			dev-&gt;bulk_in_endpointAddr = endpoint-&gt;bEndpointAddress;
+		}
+		
+		if (((endpoint-&gt;bEndpointAddress &amp; 0x80) == 0x00) &amp;&amp;
+		    ((endpoint-&gt;bmAttributes &amp; 3) == 0x02)) {
+			/* we found a bulk out endpoint */
+			dev-&gt;write_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!dev-&gt;write_urb) {
+				err(&quot;no free urbs available&quot;);
+				return -1;
+			}
+			buffer_size = sizeof(struct at76c503_tx_buffer) + 
+			  MAX_PADDING_SIZE;
+			dev-&gt;bulk_out_size = buffer_size;
+			dev-&gt;bulk_out_endpointAddr = endpoint-&gt;bEndpointAddress;
+			dev-&gt;bulk_out_buffer = kmalloc (buffer_size, GFP_KERNEL);
+			if (!dev-&gt;bulk_out_buffer) {
+				err(&quot;couldn't allocate bulk_out_buffer&quot;);
+				return -1;
+			}
+			FILL_BULK_URB(dev-&gt;write_urb, udev, 
+				      usb_sndbulkpipe(udev, 
+						      endpoint-&gt;bEndpointAddress),
+				      dev-&gt;bulk_out_buffer, buffer_size,
+				      (usb_complete_t)at76c503_write_bulk_callback, dev);
+		}
+	}
+
+	dev-&gt;ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dev-&gt;ctrl_urb) {
+		err(&quot;no free urbs available&quot;);
+		return -1;
+	}
+	dev-&gt;ctrl_buffer = kmalloc(1024, GFP_KERNEL);
+	if (!dev-&gt;ctrl_buffer) {
+		err(&quot;couldn't allocate ctrl_buffer&quot;);
+		return -1;
+	}
+
+	dbg(DBG_PROC_ENTRY, &quot;%s: EXIT&quot;, __FUNCTION__);
+
+	return 0;
+}
+
+
+static struct at76c503 *alloc_new_device(struct usb_device *udev,
+					 int board_type,
+					 const char *netdev_name)
+{
+	struct net_device *netdev;
+	struct at76c503 *dev = NULL;
+	int i;
+
+	/* allocate memory for our device state and initialize it */
+	netdev = alloc_etherdev(sizeof(struct at76c503));
+	if (netdev == NULL) {
+		err(&quot;out of memory&quot;);
+		return NULL;
+	}
+
+	dev = (struct at76c503 *)netdev-&gt;priv;
+	memset(dev, 0, sizeof(*dev));
+
+	dev-&gt;udev = udev;
+	dev-&gt;netdev = netdev;
+
+	init_MUTEX (&amp;dev-&gt;sem);
+	INIT_WORK (&amp;dev-&gt;kevent, kevent);
+
+	dev-&gt;open_count = 0;
+
+	init_timer(&amp;dev-&gt;restart_timer);
+	dev-&gt;restart_timer.data = (unsigned long)dev;
+	dev-&gt;restart_timer.function = restart_timeout;
+
+	init_timer(&amp;dev-&gt;mgmt_timer);
+	dev-&gt;mgmt_timer.data = (unsigned long)dev;
+	dev-&gt;mgmt_timer.function = mgmt_timeout;
+
+	init_timer(&amp;dev-&gt;fw_dl_timer);
+	dev-&gt;fw_dl_timer.data = (unsigned long)dev;
+	dev-&gt;fw_dl_timer.function = fw_dl_timeout;
+
+
+	spin_lock_init(&amp;dev-&gt;mgmt_spinlock);
+	spin_lock_init(&amp;dev-&gt;istate_spinlock);
+	dev-&gt;next_mgmt_bulk = NULL;
+	dev-&gt;istate = INTFW_DOWNLOAD;
+
+	/* initialize empty BSS list */
+	dev-&gt;curr_bss = dev-&gt;new_bss = NULL;
+	INIT_LIST_HEAD(&amp;dev-&gt;bss_list);
+	spin_lock_init(&amp;dev-&gt;bss_list_spinlock);
+
+	init_timer(&amp;dev-&gt;bss_list_timer);
+	dev-&gt;bss_list_timer.data = (unsigned long)dev;
+	dev-&gt;bss_list_timer.function = bss_list_timeout;
+
+	spin_lock_init(&amp;dev-&gt;spy_spinlock);
+
+	/* mark all rx data entries as unused */
+	for(i=0; i &lt; NR_RX_DATA_BUF; i++)
+		dev-&gt;rx_data[i].skb = NULL;
+
+	dev-&gt;tasklet.func = rx_tasklet;
+	dev-&gt;tasklet.data = (unsigned long)dev;
+
+	dev-&gt;board_type = board_type;
+
+	dev-&gt;pm_mode = pm_mode;
+	dev-&gt;pm_period_us = pm_period;
+
+	dev_alloc_name(netdev, netdev_name);
+
+	return dev;
+} /* alloc_new_device */
+
+/* == PROC init_new_device == 
+   firmware got downloaded, we can continue with init */
+/* We may have to move the register_netdev into alloc_new_device,
+   because hotplug may try to configure the netdev _before_
+   (or parallel to) the download of firmware */
+static int init_new_device(struct at76c503 *dev)
+{
+	struct net_device *netdev = dev-&gt;netdev;
+	int ret;
+
+	/* set up the endpoint information */
+	/* check out the endpoints */
+
+	dev-&gt;interface = dev-&gt;udev-&gt;actconfig-&gt;interface[0];
+
+	dbg(DBG_DEVSTART, &quot;USB interface: %d endpoints&quot;,
+	    NUM_EP(dev-&gt;interface));
+
+
+#ifdef CONFIG_IPAQ_HANDHELD
+	if (machine_is_h5400 ())
+		ipaq_init_led ();
+#endif
+
+	if(at76c503_alloc_urbs(dev) &lt; 0)
+		goto error;
+
+	/* get firmware version */
+	ret = get_mib(dev-&gt;udev, MIB_FW_VERSION, (u8*)&amp;dev-&gt;fw_version, sizeof(dev-&gt;fw_version));
+	if((ret &lt; 0) || ((dev-&gt;fw_version.major == 0) &amp;&amp; 
+			 (dev-&gt;fw_version.minor == 0) &amp;&amp; 
+			 (dev-&gt;fw_version.patch == 0) &amp;&amp; 
+			 (dev-&gt;fw_version.build == 0))){
+		err(&quot;getting firmware failed with %d, or version is 0&quot;, ret);
+		err(&quot;this probably means that the ext. fw was not loaded correctly&quot;);
+		goto error;
+	}
+
+	/* fw 0.84 doesn't send FCS with rx data */
+	if (dev-&gt;fw_version.major == 0 &amp;&amp; dev-&gt;fw_version.minor &lt;= 84)
+		dev-&gt;rx_data_fcs_len = 0;
+	else
+		dev-&gt;rx_data_fcs_len = 4;
+
+	info(&quot;firmware version %d.%d.%d #%d (fcs_len %d)&quot;,
+	     dev-&gt;fw_version.major, dev-&gt;fw_version.minor,
+	     dev-&gt;fw_version.patch, dev-&gt;fw_version.build,
+	     dev-&gt;rx_data_fcs_len);
+
+	/* MAC address */
+	ret = get_hw_config(dev);
+	if(ret &lt; 0){
+		err(&quot;could not get MAC address&quot;);
+		goto error;
+	}
+
+        dev-&gt;domain = getRegDomain(dev-&gt;regulatory_domain);
+	/* init. netdev-&gt;dev_addr */
+	memcpy(netdev-&gt;dev_addr, dev-&gt;mac_addr, ETH_ALEN);
+	info(&quot;device's MAC %s, regulatory domain %s (id %d)&quot;,
+	     mac2str(dev-&gt;mac_addr), dev-&gt;domain-&gt;name,
+	     dev-&gt;regulatory_domain);
+
+	/* initializing */
+	dev-&gt;international_roaming = international_roaming;
+	dev-&gt;channel = DEF_CHANNEL;
+	dev-&gt;iw_mode = default_iw_mode;
+	dev-&gt;monitor_prism_header = 1;
+	memset(dev-&gt;essid, 0, IW_ESSID_MAX_SIZE);
+	memset(dev-&gt;nickn, 0, sizeof(dev-&gt;nickn));
+	dev-&gt;rts_threshold = DEF_RTS_THRESHOLD;
+	dev-&gt;frag_threshold = DEF_FRAG_THRESHOLD;
+	dev-&gt;short_retry_limit = DEF_SHORT_RETRY_LIMIT;
+	/* dev-&gt;long_retr_limit = DEF_LONG_RETRY_LIMIT; */
+	dev-&gt;txrate = TX_RATE_AUTO;
+	dev-&gt;preamble_type = preamble_type;
+	dev-&gt;beacon_period = 100;
+	dev-&gt;beacons_last_qual=jiffies_to_msecs(jiffies);
+	dev-&gt;auth_mode = auth_mode ? WLAN_AUTH_SHARED_KEY :
+	  WLAN_AUTH_OPEN;
+	dev-&gt;scan_min_time = scan_min_time;
+	dev-&gt;scan_max_time = scan_max_time;
+	dev-&gt;scan_mode = scan_mode;
+	dev-&gt;monitor_scan_min_time = monitor_scan_min_time;
+	dev-&gt;monitor_scan_max_time = monitor_scan_max_time;
+
+	netdev-&gt;flags &amp;= ~IFF_MULTICAST; /* not yet or never */
+	netdev-&gt;open = at76c503_open;
+	netdev-&gt;stop = at76c503_stop;
+	netdev-&gt;get_stats = at76c503_get_stats;
+	netdev-&gt;ethtool_ops = &amp;at76c503_ethtool_ops;
+
+	/* Add pointers to enable iwspy support. */
+	dev-&gt;wireless_data.spy_data = &amp;dev-&gt;spy_data;
+	netdev-&gt;wireless_data = &amp;dev-&gt;wireless_data;
+
+	netdev-&gt;hard_start_xmit = at76c503_tx;
+	netdev-&gt;tx_timeout = at76c503_tx_timeout;
+	netdev-&gt;watchdog_timeo = 2 * HZ;
+	netdev-&gt;wireless_handlers = 
+		(struct iw_handler_def*)&amp;at76c503_handler_def;
+	netdev-&gt;set_multicast_list = at76c503_set_multicast;
+	netdev-&gt;set_mac_address = at76c503_set_mac_address;
+
+	/* putting this inside rtnl_lock() - rtnl_unlock() hangs modprobe ...? */
+	ret = register_netdev(dev-&gt;netdev);
+	if (ret) {
+		err(&quot;unable to register netdevice %s (status %d)!&quot;,
+		    dev-&gt;netdev-&gt;name, ret);
+		return -1;
+	}
+	info(&quot;registered %s&quot;, dev-&gt;netdev-&gt;name);
+	dev-&gt;netdev_registered = 1;
+
+	/* we let this timer run the whole time this driver instance lives */
+	mod_timer(&amp;dev-&gt;bss_list_timer, jiffies+BSS_LIST_TIMEOUT);
+
+	return 0;
+
+ error:
+	at76c503_delete_device(dev);
+	return -1;
+
+} /* init_new_device */
+
+
+/* == PROC at76c503_get_fw_info ==
+   disassembles the firmware image into version, str,
+   internal and external fw part. returns 0 on success, &lt; 0 on error */
+static int at76c503_get_fw_info(u8 *fw_data, int fw_size,
+				u32 *board, u32 *version, char **str,
+				u8 **int_fw, int *int_fw_size,
+				u8 **ext_fw, int *ext_fw_size)
+{
+/* fw structure (all numbers are little_endian)
+   offset  length  description
+   0       4       crc 32 (seed ~0, no post, all gaps are zeros, header included)
+   4       4       board type (see at76c503.h)
+   8       4       version (major&lt;&lt;24|middle&lt;&lt;16|minor&lt;&lt;8|build)
+   c       4       offset of printable string (id) area from begin of image
+                   (must be \0 terminated !)
+  10       4       offset of internal fw part area
+  14       4       length of internal fw part
+  18       4       offset of external fw part area (may be first byte _behind_
+                   image in case we have no external part)
+  1c       4       length of external fw part
+*/
+
+	__le32 val;
+	
+	if (fw_size &lt; 0x21) {
+		err(&quot;fw too short (x%x)&quot;,fw_size);
+		return -EFAULT;
+	}
+
+	/* crc currently not checked */
+
+	memcpy(&amp;val,fw_data+4,4);
+	*board = le32_to_cpu(val);
+
+	memcpy(&amp;val,fw_data+8,4);
+	*version = le32_to_cpu(val);
+
+	memcpy(&amp;val,fw_data+0xc,4);
+	*str = fw_data + le32_to_cpu(val);
+
+	memcpy(&amp;val,fw_data+0x10,4);
+	*int_fw = fw_data + le32_to_cpu(val);
+	memcpy(&amp;val,fw_data+0x14,4);
+	*int_fw_size = le32_to_cpu(val);
+
+	memcpy(&amp;val,fw_data+0x18,4);
+	*ext_fw = fw_data + le32_to_cpu(val);
+	memcpy(&amp;val,fw_data+0x1c,4);
+	*ext_fw_size = le32_to_cpu(val);
+
+	return 0;
+}
+
+/* == PROC at76c503_do_probe == */
+static int at76c503_do_probe(struct module *mod, struct usb_device *udev,
+			     u8 *fw_data, int fw_size, u32 board_type,
+			     const char *netdev_name)
+{
+	struct usb_interface *intf = udev-&gt;actconfig-&gt;interface[0];
+	int ret;
+	struct at76c503 *dev = NULL;
+	int op_mode;
+	char *id_str;
+	u32 version;
+
+	usb_get_dev(udev);
+
+	if ((dev=alloc_new_device(udev, (u8)board_type, netdev_name)) == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	op_mode = get_op_mode(udev);
+
+	usb_set_intfdata(intf, dev);
+	dev-&gt;interface = intf;
+
+	dbg(DBG_DEVSTART, &quot;opmode %d&quot;, op_mode);
+
+	/* we get OPMODE_NONE with 2.4.23, SMC2662W-AR ???
+	   we get 204 with 2.4.23, Fiberline FL-WL240u (505A+RFMD2958) ??? */
+
+	if (op_mode == OPMODE_HW_CONFIG_MODE) {
+	  err(&quot;cannot handle a device in HW_CONFIG_MODE (opmode %d)&quot;, op_mode);
+	  ret = -ENODEV;
+	  goto error;
+	}
+
+	if (op_mode != OPMODE_NORMAL_NIC_WITH_FLASH &amp;&amp;
+	    op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {
+
+		dbg(DBG_DEVSTART, &quot;need to download firmware&quot;);
+
+		/* disassem. the firmware */
+		if ((ret=at76c503_get_fw_info(fw_data, fw_size, &amp;dev-&gt;board_type,
+					      &amp;version, &amp;id_str,
+					      &amp;dev-&gt;intfw, &amp;dev-&gt;intfw_size,
+					      &amp;dev-&gt;extfw, &amp;dev-&gt;extfw_size))) {
+			goto error;
+		}
+
+		dbg(DBG_DEVSTART, &quot;firmware board %u version %u.%u.%u#%u &quot;
+		    &quot;(int %x:%tx, ext %x:%tx)&quot;,
+		    dev-&gt;board_type, version&gt;&gt;24,(version&gt;&gt;16)&amp;0xff,
+		    (version&gt;&gt;8)&amp;0xff, version&amp;0xff,
+		    dev-&gt;intfw_size, dev-&gt;intfw-fw_data,
+		    dev-&gt;extfw_size, dev-&gt;extfw-fw_data);
+		if (*id_str)
+			dbg(DBG_DEVSTART, &quot;firmware id %s&quot;,id_str);
+
+		if (dev-&gt;board_type != board_type) {
+			err(&quot;inconsistent board types %u != %u&quot;,
+			    board_type, dev-&gt;board_type);
+			at76c503_delete_device(dev);
+			goto error;
+		}
+
+		/* download internal firmware part */
+		dbg(DBG_DEVSTART, &quot;downloading internal firmware&quot;);
+		NEW_STATE(dev,INTFW_DOWNLOAD);
+		defer_kevent(dev,KEVENT_INTERNAL_FW);
+
+	} else {
+		/* internal firmware already inside the device */
+		/* get firmware version to test if external firmware is loaded */
+		/* This works only for newer firmware, e.g. the Intersil 0.90.x
+		   says &quot;control timeout on ep0in&quot; and subsequent get_op_mode() fail
+		   too :-( */
+		int force_fw_dwl = 0;
+
+		/* disassem. the firmware */
+		if ((ret=at76c503_get_fw_info(fw_data, fw_size, &amp;dev-&gt;board_type,
+					      &amp;version, &amp;id_str,
+					      &amp;dev-&gt;intfw, &amp;dev-&gt;intfw_size,
+					      &amp;dev-&gt;extfw, &amp;dev-&gt;extfw_size))) {
+			goto error;
+		}
+		
+		/* if version &gt;= 0.100.x.y or device with built-in flash we can query the device
+		 * for the fw version */
+		if (version &gt;= ((0&lt;&lt;24)|(100&lt;&lt;16)) || (op_mode == OPMODE_NORMAL_NIC_WITH_FLASH)) {
+			ret = get_mib(udev, MIB_FW_VERSION, (u8*)&amp;dev-&gt;fw_version, 
+				      sizeof(dev-&gt;fw_version));
+		} else {
+			/* force fw download only if the device has no flash inside */
+			force_fw_dwl = 1;
+		}
+
+		if ((force_fw_dwl) || (ret &lt; 0) || ((dev-&gt;fw_version.major == 0) &amp;&amp; 
+						       (dev-&gt;fw_version.minor == 0) &amp;&amp; 
+						       (dev-&gt;fw_version.patch == 0) &amp;&amp; 
+						       (dev-&gt;fw_version.build == 0))) {
+			if (force_fw_dwl)
+				dbg(DBG_DEVSTART, &quot;forced download of external firmware part&quot;);
+			else
+				dbg(DBG_DEVSTART, &quot;cannot get firmware (ret %d) or all zeros &quot;
+				    &quot;- download external firmware&quot;, ret);
+			dbg(DBG_DEVSTART, &quot;firmware board %u version %u.%u.%u#%u &quot;
+			    &quot;(int %x:%tx, ext %x:%tx)&quot;,
+			    dev-&gt;board_type, version&gt;&gt;24,(version&gt;&gt;16)&amp;0xff,
+			    (version&gt;&gt;8)&amp;0xff, version&amp;0xff,
+			    dev-&gt;intfw_size, dev-&gt;intfw-fw_data,
+			    dev-&gt;extfw_size, dev-&gt;extfw-fw_data);
+			if (*id_str)
+				dbg(DBG_DEVSTART, &quot;firmware id %s&quot;,id_str);
+
+			if (dev-&gt;board_type != board_type) {
+				err(&quot;inconsistent board types %u != %u&quot;,
+				    board_type, dev-&gt;board_type);
+				at76c503_delete_device(dev);
+				goto error;
+			}
+
+			NEW_STATE(dev,EXTFW_DOWNLOAD);
+			defer_kevent(dev,KEVENT_EXTERNAL_FW);
+		} else {
+			NEW_STATE(dev,INIT);
+			if (init_new_device(dev) &lt; 0) {
+				ret = -ENODEV;
+				goto error;
+			}
+		}
+	}
+
+	SET_NETDEV_DEV(dev-&gt;netdev, &amp;intf-&gt;dev);
+	return 0;
+
+error:
+	usb_put_dev(udev);
+	return ret;
+}
+
+
+/* Firmware names - this must be in sync with boardtype definitions */
+static struct fwentry {
+	const char *const fwname;
+	const struct firmware *fw;
+} firmwares[] = {
+	{ &quot;&quot; },
+	{ &quot;atmel_at76c503-i3861.bin&quot; },
+	{ &quot;atmel_at76c503-i3863.bin&quot; },
+	{ &quot;atmel_at76c503-rfmd.bin&quot; },
+	{ &quot;atmel_at76c503-rfmd-acc.bin&quot; },
+	{ &quot;atmel_at76c505-rfmd.bin&quot; },
+	{ &quot;atmel_at76c505-rfmd2958.bin&quot; },
+	{ &quot;atmel_at76c505a-rfmd2958.bin&quot; },
+	{ &quot;atmel_at76c505amx-rfmd.bin&quot; }
+};
+
+/* USB Device IDs supported by this driver */
+
+/* at76c503-i3861 */
+#define VENDOR_ID_ATMEL               0x03eb
+#define PRODUCT_ID_ATMEL_503I         0x7603 /* Generic AT76C503/3861 device */
+
+#define VENDOR_ID_LINKSYS_OLD         0x066b
+#define PRODUCT_ID_LINKSYS_WUSB11_V21 0x2211 /* Linksys WUSB11 v2.1/v2.6 */
+
+#define VENDOR_ID_NETGEAR             0x0864
+#define PRODUCT_ID_NETGEAR_MA101A     0x4100 /* Netgear MA 101 Rev. A */
+
+#define VENDOR_ID_TEKRAM              0x0b3b
+#define PRODUCT_ID_TEKRAM_U300C       0x1612 /* Tekram U-300C / Allnet ALL0193 */
+
+#define VENDOR_ID_HP                  0x03f0
+#define PRODUCT_ID_HP_HN210W          0x011c /* HP HN210W PKW-J7801A */
+
+#define VENDOR_ID_M4Y750              0x0cde /* Unknown Vendor ID! */
+#define PRODUCT_ID_M4Y750             0x0001 /* Sitecom/Z-Com/Zyxel M4Y-750 */
+
+#define VENDOR_ID_DYNALINK            0x069a
+#define PRODUCT_ID_DYNALINK_WLL013_I  0x0320 /* Dynalink/Askey WLL013 (intersil) */
+
+#define VENDOR_ID_SMC_OLD             0x0d5c
+#define PRODUCT_ID_SMC2662W_V1        0xa001 /* EZ connect 11Mpbs
+Wireless USB Adapter SMC2662W (v1) */
+
+#define VENDOR_ID_BENQ                0x04a5 /* BenQ (Acer) */
+#define PRODUCT_ID_BENQ_AWL_300       0x9000 /* AWL-300 */
+
+/* this adapter contains flash */
+#define VENDOR_ID_ADDTRON             0x05dd  /* Addtron */
+#define PRODUCT_ID_ADDTRON_AWU120     0xff31 /* AWU-120 */
+/* also Compex WLU11 */
+
+#define VENDOR_ID_INTEL               0x8086 /* Intel */
+#define PRODUCT_ID_INTEL_AP310        0x0200 /* AP310 AnyPoint II USB */
+
+#define VENDOR_ID_CONCEPTRONIC        0x0d8e
+#define PRODUCT_ID_CONCEPTRONIC_C11U  0x7100 /* also Dynalink L11U */
+
+#define VENDOR_ID_ARESCOM		0xd8e
+#define PRODUCT_ID_WL_210		0x7110 /* Arescom WL-210, 
+						  FCC id 07J-GL2411USB */
+#define VENDOR_ID_IO_DATA		0x04bb
+#define PRODUCT_ID_IO_DATA_WN_B11_USB   0x0919 /* IO-DATA WN-B11/USB */
+
+#define VENDOR_ID_BT            0x069a
+#define PRODUCT_ID_BT_VOYAGER_1010  0x0821 /* BT Voyager 1010 */
+
+
+/* at76c503-i3863 */
+#define VENDOR_ID_ATMEL               0x03eb
+#define PRODUCT_ID_ATMEL_503_I3863    0x7604 /* Generic AT76C503/3863 device */
+
+#define VENDOR_ID_SAMSUNG             0x055d
+#define PRODUCT_ID_SAMSUNG_SWL2100U   0xa000 /* Samsung SWL-2100U */
+
+
+/* at76c503-rfmd */
+#define VENDOR_ID_ATMEL               0x03eb
+#define PRODUCT_ID_ATMEL_503R         0x7605 /* Generic AT76C503/RFMD device */
+#define PRODUCT_ID_W_BUDDIE_WN210     0x4102 /* AirVast W-Buddie WN210 */
+
+#define VENDOR_ID_DYNALINK            0x069a
+#define PRODUCT_ID_DYNALINK_WLL013_R  0x0321 /* Dynalink/Askey WLL013 (rfmd) */
+
+#define VENDOR_ID_LINKSYS             0x077b
+#define PRODUCT_ID_LINKSYS_WUSB11_V26 0x2219 /* Linksys WUSB11 v2.6 */
+#define PRODUCT_ID_NE_NWU11B          0x2227 /* Network Everywhere NWU11B */
+
+#define VENDOR_ID_NETGEAR             0x0864
+#define PRODUCT_ID_NETGEAR_MA101B     0x4102 /* Netgear MA 101 Rev. B */
+
+#define VENDOR_ID_ACTIONTEC           0x1668
+#define PRODUCT_ID_ACTIONTEC_802UAT1  0x7605 /* Actiontec 802UAT1, HWU01150-01UK */
+
+#define VENDOR_ID_DLINK               0x2001 /* D-Link */
+#define PRODUCT_ID_DLINK_DWL120       0x3200 /* DWL-120 rev. E */
+
+#define VENDOR_ID_DICK_SMITH_ELECTR   0x1371 /* Dick Smith Electronics */
+#define PRODUCT_ID_DSE_XH1153         0x5743 /* XH1153 802.11b USB adapter */
+                                             /* also: CNet CNUSB611 (D) */
+#define PRODUCT_ID_WL_200U            0x0002 /* WL-200U */
+
+#define VENDOR_ID_BENQ                0x04a5 /* BenQ (Acer) */
+#define PRODUCT_ID_BENQ_AWL_400       0x9001 /* BenQ AWL-400 USB stick */
+
+#define VENDOR_ID_3COM                0x506
+#define PRODUCT_ID_3COM_3CRSHEW696    0xa01 /* 3COM 3CRSHEW696 */
+
+#define VENDOR_ID_SIEMENS             0x681
+#define PRODUCT_ID_SIEMENS_SANTIS_WLL013 0x1b /* Siemens Santis ADSL WLAN 
+						 USB adapter WLL 013 */
+
+#define VENDOR_ID_BELKIN_2		0x50d
+#define PRODUCT_ID_BELKIN_F5D6050_V2	0x50	/* Belkin F5D6050, version 2 */
+
+#define VENDOR_ID_BLITZ                 0x07b8  
+#define PRODUCT_ID_BLITZ_NETWAVE_BWU613 0xb000 /* iBlitzz, BWU613 (not *B or *SB !) */
+
+#define VENDOR_ID_GIGABYTE              0x1044  
+#define PRODUCT_ID_GIGABYTE_GN_WLBM101  0x8003 /* Gigabyte GN-WLBM101 */
+
+#define VENDOR_ID_PLANEX                0x2019
+#define PRODUCT_ID_PLANEX_GW_US11S      0x3220 /* Planex GW-US11S */
+
+#define VENDOR_ID_COMPAQ                0x049f
+#define PRODUCT_ID_IPAQ_INT_WLAN        0x0032 /* internal WLAN adapter in h5[4,5]xx series iPAQs */
+
+
+/* at76c503-rfmd-acc */
+#define VENDOR_ID_BELKIN              0x0d5c
+#define PRODUCT_ID_BELKIN_F5D6050     0xa002 /* Belkin F5D6050 / SMC 2662W v2 / SMC 2662W-AR */
+
+#define VENDOR_ID_SMC                 0x083a
+#define PRODUCT_ID_SMC_2664W          0x3501
+
+
+/* at76c505-rfmd */
+#define VENDOR_ID_ATMEL               0x03eb
+#define PRODUCT_ID_ATMEL_505R         0x7606 /* Generic AT76C505/RFMD device */
+
+
+/* at76c505-rfmd2958 */
+#define VENDOR_ID_ATMEL               0x03eb
+#define PRODUCT_ID_ATMEL_505R2958     0x7613 /* Generic AT76C505/RFMD device 
+					       also OvisLink WL-1130USB */
+
+#define VENDOR_ID_CNET                0x1371
+#define PRODUCT_ID_CNET_CNUSB611G     0x0013 /* CNet CNUSB 611G */
+#define PRODUCT_ID_FL_WL240U          0x0014 /* Fiberline WL-240U with the
+                                                 CNet vendor id */
+
+#define VENDOR_ID_LINKSYS_1915        0x1915 
+#define PRODUCT_ID_LINKSYS_WUSB11V28  0x2233 /* Linksys WUSB11 v2.8 */
+
+#define VENDOR_ID_XTERASYS            0x12fd
+#define PRODUCT_ID_XTERASYS_XN_2122B  0x1001 /* Xterasys XN-2122B, also
+					        IBlitzz BWU613B / BWU613SB */
+
+#define VENDOR_ID_COREGA               0x07aa
+#define PRODUCT_ID_COREGA_USB_STICK_11_KK 0x7613 /* Corega WLAN USB Stick 11 (K.K.) */
+
+#define VENDOR_ID_MSI                 0x0db0
+#define PRODUCT_ID_MSI_MS6978_WLAN_BOX_PC2PC 0x1020
+
+
+/* at76c505a-rfmd2958 */
+#define VENDOR_ID_ATMEL               0x03eb
+#define PRODUCT_ID_ATMEL_505A         0x7614 /* Generic AT76C505A device */
+#define PRODUCT_ID_ATMEL_505AS        0x7617 /* Generic AT76C505AS device */
+
+#define VENDOR_ID_GIGASET             0x1690
+#define PRODUCT_ID_GIGASET_11         0x0701
+
+
+/* at76c505amx-rfmd */
+#define VENDOR_ID_ATMEL               0x03eb
+#define PRODUCT_ID_ATMEL_505AMX       0x7615 /* Generic AT76C505AMX device */
+
+
+static struct usb_device_id dev_table[] = {
+	{ USB_DEVICE(VENDOR_ID_ATMEL,    PRODUCT_ID_ATMEL_503I        ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_LINKSYS_OLD, PRODUCT_ID_LINKSYS_WUSB11_V21),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_NETGEAR,  PRODUCT_ID_NETGEAR_MA101A    ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_TEKRAM,   PRODUCT_ID_TEKRAM_U300C      ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_HP,       PRODUCT_ID_HP_HN210W         ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_M4Y750,   PRODUCT_ID_M4Y750            ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_DYNALINK, PRODUCT_ID_DYNALINK_WLL013_I ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_SMC_OLD,  PRODUCT_ID_SMC2662W_V1       ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_BENQ,     PRODUCT_ID_BENQ_AWL_300      ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_ADDTRON,  PRODUCT_ID_ADDTRON_AWU120    ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_INTEL,    PRODUCT_ID_INTEL_AP310       ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_CONCEPTRONIC,PRODUCT_ID_CONCEPTRONIC_C11U),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_ARESCOM, PRODUCT_ID_WL_210),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_IO_DATA, PRODUCT_ID_IO_DATA_WN_B11_USB),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+	{ USB_DEVICE(VENDOR_ID_BT,       PRODUCT_ID_BT_VOYAGER_1010   ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3861 },
+
+	{ USB_DEVICE(VENDOR_ID_ATMEL,   PRODUCT_ID_ATMEL_503_I3863 ),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3863 },
+	{ USB_DEVICE(VENDOR_ID_SAMSUNG, PRODUCT_ID_SAMSUNG_SWL2100U),
+	  .driver_info = BOARDTYPE_503_INTERSIL_3863 },
+
+	{ USB_DEVICE(VENDOR_ID_ATMEL,    PRODUCT_ID_ATMEL_503R        ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_DYNALINK, PRODUCT_ID_DYNALINK_WLL013_R ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_LINKSYS,  PRODUCT_ID_LINKSYS_WUSB11_V26),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_LINKSYS,  PRODUCT_ID_NE_NWU11B         ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_NETGEAR,  PRODUCT_ID_NETGEAR_MA101B    ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_DLINK,    PRODUCT_ID_DLINK_DWL120      ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_ACTIONTEC,PRODUCT_ID_ACTIONTEC_802UAT1 ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_ATMEL,    PRODUCT_ID_W_BUDDIE_WN210    ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_DICK_SMITH_ELECTR, PRODUCT_ID_DSE_XH1153),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_DICK_SMITH_ELECTR, PRODUCT_ID_WL_200U),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_BENQ,     PRODUCT_ID_BENQ_AWL_400),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_3COM, PRODUCT_ID_3COM_3CRSHEW696),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_SIEMENS,  PRODUCT_ID_SIEMENS_SANTIS_WLL013),
+	  .driver_info = BOARDTYPE_503_RFMD },
+	{ USB_DEVICE(VENDOR_ID_BELKIN_2, PRODUCT_ID_BELKIN_F5D6050_V2 ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+        { USB_DEVICE(VENDOR_ID_BLITZ,    PRODUCT_ID_BLITZ_NETWAVE_BWU613 ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+        { USB_DEVICE(VENDOR_ID_GIGABYTE, PRODUCT_ID_GIGABYTE_GN_WLBM101 ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+        { USB_DEVICE(VENDOR_ID_PLANEX,   PRODUCT_ID_PLANEX_GW_US11S ),
+	  .driver_info = BOARDTYPE_503_RFMD },
+        { USB_DEVICE(VENDOR_ID_COMPAQ,   PRODUCT_ID_IPAQ_INT_WLAN),
+	  .driver_info = BOARDTYPE_503_RFMD },
+
+	{ USB_DEVICE(VENDOR_ID_SMC, PRODUCT_ID_SMC_2664W),
+	  .driver_info = BOARDTYPE_503_RFMD_ACC },
+	{ USB_DEVICE(VENDOR_ID_BELKIN,   PRODUCT_ID_BELKIN_F5D6050    ),
+	  .driver_info = BOARDTYPE_503_RFMD_ACC },
+
+	{ USB_DEVICE(VENDOR_ID_ATMEL,    PRODUCT_ID_ATMEL_505R       ),
+	  .driver_info = BOARDTYPE_505_RFMD },
+
+	{ USB_DEVICE(VENDOR_ID_ATMEL,    PRODUCT_ID_ATMEL_505R2958   ),
+	  .driver_info = BOARDTYPE_505_RFMD_2958 },
+	{ USB_DEVICE(VENDOR_ID_CNET,     PRODUCT_ID_FL_WL240U         ),
+	  .driver_info = BOARDTYPE_505_RFMD_2958 },
+	{ USB_DEVICE(VENDOR_ID_CNET,     PRODUCT_ID_CNET_CNUSB611G    ),
+	  .driver_info = BOARDTYPE_505_RFMD_2958 },
+	{ USB_DEVICE(VENDOR_ID_LINKSYS_1915, PRODUCT_ID_LINKSYS_WUSB11V28 ),
+	  .driver_info = BOARDTYPE_505_RFMD_2958 },
+	{ USB_DEVICE(VENDOR_ID_XTERASYS, PRODUCT_ID_XTERASYS_XN_2122B ),
+	  .driver_info = BOARDTYPE_505_RFMD_2958 },
+	{ USB_DEVICE(VENDOR_ID_COREGA,   PRODUCT_ID_COREGA_USB_STICK_11_KK ),
+	  .driver_info = BOARDTYPE_505_RFMD_2958 },
+        { USB_DEVICE(VENDOR_ID_MSI,      PRODUCT_ID_MSI_MS6978_WLAN_BOX_PC2PC),
+	  .driver_info = BOARDTYPE_505_RFMD_2958 },
+
+	{ USB_DEVICE(VENDOR_ID_ATMEL,    PRODUCT_ID_ATMEL_505A       ),
+	  .driver_info = BOARDTYPE_505A_RFMD_2958 },
+	{ USB_DEVICE(VENDOR_ID_ATMEL,    PRODUCT_ID_ATMEL_505AS      ),
+	  .driver_info = BOARDTYPE_505A_RFMD_2958 },
+        { USB_DEVICE(VENDOR_ID_GIGASET,  PRODUCT_ID_GIGASET_11       ),
+	  .driver_info = BOARDTYPE_505A_RFMD_2958 },
+
+	{ USB_DEVICE(VENDOR_ID_ATMEL,    PRODUCT_ID_ATMEL_505AMX    ),
+	  .driver_info = BOARDTYPE_505AMX_RFMD },
+
+	{ }
+};
+
+MODULE_DEVICE_TABLE (usb, dev_table);
+
+
+static int at76c50x_probe(struct usb_interface *interface,
+			  const struct usb_device_id *id)
+{
+	int retval;
+
+	struct usb_device *udev;
+	int boardtype = (int)id-&gt;driver_info;
+	const char *const fw_name = firmwares[boardtype].fwname;
+	const struct firmware *fw = firmwares[boardtype].fw;
+	udev = interface_to_usbdev(interface);
+
+	if (fw == NULL) {
+		dbg(DBG_FW, &quot;downloading firmware %s&quot;, fw_name);
+		retval = request_firmware(&amp;fw, fw_name, &amp;udev-&gt;dev);
+		if (retval == 0) {
+			dbg(DBG_FW, &quot;got it.&quot;);
+		} else {
+			err(&quot;firmware %s not found.&quot;, fw_name);
+			err(&quot;You may need to download the firmware from &quot;
+			    &quot;<A HREF="https://developer.berlios.de/projects/at76c503a/">https://developer.berlios.de/projects/at76c503a/</A>&quot;);
+			return retval;
+		}
+	} else
+		dbg(DBG_FW, &quot;re-using previously loaded fw&quot;);
+
+	retval = at76c503_do_probe(THIS_MODULE, udev,
+				   fw-&gt;data, fw-&gt;size,
+				   boardtype, netdev_name);
+	return retval;
+}
+
+static void at76c50x_disconnect(struct usb_interface *interface)
+{
+	struct at76c503 *ptr;
+
+	ptr = usb_get_intfdata (interface);
+	usb_set_intfdata(interface, NULL);
+
+	info(&quot;%s disconnecting&quot;, ((struct at76c503 *)ptr)-&gt;netdev-&gt;name);
+	at76c503_delete_device(ptr);
+	info(DRIVER_NAME &quot; disconnected&quot;);
+}
+
+/* structure for registering this driver with the USB subsystem */
+static struct usb_driver module_usb = {
+	.name = DRIVER_NAME,
+	.probe = at76c50x_probe,
+	.disconnect = at76c50x_disconnect,
+	.id_table = dev_table,
+};
+
+
+static int __init mod_init(void)
+{
+	int result;
+
+	info(DRIVER_DESC &quot; &quot; DRIVER_VERSION &quot; loading&quot;);
+
+#ifdef CONFIG_IPAQ_HANDHELD
+	if (machine_is_h5400()) {
+		/* turn WLAN power on */
+		/* both needed? */
+		SET_H5400_ASIC_GPIO (GPB, RF_POWER_ON, 1);
+		SET_H5400_ASIC_GPIO (GPB, WLAN_POWER_ON, 1);
+	}
+#endif
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&amp;module_usb);
+	if (result &lt; 0) {
+		err(&quot;usb_register failed (status %d)&quot;, result);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void __exit mod_exit(void)
+{
+	int i;
+
+	info(DRIVER_DESC &quot; &quot; DRIVER_VERSION &quot; unloading&quot;);
+	usb_deregister(&amp;module_usb);
+	for (i = 0; i &lt; ARRAY_SIZE(firmwares); i++) {
+		if (firmwares[i].fw)
+			release_firmware(firmwares[i].fw);
+	}
+
+#ifdef CONFIG_IPAQ_HANDHELD
+	if (machine_is_h5400()) {
+		/* turn WLAN power off */
+		SET_H5400_ASIC_GPIO (GPB, RF_POWER_ON, 0);
+		SET_H5400_ASIC_GPIO (GPB, WLAN_POWER_ON, 0);
+	}
+#endif
+}
+
+module_init(mod_init);
+module_exit(mod_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE(&quot;GPL&quot;);
diff --git a/drivers/net/wireless/at76c503.h b/drivers/net/wireless/at76c503.h
new file mode 100644
index 0000000..526a3ae
--- /dev/null
+++ b/drivers/net/wireless/at76c503.h
@@ -0,0 +1,716 @@
+/* -*- linux-c -*- */
+/*
+ * Copyright (c) 2002 - 2003 Oliver Kurth
+ *           (c) 2003 - 2004 J&#246;rg Albert &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">joerg.albert at gmx.de</A>&gt;
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation; either version 2 of
+ *	the License, or (at your option) any later version.
+ *
+ *  This driver was based on information from the Sourceforge driver
+ *  released and maintained by Atmel:
+ *
+ *  <A HREF="http://sourceforge.net/projects/atmelwlandriver/">http://sourceforge.net/projects/atmelwlandriver/</A>
+ *
+ *  Although the code was completely re-written,
+ *  it would have been impossible without Atmel's decision to
+ *  release an Open Source driver (unfortunately the firmware was
+ *  kept binary only). Thanks for that decision to Atmel!
+ *  
+ *  For the latest version of this driver, mailinglists
+ *  and other info, please check
+ *        <A HREF="http://at76c503a.berlios.de/">http://at76c503a.berlios.de/</A>
+ */
+
+#ifndef _AT76C503_H
+#define _AT76C503_H
+
+#include &lt;net/ieee80211.h&gt;
+
+/* current driver version */
+#define DRIVER_VERSION &quot;0.14dev&quot;
+
+
+/* our private ioctl's */
+/* set preamble length*/
+#define PRIV_IOCTL_SET_SHORT_PREAMBLE  (SIOCIWFIRSTPRIV + 0x0)
+/* set debug parameter */
+#define PRIV_IOCTL_SET_DEBUG           (SIOCIWFIRSTPRIV + 0x2)
+/* set power save mode (incl. the Atmel proprietary smart save mode */
+#define PRIV_IOCTL_SET_POWERSAVE_MODE  (SIOCIWFIRSTPRIV + 0x4)
+/* set min and max channel times for scan */
+#define PRIV_IOCTL_SET_SCAN_TIMES      (SIOCIWFIRSTPRIV + 0x6)
+/* set scan mode */
+#define PRIV_IOCTL_SET_SCAN_MODE       (SIOCIWFIRSTPRIV + 0x8)
+/* set international roaming */
+#define PRIV_IOCTL_SET_INTL_ROAMING    (SIOCIWFIRSTPRIV + 0x10)
+/* set monitor mode */
+#define PRIV_IOCTL_SET_MONITOR_MODE    (SIOCIWFIRSTPRIV + 0x12)
+
+#define DEVICE_VENDOR_REQUEST_OUT    0x40
+#define DEVICE_VENDOR_REQUEST_IN     0xc0
+#define INTERFACE_VENDOR_REQUEST_OUT 0x41
+#define INTERFACE_VENDOR_REQUEST_IN  0xc1
+#define CLASS_REQUEST_OUT            0x21
+#define CLASS_REQUEST_IN             0xa1
+
+#define CMD_STATUS_IDLE                   0x00
+#define CMD_STATUS_COMPLETE               0x01
+#define CMD_STATUS_UNKNOWN                0x02
+#define CMD_STATUS_INVALID_PARAMETER      0x03
+#define CMD_STATUS_FUNCTION_NOT_SUPPORTED 0x04
+#define CMD_STATUS_TIME_OUT               0x07
+#define CMD_STATUS_IN_PROGRESS            0x08
+#define CMD_STATUS_HOST_FAILURE           0xff
+#define CMD_STATUS_SCAN_FAILED            0xf0
+
+/* answers to get op mode */
+#define OPMODE_NONE                         0x00
+#define OPMODE_NORMAL_NIC_WITH_FLASH        0x01
+#define OPMODE_HW_CONFIG_MODE               0x02
+#define OPMODE_DFU_MODE_WITH_FLASH          0x03
+#define OPMODE_NORMAL_NIC_WITHOUT_FLASH     0x04
+
+#define CMD_SET_MIB    0x01
+#define CMD_GET_MIB    0x02
+#define CMD_SCAN       0x03
+#define CMD_JOIN       0x04
+#define CMD_START_IBSS 0x05
+#define CMD_RADIO      0x06
+#define CMD_STARTUP    0x0B
+#define CMD_GETOPMODE  0x33
+
+#define MIB_LOCAL      0x01
+#define MIB_MAC_ADD    0x02
+#define MIB_MAC        0x03
+#define MIB_MAC_MGMT   0x05
+#define MIB_MAC_WEP    0x06
+#define MIB_PHY        0x07
+#define MIB_FW_VERSION 0x08
+#define MIB_MDOMAIN    0x09
+
+#define ADHOC_MODE          1
+#define INFRASTRUCTURE_MODE 2
+
+/* values for struct mib_local, field preamble_type */
+#define PREAMBLE_TYPE_SHORT 1
+#define PREAMBLE_TYPE_LONG  0
+
+/* values for tx_rate */
+#define TX_RATE_1MBIT   0
+#define TX_RATE_2MBIT   1
+#define TX_RATE_5_5MBIT 2
+#define TX_RATE_11MBIT  3
+#define TX_RATE_AUTO    4
+
+/* power management modes */
+#define PM_ACTIVE     1
+#define PM_SAVE       2
+#define PM_SMART_SAVE 3
+
+/* international roaming state */
+#define IR_OFF        0
+#define IR_ON         1
+
+/* monitor mode - param of private ioctl */
+#define MM_OFF 0
+#define MM_ON  1
+#define MM_ON_NO_PRISM 2
+
+
+/* offsets into the MIBs we use to configure the device */
+#define TX_AUTORATE_FALLBACK_OFFSET offsetof(struct mib_local,txautorate_fallback)
+#define FRAGMENTATION_OFFSET        offsetof(struct mib_mac,frag_threshold)
+#define PREAMBLE_TYPE_OFFSET        offsetof(struct mib_local,preamble_type)
+#define RTS_OFFSET                  offsetof(struct mib_mac, rts_threshold)      
+
+/* valid only for rfmd and 505 !*/
+#define IBSS_CHANGE_OK_OFFSET       offsetof(struct mib_mac_mgmt, ibss_change)
+#define IROAMING_IMPL_OFFSET	    offsetof(struct mib_mac_mgmt, multi_domain_capability_implemented)
+#define IROAMING_OFFSET \
+  offsetof(struct mib_mac_mgmt, multi_domain_capability_enabled)
+/* the AssocID */
+#define STATION_ID_OFFSET           offsetof(struct mib_mac_mgmt, station_id)
+#define POWER_MGMT_MODE_OFFSET      offsetof(struct mib_mac_mgmt, power_mgmt_mode)
+#define LISTEN_INTERVAL_OFFSET      offsetof(struct mib_mac, listen_interval)
+
+#define PRIVACY_OPT_IMPL            offsetof(struct mib_mac_mgmt, privacy_option_implemented)
+
+#define BOARDTYPE_503_INTERSIL_3861 1
+#define BOARDTYPE_503_INTERSIL_3863 2
+#define BOARDTYPE_503_RFMD          3
+#define BOARDTYPE_503_RFMD_ACC      4
+#define BOARDTYPE_505_RFMD          5
+#define BOARDTYPE_505_RFMD_2958     6
+#define BOARDTYPE_505A_RFMD_2958    7
+#define BOARDTYPE_505AMX_RFMD       8
+
+struct hwcfg_r505 {
+	u8 cr39_values[14];
+	u8 reserved1[14];
+	u8 bb_cr[14];
+	u8 pidvid[4];
+	u8 mac_addr[ETH_ALEN];
+	u8 regulatory_domain;
+	u8 reserved2[14];
+	u8 cr15_values[14];
+	u8 reserved3[3];
+} __attribute__ ((packed));
+
+struct hwcfg_rfmd {
+	u8 cr20_values[14]; 
+	u8 cr21_values[14]; 
+	u8 bb_cr[14]; 
+	u8 pidvid[4]; 
+	u8 mac_addr[ETH_ALEN]; 
+	u8 regulatory_domain; 
+	u8 low_power_values[14];     
+	u8 normal_power_values[14]; 
+	u8 reserved1[3];   
+} __attribute__ ((packed));
+
+struct hwcfg_intersil {
+	u8   mac_addr[ETH_ALEN];
+	u8   cr31_values[14];
+	u8   cr58_values[14];
+	u8   pidvid[4];
+	u8   regulatory_domain;
+	u8   reserved[1];
+} __attribute__ ((packed));
+
+#define WEP_SMALL_KEY_LEN (40/8)
+#define WEP_LARGE_KEY_LEN (104/8)
+
+struct at76c503_card_config{
+	u8 exclude_unencrypted;
+	u8 promiscuous_mode;
+	u8 short_retry_limit;
+	u8 encryption_type;
+	__le16 rts_threshold;
+	__le16 fragmentation_threshold;         /* 256..2346 */
+	u8 basic_rate_set[4];
+	u8 auto_rate_fallback;                  /* 0,1 */
+	u8 channel;
+	u8 privacy_invoked;
+	u8 wep_default_key_id;                  /* 0..3 */
+	u8 current_ssid[32];
+	u8 wep_default_key_value[4][WEP_KEY_LEN];
+	u8 ssid_len;
+	u8 short_preamble;
+	__le16 beacon_period;
+} __attribute__ ((packed));
+
+struct at76c503_command{
+	u8 cmd;
+	u8 reserved;
+	__le16 size;
+} __attribute__ ((packed));
+
+/* the length of the Atmel firmware specific rx header before IEEE 802.11 starts */
+#define AT76C503_RX_HDRLEN offsetof(struct at76c503_rx_buffer, packet)
+
+struct at76c503_rx_buffer {
+	__le16 wlength;
+	u8 rx_rate;
+	u8 newbss;
+	u8 fragmentation;
+	u8 rssi;
+	u8 link_quality;
+	u8 noise_level;
+	u8 rx_time[4];
+	u8 packet[IEEE80211_FRAME_LEN + IEEE80211_FCS_LEN];
+} __attribute__ ((packed));
+
+/* the length of the Atmel firmware specific tx header before IEEE 802.11 starts */
+#define AT76C503_TX_HDRLEN offsetof(struct at76c503_tx_buffer, packet)
+
+struct at76c503_tx_buffer {
+	__le16 wlength;
+	u8 tx_rate;
+	u8 padding;
+	u8 reserved[4];
+	u8 packet[IEEE80211_FRAME_LEN + IEEE80211_FCS_LEN];
+} __attribute__ ((packed));
+
+/* defines for scan_type below */
+#define SCAN_TYPE_ACTIVE  0
+#define SCAN_TYPE_PASSIVE 1
+
+struct at76c503_start_scan {
+	u8   bssid[ETH_ALEN];
+	u8   essid[32];
+	u8   scan_type;
+	u8   channel;
+	__le16 probe_delay;
+	__le16 min_channel_time;
+	__le16 max_channel_time;
+	u8   essid_size;
+	u8   international_scan;
+} __attribute__ ((packed));
+
+struct at76c503_start_bss {
+	u8 bssid[ETH_ALEN];
+	u8 essid[32];
+	u8 bss_type;
+	u8 channel;
+	u8 essid_size;
+	u8 reserved[3];
+} __attribute__ ((packed));
+
+struct at76c503_join {
+	u8 bssid[ETH_ALEN];
+	u8 essid[32];
+	u8 bss_type;
+	u8 channel;
+	__le16 timeout;
+	u8 essid_size;
+	u8 reserved;
+} __attribute__ ((packed));
+
+struct set_mib_buffer {
+	u8 type;
+	u8 size;
+	u8 index;
+	u8 reserved;
+	u8 data[72];
+} __attribute__ ((packed));
+
+struct mib_local {
+        u16 reserved0;
+        u8  beacon_enable;
+        u8  txautorate_fallback;
+        u8  reserved1;
+        u8  ssid_size;
+        u8  promiscuous_mode;
+        u16 reserved2;
+        u8  preamble_type;
+        u16 reserved3;
+} __attribute__ ((packed));
+
+struct mib_mac_addr {
+	u8 mac_addr[ETH_ALEN];
+        u8 res[2]; /* ??? */
+        u8 group_addr[4][ETH_ALEN];
+        u8 group_addr_status[4];
+} __attribute__ ((packed));
+
+struct mib_mac {
+        __le32 max_tx_msdu_lifetime;
+        __le32 max_rx_lifetime;
+        __le16 frag_threshold;
+        __le16 rts_threshold;
+        __le16 cwmin;
+        __le16 cwmax;
+        u8  short_retry_time;
+        u8  long_retry_time;
+        u8  scan_type; /* active or passive */
+        u8  scan_channel;
+        __le16 probe_delay; /* delay before sending a ProbeReq in active scan, RO */
+        __le16 min_channel_time;
+        __le16 max_channel_time;
+        __le16 listen_interval;
+        u8  desired_ssid[32];
+        u8  desired_bssid[ETH_ALEN];
+        u8  desired_bsstype; /* ad-hoc or infrastructure */
+        u8  reserved2;
+} __attribute__ ((packed));
+
+struct mib_mac_mgmt {
+	__le16 beacon_period;
+	__le16 CFP_max_duration;
+	__le16 medium_occupancy_limit;
+	__le16 station_id;  /* assoc id */
+	__le16 ATIM_window;
+	u8  CFP_mode;
+	u8  privacy_option_implemented;
+	u8  DTIM_period;
+	u8  CFP_period;
+	u8  current_bssid[ETH_ALEN];
+	u8  current_essid[32];
+	u8  current_bss_type;
+	u8  power_mgmt_mode;
+	/* rfmd and 505 */
+	u8  ibss_change;
+	u8  res;
+	u8  multi_domain_capability_implemented;
+	u8  multi_domain_capability_enabled;
+	u8  country_string[3];
+	u8  reserved[3];
+} __attribute__ ((packed));
+
+struct mib_mac_wep {
+        u8 privacy_invoked; /* 0 disable encr., 1 enable encr */
+        u8 wep_default_key_id;
+        u8 wep_key_mapping_len;
+        u8 exclude_unencrypted;
+        __le32 wep_icv_error_count;
+        __le32 wep_excluded_count;
+        u8 wep_default_keyvalue[WEP_KEYS][WEP_KEY_LEN];
+        u8 encryption_level; /* 1 for 40bit, 2 for 104bit encryption */
+} __attribute__ ((packed));
+
+struct mib_phy {
+	__le32 ed_threshold;
+  
+	__le16 slot_time;
+	__le16 sifs_time;
+	__le16 preamble_length;
+	__le16 plcp_header_length;
+	__le16 mpdu_max_length;
+	__le16 cca_mode_supported;
+  
+	u8 operation_rate_set[4];
+	u8 channel_id;
+	u8 current_cca_mode;
+	u8 phy_type;
+	u8 current_reg_domain;
+} __attribute__ ((packed));
+
+struct mib_fw_version {
+        u8 major;
+        u8 minor;
+        u8 patch;
+        u8 build;
+} __attribute__ ((packed));
+
+struct mib_mdomain {
+        u8 tx_powerlevel[14];
+        u8 channel_list[14]; /* 0 for invalid channels */
+} __attribute__ ((packed));
+
+/* states in infrastructure mode */
+enum infra_state {
+	INIT,
+	SCANNING,
+	AUTHENTICATING,
+	ASSOCIATING,
+	REASSOCIATING,
+	DISASSOCIATING,
+	JOINING,
+	CONNECTED,
+	STARTIBSS,
+	INTFW_DOWNLOAD,
+	EXTFW_DOWNLOAD,
+	WAIT_FOR_DISCONNECT,
+	MONITORING,
+};
+
+/* a description of a regulatory domain and the allowed channels */
+struct reg_domain {
+  u16 code;
+  char const *name;
+  u32 channel_map; /* if bit N is set, channel (N+1) is allowed */
+};
+
+/* how long do we keep a (I)BSS in the bss_list in jiffies 
+   this should be long enough for the user to retrieve the table
+   (by iwlist ?) after the device started, because all entries from
+   other channels than the one the device locks on get removed, too */
+#define BSS_LIST_TIMEOUT (120*HZ)
+
+/* struct to store BSS info found during scan */
+#define BSS_LIST_MAX_RATE_LEN 32 /* 32 rates should be enough ... */
+
+struct bss_info{
+	struct list_head list;
+
+	u8 mac[ETH_ALEN]; /* real mac address, differs 
+			     for ad-hoc from bssid */
+	u8 bssid[ETH_ALEN]; /* bssid */
+	u8 ssid[IW_ESSID_MAX_SIZE+1]; /* ssid, +1 for trailing \0 
+					 to make it printable */
+	u8 ssid_len; /* length of ssid above */
+	u8 channel;
+	u16 capa; /* the capabilities of the BSS (in original endianess -
+		     we only check IEEE802_11 bits in it) */
+	u16 beacon_interval; /* the beacon interval in units of TU (1.024 ms)
+				(in CPU endianess - we must calc. values from it) */
+	u8 rates[BSS_LIST_MAX_RATE_LEN]; /* supported rates (list of bytes: 
+				   (basic_rate ? 0x80 : 0) + rate/(500 Kbit/s); e.g. 
+				   x82,x84,x8b,x96 for basic rates 1,2,5.5,11 MBit/s) */
+	u8 rates_len;
+
+	/* quality of received beacon */
+	u8 rssi;
+	u8 link_qual;
+	u8 noise_level;
+
+	unsigned long last_rx; /* time (jiffies) of last beacon received */
+	u16 assoc_id;          /* if this is dev-&gt;curr_bss this is the assoc id we got
+				  in a successful AssocResponse */
+};
+
+/* a rx data buffer to collect rx fragments */
+struct rx_data_buf {
+	u8 sender[ETH_ALEN]; /* sender address */
+	u16 seqnr; /* sequence number */
+	u16 fragnr; /* last fragment received */
+	unsigned long last_rx; /* jiffies of last rx */
+	struct sk_buff *skb; /* == NULL if entry is free */
+};
+
+#define NR_RX_DATA_BUF 8
+
+/* how often do we try to submit a rx urb until giving up */
+#define NR_SUBMIT_RX_TRIES 8
+
+struct at76c503 {
+	struct usb_device *udev;			/* USB device pointer */
+	struct net_device *netdev;			/* net device pointer */
+	struct net_device_stats stats;
+	struct iw_statistics wstats;
+	struct usb_interface *interface;		/* the interface for this device */
+
+	struct sk_buff *	rx_skb;			/* skbuff for receiving packets */
+	__u8			bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
+	
+	unsigned char *	bulk_out_buffer;	        /* the buffer to send data */
+	int			bulk_out_size;		/* the size of the send buffer */
+	struct urb *		write_urb;		/* the urb used to send data */
+	struct urb *		read_urb;
+	__u8			bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
+
+	int			open_count;		/* number of times this port has been opened */
+	struct semaphore	sem;			/* locks this structure */
+
+
+	unsigned long kevent_flags;
+	struct work_struct kevent;
+	int nr_submit_rx_tries; /* number of tries to submit an rx urb left */
+	struct tasklet_struct tasklet;
+	struct urb *rx_urb;     /* tmp urb pointer for rx_tasklet */
+
+	unsigned char *ctrl_buffer;
+	struct urb *ctrl_urb;
+
+	u8 op_mode;
+
+        /* the WEP stuff */
+        int wep_enabled;    /* 1 if WEP is enabled */ 
+        int wep_key_id;     /* key id to be used */
+        u8 wep_keys[WEP_KEYS][WEP_KEY_LEN]; /* the four WEP keys,
+					       5 or 13 bytes are used */
+        u8  wep_keys_len[WEP_KEYS]; /* the length of the above keys */
+
+	int channel;
+	int iw_mode;
+	int curr_ap;
+	u8 bssid[ETH_ALEN];
+	u8 essid[IW_ESSID_MAX_SIZE];
+	char nickn[IW_ESSID_MAX_SIZE+1]; /* nickname, only used in the iwconfig i/f */
+	int essid_size;
+	int radio_on;
+	int promisc;
+
+	int preamble_type;  /* 0 - long preamble, 1 - short preamble */
+	int auth_mode;      /* authentication type: 0 open, 1 shared key */
+	int txrate;         /* 0,1,2,3 = 1,2,5.5,11 MBit, 4 is auto-fallback */
+        int frag_threshold; /* threshold for fragmentation of tx packets */
+        int rts_threshold;  /* threshold for RTS mechanism */
+	int short_retry_limit;
+
+	int scan_min_time;  /* scan min channel time */
+	int scan_max_time;  /* scan max channel time */
+	int scan_mode;      /* SCAN_TYPE_ACTIVE, SCAN_TYPE_PASSIVE */
+	int scan_runs;      /* counts how many scans are started */
+
+	/* the list we got from scanning */
+	spinlock_t bss_list_spinlock; /* protects bss_list operations and setting
+				         curr_bss and new_bss */
+	struct list_head bss_list; /* the list of bss we received beacons from */
+	struct timer_list bss_list_timer; /* a timer removing old entries from
+					     the bss_list. It must acquire bss_list_spinlock
+					     before and must not remove curr_bss nor
+					     new_bss ! */
+	struct bss_info *curr_bss; /* if istate == AUTH, ASSOC, REASSOC, JOIN or CONN 
+				      dev-&gt;bss[curr_bss] is the currently selected BSS
+				      we operate on */
+	struct bss_info *new_bss;  /* if istate == REASSOC dev-&gt;new_bss
+				      is the new bss we want to reassoc to */
+	
+	u8 wanted_bssid[ETH_ALEN];
+	int wanted_bssid_valid;    /* != 0 if wanted_bssid is to be used */
+	
+	/* some data for infrastructure mode only */
+	spinlock_t mgmt_spinlock;  /* this spinlock protects access to
+				      next_mgmt_bulk */
+	spinlock_t istate_spinlock;/* this spinlock protects access to
+	                              istate */
+
+	
+	struct at76c503_tx_buffer *next_mgmt_bulk; /* pending management msg to
+						      send via bulk out */
+	enum infra_state istate;
+	enum {
+		SITE_SURVEY_IDLE,
+		SITE_SURVEY_IN_PROGRESS,
+		SITE_SURVEY_COMPLETED
+	} site_survey_state;
+	time_t last_survey;
+
+	struct timer_list restart_timer; /* the timer we use to delay the restart a bit */
+
+	struct timer_list mgmt_timer; /* the timer we use to repeat auth_req etc. */
+	int retries;  /* counts backwards while re-trying to send auth/assoc_req's */
+	u16 assoc_id; /* the assoc_id for states JOINING, REASSOCIATING, CONNECTED */
+	u8  pm_mode ; /* power management mode: ACTIVE, SAVE, SMART_SAVE */
+	u32 pm_period_us;     /* power manag. period (in us ?) - set by iwconfig */
+	u32 pm_period_beacon; /* power manag. period (in beacon intervals
+				 of the curr_bss) */
+	u32 board_type; /* BOARDTYPE_* defined above */
+
+	struct reg_domain const *domain; /* the description of the regulatory domain */
+
+	/* iwspy support */
+	spinlock_t spy_spinlock;
+	struct iw_spy_data spy_data;
+
+	struct iw_public_data wireless_data;
+
+	/* These fields contain HW config provided by the device (not all of
+	 * these fields are used by all board types) */
+	u8 mac_addr[ETH_ALEN];
+	u8 bb_cr[14];
+	u8 pidvid[4];
+	u8 regulatory_domain;
+	u8 cr15_values[14];
+	u8 cr20_values[14]; 
+	u8 cr21_values[14]; 
+	u8 cr31_values[14];
+	u8 cr39_values[14];
+	u8 cr58_values[14];
+	u8 low_power_values[14];     
+	u8 normal_power_values[14]; 
+
+	struct at76c503_card_config card_config;
+	struct mib_fw_version fw_version;
+
+	int rx_data_fcs_len; /* length of the trailing FCS 
+				(0 for fw &lt;= 0.84.x, 4 otherwise) */
+
+	/* store rx fragments until complete */
+	struct rx_data_buf rx_data[NR_RX_DATA_BUF];
+
+	/* firmware downloading stuff */
+	struct timer_list fw_dl_timer; /* timer used to wait after REMAP
+					  until device is reset */
+	int extfw_size;
+	int intfw_size;
+	/* these point into a buffer managed by at76c503-xxx.o, no need to dealloc */
+	u8 *extfw; /* points to external firmware part, extfw_size bytes long */
+	u8 *intfw; /* points to internal firmware part, intfw_size bytes long */
+	unsigned int device_unplugged:1;
+	unsigned int netdev_registered:1;
+	char obuf[2*256+1]; /* global debug output buffer to reduce stack usage */
+	char obuf_s[3*32];  /* small global debug output buffer to reduce stack usage */
+	struct set_mib_buffer mib_buf; /* global buffer for set_mib calls */
+
+	/* new whiz-bang feature flags */
+	int international_roaming;
+	int monitor_prism_header; /* if iw_mode == IW_MODE_MONITOR, 
+				     use Prism header */
+	int monitor_scan_min_time;
+	int monitor_scan_max_time;
+
+	int beacon_period;	  /* period of mgmt beacons */
+	int beacons_received;
+	unsigned long beacons_last_qual; /* last time we reset beacons_received = 0 */
+};
+
+/* Quasi-monitor mode defs (copied from &lt;kernel&gt;/drivers/net/wireless/orinoco.h) */
+
+/* message data item for INT, BOUNDEDINT, ENUMINT */
+typedef struct p80211item_uint32
+{
+	uint32_t		did	__attribute__ ((packed));
+	uint16_t		status	__attribute__ ((packed));
+	uint16_t		len	__attribute__ ((packed));
+	uint32_t		data	__attribute__ ((packed));
+} __attribute__ ((packed)) p80211item_uint32_t;
+
+typedef struct p80211msg
+{
+	uint32_t	msgcode		__attribute__ ((packed));
+	uint32_t	msglen		__attribute__ ((packed));
+	uint8_t				devname[IFNAMSIZ];
+} __attribute__ ((packed)) p80211msg_t;
+
+#define P80211ENUM_msgitem_status_data_ok		0
+#define P80211ENUM_msgitem_status_no_value		1
+#define P80211ENUM_truth_false			0
+#define P80211ENUM_truth_true			1
+
+#define DIDmsg_lnxind_wlansniffrm 0x0041
+#define DIDmsg_lnxind_wlansniffrm_hosttime 0x1041
+#define DIDmsg_lnxind_wlansniffrm_mactime 0x2041
+#define DIDmsg_lnxind_wlansniffrm_channel 0x3041
+#define DIDmsg_lnxind_wlansniffrm_rssi 0x4041
+#define DIDmsg_lnxind_wlansniffrm_sq 0x5041
+#define DIDmsg_lnxind_wlansniffrm_signal 0x6041
+#define DIDmsg_lnxind_wlansniffrm_noise 0x7041
+#define DIDmsg_lnxind_wlansniffrm_rate 0x8041
+#define DIDmsg_lnxind_wlansniffrm_istx 0x9041
+#define DIDmsg_lnxind_wlansniffrm_frmlen 0xA041
+
+typedef struct p80211msg_lnxind_wlansniffrm
+{
+	uint32_t		msgcode;
+	uint32_t		msglen;
+	uint8_t			devname[IFNAMSIZ];
+	p80211item_uint32_t	hosttime;
+	p80211item_uint32_t	mactime;
+	p80211item_uint32_t	channel;
+	p80211item_uint32_t	rssi;
+	p80211item_uint32_t	sq;
+	p80211item_uint32_t	signal;
+	p80211item_uint32_t	noise;
+	p80211item_uint32_t	rate;
+	p80211item_uint32_t	istx;
+	p80211item_uint32_t	frmlen;
+} __attribute__ ((packed)) p80211msg_lnxind_wlansniffrm_t;
+
+/* at76_debug bits */
+#define DBG_PROGRESS        0x00000001 /* progress of scan-join-(auth-assoc)-connected */
+#define DBG_BSS_TABLE       0x00000002 /* show the bss table after scans */
+#define DBG_IOCTL           0x00000004 /* ioctl calls / settings */
+#define DBG_KEVENT          0x00000008 /* kevents */
+#define DBG_TX_DATA         0x00000010 /* tx header */
+#define DBG_TX_DATA_CONTENT 0x00000020 /* tx content */
+#define DBG_TX_MGMT         0x00000040
+#define DBG_RX_DATA         0x00000080 /* rx data header */
+#define DBG_RX_DATA_CONTENT 0x00000100 /* rx data content */
+#define DBG_RX_MGMT         0x00000200 /* rx mgmt header except beacon and probe responses */
+#define DBG_RX_BEACON       0x00000400 /* rx beacon */
+#define DBG_RX_CTRL         0x00000800 /* rx control */
+#define DBG_RX_MGMT_CONTENT 0x00001000 /* rx mgmt content */
+#define DBG_RX_FRAGS        0x00002000 /* rx data fragment handling */
+#define DBG_DEVSTART        0x00004000 /* fw download, device start */
+#define DBG_URB             0x00008000 /* rx urb status, ... */
+#define DBG_RX_ATMEL_HDR    0x00010000 /* the Atmel specific header of each rx packet */
+#define DBG_PROC_ENTRY      0x00020000 /* procedure entries and exits */
+#define DBG_PM              0x00040000 /* power management settings */
+#define DBG_BSS_MATCH       0x00080000 /* show why a certain bss did not match */
+#define DBG_PARAMS          0x00100000 /* show the configured parameters */
+#define DBG_WAIT_COMPLETE   0x00200000 /* show the wait_completion progress */
+#define DBG_RX_FRAGS_SKB    0x00400000 /* show skb header for incoming rx fragments */
+#define DBG_BSS_TABLE_RM    0x00800000 /* inform on removal of old bss table entries */
+#define DBG_MONITOR_MODE    0x01000000 /* debugs from monitor mode */
+#define DBG_MIB             0x02000000 /* dump all MIBs in startup_device */
+#define DBG_MGMT_TIMER      0x04000000 /* dump mgmt_timer ops */
+#define DBG_WE_EVENTS       0x08000000 /* dump wireless events */
+#define DBG_FW              0x10000000 /* firmware download */
+#define DBG_DFU             0x20000000 /* device firmware upgrade */
+
+#define DBG_DEFAULTS 0
+extern int at76_debug;
+
+/* Use our own dbg macro */
+#undef dbg
+#define dbg(bits, format, arg...) \
+	do { \
+		if (at76_debug &amp; (bits)) \
+		printk(KERN_DEBUG __FILE__ &quot;: &quot; format &quot;\n&quot; , ## arg);\
+	} while (0)
+
+#endif /* _AT76C503_H */

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9">[ date ]</a>
              <a href="thread.html#9">[ thread ]</a>
              <a href="subject.html#9">[ subject ]</a>
              <a href="author.html#9">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">More information about the at76c503a-develop
mailing list</a><br>
</body></html>
