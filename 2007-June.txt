From proski at gnu.org  Sat Jun  2 20:00:03 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:03 -0400
Subject: [at76c503a-develop] [PATCH 01/11] Rename tasklet to rx_tasklet,
	the former is too generic
Message-ID: <20070602180003.28397.98594.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    6 +++---
 at76_usb.h |    2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index f59d60b..fc27f51 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1605,7 +1605,7 @@ static void at76_read_bulk_callback(struct urb *urb)
 	struct at76_priv *priv = urb->context;
 
 	priv->rx_urb = urb;
-	tasklet_schedule(&priv->tasklet);
+	tasklet_schedule(&priv->rx_tasklet);
 	return;
 }
 
@@ -6170,8 +6170,8 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 	for (i = 0; i < NR_RX_DATA_BUF; i++)
 		priv->rx_data[i].skb = NULL;
 
-	priv->tasklet.func = at76_rx_tasklet;
-	priv->tasklet.data = (unsigned long)priv;
+	priv->rx_tasklet.func = at76_rx_tasklet;
+	priv->rx_tasklet.data = (unsigned long)priv;
 
 	priv->board_type = board_type;
 
diff --git a/at76_usb.h b/at76_usb.h
index 34f1862..4ea3e32 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -483,7 +483,7 @@ struct at76_priv {
 	struct work_struct work_submit_rx;
 
 	int nr_submit_rx_tries;	/* number of tries to submit an rx urb left */
-	struct tasklet_struct tasklet;
+	struct tasklet_struct rx_tasklet;
 	struct urb *rx_urb;	/* tmp urb pointer for rx_tasklet */
 
 	void *ctrl_buffer;




From proski at gnu.org  Sat Jun  2 20:00:08 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:08 -0400
Subject: [at76c503a-develop] [PATCH 02/11] Remove another unneeded cast
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070602180008.28397.3483.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index fc27f51..58cbf31 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -6251,7 +6251,7 @@ static int at76_probe(struct usb_interface *interface,
 
 	usb_get_dev(udev);
 
-	if ((priv = at76_alloc_new_device(udev, (u8) board_type)) == NULL) {
+	if ((priv = at76_alloc_new_device(udev, board_type)) == NULL) {
 		ret = -ENOMEM;
 		goto error_alloc;
 	}




From proski at gnu.org  Sat Jun  2 20:00:13 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:13 -0400
Subject: [at76c503a-develop] [PATCH 03/11] op_mode should be int,
	negative values are valid and mean an error
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070602180013.28397.57074.stgit@dv.roinet.com>

We should not treat negative errno like positive valid modes.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 58cbf31..58bddd7 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -4269,7 +4269,7 @@ static void at76_work_external_fw(struct work_struct *work)
 	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_external_fw);
 	int ret;
-	u8 op_mode;
+	int op_mode;
 
 	mutex_lock(&priv->mtx);
 




From proski at gnu.org  Sat Jun  2 20:00:18 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:18 -0400
Subject: [at76c503a-develop] [PATCH 04/11] Release priv->mtx when
	registering network device
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070602180018.28397.89152.stgit@dv.roinet.com>

Not doing so causes circular mutex dependency, which is detected by the
kernel lock validation code  The driver's mutex should only protect
hardware access and driver's structures, and should not be held when
dealing with higher layers of the kernel.

The locking and the initialization may need a serious overhaul, but this
little change is a step in the right direction.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 58bddd7..10da864 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -4296,8 +4296,10 @@ static void at76_work_external_fw(struct work_struct *work)
 		}
 	}
 	priv->istate = INIT;
+	mutex_unlock(&priv->mtx);
 	if ((ret = at76_init_new_device(priv)) < 0)
 		err("Downloading external firmware failed: %d", ret);
+	return;
 
   end_external_fw:
 	mutex_unlock(&priv->mtx);




From proski at gnu.org  Sat Jun  2 20:00:24 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:24 -0400
Subject: [at76c503a-develop] [PATCH 05/11] Don't reschedule firmware loading
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070602180024.28397.55569.stgit@dv.roinet.com>

at76_probe() is run in the process context and doesn't need to delay the
firmware download.  Rescheduling doesn't guarantee the execution order,
so it's better to make the order predictable.  It also makes it possible
to handle errors in the firmware download.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   14 ++++----------
 at76_usb.h |    2 --
 2 files changed, 4 insertions(+), 12 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 10da864..c4e99be 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -4264,10 +4264,8 @@ static int at76_init_new_device(struct at76_priv *priv)
 
 
 /* Download external firmware */
-static void at76_work_external_fw(struct work_struct *work)
+static void at76_load_external_fw(struct at76_priv *priv)
 {
-	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_external_fw);
 	int ret;
 	int op_mode;
 
@@ -4307,10 +4305,8 @@ static void at76_work_external_fw(struct work_struct *work)
 
 
 /* Download internal firmware */
-static void at76_work_internal_fw(struct work_struct *work)
+static void at76_load_internal_fw(struct at76_priv *priv)
 {
-	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_internal_fw);
 	int ret;
 
 	mutex_lock(&priv->mtx);
@@ -6127,8 +6123,6 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 
 	mutex_init(&priv->mtx);
 	INIT_WORK(&priv->work_assoc_done, at76_work_assoc_done);
-	INIT_WORK(&priv->work_external_fw, at76_work_external_fw);
-	INIT_WORK(&priv->work_internal_fw, at76_work_internal_fw);
 	INIT_WORK(&priv->work_join, at76_work_join);
 	INIT_WORK(&priv->work_mgmt_timeout, at76_work_mgmt_timeout);
 	INIT_WORK(&priv->work_new_bss, at76_work_new_bss);
@@ -6285,7 +6279,7 @@ static int at76_probe(struct usb_interface *interface,
 		/* download internal firmware part */
 		at76_dbg(DBG_DEVSTART, "downloading internal firmware");
 		priv->istate = INTFW_DOWNLOAD;
-		schedule_work(&priv->work_internal_fw);
+		at76_load_internal_fw(priv);
 	} else {
 		/* Internal firmware already inside the device.  Get firmware
 		 * version to test if external firmware is loaded.
@@ -6320,7 +6314,7 @@ static int at76_probe(struct usb_interface *interface,
 					 "- download external firmware", ret);
 
 			priv->istate = EXTFW_DOWNLOAD;
-			schedule_work(&priv->work_external_fw);
+			at76_load_external_fw(priv);
 		} else {
 			priv->istate = INIT;
 			if ((ret = at76_init_new_device(priv)) < 0)
diff --git a/at76_usb.h b/at76_usb.h
index 4ea3e32..474049c 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -470,8 +470,6 @@ struct at76_priv {
 
 	/* work queues */
 	struct work_struct work_assoc_done;
-	struct work_struct work_external_fw;
-	struct work_struct work_internal_fw;
 	struct work_struct work_join;
 	struct work_struct work_mgmt_timeout;
 	struct work_struct work_new_bss;




From proski at gnu.org  Sat Jun  2 20:00:29 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:29 -0400
Subject: [at76c503a-develop] [PATCH 06/11] Don't ignore errors during
	firmware download
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070602180029.28397.74022.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   17 ++++++++++++-----
 1 files changed, 12 insertions(+), 5 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index c4e99be..14baefc 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -4264,7 +4264,7 @@ static int at76_init_new_device(struct at76_priv *priv)
 
 
 /* Download external firmware */
-static void at76_load_external_fw(struct at76_priv *priv)
+static int at76_load_external_fw(struct at76_priv *priv)
 {
 	int ret;
 	int op_mode;
@@ -4276,6 +4276,7 @@ static void at76_load_external_fw(struct at76_priv *priv)
 
 	if (op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {
 		err("unexpected opmode %d", op_mode);
+		ret = -EINVAL;
 		goto end_external_fw;
 	}
 
@@ -4297,15 +4298,16 @@ static void at76_load_external_fw(struct at76_priv *priv)
 	mutex_unlock(&priv->mtx);
 	if ((ret = at76_init_new_device(priv)) < 0)
 		err("Downloading external firmware failed: %d", ret);
-	return;
+	return ret;
 
   end_external_fw:
 	mutex_unlock(&priv->mtx);
+	return ret;
 }
 
 
 /* Download internal firmware */
-static void at76_load_internal_fw(struct at76_priv *priv)
+static int at76_load_internal_fw(struct at76_priv *priv)
 {
 	int ret;
 
@@ -4336,6 +4338,7 @@ static void at76_load_internal_fw(struct at76_priv *priv)
 
   end_internal_fw:
 	mutex_unlock(&priv->mtx);
+	return ret;
 }
 
 
@@ -6279,7 +6282,9 @@ static int at76_probe(struct usb_interface *interface,
 		/* download internal firmware part */
 		at76_dbg(DBG_DEVSTART, "downloading internal firmware");
 		priv->istate = INTFW_DOWNLOAD;
-		at76_load_internal_fw(priv);
+		ret = at76_load_internal_fw(priv);
+		if (ret)
+			goto error;
 	} else {
 		/* Internal firmware already inside the device.  Get firmware
 		 * version to test if external firmware is loaded.
@@ -6314,7 +6319,9 @@ static int at76_probe(struct usb_interface *interface,
 					 "- download external firmware", ret);
 
 			priv->istate = EXTFW_DOWNLOAD;
-			at76_load_external_fw(priv);
+			ret = at76_load_external_fw(priv);
+			if (ret)
+				goto error;
 		} else {
 			priv->istate = INIT;
 			if ((ret = at76_init_new_device(priv)) < 0)




From proski at gnu.org  Sat Jun  2 20:00:34 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:34 -0400
Subject: [at76c503a-develop] [PATCH 07/11] Internal firmware download should
	just sleep without	any timers
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070602180034.28397.68595.stgit@dv.roinet.com>

Timers are justified if they are scheduled in the interrupt context or
if they are modified.  Neither is the case.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   29 +++--------------------------
 at76_usb.h |    4 ----
 2 files changed, 3 insertions(+), 30 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 14baefc..e31a734 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1994,14 +1994,6 @@ static int at76_disassoc_req(struct at76_priv *priv, struct bss_info *bss)
 }
 
 
-/* the firmware download timeout (after remap) */
-static void at76_fw_dl_timeout(unsigned long par)
-{
-	struct at76_priv *priv = (struct at76_priv *)par;
-	schedule_work(&priv->work_reset_device);
-}
-
-
 /* the restart timer timed out */
 static void at76_restart_timeout(unsigned long par)
 {
@@ -4334,7 +4326,9 @@ static int at76_load_internal_fw(struct at76_priv *priv)
 
 	at76_dbg(DBG_DEVSTART, "sleeping for 2 seconds");
 	priv->istate = EXTFW_DOWNLOAD;
-	mod_timer(&priv->fw_dl_timer, jiffies + 2 * HZ + 1);
+	schedule_timeout_interruptible(2 * HZ + 1);
+	usb_reset_device(priv->udev);
+	priv->istate = WAIT_FOR_DISCONNECT;
 
   end_internal_fw:
 	mutex_unlock(&priv->mtx);
@@ -4599,18 +4593,6 @@ static void at76_work_new_bss(struct work_struct *work)
 }
 
 
-static void at76_work_reset_device(struct work_struct *work)
-{
-	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_reset_device);
-
-	mutex_lock(&priv->mtx);
-	usb_reset_device(priv->udev);
-	priv->istate = WAIT_FOR_DISCONNECT;
-	mutex_unlock(&priv->mtx);
-}
-
-
 static int at76_startup_device(struct at76_priv *priv)
 {
 	struct at76_card_config *ccfg = &priv->card_config;
@@ -6129,7 +6111,6 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 	INIT_WORK(&priv->work_join, at76_work_join);
 	INIT_WORK(&priv->work_mgmt_timeout, at76_work_mgmt_timeout);
 	INIT_WORK(&priv->work_new_bss, at76_work_new_bss);
-	INIT_WORK(&priv->work_reset_device, at76_work_reset_device);
 	INIT_WORK(&priv->work_restart, at76_work_restart);
 	INIT_WORK(&priv->work_scan, at76_work_scan);
 	INIT_WORK(&priv->work_set_promisc, at76_work_set_promisc);
@@ -6146,10 +6127,6 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 	priv->mgmt_timer.data = (unsigned long)priv;
 	priv->mgmt_timer.function = at76_mgmt_timeout;
 
-	init_timer(&priv->fw_dl_timer);
-	priv->fw_dl_timer.data = (unsigned long)priv;
-	priv->fw_dl_timer.function = at76_fw_dl_timeout;
-
 	spin_lock_init(&priv->mgmt_spinlock);
 	priv->next_mgmt_bulk = NULL;
 	priv->istate = INTFW_DOWNLOAD;
diff --git a/at76_usb.h b/at76_usb.h
index 474049c..7fd61f5 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -473,7 +473,6 @@ struct at76_priv {
 	struct work_struct work_join;
 	struct work_struct work_mgmt_timeout;
 	struct work_struct work_new_bss;
-	struct work_struct work_reset_device;
 	struct work_struct work_restart;
 	struct work_struct work_scan;
 	struct work_struct work_set_promisc;
@@ -576,9 +575,6 @@ struct at76_priv {
 	/* store rx fragments until complete */
 	struct rx_data_buf rx_data[NR_RX_DATA_BUF];
 
-	/* firmware downloading stuff */
-	struct timer_list fw_dl_timer;	/* timer used to wait after REMAP
-					   until device is reset */
 	int extfw_size;
 	int intfw_size;
 	/* these point into a buffer managed by the firmware dl functions, no need to dealloc */




From proski at gnu.org  Sat Jun  2 20:00:39 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:39 -0400
Subject: [at76c503a-develop] [PATCH 08/11] Delete all timers on disconnect
	to be safe
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070602180039.28397.98471.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index e31a734..fc5e81a 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -2365,6 +2365,8 @@ static void at76_delete_device(struct at76_priv *priv)
 
 	at76_free_bss_list(priv);
 	del_timer_sync(&priv->bss_list_timer);
+	del_timer_sync(&priv->mgmt_timer);
+	del_timer_sync(&priv->restart_timer);
 
 	if (priv->istate == CONNECTED) {
 		at76_iwevent_bss_disconnect(priv->netdev);




From proski at gnu.org  Sat Jun  2 20:00:44 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:44 -0400
Subject: [at76c503a-develop] [PATCH 09/11] Use
	schedule_timeout_interruptible()
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070602180044.28397.41490.stgit@dv.roinet.com>

It's more readable than using two statements.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   12 ++++--------
 1 files changed, 4 insertions(+), 8 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index fc5e81a..6d7bb45 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -376,8 +376,7 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 			need_dfu_state = 1;
 
 			at76_dbg(DBG_DFU, "DFU: Resetting device");
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(msecs_to_jiffies(dfu_timeout));
+			schedule_timeout_interruptible(msecs_to_jiffies(dfu_timeout));
 			break;
 
 		case STATE_DFU_DOWNLOAD_IDLE:
@@ -421,8 +420,7 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 					dfu_timeout = manifest_sync_timeout;
 
 				at76_dbg(DBG_DFU, "DFU: Waiting for manifest phase");
-				set_current_state(TASK_INTERRUPTIBLE);
-				schedule_timeout(msecs_to_jiffies(dfu_timeout));
+				schedule_timeout_interruptible(msecs_to_jiffies(dfu_timeout));
 			}
 			break;
 
@@ -870,8 +868,7 @@ static int at76_wait_completion(struct at76_priv *priv, int cmd)
 
 		if (status == CMD_STATUS_IN_PROGRESS ||
 		    status == CMD_STATUS_IDLE) {
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(HZ / 10);	/* 100 ms */
+			schedule_timeout_interruptible(HZ / 10);	/* 100 ms */
 		} else
 			break;
 	} while (1);
@@ -4284,8 +4281,7 @@ static int at76_load_external_fw(struct at76_priv *priv)
 		if (priv->board_type == BOARDTYPE_505A_RFMD_2958) {
 			info("200 ms delay for board type 7");
 			/* can we do this with priv->mtx down? */
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(HZ / 5 + 1);
+			schedule_timeout_interruptible(HZ / 5 + 1);
 		}
 	}
 	priv->istate = INIT;




From proski at gnu.org  Sat Jun  2 20:00:49 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:49 -0400
Subject: [at76c503a-develop] [PATCH 10/11] at76_delete_device() already
	calls usb_put_dev(), don't do it again
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070602180049.28397.53772.stgit@dv.roinet.com>

Now the driver doesn't crash the kernel if the firmware is present but
invalid.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 6d7bb45..d1050e0 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -6307,6 +6307,8 @@ static int at76_probe(struct usb_interface *interface,
 
       error:
 	at76_delete_device(priv);
+	return ret;
+
       error_alloc:
 	usb_put_dev(udev);
 	return ret;




From proski at gnu.org  Sat Jun  2 20:00:54 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 02 Jun 2007 14:00:54 -0400
Subject: [at76c503a-develop] [PATCH 11/11] Failure in init shouldn't call
	at76_delete_device(), it's done later
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070602180054.28397.74547.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    2 --
 1 files changed, 0 insertions(+), 2 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index d1050e0..607c947 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -4247,9 +4247,7 @@ static int at76_init_new_device(struct at76_priv *priv)
 	/* we let this timer run the whole time this driver instance lives */
 	mod_timer(&priv->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
 
-	return 0;
  error:
-	at76_delete_device(priv);
 	return ret;
 }
 




From agx at sigxcpu.org  Sun Jun  3 18:41:08 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Sun, 3 Jun 2007 18:41:08 +0200
Subject: [at76c503a-develop] [PATCH 01/11] Rename tasklet to rx_tasklet,
	the former is too generic
In-Reply-To: <20070602180003.28397.98594.stgit@dv.roinet.com>
References: <20070602180003.28397.98594.stgit@dv.roinet.com>
Message-ID: <20070603164107.GA4025@bogon.ms20.nix>

Hi Pavel,
On Sat, Jun 02, 2007 at 02:00:03PM -0400, Pavel Roskin wrote:
> Signed-off-by: Pavel Roskin <proski at gnu.org>
I've applied and pushed out the whole series. Thanks!
 -- Guido


From proski at gnu.org  Tue Jun  5 03:03:47 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 21:03:47 -0400
Subject: [at76c503a-develop] [PATCH 01/10] Merge at76_handle_mgmt_timeout()
	and	at76_work_mgmt_timeout()
Message-ID: <20070605010347.32602.23942.stgit@dv.roinet.com>

The later was just a trivial wrapper.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  200 +++++++++++++++++++++++++++++-------------------------------
 1 files changed, 97 insertions(+), 103 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 607c947..8a13e1e 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -2169,108 +2169,6 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 }
 
 
-/* the deferred procedure called from at76_devent() */
-static void at76_handle_mgmt_timeout(struct at76_priv *priv)
-{
-	if ((priv->istate != SCANNING && priv->istate != MONITORING) ||
-	    (at76_debug & DBG_MGMT_TIMER))
-		/* this is normal behavior in states MONITORING, SCANNING ... */
-		at76_dbg(DBG_PROGRESS, "%s: timeout, state %d", priv->netdev->name,
-		         priv->istate);
-
-	switch (priv->istate) {
-
-	case MONITORING:
-	case SCANNING:
-		at76_handle_mgmt_timeout_scan(priv);
-		break;
-
-	case JOINING:
-		at76_assert(0);
-		break;
-
-	case CONNECTED:	/* we haven't received the beacon of this BSS for
-				   BEACON_TIMEOUT seconds */
-		info("%s: lost beacon bssid %s",
-		     priv->netdev->name, mac2str(priv->curr_bss->bssid));
-		/* jal: starting mgmt_timer in ad-hoc mode is questionable,
-		   but I'll leave it here to track down another lockup problem */
-		if (priv->iw_mode != IW_MODE_ADHOC) {
-			netif_carrier_off(priv->netdev);
-			netif_stop_queue(priv->netdev);
-			at76_iwevent_bss_disconnect(priv->netdev);
-			priv->istate = SCANNING;
-			schedule_work(&priv->work_scan);
-		}
-		break;
-
-	case AUTHENTICATING:
-		if (priv->retries-- >= 0) {
-			at76_auth_req(priv, priv->curr_bss, 1, NULL);
-			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-			         __FUNCTION__, __LINE__);
-			mod_timer(&priv->mgmt_timer, jiffies + HZ);
-		} else {
-			/* try to get next matching BSS */
-			priv->istate = JOINING;
-			schedule_work(&priv->work_join);
-		}
-		break;
-
-	case ASSOCIATING:
-		if (priv->retries-- >= 0) {
-			at76_assoc_req(priv, priv->curr_bss);
-			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-			         __FUNCTION__, __LINE__);
-			mod_timer(&priv->mgmt_timer, jiffies + HZ);
-		} else {
-			/* jal: TODO: we may be authenticated to several
-			   BSS and may try to associate to the next of them here
-			   in the future ... */
-
-			/* try to get next matching BSS */
-			priv->istate = JOINING;
-			schedule_work(&priv->work_join);
-		}
-		break;
-
-	case REASSOCIATING:
-		if (priv->retries-- >= 0)
-			at76_reassoc_req(priv, priv->curr_bss, priv->new_bss);
-		else {
-			/* we disassociate from the curr_bss and
-			   scan again ... */
-			priv->istate = DISASSOCIATING;
-			priv->retries = DISASSOC_RETRIES;
-			at76_disassoc_req(priv, priv->curr_bss);
-		}
-		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-		         __FUNCTION__, __LINE__);
-		mod_timer(&priv->mgmt_timer, jiffies + HZ);
-		break;
-
-	case DISASSOCIATING:
-		if (priv->retries-- >= 0) {
-			at76_disassoc_req(priv, priv->curr_bss);
-			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-		     	         __FUNCTION__, __LINE__);
-			mod_timer(&priv->mgmt_timer, jiffies + HZ);
-		} else {
-			/* we scan again ... */
-			priv->istate = SCANNING;
-			schedule_work(&priv->work_scan);
-		}
-		break;
-
-	case INIT:
-		break;
-
-	default:
-		at76_assert(0);
-	}
-}
-
-
 /* Called after successful association */
 static void at76_work_assoc_done(struct work_struct *work)
 {
@@ -4542,13 +4440,109 @@ static void at76_work_join(struct work_struct *work)
 }
 
 
+/* Process scheduled events */
 static void at76_work_mgmt_timeout(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_mgmt_timeout);
 
 	mutex_lock(&priv->mtx);
-	at76_handle_mgmt_timeout(priv);
+	if ((priv->istate != SCANNING && priv->istate != MONITORING) ||
+	    (at76_debug & DBG_MGMT_TIMER))
+		/* this is normal behavior in states MONITORING, SCANNING ... */
+		at76_dbg(DBG_PROGRESS, "%s: timeout, state %d", priv->netdev->name,
+		         priv->istate);
+
+	switch (priv->istate) {
+
+	case MONITORING:
+	case SCANNING:
+		at76_handle_mgmt_timeout_scan(priv);
+		break;
+
+	case JOINING:
+		at76_assert(0);
+		break;
+
+	case CONNECTED:	/* we haven't received the beacon of this BSS for
+				   BEACON_TIMEOUT seconds */
+		info("%s: lost beacon bssid %s",
+		     priv->netdev->name, mac2str(priv->curr_bss->bssid));
+		/* jal: starting mgmt_timer in ad-hoc mode is questionable,
+		   but I'll leave it here to track down another lockup problem */
+		if (priv->iw_mode != IW_MODE_ADHOC) {
+			netif_carrier_off(priv->netdev);
+			netif_stop_queue(priv->netdev);
+			at76_iwevent_bss_disconnect(priv->netdev);
+			priv->istate = SCANNING;
+			schedule_work(&priv->work_scan);
+		}
+		break;
+
+	case AUTHENTICATING:
+		if (priv->retries-- >= 0) {
+			at76_auth_req(priv, priv->curr_bss, 1, NULL);
+			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
+			         __FUNCTION__, __LINE__);
+			mod_timer(&priv->mgmt_timer, jiffies + HZ);
+		} else {
+			/* try to get next matching BSS */
+			priv->istate = JOINING;
+			schedule_work(&priv->work_join);
+		}
+		break;
+
+	case ASSOCIATING:
+		if (priv->retries-- >= 0) {
+			at76_assoc_req(priv, priv->curr_bss);
+			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
+			         __FUNCTION__, __LINE__);
+			mod_timer(&priv->mgmt_timer, jiffies + HZ);
+		} else {
+			/* jal: TODO: we may be authenticated to several
+			   BSS and may try to associate to the next of them here
+			   in the future ... */
+
+			/* try to get next matching BSS */
+			priv->istate = JOINING;
+			schedule_work(&priv->work_join);
+		}
+		break;
+
+	case REASSOCIATING:
+		if (priv->retries-- >= 0)
+			at76_reassoc_req(priv, priv->curr_bss, priv->new_bss);
+		else {
+			/* we disassociate from the curr_bss and
+			   scan again ... */
+			priv->istate = DISASSOCIATING;
+			priv->retries = DISASSOC_RETRIES;
+			at76_disassoc_req(priv, priv->curr_bss);
+		}
+		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
+		         __FUNCTION__, __LINE__);
+		mod_timer(&priv->mgmt_timer, jiffies + HZ);
+		break;
+
+	case DISASSOCIATING:
+		if (priv->retries-- >= 0) {
+			at76_disassoc_req(priv, priv->curr_bss);
+			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
+		     	         __FUNCTION__, __LINE__);
+			mod_timer(&priv->mgmt_timer, jiffies + HZ);
+		} else {
+			/* we scan again ... */
+			priv->istate = SCANNING;
+			schedule_work(&priv->work_scan);
+		}
+		break;
+
+	case INIT:
+		break;
+
+	default:
+		at76_assert(0);
+	}
 	mutex_unlock(&priv->mtx);
 }
 




From proski at gnu.org  Tue Jun  5 03:03:57 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 21:03:57 -0400
Subject: [at76c503a-develop] [PATCH 03/10] Don't document endianess in
	comments, it's documented by the type
In-Reply-To: <20070605010347.32602.23942.stgit@dv.roinet.com>
References: <20070605010347.32602.23942.stgit@dv.roinet.com>
Message-ID: <20070605010357.32602.47296.stgit@dv.roinet.com>

While at that, improve the affected comments.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.h |    6 ++----
 1 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/at76_usb.h b/at76_usb.h
index 428a562..7b7db30 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -418,10 +418,8 @@ struct bss_info {
 					   to make it printable */
 	u8 ssid_len;		/* length of ssid above */
 	u8 channel;
-	u16 capa;		/* the capabilities of the BSS (in original endianess -
-				   we only check IEEE802_11 bits in it) */
-	u16 beacon_interval;	/* the beacon interval in units of TU (1.024 ms)
-				   (in CPU endianess - we must calc. values from it) */
+	u16 capa;		/* BSS capabilities */
+	u16 beacon_interval;	/* beacon interval in Kus (1024 microseconds) */
 	u8 rates[BSS_LIST_MAX_RATE_LEN];	/* supported rates (list of bytes: 
 						   (basic_rate ? 0x80 : 0) + rate/(500 Kbit/s); e.g. 
 						   x82,x84,x8b,x96 for basic rates 1,2,5.5,11 MBit/s) */




From proski at gnu.org  Tue Jun  5 03:03:52 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 21:03:52 -0400
Subject: [at76c503a-develop] [PATCH 02/10] Rename request structures to make
	them distinct from	functions
In-Reply-To: <20070605010347.32602.23942.stgit@dv.roinet.com>
References: <20070605010347.32602.23942.stgit@dv.roinet.com>
Message-ID: <20070605010352.32602.88687.stgit@dv.roinet.com>

at76_start_scan was both a function and a structure.  Use "req" in the
structure names to indicate that they are requests.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   16 ++++++++--------
 at76_usb.h |    6 +++---
 2 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 8a13e1e..758a2b8 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1476,9 +1476,9 @@ static int at76_get_current_channel(struct at76_priv *priv)
  */
 static int at76_start_scan(struct at76_priv *priv, int use_essid, int ir_step)
 {
-	struct at76_start_scan scan;
+	struct at76_req_scan scan;
 
-	memset(&scan, 0, sizeof(struct at76_start_scan));
+	memset(&scan, 0, sizeof(struct at76_req_scan));
 	memset(scan.bssid, 0xff, ETH_ALEN);
 
 	if (use_essid) {
@@ -1533,9 +1533,9 @@ static int at76_start_scan(struct at76_priv *priv, int use_essid, int ir_step)
 
 static int at76_start_ibss(struct at76_priv *priv)
 {
-	struct at76_start_bss bss;
+	struct at76_req_ibss bss;
 
-	memset(&bss, 0, sizeof(struct at76_start_bss));
+	memset(&bss, 0, sizeof(struct at76_req_ibss));
 	memset(bss.bssid, 0xff, ETH_ALEN);
 	memcpy(bss.essid, priv->essid, IW_ESSID_MAX_SIZE);
 	bss.essid_size = priv->essid_size;
@@ -1543,18 +1543,18 @@ static int at76_start_ibss(struct at76_priv *priv)
 	bss.channel = priv->channel;
 
 	return at76_set_card_command(priv->udev, CMD_START_IBSS, &bss,
-				     sizeof(struct at76_start_bss));
+				     sizeof(struct at76_req_ibss));
 }
 
 
 /* idx points into priv->bss */
 static int at76_join_bss(struct at76_priv *priv, struct bss_info *ptr)
 {
-	struct at76_join join;
+	struct at76_req_join join;
 
 	at76_assert(ptr != NULL);
 
-	memset(&join, 0, sizeof(struct at76_join));
+	memset(&join, 0, sizeof(struct at76_req_join));
 	memcpy(join.bssid, ptr->bssid, ETH_ALEN);
 	memcpy(join.essid, ptr->ssid, ptr->ssid_len);
 	join.essid_size = ptr->ssid_len;
@@ -1566,7 +1566,7 @@ static int at76_join_bss(struct at76_priv *priv, struct bss_info *ptr)
 	         priv->netdev->name, mac2str(join.bssid),
 	         join.essid, join.bss_type, join.channel, le16_to_cpu(join.timeout));
 	return at76_set_card_command(priv->udev, CMD_JOIN, &join,
-				     sizeof(struct at76_join));
+				     sizeof(struct at76_req_join));
 }
 
 
diff --git a/at76_usb.h b/at76_usb.h
index 7fd61f5..428a562 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -222,7 +222,7 @@ struct at76_tx_buffer {
 #define SCAN_TYPE_ACTIVE  0
 #define SCAN_TYPE_PASSIVE 1
 
-struct at76_start_scan {
+struct at76_req_scan {
 	u8 bssid[ETH_ALEN];
 	u8 essid[32];
 	u8 scan_type;
@@ -234,7 +234,7 @@ struct at76_start_scan {
 	u8 international_scan;
 } __attribute__ ((packed));
 
-struct at76_start_bss {
+struct at76_req_ibss {
 	u8 bssid[ETH_ALEN];
 	u8 essid[32];
 	u8 bss_type;
@@ -243,7 +243,7 @@ struct at76_start_bss {
 	u8 reserved[3];
 } __attribute__ ((packed));
 
-struct at76_join {
+struct at76_req_join {
 	u8 bssid[ETH_ALEN];
 	u8 essid[32];
 	u8 bss_type;




From proski at gnu.org  Tue Jun  5 03:04:07 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 21:04:07 -0400
Subject: [at76c503a-develop] [PATCH 05/10] Call at76_set_monitor_mode() from
	at76_startup_device()
In-Reply-To: <20070605010347.32602.23942.stgit@dv.roinet.com>
References: <20070605010347.32602.23942.stgit@dv.roinet.com>
Message-ID: <20070605010407.32602.12501.stgit@dv.roinet.com>

at76_set_monitor_mode() is always called after at76_startup_device(),
and other at76_set functions are called from at76_startup_device()
directly.  Move at76_set_monitor_mode() closer to the other at76_set
functions.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   37 ++++++++++++++++++-------------------
 1 files changed, 18 insertions(+), 19 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index cf684ac..ab062d8 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1061,6 +1061,21 @@ static int at76_set_autorate_fallback(struct at76_priv *priv, int onoff)
 }
 
 
+/* set network device type for the current mode */
+static void at76_set_monitor_mode(struct at76_priv *priv)
+{
+	if (priv->iw_mode == IW_MODE_MONITOR) {
+		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE ON",
+			 priv->netdev->name);
+		priv->netdev->type = ARPHRD_IEEE80211_RADIOTAP;
+	} else {
+		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE OFF",
+		         priv->netdev->name);
+		priv->netdev->type = ARPHRD_ETHER;
+	}
+}
+
+
 static int at76_add_mac_address(struct at76_priv *priv, void *addr)
 {
 	int ret = 0;
@@ -4672,6 +4687,8 @@ static int at76_startup_device(struct at76_priv *priv)
 	if ((ret = at76_set_iroaming(priv, priv->international_roaming)) < 0)
 		return ret;
 
+	at76_set_monitor_mode(priv);
+
 	if (at76_debug & DBG_MIB) {
 		at76_dump_mib_mac(priv);
 		at76_dump_mib_mac_addr(priv);
@@ -4686,23 +4703,6 @@ static int at76_startup_device(struct at76_priv *priv)
 }
 
 
-/**
- * set_monitor_mode - sets priv->netdev->type
- */
-static void at76_set_monitor_mode(struct at76_priv *priv)
-{
-	if (priv->iw_mode == IW_MODE_MONITOR) {
-		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE ON",
-			 priv->netdev->name);
-		priv->netdev->type = ARPHRD_IEEE80211_RADIOTAP;
-	} else {
-		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE OFF",
-		         priv->netdev->name);
-		priv->netdev->type = ARPHRD_ETHER;
-	}
-}
-
-
 static void at76_work_restart(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
@@ -4711,10 +4711,9 @@ static void at76_work_restart(struct work_struct *work)
 	mutex_lock(&priv->mtx);
 
 	at76_startup_device(priv);
-	at76_set_monitor_mode(priv);
-
 	netif_carrier_off(priv->netdev);	/* disable running netdev watchdog */
 	netif_stop_queue(priv->netdev);	/* stop tx data packets */
+
 	if (priv->iw_mode != IW_MODE_MONITOR) {
 		priv->istate = SCANNING;
 		schedule_work(&priv->work_scan);




From proski at gnu.org  Tue Jun  5 03:04:02 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 21:04:02 -0400
Subject: [at76c503a-develop] [PATCH 04/10] Remove support for channel
	scanning in monitor mode
In-Reply-To: <20070605010347.32602.23942.stgit@dv.roinet.com>
References: <20070605010347.32602.23942.stgit@dv.roinet.com>
Message-ID: <20070605010402.32602.29781.stgit@dv.roinet.com>

This should be implemented by the userspace.  No other Linux driver does
that.  The expected behavior is that the driver stays on the same
channel while in monitor mode.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   43 ++++++++-----------------------------------
 at76_usb.h |    3 ---
 2 files changed, 8 insertions(+), 38 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 758a2b8..cf684ac 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -183,8 +183,6 @@ static int preamble_type = PREAMBLE_TYPE_LONG;
 static int auth_mode;
 static int international_roaming; /* = IR_OFF */
 static int default_iw_mode = IW_MODE_INFRA;
-static int monitor_scan_min_time = 50;
-static int monitor_scan_max_time = 600;
 
 /* the supported rates of this hardware, bit7 marks a basic rate */
 static const u8 hw_rates[] = { 0x82, 0x84, 0x0b, 0x16 };
@@ -1502,11 +1500,7 @@ static int at76_start_scan(struct at76_priv *priv, int use_essid, int ir_step)
 	/* INFO: For probe_delay, not multiplying by 1024 as this will be
 	   slightly less than min_channel_time
 	   (per spec: probe delay < min. channel time) */
-	if (priv->istate == MONITORING) {
-		scan.min_channel_time = cpu_to_le16(priv->monitor_scan_min_time);
-		scan.max_channel_time = cpu_to_le16(priv->monitor_scan_max_time);
-		scan.probe_delay = cpu_to_le16(priv->monitor_scan_min_time * 1000);
-	} else {
+	if (priv->istate != MONITORING) {
 		scan.min_channel_time = cpu_to_le16(priv->scan_min_time);
 		scan.max_channel_time = cpu_to_le16(priv->scan_max_time);
 		scan.probe_delay = cpu_to_le16(priv->scan_min_time * 1000);
@@ -2811,20 +2805,11 @@ static int at76_iw_handler_set_scan(struct net_device *netdev,
 			priv->scan_mode = SCAN_TYPE_ACTIVE;
 
 		/* Sanity check values? */
-		if (req->min_channel_time > 0) {
-			if (priv->istate == MONITORING)
-				priv->monitor_scan_min_time =
-				    req->min_channel_time;
-			else
-				priv->scan_min_time = req->min_channel_time;
-		}
-		if (req->max_channel_time > 0) {
-			if (priv->istate == MONITORING)
-				priv->monitor_scan_max_time =
-				    req->max_channel_time;
-			else
-				priv->scan_max_time = req->max_channel_time;
-		}
+		if (req->min_channel_time > 0)
+			priv->scan_min_time = req->min_channel_time;
+
+		if (req->max_channel_time > 0)
+			priv->scan_max_time = req->max_channel_time;
 	}
 
 	/* change to scanning state */
@@ -3476,14 +3461,8 @@ static int at76_iw_set_scan_times(struct net_device *netdev,
 	if (mint <= 0 || maxt <= 0 || mint > maxt) {
 		ret = -EINVAL;
 	} else {
-		if (priv->istate == MONITORING) {
-			priv->monitor_scan_min_time = mint;
-			priv->monitor_scan_max_time = maxt;
-			ret = 0;
-		} else {
-			priv->scan_min_time = mint;
-			priv->scan_max_time = maxt;
-		}
+		priv->scan_min_time = mint;
+		priv->scan_max_time = maxt;
 	}
 
 	return ret;
@@ -4113,8 +4092,6 @@ static int at76_init_new_device(struct at76_priv *priv)
 	priv->scan_min_time = scan_min_time;
 	priv->scan_max_time = scan_max_time;
 	priv->scan_mode = scan_mode;
-	priv->monitor_scan_min_time = monitor_scan_min_time;
-	priv->monitor_scan_max_time = monitor_scan_max_time;
 
 	netdev->flags &= ~IFF_MULTICAST; /* not yet or never */
 	netdev->open = at76_open;
@@ -6378,10 +6355,6 @@ module_param(international_roaming, int, 0400);
 MODULE_PARM_DESC(international_roaming, "enable international roaming: 0 (no, default), 1 (yes)");
 module_param(default_iw_mode, int, 0400);
 MODULE_PARM_DESC(default_iw_mode, "default IW mode for a new device: 1 (ad-hoc), 2 (infrastructure, def.), 6 (monitor mode)");
-module_param(monitor_scan_min_time, int, 0400);
-MODULE_PARM_DESC(monitor_scan_min_time, "scan min channel time in MONITOR MODE (default: 50)");
-module_param(monitor_scan_max_time, int, 0400);
-MODULE_PARM_DESC(monitor_scan_max_time, "scan max channel time in MONITOR MODE (default: 600)");
 
 module_init(at76_mod_init);
 module_exit(at76_mod_exit);
diff --git a/at76_usb.h b/at76_usb.h
index 7b7db30..a97c042 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -584,9 +584,6 @@ struct at76_priv {
 	struct set_mib_buffer mib_buf;	/* global buffer for set_mib calls */
 
 	/* beacon counting */
-	int monitor_scan_min_time;
-	int monitor_scan_max_time;
-
 	int beacon_period;	/* period of mgmt beacons */
 	int beacons_received;
 	unsigned long beacons_last_qual;	/* last time we reset beacons_received = 0 */




From proski at gnu.org  Tue Jun  5 03:04:13 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 21:04:13 -0400
Subject: [at76c503a-develop] [PATCH 06/10] Run at76_usb.h through Lindent
In-Reply-To: <20070605010347.32602.23942.stgit@dv.roinet.com>
References: <20070605010347.32602.23942.stgit@dv.roinet.com>
Message-ID: <20070605010412.32602.4954.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.h |   25 ++++++++++++-------------
 1 files changed, 12 insertions(+), 13 deletions(-)

diff --git a/at76_usb.h b/at76_usb.h
index a97c042..6169866 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -106,7 +106,6 @@
 #define IR_OFF        0
 #define IR_ON         1
 
-
 /* offsets into the MIBs we use to configure the device */
 #define TX_AUTORATE_FALLBACK_OFFSET offsetof(struct mib_local,txautorate_fallback)
 #define FRAGMENTATION_OFFSET        offsetof(struct mib_mac,frag_threshold)
@@ -365,17 +364,17 @@ struct mib_mdomain {
 } __attribute__ ((packed));
 
 struct at76_fw_header {
-	__le32 crc;			/* CRC32 of the whole image */
-	__le32 board_type;		/* firmware compatibility code */
-	u8 build;			/* firmware build number */
-	u8 patch;			/* firmware patch level */
-	u8 minor;			/* firmware minor version */
-	u8 major;			/* firmware major version */
-	__le32 str_offset;		/* offset of the copyright string */
-	__le32 int_fw_offset;		/* internal firmware image offset */
-	__le32 int_fw_len;		/* internal firmware image length */
-	__le32 ext_fw_offset;		/* external firmware image offset */
-	__le32 ext_fw_len;		/* external firmware image length */
+	__le32 crc;		/* CRC32 of the whole image */
+	__le32 board_type;	/* firmware compatibility code */
+	u8 build;		/* firmware build number */
+	u8 patch;		/* firmware patch level */
+	u8 minor;		/* firmware minor version */
+	u8 major;		/* firmware major version */
+	__le32 str_offset;	/* offset of the copyright string */
+	__le32 int_fw_offset;	/* internal firmware image offset */
+	__le32 int_fw_len;	/* internal firmware image length */
+	__le32 ext_fw_offset;	/* external firmware image offset */
+	__le32 ext_fw_len;	/* external firmware image length */
 } __attribute__ ((packed));
 
 /* states in infrastructure mode */
@@ -533,7 +532,7 @@ struct at76_priv {
 					   next_mgmt_bulk */
 
 	struct at76_tx_buffer *next_mgmt_bulk;	/* pending management msg to
-							   send via bulk out */
+						   send via bulk out */
 	enum infra_state istate;
 	enum {
 		SCAN_IDLE,




From proski at gnu.org  Tue Jun  5 03:04:18 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 21:04:18 -0400
Subject: [at76c503a-develop] [PATCH 07/10] Run unexpand on at76_usb.c to
	convert spaces to tabs	when possible
In-Reply-To: <20070605010347.32602.23942.stgit@dv.roinet.com>
References: <20070605010347.32602.23942.stgit@dv.roinet.com>
Message-ID: <20070605010418.32602.66833.stgit@dv.roinet.com>

Manually adjust some comments, remove excessive newlines inside
functions.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  531 ++++++++++++++++++++++++++++++------------------------------
 1 files changed, 264 insertions(+), 267 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index ab062d8..fc9b774 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -51,12 +51,12 @@ static struct fwentry {
 	const char *const fwname;
 	const struct firmware *fw;
 } firmwares[] = {
-	[0]                           = { "" },
+	[0]			      = { "" },
 	[BOARDTYPE_503_INTERSIL_3861] = { "atmel_at76c503-i3861.bin" },
 	[BOARDTYPE_503_INTERSIL_3863] = { "atmel_at76c503-i3863.bin" },
-	[BOARDTYPE_503_RFMD]          = { "atmel_at76c503-rfmd.bin" },
+	[BOARDTYPE_503_RFMD]	      = { "atmel_at76c503-rfmd.bin" },
 	[BOARDTYPE_503_RFMD_ACC]      = { "atmel_at76c503-rfmd-acc.bin" },
-	[BOARDTYPE_505_RFMD]          = { "atmel_at76c505-rfmd.bin" },
+	[BOARDTYPE_505_RFMD]	      = { "atmel_at76c505-rfmd.bin" },
 	[BOARDTYPE_505_RFMD_2958]     = { "atmel_at76c505-rfmd2958.bin" },
 	[BOARDTYPE_505A_RFMD_2958]    = { "atmel_at76c505a-rfmd2958.bin" },
 	[BOARDTYPE_505AMX_RFMD]       = { "atmel_at76c505amx-rfmd.bin" },
@@ -195,7 +195,7 @@ static const long channel_frequency[] = {
 
 /* Firmware download */
 /* DFU states */
-#define STATE_IDLE  			0x00
+#define STATE_IDLE			0x00
 #define STATE_DETACH			0x01
 #define STATE_DFU_IDLE			0x02
 #define STATE_DFU_DOWNLOAD_SYNC		0x03
@@ -243,7 +243,7 @@ static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
 	struct usb_device *udev = ctx->udev;
 
 	at76_dbg(DBG_DFU, "dfu_download_block(): buffer=%p, bytes=%d, block=%d",
-	         buffer, bytes, block);
+		 buffer, bytes, block);
 
 	if (tmpbuf == NULL)
 		return -ENOMEM;
@@ -320,7 +320,7 @@ static struct dfu_ctx *at76_dfu_alloc_ctx(struct usb_device *udev)
 /* if manifest_sync_timeout > 0 use this timeout (in msec) instead of the
    one reported by the device in state MANIFEST_SYNC */
 static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
-			        u32 dfu_len, int manifest_sync_timeout)
+				u32 dfu_len, int manifest_sync_timeout)
 {
 	struct dfu_ctx *ctx;
 	struct dfu_status *dfu_stat_buf;
@@ -333,7 +333,7 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 	int dfu_block_cnt = 0;
 
 	at76_dbg(DBG_DFU, "%s( %p, %u, %d)", __FUNCTION__, dfu_buffer,
-	         dfu_len, manifest_sync_timeout);
+		 dfu_len, manifest_sync_timeout);
 
 	if (dfu_len == 0) {
 		err("FW Buffer length invalid!");
@@ -776,8 +776,8 @@ static int at76_download_external_fw(struct usb_device *udev, u8 *buf, int size)
 
 		memcpy(block, buf, bsize);
 		at76_dbg(DBG_DEVSTART,
-		         "ext fw, size left = %5d, bsize = %4d, i = %2d",
-		         size, bsize, i);
+			 "ext fw, size left = %5d, bsize = %4d, i = %2d",
+			 size, bsize, i);
 		if ((ret = at76_load_ext_fw_block(udev, i, block, bsize)) < 0) {
 			err("loading %dth firmware block failed: %d", i, ret);
 			goto exit;
@@ -860,9 +860,9 @@ static int at76_wait_completion(struct at76_priv *priv, int cmd)
 		}
 
 		at76_dbg(DBG_WAIT_COMPLETE,
-		         "%s: Waiting on cmd %d, status = %d (%s)",
-		         priv->netdev->name, cmd, status,
-		         at76_get_cmd_status_string(status));
+			 "%s: Waiting on cmd %d, status = %d (%s)",
+			 priv->netdev->name, cmd, status,
+			 at76_get_cmd_status_string(status));
 
 		if (status == CMD_STATUS_IN_PROGRESS ||
 		    status == CMD_STATUS_IDLE) {
@@ -1070,7 +1070,7 @@ static void at76_set_monitor_mode(struct at76_priv *priv)
 		priv->netdev->type = ARPHRD_IEEE80211_RADIOTAP;
 	} else {
 		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE OFF",
-		         priv->netdev->name);
+			 priv->netdev->name);
 		priv->netdev->type = ARPHRD_ETHER;
 	}
 }
@@ -1425,11 +1425,11 @@ static void at76_dump_mib_mdomain(struct at76_priv *priv)
 	}
 
 	at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %s tx_powerlevel %s",
-	         priv->netdev->name,
-	         hex2str(obuf1, mdomain.channel_list,
-		         (sizeof(obuf1) - 1) / 2, '\0'),
-	         hex2str(obuf2, mdomain.tx_powerlevel,
-		         (sizeof(obuf2) - 1) / 2, '\0'));
+		 priv->netdev->name,
+		 hex2str(obuf1, mdomain.channel_list,
+			 (sizeof(obuf1) - 1) / 2, '\0'),
+		 hex2str(obuf2, mdomain.tx_powerlevel,
+			 (sizeof(obuf2) - 1) / 2, '\0'));
 }
 
 
@@ -1528,13 +1528,13 @@ static int at76_start_scan(struct at76_priv *priv, int use_essid, int ir_step)
 	/* other values are set to 0 for type 0 */
 
 	at76_dbg(DBG_PROGRESS, "%s: start_scan (use_essid = %d, intl = %d, "
-	         "channel = %d, probe_delay = %d, scan_min_time = %d, "
-	         "scan_max_time = %d)",
-	         priv->netdev->name, use_essid,
-	         scan.international_scan, scan.channel,
-	         le16_to_cpu(scan.probe_delay),
-	         le16_to_cpu(scan.min_channel_time),
-	         le16_to_cpu(scan.max_channel_time));
+		 "channel = %d, probe_delay = %d, scan_min_time = %d, "
+		 "scan_max_time = %d)",
+		 priv->netdev->name, use_essid,
+		 scan.international_scan, scan.channel,
+		 le16_to_cpu(scan.probe_delay),
+		 le16_to_cpu(scan.min_channel_time),
+		 le16_to_cpu(scan.max_channel_time));
 
 	return at76_set_card_command(priv->udev, CMD_SCAN, &scan, sizeof(scan));
 }
@@ -1572,8 +1572,8 @@ static int at76_join_bss(struct at76_priv *priv, struct bss_info *ptr)
 	join.timeout = cpu_to_le16(2000);
 
 	at76_dbg(DBG_PROGRESS, "%s join addr %s ssid %s type %d ch %d timeout %d",
-	         priv->netdev->name, mac2str(join.bssid),
-	         join.essid, join.bss_type, join.channel, le16_to_cpu(join.timeout));
+		 priv->netdev->name, mac2str(join.bssid),
+		 join.essid, join.bss_type, join.channel, le16_to_cpu(join.timeout));
 	return at76_set_card_command(priv->udev, CMD_JOIN, &join,
 				     sizeof(struct at76_req_join));
 }
@@ -1627,8 +1627,8 @@ static void at76_write_bulk_callback(struct urb *urb)
 	if (urb->status != 0) {
 		if ((urb->status != -ENOENT) && (urb->status != -ECONNRESET)) {
 			at76_dbg(DBG_URB,
-			         "%s - nonzero write bulk status received: %d",
-			         __FUNCTION__, urb->status);
+				 "%s - nonzero write bulk status received: %d",
+				 __FUNCTION__, urb->status);
 		} else
 			return; /* urb has been unlinked */
 		stats->tx_errors++;
@@ -1709,9 +1709,9 @@ static int at76_send_mgmt_bulk(struct at76_priv *priv,
 		}
 
 		at76_dbg(DBG_TX_MGMT, "%s: tx mgmt: wlen %d tx_rate %d pad %d %s",
-		         priv->netdev->name, le16_to_cpu(txbuf->wlength),
-		         txbuf->tx_rate, txbuf->padding,
-		         hex2str(priv->obuf, txbuf->packet,
+			 priv->netdev->name, le16_to_cpu(txbuf->wlength),
+			 txbuf->tx_rate, txbuf->padding,
+			 hex2str(priv->obuf, txbuf->packet,
 			    min((sizeof(priv->obuf) - 1) / 2,
 				(size_t) le16_to_cpu(txbuf->wlength)), '\0'));
 
@@ -1789,13 +1789,13 @@ static int at76_auth_req(struct at76_priv *priv, struct bss_info *bss,
 	/* init. at76_priv tx header */
 	tx_buffer->wlength = cpu_to_le16(buf_len - AT76_TX_HDRLEN);
 	at76_dbg(DBG_TX_MGMT, "%s: AuthReq bssid %s alg %d seq_nr %d",
-	         priv->netdev->name, mac2str(mgmt->addr3),
-	         le16_to_cpu(req->algorithm), le16_to_cpu(req->transaction));
+		 priv->netdev->name, mac2str(mgmt->addr3),
+		 le16_to_cpu(req->algorithm), le16_to_cpu(req->transaction));
 	if (seq_nr == 3) {
 		at76_dbg(DBG_TX_MGMT, "%s: AuthReq challenge: %s ...",
-		         priv->netdev->name,
-		         hex2str(priv->obuf, req->info_element,
-		             min((int)sizeof(priv->obuf) / 3, 18), ' '));
+			 priv->netdev->name,
+			 hex2str(priv->obuf, req->info_element,
+			     min((int)sizeof(priv->obuf) / 3, 18), ' '));
 	}
 
 	/* either send immediately (if no data tx is pending
@@ -1867,9 +1867,9 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 		priv->obuf[len] = '\0';
 		next_ie(&tlv); /* points to IE of rates now */
 		at76_dbg(DBG_TX_MGMT, "%s: AssocReq bssid %s capa x%04x ssid %s rates %s",
-		         priv->netdev->name, mac2str(mgmt->addr3),
-		         le16_to_cpu(req->capability), priv->obuf,
-		         hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
+			 priv->netdev->name, mac2str(mgmt->addr3),
+			 le16_to_cpu(req->capability), priv->obuf,
+			 hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
 			    '\0'));
 	}
 
@@ -1882,7 +1882,7 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 /* we are currently associated to curr_bss and
    want to reassoc to new_bss */
 static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
-		            struct bss_info *new_bss)
+			    struct bss_info *new_bss)
 {
 	struct at76_tx_buffer *tx_buffer;
 	struct ieee80211_hdr_3addr *mgmt;
@@ -1948,10 +1948,10 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 		priv->obuf[IW_ESSID_MAX_SIZE] = '\0';
 		next_ie(&tlv); /* points to IE of rates now */
 		at76_dbg(DBG_TX_MGMT, "%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s",
-		         priv->netdev->name,
-		         hex2str(ocurr, req->current_ap, ETH_ALEN, ':'),
-		         mac2str(mgmt->addr3), le16_to_cpu(req->capability), priv->obuf,
-		         hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
+			 priv->netdev->name,
+			 hex2str(ocurr, req->current_ap, ETH_ALEN, ':'),
+			 mac2str(mgmt->addr3), le16_to_cpu(req->capability), priv->obuf,
+			 hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
 			    '\0'));
 	}
 
@@ -1992,7 +1992,7 @@ static int at76_disassoc_req(struct at76_priv *priv, struct bss_info *bss)
 	tx_buffer->wlength = cpu_to_le16(DISASSOC_FRAME_SIZE - AT76_TX_HDRLEN);
 
 	at76_dbg(DBG_TX_MGMT, "%s: DisAssocReq bssid %s",
-	         priv->netdev->name, mac2str(mgmt->addr3));
+		 priv->netdev->name, mac2str(mgmt->addr3));
 
 	/* either send immediately (if no data tx is pending
 	   or put it in pending list */
@@ -2025,9 +2025,9 @@ static void at76_bss_list_timeout(unsigned long par)
 		if (ptr != priv->curr_bss && ptr != priv->new_bss &&
 		    time_after(jiffies, ptr->last_rx + BSS_LIST_TIMEOUT)) {
 			at76_dbg(DBG_BSS_TABLE_RM,
-			         "%s: bss_list: removing old BSS %s ch %d",
-			         priv->netdev->name, mac2str(ptr->bssid),
-			         ptr->channel);
+				 "%s: bss_list: removing old BSS %s ch %d",
+				 priv->netdev->name, mac2str(ptr->bssid),
+				 ptr->channel);
 			list_del(&ptr->list);
 			kfree(ptr);
 		}
@@ -2048,23 +2048,23 @@ static void at76_dump_bss_table(struct at76_priv *priv)
 	spin_lock_irqsave(&priv->bss_list_spinlock, flags);
 
 	pr_debug("%s BSS table (curr=%p, new=%p):", priv->netdev->name,
-	         priv->curr_bss, priv->new_bss);
+		 priv->curr_bss, priv->new_bss);
 
 	list_for_each(lptr, &priv->bss_list) {
 		ptr = list_entry(lptr, struct bss_info, list);
 		pr_debug("0x%p: bssid %s channel %d ssid %s (%s)"
-		         " capa x%04x rates %s rssi %d link %d noise %d",
-		         ptr, mac2str(ptr->bssid),
-		         ptr->channel,
-		         ptr->ssid,
-		         hex2str(priv->obuf, ptr->ssid,
+			 " capa x%04x rates %s rssi %d link %d noise %d",
+			 ptr, mac2str(ptr->bssid),
+			 ptr->channel,
+			 ptr->ssid,
+			 hex2str(priv->obuf, ptr->ssid,
 			       min((sizeof(priv->obuf) - 1) / 2,
 				   (size_t) ptr->ssid_len), '\0'),
-		         ptr->capa,
-		         hex2str(obuf_s, ptr->rates,
+			 ptr->capa,
+			 hex2str(obuf_s, ptr->rates,
 			       min(sizeof(obuf_s) / 3,
 				   (size_t) ptr->rates_len), ' '),
-		         ptr->rssi, ptr->link_qual, ptr->noise_level);
+			 ptr->rssi, ptr->link_qual, ptr->noise_level);
 	}
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
@@ -2094,9 +2094,9 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 		   further down the line and stop this cycle */
 	}
 	at76_dbg(DBG_PROGRESS, "%s %s:%d got cmd_status %d (istate %d, "
-	         "scan_runs %d)",
-	         priv->netdev->name, __FUNCTION__, __LINE__, status,
-	         priv->istate, priv->scan_runs);
+		 "scan_runs %d)",
+		 priv->netdev->name, __FUNCTION__, __LINE__, status,
+		 priv->istate, priv->scan_runs);
 	if (status == CMD_STATUS_COMPLETE) {
 		if (priv->istate == SCANNING) {
 			if (at76_debug & DBG_BSS_TABLE)
@@ -2111,11 +2111,11 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 					char obuf1[2*14+1], obuf2[2*14+1];
 
 					at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %s "
-					         "tx_powerlevel %s",
-					         priv->netdev->name,
-					         hex2str(obuf1, mdomain.channel_list,
-				     		    (sizeof(obuf1)-1)/2,'\0'),
-				     	         hex2str(obuf2, mdomain.tx_powerlevel,
+						 "tx_powerlevel %s",
+						 priv->netdev->name,
+						 hex2str(obuf1, mdomain.channel_list,
+						    (sizeof(obuf1)-1)/2,'\0'),
+						 hex2str(obuf2, mdomain.tx_powerlevel,
 						    (sizeof(obuf2)-1)/2,'\0'));
 				}
 				if ((ret = at76_start_scan(priv, 0, 1)) < 0) {
@@ -2123,7 +2123,7 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 					    priv->netdev->name, __FUNCTION__, ret);
 				}
 				at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
-				         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+					 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 				mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 				break;
 
@@ -2133,7 +2133,7 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 					    priv->netdev->name, __FUNCTION__, ret);
 				}
 				at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
-				         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+					 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 				mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 				break;
 
@@ -2155,10 +2155,10 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 
 			at76_assert(priv->istate == MONITORING);
 			at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE: restart scan",
-			         priv->netdev->name);
+				 priv->netdev->name);
 			at76_start_scan(priv, 0, 0);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
-			         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+				 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 			mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 		}
 
@@ -2172,7 +2172,7 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 		/* the first cmd status after scan start is always a IDLE ->
 		   start the timer to poll again until COMPLETED */
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
-		         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 	}
 }
@@ -2199,8 +2199,8 @@ static void at76_work_assoc_done(struct work_struct *work)
 			pm_period_beacon = min(pm_period_beacon, 0xffffu);
 
 			at76_dbg(DBG_PM, "%s: pm_mode %d assoc id x%x listen int %d",
-			         priv->netdev->name, priv->pm_mode,
-			         priv->curr_bss->assoc_id, pm_period_beacon);
+				 priv->netdev->name, priv->pm_mode,
+				 priv->curr_bss->assoc_id, pm_period_beacon);
 
 			at76_set_associd(priv, priv->curr_bss->assoc_id);
 			at76_set_listen_interval(priv, (u16)pm_period_beacon);
@@ -2217,7 +2217,7 @@ static void at76_work_assoc_done(struct work_struct *work)
 	priv->istate = CONNECTED;
 	at76_iwevent_bss_connect(priv->netdev, priv->curr_bss->bssid);
 	at76_dbg(DBG_PROGRESS, "%s: connected to BSSID %s",
-	         priv->netdev->name, mac2str(priv->curr_bss->bssid));
+		 priv->netdev->name, mac2str(priv->curr_bss->bssid));
 
 	mutex_unlock(&priv->mtx);
 }
@@ -2338,10 +2338,10 @@ static int at76_alloc_urbs(struct at76_priv *priv)
 				return -ENOMEM;
 			}
 			usb_fill_bulk_urb(priv->write_urb, udev,
-				          usb_sndbulkpipe(udev,
+					  usb_sndbulkpipe(udev,
 						      endpoint->bEndpointAddress),
-				          priv->bulk_out_buffer, buffer_size,
-				          at76_write_bulk_callback, priv);
+					  priv->bulk_out_buffer, buffer_size,
+					  at76_write_bulk_callback, priv);
 		}
 	}
 
@@ -2384,8 +2384,8 @@ static struct iw_statistics *at76_get_wireless_stats(struct net_device *netdev)
 	struct at76_priv *priv = netdev_priv(netdev);
 
 	at76_dbg(DBG_IOCTL, "RETURN qual %d level %d noise %d updated %d",
-	         priv->wstats.qual.qual, priv->wstats.qual.level,
-	         priv->wstats.qual.noise, priv->wstats.qual.updated);
+		 priv->wstats.qual.qual, priv->wstats.qual.level,
+		 priv->wstats.qual.noise, priv->wstats.qual.updated);
 
 	return &priv->wstats;
 }
@@ -2415,7 +2415,7 @@ static int at76_iw_handler_commit(struct net_device *netdev,
 	struct at76_priv *priv = netdev_priv(netdev);
 	unsigned long flags;
 	at76_dbg(DBG_IOCTL, "%s %s: restarting the device", netdev->name,
-	         __FUNCTION__);
+		 __FUNCTION__);
 
 	/* TODO: stop any pending tx bulk urb */
 	if (priv->istate != INIT) {
@@ -2516,7 +2516,7 @@ static int at76_iw_handler_get_freq(struct net_device *netdev,
 
 	if (priv->channel) {
 		at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - freq %ld x 10e%d",
-		         netdev->name, channel_frequency[priv->channel - 1], 6);
+			 netdev->name, channel_frequency[priv->channel - 1], 6);
 	}
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - ch %d", netdev->name, priv->channel);
 
@@ -2626,7 +2626,6 @@ static int at76_iw_handler_get_range(struct net_device *netdev,
 	range->min_retry = 1;
 	range->max_retry = 255;
 
-
 	range->num_channels = NUM_CHANNELS;
 	range->num_frequency = 0;
 
@@ -2655,7 +2654,7 @@ static int at76_iw_handler_set_spy(struct net_device *netdev,
 	int ret = 0;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWSPY - number of addresses %d",
-	         netdev->name, data->length);
+		 netdev->name, data->length);
 
 	spin_lock_bh(&(priv->spy_spinlock));
 	ret = iw_handler_set_spy(priv->netdev, info, (union iwreq_data *)data,
@@ -2680,7 +2679,7 @@ static int at76_iw_handler_get_spy(struct net_device *netdev,
 	spin_unlock_bh(&(priv->spy_spinlock));
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWSPY - number of addresses %d",
-	         netdev->name, data->length);
+		 netdev->name, data->length);
 
 	return ret;
 }
@@ -2694,7 +2693,7 @@ static int at76_iw_handler_set_thrspy(struct net_device *netdev,
 	int ret;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWTHRSPY - number of addresses %d)",
-	         netdev->name, data->length);
+		 netdev->name, data->length);
 
 	spin_lock_bh(&(priv->spy_spinlock));
 	ret = iw_handler_set_thrspy(netdev, info, (union iwreq_data *)data,
@@ -2718,7 +2717,7 @@ static int at76_iw_handler_get_thrspy(struct net_device *netdev,
 	spin_unlock_bh(&(priv->spy_spinlock));
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWTHRSPY - number of addresses %d)",
-	         netdev->name, data->length);
+		 netdev->name, data->length);
 
 	return ret;
 }
@@ -2731,7 +2730,7 @@ static int at76_iw_handler_set_wap(struct net_device *netdev,
 	struct at76_priv *priv = netdev_priv(netdev);
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWAP - wap/bssid %s", netdev->name,
-	         mac2str(ap_addr->sa_data));
+		 mac2str(ap_addr->sa_data));
 
 	/* if the incoming address == ff:ff:ff:ff:ff:ff, the user has
 	   chosen any or auto AP preference */
@@ -2758,7 +2757,7 @@ static int at76_iw_handler_get_wap(struct net_device *netdev,
 	memcpy(ap_addr->sa_data, priv->bssid, ETH_ALEN);
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWAP - wap/bssid %s", netdev->name,
-	         mac2str(ap_addr->sa_data));
+		 mac2str(ap_addr->sa_data));
 
 	return 0;
 }
@@ -3081,7 +3080,7 @@ static int at76_iw_handler_get_rate(struct net_device *netdev,
 	bitrate->disabled = 0;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRATE - %d", netdev->name,
-	         bitrate->value);
+		 bitrate->value);
 
 	return ret;
 }
@@ -3122,7 +3121,7 @@ static int at76_iw_handler_get_rts(struct net_device *netdev,
 	rts->fixed = 1;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRTS - value %d disabled %s",
-	         netdev->name, rts->value, (rts->disabled) ? "true" : "false");
+		 netdev->name, rts->value, (rts->disabled) ? "true" : "false");
 
 	return 0;
 }
@@ -3137,7 +3136,7 @@ static int at76_iw_handler_set_frag(struct net_device *netdev,
 	int fthr = frag->value;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWFRAG - value %d, disabled %s",
-	         netdev->name, frag->value, (frag->disabled) ? "true" : "false");
+		 netdev->name, frag->value, (frag->disabled) ? "true" : "false");
 
 	if (frag->disabled)
 		fthr = MAX_FRAG_THRESHOLD;
@@ -3163,7 +3162,7 @@ static int at76_iw_handler_get_frag(struct net_device *netdev,
 	frag->fixed = 1;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFRAG - value %d, disabled %s",
-	         netdev->name, frag->value, (frag->disabled) ? "true" : "false");
+		 netdev->name, frag->value, (frag->disabled) ? "true" : "false");
 
 	return 0;
 }
@@ -3179,7 +3178,7 @@ static int at76_iw_handler_get_txpow(struct net_device *netdev,
 	power->flags = IW_TXPOW_DBM;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWTXPOW - txpow %d dBm", netdev->name,
-	         power->value);
+		 power->value);
 
 	return 0;
 }
@@ -3195,7 +3194,7 @@ static int at76_iw_handler_set_retry(struct net_device *netdev,
 	int ret = -EIWCOMMIT;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRETRY disabled %d  flags x%x val %d",
-	         netdev->name, retry->disabled, retry->flags, retry->value);
+		 netdev->name, retry->disabled, retry->flags, retry->value);
 
 	if (!retry->disabled && (retry->flags & IW_RETRY_LIMIT)) {
 		if ((retry->flags & IW_RETRY_MIN) ||
@@ -3220,9 +3219,7 @@ static int at76_iw_handler_get_retry(struct net_device *netdev,
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRETRY", netdev->name);
 
-	retry->disabled = 0;      /* Can't be disabled */
-
-
+	retry->disabled = 0;	/* Can't be disabled */
 	retry->flags = IW_RETRY_LIMIT;
 	retry->value = priv->short_retry_limit;
 
@@ -3240,13 +3237,13 @@ static int at76_iw_handler_set_encode(struct net_device *netdev,
 	int len = encoding->length;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - enc.flags %08x "
-	         "pointer %p len %d", netdev->name, encoding->flags,
-	         encoding->pointer, encoding->length);
+		 "pointer %p len %d", netdev->name, encoding->flags,
+		 encoding->pointer, encoding->length);
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - old wepstate: enabled %s key_id %d "
-	         "auth_mode %s",
-	         netdev->name, (priv->wep_enabled) ? "true" : "false",
-	         priv->wep_key_id,
-	         (priv->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
+		 "auth_mode %s",
+		 netdev->name, (priv->wep_enabled) ? "true" : "false",
+		 priv->wep_key_id,
+		 (priv->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
 
 	/* take the old default key if index is invalid */
 	if ((index < 0) || (index >= WEP_KEYS))
@@ -3272,10 +3269,10 @@ static int at76_iw_handler_set_encode(struct net_device *netdev,
 		priv->auth_mode = WLAN_AUTH_OPEN;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - new wepstate: enabled %s key_id %d "
-	         "key_len %d auth_mode %s",
-	         netdev->name, (priv->wep_enabled) ? "true" : "false",
-	         priv->wep_key_id + 1, priv->wep_keys_len[priv->wep_key_id],
-	         (priv->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
+		 "key_len %d auth_mode %s",
+		 netdev->name, (priv->wep_enabled) ? "true" : "false",
+		 priv->wep_key_id + 1, priv->wep_keys_len[priv->wep_key_id],
+		 (priv->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
 
 	return -EIWCOMMIT;
 }
@@ -3336,9 +3333,9 @@ static int at76_iw_handler_set_power(struct net_device *netdev,
 		priv->pm_mode = AT76_PM_OFF;
 	} else {
 		switch (prq->flags & IW_POWER_MODE) {
-                case IW_POWER_ALL_R:
+		case IW_POWER_ALL_R:
 		case IW_POWER_ON:
-                        break;
+			break;
 		default:
 			err = -EINVAL;
 			goto out;
@@ -3391,7 +3388,7 @@ static int at76_iw_set_short_preamble(struct net_device *netdev,
 	int ret = -EIWCOMMIT;
 
 	at76_dbg(DBG_IOCTL, "%s: AT76_SET_SHORT_PREAMBLE, %d",
-	         netdev->name, val);
+		 netdev->name, val);
 
 	if (val < 0 || val > 2) {
 		/* allow value of 2 - in the win98 driver it stands
@@ -3449,9 +3446,9 @@ static int at76_iw_set_powersave_mode(struct net_device *netdev,
 	int ret = -EIWCOMMIT;
 
 	at76_dbg(DBG_IOCTL, "%s: AT76_SET_POWERSAVE_MODE, %d (%s)",
-	         netdev->name, val,
-	         val == AT76_PM_OFF ? "active" : val == AT76_PM_ON ? "save" :
-	         val == AT76_PM_SMART ? "smart save" : "<invalid>");
+		 netdev->name, val,
+		 val == AT76_PM_OFF ? "active" : val == AT76_PM_ON ? "save" :
+		 val == AT76_PM_SMART ? "smart save" : "<invalid>");
 	if (val < AT76_PM_OFF || val > AT76_PM_SMART) {
 		ret = -EINVAL;
 	} else {
@@ -3472,7 +3469,7 @@ static int at76_iw_set_scan_times(struct net_device *netdev,
 	int ret = -EIWCOMMIT;
 
 	at76_dbg(DBG_IOCTL, "%s: AT76_SET_SCAN_TIMES - min %d max %d",
-	         netdev->name, mint, maxt);
+		 netdev->name, mint, maxt);
 	if (mint <= 0 || maxt <= 0 || mint > maxt) {
 		ret = -EINVAL;
 	} else {
@@ -3533,8 +3530,8 @@ static int at76_iw_set_intl_roaming(struct net_device *netdev,
 	int ret = -EIWCOMMIT;
 
 	at76_dbg(DBG_IOCTL, "%s: AT76_SET_INTL_ROAMING - mode %s",
-	         netdev->name, (val == IR_OFF) ? "off" :
-	         (val == IR_ON) ? "on" : "<invalid>");
+		 netdev->name, (val == IR_OFF) ? "off" :
+		 (val == IR_ON) ? "on" : "<invalid>");
 
 	if (val != IR_OFF && val != IR_ON) {
 		ret = -EINVAL;
@@ -3554,36 +3551,36 @@ static int at76_iw_set_intl_roaming(struct net_device *netdev,
  */
 static const iw_handler	at76_handlers[] =
 {
-        [SIOCSIWCOMMIT-SIOCIWFIRST] = (iw_handler) at76_iw_handler_commit,
-        [SIOCGIWNAME  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_name,
-        [SIOCSIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_freq,
-        [SIOCGIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_freq,
-        [SIOCSIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_mode,
-        [SIOCGIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_mode,
-        [SIOCGIWRANGE -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_range,
-        [SIOCSIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_spy,
-        [SIOCGIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_spy,
-        [SIOCSIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_thrspy,
-        [SIOCGIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_thrspy,
-        [SIOCSIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_wap,
-        [SIOCGIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_wap,
-        [SIOCSIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_scan,
-        [SIOCGIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_scan,
-        [SIOCSIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_essid,
-        [SIOCGIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_essid,
-        [SIOCSIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rate,
-        [SIOCGIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rate,
-        [SIOCSIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rts,
-        [SIOCGIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rts,
-        [SIOCSIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_frag,
-        [SIOCGIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_frag,
-        [SIOCGIWTXPOW -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_txpow,
-        [SIOCSIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_retry,
-        [SIOCGIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_retry,
-        [SIOCSIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_encode,
-        [SIOCGIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_encode,
-        [SIOCSIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_power,
-        [SIOCGIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_power,
+	[SIOCSIWCOMMIT-SIOCIWFIRST] = (iw_handler) at76_iw_handler_commit,
+	[SIOCGIWNAME  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_name,
+	[SIOCSIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_freq,
+	[SIOCGIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_freq,
+	[SIOCSIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_mode,
+	[SIOCGIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_mode,
+	[SIOCGIWRANGE -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_range,
+	[SIOCSIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_spy,
+	[SIOCGIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_spy,
+	[SIOCSIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_thrspy,
+	[SIOCGIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_thrspy,
+	[SIOCSIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_wap,
+	[SIOCGIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_wap,
+	[SIOCSIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_scan,
+	[SIOCGIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_scan,
+	[SIOCSIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_essid,
+	[SIOCGIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_essid,
+	[SIOCSIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rate,
+	[SIOCGIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rate,
+	[SIOCSIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rts,
+	[SIOCGIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rts,
+	[SIOCSIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_frag,
+	[SIOCGIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_frag,
+	[SIOCGIWTXPOW -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_txpow,
+	[SIOCSIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_retry,
+	[SIOCGIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_retry,
+	[SIOCSIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_encode,
+	[SIOCGIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_encode,
+	[SIOCSIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_power,
+	[SIOCGIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_power,
 };
 
 #define AT76_SET_PRIV(h, f) [h - SIOCIWFIRSTPRIV] = (iw_handler) f
@@ -3616,7 +3613,7 @@ static const struct iw_priv_args at76_priv_args[] = {
 
 	{AT76_SET_POWERSAVE_MODE,
 	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 "powersave_mode"},	/* 1 -  active, 2 - power save,
+	 "powersave_mode"},	/* 1 - active, 2 - power save,
 				   3 - smart power save */
 	{AT76_SET_SCAN_TIMES,
 	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0,
@@ -3640,7 +3637,7 @@ static const struct iw_handler_def at76_handler_def =
 	.standard	= at76_handlers,
 	.private	= at76_priv_handlers,
 	.private_args	= at76_priv_args,
- 	.get_wireless_stats = at76_get_wireless_stats,
+	.get_wireless_stats = at76_get_wireless_stats,
 };
 
 
@@ -3651,40 +3648,40 @@ Ethernet Frame Formats:
 
 Ethernet (a.k.a. Ethernet II)
 
-        +---------+---------+---------+----------
-        |   Dst   |   Src   |  Type   |  Data...
-        +---------+---------+---------+----------
+	+---------+---------+---------+----------
+	|   Dst   |   Src   |  Type   |  Data...
+	+---------+---------+---------+----------
 
-         <-- 6 --> <-- 6 --> <-- 2 --> <-46-1500->
+	 <-- 6 --> <-- 6 --> <-- 2 --> <-46-1500->
 
-         Type 0x80 0x00 = TCP/IP
-         Type 0x06 0x00 = XNS
-         Type 0x81 0x37 = Novell NetWare
+	 Type 0x80 0x00 = TCP/IP
+	 Type 0x06 0x00 = XNS
+	 Type 0x81 0x37 = Novell NetWare
 
 
 802.3
 
-        +---------+---------+---------+----------
-        |   Dst   |   Src   | Length  | Data...
-        +---------+---------+---------+----------
+	+---------+---------+---------+----------
+	|   Dst   |   Src   | Length  | Data...
+	+---------+---------+---------+----------
 
-         <-- 6 --> <-- 6 --> <-- 2 --> <-46-1500->
+	 <-- 6 --> <-- 6 --> <-- 2 --> <-46-1500->
 
 802.2 (802.3 with 802.2 header)
 
-        +---------+---------+---------+-------+-------+-------+----------
-        |   Dst   |   Src   | Length  | DSAP  | SSAP  |Control| Data...
-        +---------+---------+---------+-------+-------+-------+----------
+	+---------+---------+---------+-------+-------+-------+----------
+	|   Dst   |   Src   | Length  | DSAP  | SSAP  |Control| Data...
+	+---------+---------+---------+-------+-------+-------+----------
 
-                                       <- 1 -> <- 1 -> <- 1 -> <-43-1497->
+				       <- 1 -> <- 1 -> <- 1 -> <-43-1497->
 
 SNAP (802.3 with 802.2 and SNAP headers)
 
-        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
-        |   Dst   |   Src   | Length  | 0xAA  | 0xAA  | 0x03  |  Org Code |   Type  | Data...
-        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
+	+---------+---------+---------+-------+-------+-------+-----------+---------+-----------
+	|   Dst   |   Src   | Length  | 0xAA  | 0xAA  | 0x03  |  Org Code |   Type  | Data...
+	+---------+---------+---------+-------+-------+-------+-----------+---------+-----------
 
-                                                               <--  3  --> <-- 2 --> <-38-1492->
+							       <--  3  --> <-- 2 --> <-38-1492->
 
 */
 static const u8 snapsig[] = { 0xaa, 0xaa, 0x03 };
@@ -3796,17 +3793,17 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 
 	{
 		at76_dbg(DBG_TX_DATA_CONTENT, "%s skb->data %s", priv->netdev->name,
-		         hex2str(priv->obuf, skb->data,
+			 hex2str(priv->obuf, skb->data,
 			    min((int)(sizeof(priv->obuf) - 1) / 2, 32), '\0'));
 		at76_dbg(DBG_TX_DATA, "%s tx  wlen x%x pad x%x rate %d hdr %s",
-		         priv->netdev->name,
-		         le16_to_cpu(tx_buffer->wlength),
-		         tx_buffer->padding, tx_buffer->tx_rate,
-		         hex2str(priv->obuf, i802_11_hdr,
+			 priv->netdev->name,
+			 le16_to_cpu(tx_buffer->wlength),
+			 tx_buffer->padding, tx_buffer->tx_rate,
+			 hex2str(priv->obuf, i802_11_hdr,
 			    min((sizeof(priv->obuf) - 1) / 2,
 				sizeof(struct ieee80211_hdr_3addr)), '\0'));
 		at76_dbg(DBG_TX_DATA_CONTENT, "%s payload %s", priv->netdev->name,
-		         hex2str(priv->obuf, payload,
+			 hex2str(priv->obuf, payload,
 			    min((int)(sizeof(priv->obuf) - 1) / 2, 48), '\0'));
 	}
 
@@ -3815,9 +3812,9 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	netdev->trans_start = jiffies;
 
 	usb_fill_bulk_urb(priv->write_urb, priv->udev,
-		         usb_sndbulkpipe(priv->udev, priv->bulk_out_endpointAddr),
-		         tx_buffer, submit_len,
-		         at76_write_bulk_callback, priv);
+			 usb_sndbulkpipe(priv->udev, priv->bulk_out_endpointAddr),
+			 tx_buffer, submit_len,
+			 at76_write_bulk_callback, priv);
 	ret = usb_submit_urb(priv->write_urb, GFP_ATOMIC);
 	if (ret) {
 		stats->tx_errors++;
@@ -3878,9 +3875,9 @@ static int at76_submit_rx_urb(struct at76_priv *priv)
 
 	size = skb_tailroom(skb);
 	usb_fill_bulk_urb(priv->read_urb, priv->udev,
-		         usb_rcvbulkpipe(priv->udev, priv->bulk_in_endpointAddr),
-		         skb_put(skb, size), size,
-		         at76_read_bulk_callback, priv);
+			 usb_rcvbulkpipe(priv->udev, priv->bulk_in_endpointAddr),
+			 skb_put(skb, size), size,
+			 at76_read_bulk_callback, priv);
 	ret = usb_submit_urb(priv->read_urb, GFP_ATOMIC);
 	if (ret < 0) {
 		if (ret == -ENODEV)
@@ -3898,8 +3895,8 @@ exit:
 				schedule_work(&priv->work_submit_rx);
 			else {
 				err("%s: giving up to submit rx urb after %d failures -"
-			    	    " please unload the driver and/or power cycle the device",
-			    	    priv->netdev->name, NR_SUBMIT_RX_TRIES);
+				    " please unload the driver and/or power cycle the device",
+				    priv->netdev->name, NR_SUBMIT_RX_TRIES);
 			}
 		}
 	} else
@@ -3924,7 +3921,7 @@ static int at76_open(struct net_device *netdev)
 	if (compare_ether_addr(netdev->dev_addr, priv->mac_addr)) {
 		if (at76_add_mac_address(priv, netdev->dev_addr) >= 0)
 			at76_dbg(DBG_PROGRESS, "%s: set new MAC addr %s",
-			         netdev->name, mac2str(netdev->dev_addr));
+				 netdev->name, mac2str(netdev->dev_addr));
 	}
 #ifdef DEBUG
 	at76_dump_mib_mac_addr(priv);
@@ -4048,7 +4045,7 @@ static int at76_init_new_device(struct at76_priv *priv)
 	priv->interface = priv->udev->actconfig->interface[0];
 
 	at76_dbg(DBG_DEVSTART, "USB interface: %d endpoints",
-	         priv->interface->cur_altsetting->desc.bNumEndpoints);
+		 priv->interface->cur_altsetting->desc.bNumEndpoints);
 
 	if ((ret = at76_alloc_urbs(priv)) < 0)
 		goto error;
@@ -4161,7 +4158,7 @@ static int at76_load_external_fw(struct at76_priv *priv)
 
 	if (priv->extfw && priv->extfw_size) {
 		ret = at76_download_external_fw(priv->udev, priv->extfw,
-					        priv->extfw_size);
+						priv->extfw_size);
 		if (ret < 0) {
 			err("Downloading external firmware failed: %d", ret);
 			goto end_external_fw;
@@ -4192,9 +4189,9 @@ static int at76_load_internal_fw(struct at76_priv *priv)
 	mutex_lock(&priv->mtx);
 
 	ret = at76_usbdfu_download(priv->udev, priv->intfw,
-			           priv->intfw_size,
-			           priv->board_type ==
-			           BOARDTYPE_505A_RFMD_2958 ? 2000 : 0);
+				   priv->intfw_size,
+				   priv->board_type ==
+				   BOARDTYPE_505A_RFMD_2958 ? 2000 : 0);
 
 	if (ret < 0) {
 		err("downloading internal fw failed with %d", ret);
@@ -4231,7 +4228,7 @@ static int at76_essid_matched(struct at76_priv *priv, struct bss_info *ptr)
 		       !memcmp(priv->essid, ptr->ssid, ptr->ssid_len)));
 	if (!ret)
 		at76_dbg(DBG_BSS_MATCH, "%s bss table entry %p: essid didn't match",
-		         priv->netdev->name, ptr);
+			 priv->netdev->name, ptr);
 	return ret;
 }
 
@@ -4246,7 +4243,7 @@ static inline int at76_mode_matched(struct at76_priv *priv, struct bss_info *ptr
 		ret = ptr->capa & WLAN_CAPABILITY_ESS;
 	if (!ret)
 		at76_dbg(DBG_BSS_MATCH, "%s bss table entry %p: mode didn't match",
-		         priv->netdev->name, ptr);
+			 priv->netdev->name, ptr);
 	return ret;
 }
 
@@ -4265,8 +4262,8 @@ static int at76_rates_matched(struct at76_priv *priv, struct bss_info *ptr)
 			    && *rate != (0x80 | hw_rates[2])
 			    && *rate != (0x80 | hw_rates[3])) {
 				at76_dbg(DBG_BSS_MATCH,
-				         "%s: bss table entry %p: basic rate %02x not supported",
-				         priv->netdev->name, ptr, *rate);
+					 "%s: bss table entry %p: basic rate %02x not supported",
+					 priv->netdev->name, ptr, *rate);
 				return 0;
 			}
 		}
@@ -4274,7 +4271,7 @@ static int at76_rates_matched(struct at76_priv *priv, struct bss_info *ptr)
 	if (priv->preamble_type == PREAMBLE_TYPE_SHORT &&
 	    !(ptr->capa & WLAN_CAPABILITY_SHORT_PREAMBLE)) {
 		at76_dbg(DBG_BSS_MATCH, "%s: %p does not support short preamble",
-		         priv->netdev->name, ptr);
+			 priv->netdev->name, ptr);
 		return 0;
 	} else
 		return 1;
@@ -4286,7 +4283,7 @@ static inline int at76_wep_matched(struct at76_priv *priv, struct bss_info *ptr)
 	if (!priv->wep_enabled && ptr->capa & WLAN_CAPABILITY_PRIVACY) {
 		/* we have disabled WEP, but the BSS signals privacy */
 		at76_dbg(DBG_BSS_MATCH, "%s: bss table entry %p: requires encryption",
-		         priv->netdev->name, ptr);
+			 priv->netdev->name, ptr);
 		return 0;
 	}
 	/* otherwise if the BSS does not signal privacy it may well
@@ -4343,7 +4340,7 @@ static struct bss_info *at76_match_bss(struct at76_priv *priv,
 	/* otherwise ptr points to the struct bss_info we have chosen */
 
 	at76_dbg(DBG_BSS_TABLE, "%s %s: returned %p", priv->netdev->name,
-	         __FUNCTION__, ptr);
+		 __FUNCTION__, ptr);
 	return ptr;
 }
 
@@ -4411,7 +4408,7 @@ static void at76_work_join(struct work_struct *work)
 			priv->istate = AUTHENTICATING;
 			at76_auth_req(priv, priv->curr_bss, 1, NULL);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-			         __FUNCTION__, __LINE__);
+				 __FUNCTION__, __LINE__);
 			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		}
 		goto end_join;
@@ -4443,7 +4440,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 	    (at76_debug & DBG_MGMT_TIMER))
 		/* this is normal behavior in states MONITORING, SCANNING ... */
 		at76_dbg(DBG_PROGRESS, "%s: timeout, state %d", priv->netdev->name,
-		         priv->istate);
+			 priv->istate);
 
 	switch (priv->istate) {
 
@@ -4475,7 +4472,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 		if (priv->retries-- >= 0) {
 			at76_auth_req(priv, priv->curr_bss, 1, NULL);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-			         __FUNCTION__, __LINE__);
+				 __FUNCTION__, __LINE__);
 			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		} else {
 			/* try to get next matching BSS */
@@ -4488,7 +4485,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 		if (priv->retries-- >= 0) {
 			at76_assoc_req(priv, priv->curr_bss);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-			         __FUNCTION__, __LINE__);
+				 __FUNCTION__, __LINE__);
 			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		} else {
 			/* jal: TODO: we may be authenticated to several
@@ -4512,7 +4509,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 			at76_disassoc_req(priv, priv->curr_bss);
 		}
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-		         __FUNCTION__, __LINE__);
+			 __FUNCTION__, __LINE__);
 		mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		break;
 
@@ -4520,7 +4517,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 		if (priv->retries-- >= 0) {
 			at76_disassoc_req(priv, priv->curr_bss);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-		     	         __FUNCTION__, __LINE__);
+				 __FUNCTION__, __LINE__);
 			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		} else {
 			/* we scan again ... */
@@ -4655,7 +4652,7 @@ static int at76_startup_device(struct at76_priv *priv)
 	ccfg->beacon_period = cpu_to_le16(priv->beacon_period);
 
 	ret = at76_set_card_command(priv->udev, CMD_STARTUP, &priv->card_config,
-			            sizeof(struct at76_card_config));
+				    sizeof(struct at76_card_config));
 	if (ret < 0) {
 		err("%s: at76_set_card_command failed: %d", priv->netdev->name, ret);
 		return ret;
@@ -4721,8 +4718,8 @@ static void at76_work_restart(struct work_struct *work)
 		priv->istate = MONITORING;
 		at76_start_scan(priv, 0, 0);
 		at76_dbg(DBG_MGMT_TIMER,
-		         "%s:%d: starting mgmt_timer for %d ticks",
-		         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+			 "%s:%d: starting mgmt_timer for %d ticks",
+			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 		mod_timer(&priv->mgmt_timer,
 			  jiffies + SCAN_POLL_INTERVAL);
 	}
@@ -4751,7 +4748,7 @@ static void at76_work_scan(struct work_struct *work)
 		    priv->netdev->name, __FUNCTION__, ret);
 	} else {
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
-		         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 	}
 
@@ -4853,7 +4850,7 @@ static void at76_rx_mgmt_assoc(struct at76_priv *priv,
 	u16 status = le16_to_cpu(resp->status);
 	u16 capa = le16_to_cpu(resp->capability);
 	at76_dbg(DBG_RX_MGMT, "%s: rx AssocResp bssid %s capa x%04x status x%04x "
-	         "assoc_id x%04x rates %s",
+		 "assoc_id x%04x rates %s",
 	    priv->netdev->name, mac2str(mgmt->addr3), capa, status, assoc_id,
 	    hex2str(priv->obuf, resp->info_element->data,
 		    min((size_t)resp->info_element->len, (sizeof(priv->obuf)-1)/2), '\0'));
@@ -4895,9 +4892,9 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *priv,
 	u16 assoc_id = le16_to_cpu(resp->aid);
 
 	at76_dbg(DBG_RX_MGMT, "%s: rx ReAssocResp bssid %s capa x%04x status x%04x "
-	         "assoc_id x%04x rates %s",
-	         priv->netdev->name, mac2str(mgmt->addr3), capa, status, assoc_id,
-	         hex2str(priv->obuf, resp->info_element->data,
+		 "assoc_id x%04x rates %s",
+		 priv->netdev->name, mac2str(mgmt->addr3), capa, status, assoc_id,
+		 hex2str(priv->obuf, resp->info_element->data,
 		    min((size_t) resp->info_element->len,
 			(sizeof(priv->obuf) - 1) / 2), '\0'));
 	if (priv->istate == REASSOCIATING) {
@@ -4923,7 +4920,7 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *priv,
 			memcpy(priv->bssid, bptr->bssid, ETH_ALEN);
 			priv->channel = bptr->channel;
 			at76_dbg(DBG_PROGRESS, "%s: reassociated to BSSID %s",
-			         priv->netdev->name, mac2str(priv->bssid));
+				 priv->netdev->name, mac2str(priv->bssid));
 			schedule_work(&priv->work_assoc_done);
 		} else {
 			del_timer_sync(&priv->mgmt_timer);
@@ -4945,9 +4942,9 @@ static void at76_rx_mgmt_disassoc(struct at76_priv *priv,
 	struct ieee80211_hdr_3addr *mgmt = &resp->header;
 
 	at76_dbg(DBG_RX_MGMT, "%s: rx DisAssoc bssid %s reason x%04x destination %s",
-	         priv->netdev->name, mac2str(mgmt->addr3),
-	         le16_to_cpu(resp->reason),
-	         hex2str(priv->obuf, mgmt->addr1,
+		 priv->netdev->name, mac2str(mgmt->addr3),
+		 le16_to_cpu(resp->reason),
+		 hex2str(priv->obuf, mgmt->addr1,
 		    min((int)sizeof(priv->obuf) / 3, ETH_ALEN), ':'));
 	if (priv->istate == SCANNING || priv->istate == INIT)
 		return;
@@ -4998,16 +4995,16 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv, struct at76_rx_buffer *buf
 	int status = le16_to_cpu(resp->status);
 
 	at76_dbg(DBG_RX_MGMT, "%s: rx AuthFrame bssid %s alg %d seq_nr %d status %d "
-	         "destination %s",
-	         priv->netdev->name, mac2str(mgmt->addr3),
-	         alg, seq_nr, status,
-	         hex2str(priv->obuf, mgmt->addr1,
+		 "destination %s",
+		 priv->netdev->name, mac2str(mgmt->addr3),
+		 alg, seq_nr, status,
+		 hex2str(priv->obuf, mgmt->addr1,
 		    min((int)sizeof(priv->obuf) / 3, ETH_ALEN), ':'));
 
 	if (alg == WLAN_AUTH_SHARED_KEY && seq_nr == 2) {
 		at76_dbg(DBG_RX_MGMT, "%s: AuthFrame challenge %s ...",
-		         priv->netdev->name,
-		         hex2str(priv->obuf, resp->info_element,
+			 priv->netdev->name,
+			 hex2str(priv->obuf, resp->info_element,
 			    min((int)sizeof(priv->obuf) / 3, 18), ' '));
 	}
 	if (priv->istate != AUTHENTICATING) {
@@ -5042,7 +5039,7 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv, struct at76_rx_buffer *buf
 			priv->istate = ASSOCIATING;
 			at76_assoc_req(priv, priv->curr_bss);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-			         __FUNCTION__, __LINE__);
+				 __FUNCTION__, __LINE__);
 			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 			return;
 		}
@@ -5050,7 +5047,7 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv, struct at76_rx_buffer *buf
 		at76_assert(seq_nr == 2);
 		at76_auth_req(priv, priv->curr_bss, seq_nr + 1, resp->info_element);
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
-		         __FUNCTION__, __LINE__);
+			 __FUNCTION__, __LINE__);
 		mod_timer(&priv->mgmt_timer, jiffies + HZ);
 	}
 	/* else: ignore AuthFrames to other recipients */
@@ -5065,10 +5062,10 @@ static void at76_rx_mgmt_deauth(struct at76_priv *priv,
 	struct ieee80211_hdr_3addr *mgmt = &resp->header;
 
 	at76_dbg(DBG_RX_MGMT | DBG_PROGRESS,
-	         "%s: rx DeAuth bssid %s reason x%04x destination %s",
-	         priv->netdev->name, mac2str(mgmt->addr3),
-	         le16_to_cpu(resp->reason),
-	         hex2str(priv->obuf, mgmt->addr1,
+		 "%s: rx DeAuth bssid %s reason x%04x destination %s",
+		 priv->netdev->name, mac2str(mgmt->addr3),
+		 le16_to_cpu(resp->reason),
+		 hex2str(priv->obuf, mgmt->addr1,
 		    min((int)sizeof(priv->obuf) / 3, ETH_ALEN), ':'));
 	if (priv->istate == DISASSOCIATING ||
 	    priv->istate == AUTHENTICATING ||
@@ -5156,7 +5153,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 		/* haven't found the bss in the list */
 		if ((match=kmalloc(sizeof(struct bss_info), GFP_ATOMIC)) == NULL) {
 			at76_dbg(DBG_BSS_TABLE, "%s: cannot kmalloc new bss info (%zd byte)",
-		          	    priv->netdev->name, sizeof(struct bss_info));
+				    priv->netdev->name, sizeof(struct bss_info));
 			goto rx_mgmt_beacon_end;
 		}
 		memset(match, 0, sizeof(*match));
@@ -5178,7 +5175,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 	match->noise_level = buf->noise_level;
 	memcpy(match->bssid, mgmt->addr3, ETH_ALEN);
 	at76_dbg(DBG_RX_BEACON, "%s: bssid %s", priv->netdev->name,
-	         mac2str(match->bssid));
+		 mac2str(match->bssid));
 
 	tlv = bdata->info_element;
 
@@ -5217,7 +5214,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 								   string for
 								   printing */
 				at76_dbg(DBG_RX_BEACON, "%s: SSID - %s",
-				         priv->netdev->name, match->ssid);
+					 priv->netdev->name, match->ssid);
 			}
 			have_ssid = 1;
 			break;
@@ -5230,9 +5227,9 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 				       match->rates_len);
 				have_rates = 1;
 				at76_dbg(DBG_RX_BEACON,
-				         "%s: SUPPORTED RATES %s",
-				         priv->netdev->name,
-				         hex2str(priv->obuf, tlv->data,
+					 "%s: SUPPORTED RATES %s",
+					 priv->netdev->name,
+					 hex2str(priv->obuf, tlv->data,
 					    min_t(int, (sizeof(priv->obuf)-1)/2,
 						  tlv->len), '\0'));
 			}
@@ -5243,7 +5240,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 				match->channel = tlv->data[0];
 				have_channel = 1;
 				at76_dbg(DBG_RX_BEACON, "%s: CHANNEL - %d",
-				         priv->netdev->name, match->channel);
+					 priv->netdev->name, match->channel);
 			}
 			break;
 
@@ -5252,8 +5249,8 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 		case MFIE_TYPE_IBSS_SET:
 		default:
 			at76_dbg(DBG_RX_BEACON, "%s: beacon IE id %d len %d %s",
-			         priv->netdev->name, tlv->id, tlv->len,
-			         hex2str(priv->obuf, tlv->data,
+				 priv->netdev->name, tlv->id, tlv->len,
+				 hex2str(priv->obuf, tlv->data,
 				    min_t(int, (sizeof(priv->obuf)-1)/2,
 					  tlv->len), '\0'));
 			break;
@@ -5272,7 +5269,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 	}
 
 	at76_dbg(DBG_RX_BEACON, "%s: Finished processing beacon data",
-	         priv->netdev->name);
+		 priv->netdev->name);
 
 	match->last_rx = jiffies; /* record last rx of beacon */
 
@@ -5371,7 +5368,7 @@ static void at76_rx_mgmt(struct at76_priv *priv, struct at76_rx_buffer *buf)
 		 priv->netdev->name, subtype,
 		 hex2str(priv->obuf, mgmt,
 		     min((sizeof(priv->obuf) - 1) / 2,
-		         (size_t) le16_to_cpu(buf->wlength)), '\0'));
+			 (size_t) le16_to_cpu(buf->wlength)), '\0'));
 
 	switch (subtype) {
 	case IEEE80211_STYPE_BEACON:
@@ -5624,23 +5621,23 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 	unsigned long oldest = ~0UL;
 
 	at76_dbg(DBG_RX_FRAGS, "%s: rx data frame_ctl %04x addr2 %s seq/frag %d/%d "
-	         "length %d data %d: %s ...",
-	         priv->netdev->name, frame_ctl,
-	         mac2str(i802_11_hdr->addr2),
-	         seqnr, fragnr, length, data_len,
-	         hex2str(priv->obuf, data,
+		 "length %d data %d: %s ...",
+		 priv->netdev->name, frame_ctl,
+		 mac2str(i802_11_hdr->addr2),
+		 seqnr, fragnr, length, data_len,
+		 hex2str(priv->obuf, data,
 		    min((int)(sizeof(priv->obuf) - 1) / 2, 32), '\0'));
 
 #ifdef SKB_WITH_OVERHEAD
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: incoming skb: head %p data %p "
-	         "tail %d end %d len %d",
-	         priv->netdev->name, skb->head, skb->data, skb->tail,
-	         skb->end, skb->len);
+		 "tail %d end %d len %d",
+		 priv->netdev->name, skb->head, skb->data, skb->tail,
+		 skb->end, skb->len);
 #else
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: incoming skb: head %p data %p "
-	         "tail %p end %p len %d",
-	         priv->netdev->name, skb->head, skb->data, skb->tail,
-	         skb->end, skb->len);
+		 "tail %p end %p len %d",
+		 priv->netdev->name, skb->head, skb->data, skb->tail,
+		 skb->end, skb->len);
 #endif
 
 	if (data_len < 0) {
@@ -5677,14 +5674,14 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 
 #ifdef SKB_WITH_OVERHEAD
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: trimmed skb: head %p data %p tail %d "
-	         "end %d len %d data %p data_len %d",
-	         priv->netdev->name, skb->head, skb->data, skb->tail,
-	         skb->end, skb->len, data, data_len);
+		 "end %d len %d data %p data_len %d",
+		 priv->netdev->name, skb->head, skb->data, skb->tail,
+		 skb->end, skb->len, data, data_len);
 #else
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: trimmed skb: head %p data %p tail %p "
-	         "end %p len %d data %p data_len %d",
-	         priv->netdev->name, skb->head, skb->data, skb->tail,
-	         skb->end, skb->len, data, data_len);
+		 "end %p len %d data %p data_len %d",
+		 priv->netdev->name, skb->head, skb->data, skb->tail,
+		 skb->end, skb->len, data, data_len);
 #endif
 
 	/* look if we've got a chain for the sender address.
@@ -5715,8 +5712,8 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 	if (i < NR_RX_DATA_BUF) {
 
 		at76_dbg(DBG_RX_FRAGS, "%s: %d. cacheentry (seq/frag=%d/%d) "
-		         "matched sender addr",
-		         priv->netdev->name, i, bptr->seqnr, bptr->fragnr);
+			 "matched sender addr",
+			 priv->netdev->name, i, bptr->seqnr, bptr->fragnr);
 
 		/* bptr points to an entry for the sender address */
 		if (bptr->seqnr == seqnr) {
@@ -5742,14 +5739,14 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 					skb = bptr->skb;
 					bptr->skb = NULL; /* free the entry */
 					at76_dbg(DBG_RX_FRAGS, "%s: last frag of seq %d",
-					         priv->netdev->name, seqnr);
+						 priv->netdev->name, seqnr);
 					return skb;
 				} else
 					return NULL;
 			} else {
 				/* wrong fragment number -> ignore it */
 				at76_dbg(DBG_RX_FRAGS, "%s: frag nr does not match: %d+1 != %d",
-				         priv->netdev->name, bptr->fragnr, fragnr);
+					 priv->netdev->name, bptr->fragnr, fragnr);
 				return NULL;
 			}
 		} else {
@@ -5759,8 +5756,8 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 				   old one by this */
 				/* bptr->sender has the correct value already */
 				at76_dbg(DBG_RX_FRAGS, "%s: start of new seq %d, "
-				         "removing old seq %d", priv->netdev->name,
-				         seqnr, bptr->seqnr);
+					 "removing old seq %d", priv->netdev->name,
+					 seqnr, bptr->seqnr);
 				bptr->seqnr = seqnr;
 				bptr->fragnr = 0;
 				bptr->last_rx = jiffies;
@@ -5772,8 +5769,8 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 				/* it from the middle of a new chain ->
 				   delete the old entry and skip the new one */
 				at76_dbg(DBG_RX_FRAGS, "%s: middle of new seq %d (%d) "
-				         "removing old seq %d", priv->netdev->name,
-				         seqnr, fragnr, bptr->seqnr);
+					 "removing old seq %d", priv->netdev->name,
+					 seqnr, fragnr, bptr->seqnr);
 				dev_kfree_skb(bptr->skb);
 				bptr->skb = NULL;
 			}
@@ -5786,7 +5783,7 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 		if (fragnr != 0) {
 			/* this is not the begin of a fragment chain ... */
 			at76_dbg(DBG_RX_FRAGS, "%s: no chain for non-first fragment (%d)",
-			         priv->netdev->name, fragnr);
+				 priv->netdev->name, fragnr);
 			return NULL;
 		}
 		at76_assert(optr != NULL);
@@ -5800,8 +5797,8 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 			priv->rx_skb = skb;
 
 			at76_dbg(DBG_RX_FRAGS, "%s: free old contents: sender %s seq/frag %d/%d",
-			         priv->netdev->name, mac2str(optr->sender),
-			         optr->seqnr, optr->fragnr);
+				 priv->netdev->name, mac2str(optr->sender),
+				 optr->seqnr, optr->fragnr);
 
 		} else {
 			/* take the skb from priv->rx_skb */
@@ -5887,7 +5884,7 @@ static void at76_rx_monitor_mode(struct at76_priv *priv)
 	if (length < priv->rx_data_fcs_len) {
 		/* buffer contains no data */
 		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE: rx skb without data",
-		         priv->netdev->name);
+			 priv->netdev->name);
 		return;
 	}
 
@@ -5996,8 +5993,8 @@ static void at76_rx_tasklet(unsigned long param)
 	if (urb->status != 0) {
 		if ((urb->status != -ENOENT) && (urb->status != -ECONNRESET)) {
 			at76_dbg(DBG_URB,
-			         "%s %s: - nonzero read bulk status received: %d",
-			         __FUNCTION__, netdev->name, urb->status);
+				 "%s %s: - nonzero read bulk status received: %d",
+				 __FUNCTION__, netdev->name, urb->status);
 			goto no_more_urb;
 		}
 		return;
@@ -6037,7 +6034,7 @@ static void at76_rx_tasklet(unsigned long param)
 
 	case IEEE80211_FTYPE_CTL:
 		at76_dbg(DBG_RX_CTRL, "%s: ignored ctrl frame: %04x",
-		         priv->netdev->name, frame_ctl);
+			 priv->netdev->name, frame_ctl);
 		break;
 
 	default:




From proski at gnu.org  Tue Jun  5 03:04:23 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 21:04:23 -0400
Subject: [at76c503a-develop] [PATCH 08/10] Align all labels at position 6,
	as Lindent would do
In-Reply-To: <20070605010347.32602.23942.stgit@dv.roinet.com>
References: <20070605010347.32602.23942.stgit@dv.roinet.com>
Message-ID: <20070605010423.32602.85772.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   64 ++++++++++++++++++++++++++++++------------------------------
 1 files changed, 32 insertions(+), 32 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index fc9b774..ce6904a 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -448,7 +448,7 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 		}
 	} while (!is_done && DFU_USB_SUCCESS(status));
 
- exit:
+      exit:
 	kfree(ctx);
 	if (status < 0)
 		return status;
@@ -794,7 +794,7 @@ static int at76_download_external_fw(struct usb_device *udev, u8 *buf, int size)
 		goto exit;
 	}
 
- exit:
+      exit:
 	kfree(block);
 	return ret;
 }
@@ -1158,9 +1158,9 @@ static int at76_dump_mib_mac_addr(struct at76_priv *priv)
 	       mac_addr->group_addr_status[0], mac_addr->group_addr_status[1],
 	       mac_addr->group_addr_status[2], mac_addr->group_addr_status[3]);
 
- err:
+      err:
 	kfree(mac_addr);
- exit:
+      exit:
 	return ret;
 }
 
@@ -1204,9 +1204,9 @@ static int at76_dump_mib_mac_wep(struct at76_priv *priv)
 							 '\0') :
 	       "<invalid key id>");
 
- err:
+      err:
 	kfree(mac_wep);
- exit:
+      exit:
 	return ret;
 }
 
@@ -1260,9 +1260,9 @@ static int at76_dump_mib_mac_mgmt(struct at76_priv *priv)
 	       mac_mgmt->multi_domain_capability_implemented,
 	       mac_mgmt->multi_domain_capability_enabled,
 	       country_string);
- err:
+      err:
 	kfree(mac_mgmt);
- exit:
+      exit:
 	return ret;
 }
 
@@ -1310,7 +1310,7 @@ static int at76_dump_mib_mac(struct at76_priv *priv)
 	       mac2str(mac->desired_bssid), mac->desired_bsstype);
       err:
 	kfree(mac);
- exit:
+      exit:
 	return ret;
 }
 
@@ -1348,9 +1348,9 @@ static int at76_dump_mib_phy(struct at76_priv *priv)
 	       phy->operation_rate_set[2], phy->operation_rate_set[3],
 	       phy->channel_id,
 	       phy->current_cca_mode, phy->phy_type, phy->current_reg_domain);
- err:
+      err:
 	kfree(phy);
- exit:
+      exit:
 	return ret;
 }
 
@@ -1378,9 +1378,9 @@ static int at76_dump_mib_local(struct at76_priv *priv)
 	       local->beacon_enable,
 	       local->txautorate_fallback,
 	       local->ssid_size, local->promiscuous_mode, local->preamble_type);
- err:
+      err:
 	kfree(local);
- exit:
+      exit:
 	return ret;
 }
 
@@ -1405,9 +1405,9 @@ static int at76_get_mib_mdomain(struct at76_priv *priv, struct mib_mdomain *val)
 
 	memcpy(val, mdomain, sizeof(*val));
 
- err:
+      err:
 	kfree(mdomain);
- exit:
+      exit:
 	return ret;
 }
 
@@ -1452,9 +1452,9 @@ static int at76_get_current_bssid(struct at76_priv *priv)
 	}
 	memcpy(priv->bssid, mac_mgmt->current_bssid, ETH_ALEN);
 	info("using BSSID %s", mac2str(priv->bssid));
- err:
+      err:
 	kfree(mac_mgmt);
- exit:
+      exit:
 	return ret;
 }
 
@@ -1474,9 +1474,9 @@ static int at76_get_current_channel(struct at76_priv *priv)
 		goto err;
 	}
 	priv->channel = phy->channel_id;
- err:
+      err:
 	kfree(phy);
- exit:
+      exit:
 	return ret;
 }
 
@@ -3349,7 +3349,7 @@ static int at76_iw_handler_set_power(struct net_device *netdev,
 		}
 		priv->pm_mode = AT76_PM_ON;
 	}
-out:
+      out:
 	return err;
 }
 
@@ -3832,7 +3832,7 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	dev_kfree_skb(skb);
 	return 0;
 
- err:
+      err:
 	return ret;
 }
 
@@ -3886,7 +3886,7 @@ static int at76_submit_rx_urb(struct at76_priv *priv)
 			err("%s: rx, usb_submit_urb failed: %d", priv->netdev->name, ret);
 	}
 
-exit:
+      exit:
 	if (ret < 0) {
 		if (ret != -ENODEV) {
 			/* If we can't submit the URB, the adapter becomes completely
@@ -3941,7 +3941,7 @@ static int at76_open(struct net_device *netdev)
 	schedule_work(&priv->work_restart);
 
 	at76_dbg(DBG_PROC_ENTRY, "at76_open end");
- err:
+      err:
 	mutex_unlock(&priv->mtx);
 	return ret < 0 ? ret : 0;
 }
@@ -4134,7 +4134,7 @@ static int at76_init_new_device(struct at76_priv *priv)
 	/* we let this timer run the whole time this driver instance lives */
 	mod_timer(&priv->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
 
- error:
+      error:
 	return ret;
 }
 
@@ -4175,7 +4175,7 @@ static int at76_load_external_fw(struct at76_priv *priv)
 		err("Downloading external firmware failed: %d", ret);
 	return ret;
 
-  end_external_fw:
+      end_external_fw:
 	mutex_unlock(&priv->mtx);
 	return ret;
 }
@@ -4213,7 +4213,7 @@ static int at76_load_internal_fw(struct at76_priv *priv)
 	usb_reset_device(priv->udev);
 	priv->istate = WAIT_FOR_DISCONNECT;
 
-  end_internal_fw:
+      end_internal_fw:
 	mutex_unlock(&priv->mtx);
 	return ret;
 }
@@ -4424,7 +4424,7 @@ static void at76_work_join(struct work_struct *work)
 	priv->istate = SCANNING;
 	schedule_work(&priv->work_scan);
 
-  end_join:
+      end_join:
 	mutex_unlock(&priv->mtx);
 }
 
@@ -4567,7 +4567,7 @@ static void at76_work_new_bss(struct work_struct *work)
 	if (ret < 0)
 		err("%s: set_mib (ibss change ok) failed: %d", netdev->name, ret);
 
-  new_bss_clean:
+      new_bss_clean:
 	mutex_unlock(&priv->mtx);
 }
 
@@ -4823,7 +4823,7 @@ static void at76_work_start_ibss(struct work_struct *work)
 	netif_carrier_on(priv->netdev);
 	netif_start_queue(priv->netdev);
 
-  end_startibss:
+      end_startibss:
 	mutex_unlock(&priv->mtx);
 }
 
@@ -5273,7 +5273,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 
 	match->last_rx = jiffies; /* record last rx of beacon */
 
-rx_mgmt_beacon_end:
+      rx_mgmt_beacon_end:
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
 
@@ -6041,9 +6041,9 @@ static void at76_rx_tasklet(unsigned long param)
 		info("%s: it's a frame from mars: %2x", priv->netdev->name,
 		     frame_ctl);
 	}
- finish:
+      finish:
 	at76_submit_rx_urb(priv);
- no_more_urb:
+      no_more_urb:
 	return;
 }
 




From proski at gnu.org  Tue Jun  5 03:04:29 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 21:04:29 -0400
Subject: [at76c503a-develop] [PATCH 09/10] Remove at76_ieee80211_fixup(),
	it's not used
In-Reply-To: <20070605010347.32602.23942.stgit@dv.roinet.com>
References: <20070605010347.32602.23942.stgit@dv.roinet.com>
Message-ID: <20070605010429.32602.22229.stgit@dv.roinet.com>

Perhaps it was intended for some kind of "fixed up" monitor mode, but
the code has no chance to be executed since the monitor mode consumes
the packets before this point.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   62 +-----------------------------------------------------------
 1 files changed, 1 insertions(+), 61 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index ce6904a..71d5fd8 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -5531,62 +5531,6 @@ static inline void skb_reset_mac_header(struct sk_buff *skb)
 #endif
 
 
-/* Adjust the skb to trim the hardware header and CRC, and set up skb->mac,
- * skb->protocol, etc.
- */
-static void at76_ieee80211_fixup(struct sk_buff *skb, int iw_mode)
-{
-	struct ieee80211_hdr_3addr *i802_11_hdr;
-	struct ethhdr *eth_hdr_p;
-	u8 *src_addr;
-	u8 *dest_addr;
-	__be16 proto = 0;
-
-	skb_reset_mac_header(skb);
-	i802_11_hdr = (struct ieee80211_hdr_3addr *)skb->data;
-	skb_pull(skb, sizeof(struct ieee80211_hdr_3addr));
-
-	src_addr = iw_mode == IW_MODE_ADHOC ? i802_11_hdr->addr2
-	    : i802_11_hdr->addr3;
-	dest_addr = i802_11_hdr->addr1;
-
-	eth_hdr_p = (struct ethhdr *)skb->data;
-	if (!compare_ether_addr(eth_hdr_p->h_source, src_addr) &&
-	    !compare_ether_addr(eth_hdr_p->h_dest, dest_addr)) {
-		/* There's an ethernet header encapsulated within the data
-		 * portion, count it as part of the hardware header */
-		skb_pull(skb, sizeof(struct ethhdr));
-		proto = eth_hdr_p->h_proto;
-	} else if (!memcmp(skb->data, snapsig, sizeof(snapsig))) {
-		/* SNAP frame - collapse it */
-		/* RFC1042/802.1h encapsulated packet.  Treat the SNAP header
-		 * as part of the HW header and note the protocol. */
-		/* NOTE: prism2 doesn't collapse Appletalk frames (why?). */
-		skb_pull(skb, sizeof(rfc1042sig) + 2);
-		proto = *(__be16 *)(skb->data - 2);
-	}
-
-	if (ntohs(proto) > 1518) {
-		skb->protocol = proto;
-	} else {
-#ifdef IEEE_STANDARD
-		/* According to all standards, we should assume the data
-		 * portion contains 802.2 LLC information */
-		skb->protocol = htons(ETH_P_802_2);
-#else /* IEEE_STANDARD */
-		/* Unfortunately, it appears no actual 802.11 implementations
-		 * follow any standards specs.  They all appear to put a
-		 * 16-bit ethertype after the 802.11 header instead, so we'll
-		 * use that (and consider it part of the hardware header). */
-		/* Note that this means we can never support non-SNAP 802.2
-		 * frames (because we can't tell when we get one) */
-		skb->protocol = *(__be16 *)skb->data;
-		skb_pull(skb, 2);
-#endif /* IEEE_STANDARD */
-	}
-}
-
-
 /* check for fragmented data in priv->rx_skb. If the packet was no fragment
    or it was the last of a fragment set a skb containing the whole packet
    is returned for further processing. Otherwise we get NULL and are
@@ -5852,11 +5796,7 @@ static void at76_rx_data(struct at76_priv *priv)
 		skb->pkt_type = PACKET_OTHERHOST;
 	}
 
-	if (netdev->type == ARPHRD_ETHER) {
-		at76_ieee80211_to_eth(skb, priv->iw_mode);
-	} else {
-		at76_ieee80211_fixup(skb, priv->iw_mode);
-	}
+	at76_ieee80211_to_eth(skb, priv->iw_mode);
 
 	netdev->last_rx = jiffies;
 	netif_rx(skb);




From proski at gnu.org  Tue Jun  5 03:04:34 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 21:04:34 -0400
Subject: [at76c503a-develop] [PATCH 10/10] Fully separate scanning and
	monitoring
In-Reply-To: <20070605010347.32602.23942.stgit@dv.roinet.com>
References: <20070605010347.32602.23942.stgit@dv.roinet.com>
Message-ID: <20070605010434.32602.18362.stgit@dv.roinet.com>

Don't use management timer in monitor mode, it's not needed.  All that's
needed is to read the status from CMD_SCAN.  Remove monitor mode support
from at76_handle_mgmt_timeout_scan(), reorganize the logic to reduce
indentation.

Split at76_start_monitor() from at76_start_scan().

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  168 +++++++++++++++++++++++++++++++-----------------------------
 1 files changed, 86 insertions(+), 82 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 71d5fd8..1c23efc 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1506,8 +1506,7 @@ static int at76_start_scan(struct at76_priv *priv, int use_essid, int ir_step)
 
 	/* atmelwlandriver differs between scan type 0 and 1 (active/passive)
 	   For ad-hoc mode, it uses type 0 only. */
-	if ((priv->international_roaming == IR_ON && ir_step == 0) ||
-	    priv->iw_mode == IW_MODE_MONITOR)
+	if (priv->international_roaming == IR_ON && ir_step == 0)
 		scan.scan_type = SCAN_TYPE_PASSIVE;
 	else
 		scan.scan_type = priv->scan_mode;
@@ -1515,11 +1514,10 @@ static int at76_start_scan(struct at76_priv *priv, int use_essid, int ir_step)
 	/* INFO: For probe_delay, not multiplying by 1024 as this will be
 	   slightly less than min_channel_time
 	   (per spec: probe delay < min. channel time) */
-	if (priv->istate != MONITORING) {
-		scan.min_channel_time = cpu_to_le16(priv->scan_min_time);
-		scan.max_channel_time = cpu_to_le16(priv->scan_max_time);
-		scan.probe_delay = cpu_to_le16(priv->scan_min_time * 1000);
-	}
+	scan.min_channel_time = cpu_to_le16(priv->scan_min_time);
+	scan.max_channel_time = cpu_to_le16(priv->scan_max_time);
+	scan.probe_delay = cpu_to_le16(priv->scan_min_time * 1000);
+
 	if (priv->international_roaming == IR_ON && ir_step == 1)
 		scan.international_scan = 0;
 	else
@@ -1540,6 +1538,27 @@ static int at76_start_scan(struct at76_priv *priv, int use_essid, int ir_step)
 }
 
 
+/* Enable monitor mode */
+static int at76_start_monitor(struct at76_priv *priv)
+{
+	struct at76_req_scan scan;
+	int ret;
+
+	memset(&scan, 0, sizeof(struct at76_req_scan));
+	memset(scan.bssid, 0xff, ETH_ALEN);
+
+	scan.channel = priv->channel;
+	scan.scan_type = SCAN_TYPE_PASSIVE;
+	scan.international_scan = priv->international_roaming;
+
+	ret = at76_set_card_command(priv->udev, CMD_SCAN, &scan, sizeof(scan));
+	if (ret >= 0)
+		ret = at76_get_cmd_status(priv->udev, CMD_SCAN);
+
+	return ret;
+}
+
+
 static int at76_start_ibss(struct at76_priv *priv)
 {
 	struct at76_req_ibss bss;
@@ -2097,72 +2116,8 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 		 "scan_runs %d)",
 		 priv->netdev->name, __FUNCTION__, __LINE__, status,
 		 priv->istate, priv->scan_runs);
-	if (status == CMD_STATUS_COMPLETE) {
-		if (priv->istate == SCANNING) {
-			if (at76_debug & DBG_BSS_TABLE)
-				at76_dump_bss_table(priv);
-			switch (priv->scan_runs) {
-
-			case 1:
-				at76_assert(priv->international_roaming);
-				if ((ret=at76_get_mib_mdomain(priv, &mdomain)) < 0) {
-					err("at76_get_mib_mdomain returned %d", ret);
-				} else {
-					char obuf1[2*14+1], obuf2[2*14+1];
-
-					at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %s "
-						 "tx_powerlevel %s",
-						 priv->netdev->name,
-						 hex2str(obuf1, mdomain.channel_list,
-						    (sizeof(obuf1)-1)/2,'\0'),
-						 hex2str(obuf2, mdomain.tx_powerlevel,
-						    (sizeof(obuf2)-1)/2,'\0'));
-				}
-				if ((ret = at76_start_scan(priv, 0, 1)) < 0) {
-					err("%s: %s: start_scan (ANY) failed with %d",
-					    priv->netdev->name, __FUNCTION__, ret);
-				}
-				at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
-					 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-				mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
-				break;
-
-			case 2:
-				if ((ret = at76_start_scan(priv, 1, 1)) < 0) {
-					err("%s: %s: start_scan (SSID) failed with %d",
-					    priv->netdev->name, __FUNCTION__, ret);
-				}
-				at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
-					 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-				mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
-				break;
-
-			case 3:
-				priv->scan_state = SCAN_COMPLETED;
-				/* report the end of scan to user space */
-				at76_iwevent_scan_complete(priv->netdev);
-				priv->istate = JOINING;
-				/* call join_bss immediately after
-				   re-run of all other threads in at76_devent */
-				schedule_work(&priv->work_join);
-				break;
-
-			default:
-				err("unexpected priv->scan_runs %d", priv->scan_runs);
-			}
-			priv->scan_runs++;
-		} else {
-
-			at76_assert(priv->istate == MONITORING);
-			at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE: restart scan",
-				 priv->netdev->name);
-			at76_start_scan(priv, 0, 0);
-			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
-				 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-			mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
-		}
 
-	} else {
+	if (status != CMD_STATUS_COMPLETE) {
 		if ((status != CMD_STATUS_IN_PROGRESS) &&
 		    (status != CMD_STATUS_IDLE))
 			err("%s: %s: Bad scan status: %s",
@@ -2174,7 +2129,61 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
 			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		return;
 	}
+
+	if (at76_debug & DBG_BSS_TABLE)
+		at76_dump_bss_table(priv);
+	switch (priv->scan_runs) {
+
+	case 1:
+		at76_assert(priv->international_roaming);
+		if ((ret=at76_get_mib_mdomain(priv, &mdomain)) < 0) {
+			err("at76_get_mib_mdomain returned %d", ret);
+		} else {
+			char obuf1[2*14+1], obuf2[2*14+1];
+
+			at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %s "
+				 "tx_powerlevel %s", priv->netdev->name,
+				 hex2str(obuf1, mdomain.channel_list,
+					 (sizeof(obuf1) - 1) / 2, '\0'),
+				 hex2str(obuf2, mdomain.tx_powerlevel,
+					 (sizeof(obuf2) - 1) / 2, '\0'));
+			}
+		if ((ret = at76_start_scan(priv, 0, 1)) < 0) {
+			err("%s: %s: start_scan (ANY) failed with %d",
+			    priv->netdev->name, __FUNCTION__, ret);
+		}
+		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
+			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		break;
+
+	case 2:
+		if ((ret = at76_start_scan(priv, 1, 1)) < 0) {
+			err("%s: %s: start_scan (SSID) failed with %d",
+			    priv->netdev->name, __FUNCTION__, ret);
+		}
+		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
+			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
+		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		break;
+
+	case 3:
+		priv->scan_state = SCAN_COMPLETED;
+		/* report the end of scan to user space */
+		at76_iwevent_scan_complete(priv->netdev);
+		priv->istate = JOINING;
+		/* call join_bss immediately after
+		   re-run of all other threads in at76_devent */
+		schedule_work(&priv->work_join);
+		break;
+
+	default:
+		err("unexpected priv->scan_runs %d", priv->scan_runs);
+	}
+
+	priv->scan_runs++;
 }
 
 
@@ -4436,19 +4445,19 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 					     work_mgmt_timeout);
 
 	mutex_lock(&priv->mtx);
-	if ((priv->istate != SCANNING && priv->istate != MONITORING) ||
-	    (at76_debug & DBG_MGMT_TIMER))
-		/* this is normal behavior in states MONITORING, SCANNING ... */
+
+	/* timeouts are normal in SCANNING state, otherwise report */
+	if ((priv->istate != SCANNING) || (at76_debug & DBG_MGMT_TIMER))
 		at76_dbg(DBG_PROGRESS, "%s: timeout, state %d", priv->netdev->name,
 			 priv->istate);
 
 	switch (priv->istate) {
 
-	case MONITORING:
 	case SCANNING:
 		at76_handle_mgmt_timeout_scan(priv);
 		break;
 
+	case MONITORING:
 	case JOINING:
 		at76_assert(0);
 		break;
@@ -4716,12 +4725,7 @@ static void at76_work_restart(struct work_struct *work)
 		schedule_work(&priv->work_scan);
 	} else {
 		priv->istate = MONITORING;
-		at76_start_scan(priv, 0, 0);
-		at76_dbg(DBG_MGMT_TIMER,
-			 "%s:%d: starting mgmt_timer for %d ticks",
-			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-		mod_timer(&priv->mgmt_timer,
-			  jiffies + SCAN_POLL_INTERVAL);
+		at76_start_monitor(priv);
 	}
 
 	mutex_unlock(&priv->mtx);




From proski at gnu.org  Tue Jun  5 04:00:55 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 04 Jun 2007 22:00:55 -0400
Subject: [at76c503a-develop] New TODO list.
Message-ID: <1181008855.31696.29.camel@dv>

Hello!

This is the current TODO list for the driver.  It's not my personal TODO
list.  Others are welcome to comment and to implement some of the items.
The last thing I want is to discourage others from coding.

I feel that the driver is approaching the point when it's on the par
with the existing drivers, such as hostap.  I'm not taking about
features, only about code quality and stability.  However, the
requirements for the new drivers are much higher.

The weird monitor mode implementation on top of scanning was giving me
nightmares, but I could sort it out.  The twisted initialization process
has been streamlined.  The remaining issues seem trivial in comparison.

Merging timers and workqueues turns out to be more tricky than I
expected, although it could lead to significant simplification of the
code.

The USB specific diagnostic macros raised some eyebrows during the
initial submission.  I think the best approach would be to use standard
printk, even if it means longer code.

The header file has survived Lindent just fine, but the C file is not
ready.  It still has excessive indentation in places, which will wrap
badly.  Also, Lindent insists that we use one newline between functions.
I changed one newline to two, perhaps I should change it back.

Lindent produces much better results if we give it all typedefs used in
the code.  This is my current Lindent:

indent -npro -kr -i8 -ts8 -sob -l80 -ss -ncs \
 -T s8 -T s16 -T s32 -T s64 \
 -T __s8 -T __s16 -T __s32 -T __s64 \
 -T u8 -T u16 -T u32 -T u64 \
 -T __u8 -T __u16 -T __u32 -T __u64 \
 -T __be16 -T __be32 -T __be64 \
 -T __le16 -T __le32 -T __le64 \
 -T size_t \
 "$@"

Wireless developers really don't like non-standard parameters (both
module and iwpriv parameters).  I think we'll need to bring their number
to the minimum.

I think the driver is quickly approaching to the point when it can be
re-submitted.  But we may get another list of requirements.

The current TODO list:


Patch available
---------------

Monitor mode should stay on one channel.

Separate monitor mode from the scanning code.


Required for kernel submission
------------------------------

Try to integrate timers and workqueues (if result is ugly, we'll be able
to argue that we have tried).

Fix last indentation issues (especially missing spaces around
operators).

Remove module parameters that can be set by iwpriv.


Nice to do
----------

Create corresponding "get" iwpriv calls.

Check rescheduled calls to see if they can be called directly.

Change diagnostics to avoid printing full path to the kernel log.

Integrate more functions.  In many cases, one function is called only in
one place, and the separation of the code is artificial.

Retest and reevaluate all locking.  Try to relax locks if safe.  In
particular, avoid locking hard irqs.

Share firmware with the PCI driver.


Wishlist
--------

Support WPA.

Port to mac80211.

-- 
Regards,
Pavel Roskin



From agx at sigxcpu.org  Tue Jun  5 09:32:05 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Tue, 5 Jun 2007 09:32:05 +0200
Subject: [at76c503a-develop] [PATCH 01/10] Merge
	at76_handle_mgmt_timeout() and at76_work_mgmt_timeout()
In-Reply-To: <20070605010347.32602.23942.stgit@dv.roinet.com>
References: <20070605010347.32602.23942.stgit@dv.roinet.com>
Message-ID: <20070605073205.GA26584@bogon.ms20.nix>

On Mon, Jun 04, 2007 at 09:03:47PM -0400, Pavel Roskin wrote:
> The later was just a trivial wrapper.
All applied and pushed out, thanks!
 -- Guido


From proski at gnu.org  Fri Jun  8 09:16:24 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 08 Jun 2007 03:16:24 -0400
Subject: [at76c503a-develop] [PATCH 2/2] Don't keep priv->interface,
	use USB interface provided in at76_probe()
In-Reply-To: <20070608071619.9966.71582.stgit@dv.roinet.com>
References: <20070608071619.9966.71582.stgit@dv.roinet.com>
Message-ID: <20070608071624.9966.94203.stgit@dv.roinet.com>

This reduces driver's dependency on USB internals.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   16 +++++++---------
 at76_usb.h |    1 -
 2 files changed, 7 insertions(+), 10 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index ddd890b..6ad97c8 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -2293,9 +2293,9 @@ static void at76_delete_device(struct at76_priv *priv)
 }
 
 
-static int at76_alloc_urbs(struct at76_priv *priv)
+static int at76_alloc_urbs(struct at76_priv *priv,
+			   struct usb_interface *interface)
 {
-	struct usb_interface *interface = priv->interface;
 	struct usb_endpoint_descriptor *endpoint;
 	struct usb_device *udev = priv->udev;
 	int i, buffer_size;
@@ -4039,7 +4039,8 @@ static struct ethtool_ops at76_ethtool_ops = {
  * because hotplug may try to configure the netdev _before_ (or parallel to)
  * the download of firmware
  */
-static int at76_init_new_device(struct at76_priv *priv)
+static int at76_init_new_device(struct at76_priv *priv,
+				struct usb_interface *interface)
 {
 	struct net_device *netdev = priv->netdev;
 	int ret;
@@ -4048,12 +4049,10 @@ static int at76_init_new_device(struct at76_priv *priv)
 	/* set up the endpoint information */
 	/* check out the endpoints */
 
-	priv->interface = priv->udev->actconfig->interface[0];
-
 	at76_dbg(DBG_DEVSTART, "USB interface: %d endpoints",
-		 priv->interface->cur_altsetting->desc.bNumEndpoints);
+		 interface->cur_altsetting->desc.bNumEndpoints);
 
-	if ((ret = at76_alloc_urbs(priv)) < 0)
+	if ((ret = at76_alloc_urbs(priv, interface)) < 0)
 		goto error;
 
 	/* get firmware version */
@@ -6196,10 +6195,9 @@ static int at76_probe(struct usb_interface *interface,
 	}
 
 	usb_set_intfdata(interface, priv);
-	priv->interface = interface;
 	priv->fwe = fwe;
 
-	ret = at76_init_new_device(priv);
+	ret = at76_init_new_device(priv, interface);
 	if (ret < 0)
 		at76_delete_device(priv);
 
diff --git a/at76_usb.h b/at76_usb.h
index de5f035..204fb12 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -463,7 +463,6 @@ struct at76_priv {
 	struct net_device *netdev;	/* net device pointer */
 	struct net_device_stats stats;
 	struct iw_statistics wstats;
-	struct usb_interface *interface;	/* the interface for this device */
 
 	struct sk_buff *rx_skb;	/* skbuff for receiving packets */
 	__u8 bulk_in_endpointAddr;	/* the address of the bulk in endpoint */




From proski at gnu.org  Fri Jun  8 09:16:19 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 08 Jun 2007 03:16:19 -0400
Subject: [at76c503a-develop] [PATCH 1/2] Decouple networking from firmware
	download
Message-ID: <20070608071619.9966.71582.stgit@dv.roinet.com>

Move all firmware related data from struct at76_priv to struct fwentry. 
Move struct fwentry to the header file.  Share the firmware data between
devices.

Never load firmware version or anything else into firmwares[], as one
broken device can mess it for others.  Use temporary structures instead.

Change at76_load_internal_fw() and at76_load_external_fw() not to
require struct at76_priv, which is allocated as part of the network
device.  at76_disconnect() should check if priv is allocated.

Don't use priv->istate to track the firmware loading, as it's done in a
predictable consecutive manner now.  No state machine is needed at this
point.  There should be no priv at all before the firmware is loaded. 
Until the device is fully initialized, priv->istate should be INIT. 

Don't use mutexes during firmware download for the same reason.  In
fact, they were used incorrectly since priv is not the same during
internal and external firmware download.

Parse firmware immediately after loading in a new function
at76_load_firmware() replacing at76_parse_fw() and parts of
at76_probe().

Don't access udev before usb_get_dev() is called and be careful to call
usb_put_dev() for all errors.

Improve error handling and diagnostics in the affected code.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  343 +++++++++++++++++++++++++++++-------------------------------
 at76_usb.h |   25 +++-
 2 files changed, 182 insertions(+), 186 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 1c23efc..ddd890b 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -46,11 +46,7 @@
 
 static int at76_debug = DBG_DEFAULTS;
 
-/* Firmware names */
-static struct fwentry {
-	const char *const fwname;
-	const struct firmware *fw;
-} firmwares[] = {
+static struct fwentry firmwares[] = {
 	[0]			      = { "" },
 	[BOARDTYPE_503_INTERSIL_3861] = { "atmel_at76c503-i3861.bin" },
 	[BOARDTYPE_503_INTERSIL_3863] = { "atmel_at76c503-i3863.bin" },
@@ -656,7 +652,7 @@ static int at76_get_hw_config(struct at76_priv *priv)
 	if (!hwcfg)
 		return -ENOMEM;
 
-	switch (priv->board_type) {
+	switch (priv->fwe->board_type) {
 
 	case BOARDTYPE_503_INTERSIL_3861:
 	case BOARDTYPE_503_INTERSIL_3863:
@@ -688,7 +684,7 @@ static int at76_get_hw_config(struct at76_priv *priv)
 
 	default:
 		err("Bad board type set (%d).  Unable to get hardware config.",
-		    priv->board_type);
+		    priv->fwe->board_type);
 		ret = -EINVAL;
 	}
 
@@ -2920,8 +2916,8 @@ static int at76_iw_handler_get_scan(struct net_device *netdev,
 		iwe->u.qual.level = (curr_bss->rssi * 100 / 42);
 		if (iwe->u.qual.level > 100)
 			iwe->u.qual.level = 100;
-		if ((priv->board_type == BOARDTYPE_503_INTERSIL_3861) ||
-		    (priv->board_type == BOARDTYPE_503_INTERSIL_3863)) {
+		if ((priv->fwe->board_type == BOARDTYPE_503_INTERSIL_3861) ||
+		    (priv->fwe->board_type == BOARDTYPE_503_INTERSIL_3863)) {
 			iwe->u.qual.qual = curr_bss->link_qual;
 		} else {
 			iwe->u.qual.qual = 0;
@@ -4018,8 +4014,8 @@ static void at76_ethtool_get_drvinfo(struct net_device *netdev,
 
 	snprintf(info->fw_version, sizeof(info->fw_version) - 1,
 		 "%d.%d.%d-%d",
-		 priv->fw_version.major, priv->fw_version.minor,
-		 priv->fw_version.patch, priv->fw_version.build);
+		 priv->fwe->fw_version.major, priv->fwe->fw_version.minor,
+		 priv->fwe->fw_version.patch, priv->fwe->fw_version.build);
 }
 
 
@@ -4047,6 +4043,7 @@ static int at76_init_new_device(struct at76_priv *priv)
 {
 	struct net_device *netdev = priv->netdev;
 	int ret;
+	struct mib_fw_version req_fw_version;
 
 	/* set up the endpoint information */
 	/* check out the endpoints */
@@ -4060,28 +4057,33 @@ static int at76_init_new_device(struct at76_priv *priv)
 		goto error;
 
 	/* get firmware version */
-	ret = at76_get_mib(priv->udev, MIB_FW_VERSION, &priv->fw_version,
-			   sizeof(priv->fw_version));
-	if ((ret < 0) || ((priv->fw_version.major == 0) &&
-			  (priv->fw_version.minor == 0) &&
-			  (priv->fw_version.patch == 0) &&
-			  (priv->fw_version.build == 0))) {
-		err("getting firmware failed with %d, or version is 0", ret);
+	ret = at76_get_mib(priv->udev, MIB_FW_VERSION, &req_fw_version,
+			   sizeof(req_fw_version));
+	if (ret < 0) {
+		err("error %d getting firmware version", ret);
+		ret = -ENODEV;
+		goto error;
+	}
+
+	if ((req_fw_version.major == 0) &&
+	    (req_fw_version.minor == 0) &&
+	    (req_fw_version.patch == 0) &&
+	    (req_fw_version.build == 0)) {
+		err("firmware version consists of all zeroes");
 		err("this probably means that the ext. fw was not loaded correctly");
-		if(ret >= 0)
-			ret = -ENODEV;
+		ret = -ENODEV;
 		goto error;
 	}
 
 	/* fw 0.84 doesn't send FCS with rx data */
-	if (priv->fw_version.major == 0 && priv->fw_version.minor <= 84)
+	if (req_fw_version.major == 0 && req_fw_version.minor <= 84)
 		priv->rx_data_fcs_len = 0;
 	else
 		priv->rx_data_fcs_len = 4;
 
 	info("firmware version %d.%d.%d #%d (fcs_len %d)",
-	     priv->fw_version.major, priv->fw_version.minor,
-	     priv->fw_version.patch, priv->fw_version.build,
+	     req_fw_version.major, req_fw_version.minor,
+	     req_fw_version.patch, req_fw_version.build,
 	     priv->rx_data_fcs_len);
 
 	/* MAC address */
@@ -4149,58 +4151,44 @@ static int at76_init_new_device(struct at76_priv *priv)
 
 
 /* Download external firmware */
-static int at76_load_external_fw(struct at76_priv *priv)
+static int at76_load_external_fw(struct usb_device *udev, struct fwentry *fwe)
 {
 	int ret;
 	int op_mode;
 
-	mutex_lock(&priv->mtx);
-
-	op_mode = at76_get_op_mode(priv->udev);
+	op_mode = at76_get_op_mode(udev);
 	at76_dbg(DBG_DEVSTART, "opmode %d", op_mode);
 
 	if (op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {
 		err("unexpected opmode %d", op_mode);
-		ret = -EINVAL;
-		goto end_external_fw;
+		return -EINVAL;
 	}
 
-	if (priv->extfw && priv->extfw_size) {
-		ret = at76_download_external_fw(priv->udev, priv->extfw,
-						priv->extfw_size);
-		if (ret < 0) {
-			err("Downloading external firmware failed: %d", ret);
-			goto end_external_fw;
-		}
-		if (priv->board_type == BOARDTYPE_505A_RFMD_2958) {
-			info("200 ms delay for board type 7");
-			/* can we do this with priv->mtx down? */
-			schedule_timeout_interruptible(HZ / 5 + 1);
-		}
-	}
-	priv->istate = INIT;
-	mutex_unlock(&priv->mtx);
-	if ((ret = at76_init_new_device(priv)) < 0)
+	if (!fwe->extfw || !fwe->extfw_size)
+		return -ENOENT;
+
+	ret = at76_download_external_fw(udev, fwe->extfw, fwe->extfw_size);
+	if (ret < 0) {
 		err("Downloading external firmware failed: %d", ret);
-	return ret;
+		return ret;
+	}
 
-      end_external_fw:
-	mutex_unlock(&priv->mtx);
-	return ret;
+	if (fwe->board_type == BOARDTYPE_505A_RFMD_2958) {
+		info("200 ms delay for board type 7");
+		schedule_timeout_interruptible(HZ / 5 + 1);
+	}
+	return 0;
 }
 
 
 /* Download internal firmware */
-static int at76_load_internal_fw(struct at76_priv *priv)
+static int at76_load_internal_fw(struct usb_device *udev, struct fwentry *fwe)
 {
 	int ret;
+	int need_remap = (fwe->board_type != BOARDTYPE_505A_RFMD_2958);
 
-	mutex_lock(&priv->mtx);
-
-	ret = at76_usbdfu_download(priv->udev, priv->intfw,
-				   priv->intfw_size,
-				   priv->board_type ==
-				   BOARDTYPE_505A_RFMD_2958 ? 2000 : 0);
+	ret = at76_usbdfu_download(udev, fwe->intfw, fwe->intfw_size,
+				   need_remap ? 0 : 2000);
 
 	if (ret < 0) {
 		err("downloading internal fw failed with %d", ret);
@@ -4210,20 +4198,17 @@ static int at76_load_internal_fw(struct at76_priv *priv)
 	at76_dbg(DBG_DEVSTART, "sending REMAP");
 
 	/* no REMAP for 505A (see SF driver) */
-	if (priv->board_type != BOARDTYPE_505A_RFMD_2958)
-		if ((ret = at76_remap(priv->udev)) < 0) {
+	if (need_remap)
+		if ((ret = at76_remap(udev)) < 0) {
 			err("sending REMAP failed with %d", ret);
 			goto end_internal_fw;
 		}
 
 	at76_dbg(DBG_DEVSTART, "sleeping for 2 seconds");
-	priv->istate = EXTFW_DOWNLOAD;
 	schedule_timeout_interruptible(2 * HZ + 1);
-	usb_reset_device(priv->udev);
-	priv->istate = WAIT_FOR_DISCONNECT;
+	usb_reset_device(udev);
 
       end_internal_fw:
-	mutex_unlock(&priv->mtx);
 	return ret;
 }
 
@@ -5299,8 +5284,8 @@ static void at76_calc_level(struct at76_priv *priv, struct at76_rx_buffer *buf,
 static void at76_calc_qual(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			   struct iw_quality* qual)
 {
-	if ((priv->board_type == BOARDTYPE_503_INTERSIL_3861) ||
-	    (priv->board_type == BOARDTYPE_503_INTERSIL_3863)) {
+	if ((priv->fwe->board_type == BOARDTYPE_503_INTERSIL_3861) ||
+	    (priv->fwe->board_type == BOARDTYPE_503_INTERSIL_3863)) {
 		qual->qual = buf->link_quality;
 	} else {
 		unsigned long msec;
@@ -5992,8 +5977,7 @@ static void at76_rx_tasklet(unsigned long param)
 }
 
 
-static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
-					       int board_type)
+static struct at76_priv *at76_alloc_new_device(struct usb_device *udev)
 {
 	struct net_device *netdev;
 	struct at76_priv *priv = NULL;
@@ -6036,7 +6020,7 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 
 	spin_lock_init(&priv->mgmt_spinlock);
 	priv->next_mgmt_bulk = NULL;
-	priv->istate = INTFW_DOWNLOAD;
+	priv->istate = INIT;
 
 	/* initialize empty BSS list */
 	priv->curr_bss = priv->new_bss = NULL;
@@ -6056,8 +6040,6 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 	priv->rx_tasklet.func = at76_rx_tasklet;
 	priv->rx_tasklet.data = (unsigned long)priv;
 
-	priv->board_type = board_type;
-
 	priv->pm_mode = AT76_PM_OFF;
 	priv->pm_period = 0;
 
@@ -6065,45 +6047,66 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 }
 
 
-/* Parse the firmware image */
-static int at76_parse_fw(struct at76_priv *priv, u8 *fw_data, int fw_size,
-			 int board_type)
+/* Load firmware into kernel memory and parse it */
+static struct fwentry *at76_load_firmware(struct usb_device *udev,
+					  int board_type)
 {
+	int ret;
 	char *str;
-	struct at76_fw_header *fw = (struct at76_fw_header *)fw_data;
+	struct at76_fw_header *fwh;
+	struct fwentry *fwe = &firmwares[board_type];
 
-	if (fw_size <= sizeof(*fw)) {
-		err("firmware is too short (0x%x)", fw_size);
-		return -EFAULT;
+	if (fwe->loaded) {
+		at76_dbg(DBG_FW, "re-using previously loaded fw");
+		return fwe;
+	}
+
+	at76_dbg(DBG_FW, "downloading firmware %s", fwe->fwname);
+	ret = request_firmware(&fwe->fw, fwe->fwname, &udev->dev);
+	if (ret < 0) {
+		err("firmware %s not found.", fwe->fwname);
+		err("You may need to download the firmware from "
+		    "https://developer.berlios.de/projects/at76c503a/");
+		return NULL;
+	}
+
+	at76_dbg(DBG_FW, "got it.");
+	fwh = (struct at76_fw_header *)(fwe->fw->data);
+
+	if (fwe->fw->size <= sizeof(*fwh)) {
+		err("firmware is too short (0x%zx)", fwe->fw->size);
+		return NULL;
 	}
 
 	/* CRC currently not checked */
-	priv->board_type = le32_to_cpu(fw->board_type);
-	priv->fw_version.major = fw->major;
-	priv->fw_version.minor = fw->minor;
-	priv->fw_version.patch = fw->patch;
-	priv->fw_version.build = fw->build;
-	str = (char *)fw_data + le32_to_cpu(fw->str_offset);
-	priv->intfw = (u8 *)fw + le32_to_cpu(fw->int_fw_offset);
-	priv->intfw_size = le32_to_cpu(fw->int_fw_len);
-	priv->extfw = (u8 *)fw + le32_to_cpu(fw->ext_fw_offset);
-	priv->extfw_size = le32_to_cpu(fw->ext_fw_len);
+	fwe->board_type = le32_to_cpu(fwh->board_type);
+	if (fwe->board_type != board_type) {
+		err("board type mismatch, requested %u, got %u", board_type,
+		    fwe->board_type);
+		return NULL;
+	}
+
+	fwe->fw_version.major = fwh->major;
+	fwe->fw_version.minor = fwh->minor;
+	fwe->fw_version.patch = fwh->patch;
+	fwe->fw_version.build = fwh->build;
+
+	str = (char *)fwh + le32_to_cpu(fwh->str_offset);
+	fwe->intfw = (u8 *)fwh + le32_to_cpu(fwh->int_fw_offset);
+	fwe->intfw_size = le32_to_cpu(fwh->int_fw_len);
+	fwe->extfw = (u8 *)fwh + le32_to_cpu(fwh->ext_fw_offset);
+	fwe->extfw_size = le32_to_cpu(fwh->ext_fw_len);
+
+	fwe->loaded = 1;
 
 	at76_dbg(DBG_DEVSTART, "firmware board %u version %u.%u.%u#%u "
-		 "(int %x:%tx, ext %x:%tx)", priv->board_type,
-		 priv->fw_version.major, priv->fw_version.minor,
-		 priv->fw_version.patch, priv->fw_version.build,
-		 priv->intfw_size, priv->intfw - fw_data,
-		 priv->extfw_size, priv->extfw - fw_data);
+		 "(int %x:%x, ext %x:%x)", board_type,
+		 fwh->major, fwh->minor, fwh->patch, fwh->build,
+		 le32_to_cpu(fwh->int_fw_offset), le32_to_cpu(fwh->int_fw_len),
+		 le32_to_cpu(fwh->ext_fw_offset), le32_to_cpu(fwh->ext_fw_len));
 	at76_dbg(DBG_DEVSTART, "firmware id %s", str);
 
-	if (priv->board_type != board_type) {
-		err("inconsistent board types %u != %u", board_type,
-		    priv->board_type);
-		return -EINVAL;
-	}
-
-	return 0;
+	return fwe;
 }
 
 
@@ -6112,38 +6115,23 @@ static int at76_probe(struct usb_interface *interface,
 {
 	int ret;
 	struct at76_priv *priv;
-	int board_type = (int)id->driver_info;
-	const char *const fw_name = firmwares[board_type].fwname;
-	const struct firmware *fw = firmwares[board_type].fw;
-	struct usb_device *udev = interface_to_usbdev(interface);
+	struct fwentry *fwe;
+	struct usb_device *udev;
 	int op_mode;
+	int need_ext_fw = 0;
+	struct mib_fw_version req_fw_version;
 
-	if (fw == NULL) {
-		at76_dbg(DBG_FW, "downloading firmware %s", fw_name);
-		ret = request_firmware(&fw, fw_name, &udev->dev);
-		if (ret == 0) {
-			at76_dbg(DBG_FW, "got it.");
-		} else {
-			err("firmware %s not found.", fw_name);
-			err("You may need to download the firmware from "
-			    "https://developer.berlios.de/projects/at76c503a/");
-			return ret;
-		}
-	} else
-		at76_dbg(DBG_FW, "re-using previously loaded fw");
-
-	usb_get_dev(udev);
+	udev = usb_get_dev(interface_to_usbdev(interface));
 
-	if ((priv = at76_alloc_new_device(udev, board_type)) == NULL) {
-		ret = -ENOMEM;
-		goto error_alloc;
+	/* Load firmware into kernel memory */
+	fwe = at76_load_firmware(udev, (int)id->driver_info);
+	if (!fwe) {
+		ret = -ENOENT;
+		goto error;
 	}
 
 	op_mode = at76_get_op_mode(udev);
 
-	usb_set_intfdata(interface, priv);
-	priv->interface = interface;
-
 	at76_dbg(DBG_DEVSTART, "opmode %d", op_mode);
 
 	/* we get OPMODE_NONE with 2.4.23, SMC2662W-AR ???
@@ -6152,73 +6140,72 @@ static int at76_probe(struct usb_interface *interface,
 	if (op_mode == OPMODE_HW_CONFIG_MODE) {
 		err("cannot handle a device in HW_CONFIG_MODE (opmode %d)",
 		    op_mode);
-		ret = -ENODEV;
+		ret = -EBUSY;
 		goto error;
 	}
 
-	/* parse the firmware */
-	ret = at76_parse_fw(priv, fw->data, fw->size, board_type);
-	if (ret)
-		goto error;
-
 	if (op_mode != OPMODE_NORMAL_NIC_WITH_FLASH
 	    && op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {
 		/* download internal firmware part */
 		at76_dbg(DBG_DEVSTART, "downloading internal firmware");
-		priv->istate = INTFW_DOWNLOAD;
-		ret = at76_load_internal_fw(priv);
-		if (ret)
+		ret = at76_load_internal_fw(udev, fwe);
+		if (ret < 0) {
+			err("error %d downloading internal firmware", ret);
 			goto error;
-	} else {
-		/* Internal firmware already inside the device.  Get firmware
-		 * version to test if external firmware is loaded.
-		 * This works only for newer firmware, e.g. the Intersil 0.90.x
-		 * says "control timeout on ep0in" and subsequent
-		 * at76_get_op_mode() fail too :-( */
-		int force_fw_dwl = 0;
-
-		/* if version >= 0.100.x.y or device with built-in flash we can
-		 * query the device for the fw version */
-		if ((priv->fw_version.major > 0 || priv->fw_version.minor >= 100)
-		    || (op_mode == OPMODE_NORMAL_NIC_WITH_FLASH)) {
-			ret = at76_get_mib(udev, MIB_FW_VERSION,
-					   &priv->fw_version,
-					   sizeof(priv->fw_version));
-		} else {
-			/* force fw download only if the device has no flash inside */
-			force_fw_dwl = 1;
 		}
+		usb_put_dev(udev);
+		return ret;
+	}
 
-		if ((force_fw_dwl) || (ret < 0)
-		    || ((priv->fw_version.major == 0)
-			&& (priv->fw_version.minor == 0)
-			&& (priv->fw_version.patch == 0)
-			&& (priv->fw_version.build == 0))) {
-			if (force_fw_dwl)
-				at76_dbg(DBG_DEVSTART,
-					 "forced download of external firmware part");
-			else
-				at76_dbg(DBG_DEVSTART,
-					 "cannot get firmware (ret %d) or all zeros "
-					 "- download external firmware", ret);
-
-			priv->istate = EXTFW_DOWNLOAD;
-			ret = at76_load_external_fw(priv);
-			if (ret)
-				goto error;
-		} else {
-			priv->istate = INIT;
-			if ((ret = at76_init_new_device(priv)) < 0)
-				goto error;
-		}
+	/* Internal firmware already inside the device.  Get firmware
+	 * version to test if external firmware is loaded.
+	 * This works only for newer firmware, e.g. the Intersil 0.90.x
+	 * says "control timeout on ep0in" and subsequent
+	 * at76_get_op_mode() fail too :-( */
+
+	/* if version >= 0.100.x.y or device with built-in flash we can
+	 * query the device for the fw version */
+	if ((fwe->fw_version.major > 0 || fwe->fw_version.minor >= 100)
+	    || (op_mode == OPMODE_NORMAL_NIC_WITH_FLASH)) {
+		ret = at76_get_mib(udev, MIB_FW_VERSION,
+				   &req_fw_version,
+				   sizeof(req_fw_version));
+		if ((ret < 0)
+		    || ((req_fw_version.major == 0)
+			&& (req_fw_version.minor == 0)
+			&& (req_fw_version.patch == 0)
+			&& (req_fw_version.build == 0)))
+		need_ext_fw = 1;
+	} else {
+		/* No way to check firmware version, reload to be sure */
+		need_ext_fw = 1;
 	}
-	return 0;
 
-      error:
-	at76_delete_device(priv);
+	if (need_ext_fw) {
+		at76_dbg(DBG_DEVSTART, "downloading external firmware");
+
+		ret = at76_load_external_fw(udev, fwe);
+		if (ret)
+			goto error;
+	}
+
+	priv = at76_alloc_new_device(udev);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	usb_set_intfdata(interface, priv);
+	priv->interface = interface;
+	priv->fwe = fwe;
+
+	ret = at76_init_new_device(priv);
+	if (ret < 0)
+		at76_delete_device(priv);
+
 	return ret;
 
-      error_alloc:
+      error:
 	usb_put_dev(udev);
 	return ret;
 }
@@ -6231,6 +6218,10 @@ static void at76_disconnect(struct usb_interface *interface)
 	priv = usb_get_intfdata(interface);
 	usb_set_intfdata(interface, NULL);
 
+	/* Disconnect after loading internal firmware */
+	if (!priv)
+		return;
+
 	info("%s disconnecting", priv->netdev->name);
 	at76_delete_device(priv);
 	info(DRIVER_NAME " disconnected");
diff --git a/at76_usb.h b/at76_usb.h
index 6169866..de5f035 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -388,9 +388,6 @@ enum infra_state {
 	JOINING,
 	CONNECTED,
 	STARTIBSS,
-	INTFW_DOWNLOAD,
-	EXTFW_DOWNLOAD,
-	WAIT_FOR_DISCONNECT,
 	MONITORING,
 };
 
@@ -447,6 +444,20 @@ struct rx_data_buf {
 /* how often do we try to submit a rx urb until giving up */
 #define NR_SUBMIT_RX_TRIES 8
 
+/* Data for one loaded firmware file */
+struct fwentry {
+	const char *const fwname;
+	const struct firmware *fw;
+	int extfw_size;
+	int intfw_size;
+	/* these point into a buffer managed by the firmware dl functions, no need to dealloc */
+	u8 *extfw;		/* points to external firmware part, extfw_size bytes long */
+	u8 *intfw;		/* points to internal firmware part, intfw_size bytes long */
+	u32 board_type;		/* BOARDTYPE_* in at76_usb_ids.h */
+	struct mib_fw_version fw_version;
+	int loaded;		/* Loaded and parsed successfully */
+};
+
 struct at76_priv {
 	struct usb_device *udev;	/* USB device pointer */
 	struct net_device *netdev;	/* net device pointer */
@@ -547,7 +558,6 @@ struct at76_priv {
 	int retries;		/* counts backwards while re-trying to send auth/assoc_req's */
 	u8 pm_mode;		/* power management mode: AT76_PM_{OFF, ON, SMART} */
 	u32 pm_period;		/* power manag. period in us */
-	u32 board_type;		/* BOARDTYPE_* in at76_usb_ids.h */
 
 	struct reg_domain const *domain;	/* the description of the regulatory domain */
 	int international_roaming;
@@ -564,7 +574,6 @@ struct at76_priv {
 	u8 regulatory_domain;
 
 	struct at76_card_config card_config;
-	struct mib_fw_version fw_version;
 
 	int rx_data_fcs_len;	/* length of the trailing FCS 
 				   (0 for fw <= 0.84.x, 4 otherwise) */
@@ -572,11 +581,7 @@ struct at76_priv {
 	/* store rx fragments until complete */
 	struct rx_data_buf rx_data[NR_RX_DATA_BUF];
 
-	int extfw_size;
-	int intfw_size;
-	/* these point into a buffer managed by the firmware dl functions, no need to dealloc */
-	u8 *extfw;		/* points to external firmware part, extfw_size bytes long */
-	u8 *intfw;		/* points to internal firmware part, intfw_size bytes long */
+	struct fwentry *fwe;
 	unsigned int device_unplugged:1;
 	unsigned int netdev_registered:1;
 	char obuf[2 * 256 + 1];	/* global debug output buffer to reduce stack usage */




From agx at sigxcpu.org  Sat Jun  9 18:38:30 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Sat, 9 Jun 2007 18:38:30 +0200
Subject: [at76c503a-develop] [PATCH 1/2] Decouple networking from
	firmware download
In-Reply-To: <20070608071619.9966.71582.stgit@dv.roinet.com>
References: <20070608071619.9966.71582.stgit@dv.roinet.com>
Message-ID: <20070609163830.GA7559@bogon.ms20.nix>

Hi Pavel,
On Fri, Jun 08, 2007 at 03:16:19AM -0400, Pavel Roskin wrote:
> Move all firmware related data from struct at76_priv to struct fwentry. 
> Move struct fwentry to the header file.  Share the firmware data between
> devices.
Applied, thanks. It seems one of the later patch series broke network
manager, which I didn't notice until now - I'll have a look, once I have
a bit spare time on my hands.
Cheers,
 -- Guido


From proski at gnu.org  Sat Jun  9 20:07:28 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat,  9 Jun 2007 14:07:28 -0400
Subject: [at76c503a-develop] [PATCH 1/2] Decouple networking
	from	firmware download
In-Reply-To: <20070609163830.GA7559@bogon.ms20.nix>
References: <20070608071619.9966.71582.stgit@dv.roinet.com>
	<20070609163830.GA7559@bogon.ms20.nix>
Message-ID: <20070609140728.l3wg4kwcwk4w8kgs@webmail.spamcop.net>

Hi Guido,

Quoting Guido Guenther <agx at sigxcpu.org>:

> On Fri, Jun 08, 2007 at 03:16:19AM -0400, Pavel Roskin wrote:
> > Move all firmware related data from struct at76_priv to struct fwentry.
> > Move struct fwentry to the header file.  Share the firmware data between
> > devices.
> Applied, thanks. It seems one of the later patch series broke network
> manager, which I didn't notice until now - I'll have a look, once I have
> a bit spare time on my hands.

It would be great if you give a bit more details.  I don't use Network Manager,
so I can mistake some of its quirk for the driver problem.  The version of
Network Manager and the distro could be useful too.

Actually, the last series should be good for the networking, since we don't
allocate a network device for loading the internal firmware anymore.  It may
also help with conversion to mac80211, because in this case all networking is
done by the mac80211 layer.

Maybe I did something wrong with usb_get_device/usb_put_device.  That's
something I need to recheck anyway.

--
Regards,
Pavel Roskin


From agx at sigxcpu.org  Sat Jun  9 21:57:26 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Sat, 9 Jun 2007 21:57:26 +0200
Subject: [at76c503a-develop] [PATCH 1/2] Decouple networking from
	firmware download
In-Reply-To: <20070609140728.l3wg4kwcwk4w8kgs@webmail.spamcop.net>
References: <20070608071619.9966.71582.stgit@dv.roinet.com>
	<20070609163830.GA7559@bogon.ms20.nix>
	<20070609140728.l3wg4kwcwk4w8kgs@webmail.spamcop.net>
Message-ID: <20070609195726.GA8457@bogon.ms20.nix>

Hi Pavel,
On Sat, Jun 09, 2007 at 02:07:28PM -0400, Pavel Roskin wrote:
> It would be great if you give a bit more details.  I don't use Network Manager,
> so I can mistake some of its quirk for the driver problem.  The version of
> Network Manager and the distro could be useful too.
> 
> Actually, the last series should be good for the networking, since we don't
> allocate a network device for loading the internal firmware anymore.  It may
> also help with conversion to mac80211, because in this case all networking is
> done by the mac80211 layer.
> 
> Maybe I did something wrong with usb_get_device/usb_put_device.  That's
> something I need to recheck anyway.
No, it definitetly wasn't the very last series of patches, might be a
problem with 2.6.22-rc4 - I'll have check with an older kernel in the
next days once near the wireless hardware again.
Cheers,
 -- Guido


From agx at sigxcpu.org  Sun Jun 10 15:35:26 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Sun, 10 Jun 2007 15:35:26 +0200
Subject: [at76c503a-develop] [PATCH 1/2] Decouple networking from
	firmware download
In-Reply-To: <20070609140728.l3wg4kwcwk4w8kgs@webmail.spamcop.net>
References: <20070608071619.9966.71582.stgit@dv.roinet.com>
	<20070609163830.GA7559@bogon.ms20.nix>
	<20070609140728.l3wg4kwcwk4w8kgs@webmail.spamcop.net>
Message-ID: <20070610133526.GC4412@bogon.ms20.nix>

On Sat, Jun 09, 2007 at 02:07:28PM -0400, Pavel Roskin wrote:
> It would be great if you give a bit more details.  I don't use Network Manager,
> so I can mistake some of its quirk for the driver problem.  The version of
> Network Manager and the distro could be useful too.
The problem doesn't only happen with at76_usb, also with sungem, it's
not a driver issue, sorry for the noise.
Cheers,
 -- Guido


From proski at gnu.org  Wed Jun 13 09:37:07 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 03:37:07 -0400
Subject: [at76c503a-develop] [PATCH 1/2] Don't use workqueue to reschedule
	IBSS creation
Message-ID: <20070613073707.28252.72349.stgit@dv.roinet.com>

Scheduling is done in process context, so it can be avoided.  Merge
at76_work_start_ibss() into at76_start_ibss().

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   93 ++++++++++++++++++++++++++----------------------------------
 at76_usb.h |    1 -
 2 files changed, 40 insertions(+), 54 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 6ad97c8..b8709ad 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1558,6 +1558,9 @@ static int at76_start_monitor(struct at76_priv *priv)
 static int at76_start_ibss(struct at76_priv *priv)
 {
 	struct at76_req_ibss bss;
+	int ret;
+
+	at76_assert(priv->istate == STARTIBSS);
 
 	memset(&bss, 0, sizeof(struct at76_req_ibss));
 	memset(bss.bssid, 0xff, ETH_ALEN);
@@ -1566,8 +1569,42 @@ static int at76_start_ibss(struct at76_priv *priv)
 	bss.bss_type = ADHOC_MODE;
 	bss.channel = priv->channel;
 
-	return at76_set_card_command(priv->udev, CMD_START_IBSS, &bss,
-				     sizeof(struct at76_req_ibss));
+	ret = at76_set_card_command(priv->udev, CMD_START_IBSS, &bss,
+				    sizeof(struct at76_req_ibss));
+	if (ret < 0) {
+		err("%s: start_ibss failed: %d", priv->netdev->name, ret);
+		return ret;
+	}
+
+	ret = at76_wait_completion(priv, CMD_START_IBSS);
+	if (ret != CMD_STATUS_COMPLETE) {
+		err("%s start_ibss failed to complete,%d",
+		    priv->netdev->name, ret);
+		return ret;
+	}
+
+	ret = at76_get_current_bssid(priv);
+	if (ret < 0)
+		return ret;
+
+	ret = at76_get_current_channel(priv);
+	if (ret < 0)
+		return ret;
+
+	/* not sure what this is good for ??? */
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC_MGMT;
+	priv->mib_buf.size = 1;
+	priv->mib_buf.index = IBSS_CHANGE_OK_OFFSET;
+	ret = at76_set_mib(priv, &priv->mib_buf);
+	if (ret < 0) {
+		err("%s: set_mib (ibss change ok) failed: %d", priv->netdev->name, ret);
+		return ret;
+	}
+
+	netif_carrier_on(priv->netdev);
+	netif_start_queue(priv->netdev);
+	return 0;
 }
 
 
@@ -4410,7 +4447,7 @@ static void at76_work_join(struct work_struct *work)
 	/* here we haven't found a matching (i)bss ... */
 	if (priv->iw_mode == IW_MODE_ADHOC) {
 		priv->istate = STARTIBSS;
-		schedule_work(&priv->work_start_ibss);
+		at76_start_ibss(priv);
 		goto end_join;
 	}
 	/* haven't found a matching BSS in infra mode - try again */
@@ -4767,55 +4804,6 @@ static void at76_work_set_promisc(struct work_struct *work)
 }
 
 
-static void at76_work_start_ibss(struct work_struct *work)
-{
-	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_start_ibss);
-	int ret;
-
-	mutex_lock(&priv->mtx);
-
-	at76_assert(priv->istate == STARTIBSS);
-	ret = at76_start_ibss(priv);
-	if (ret < 0) {
-		err("%s: start_ibss failed: %d", priv->netdev->name, ret);
-		goto end_startibss;
-	}
-
-	ret = at76_wait_completion(priv, CMD_START_IBSS);
-	if (ret != CMD_STATUS_COMPLETE) {
-		err("%s start_ibss failed to complete,%d",
-		    priv->netdev->name, ret);
-		goto end_startibss;
-	}
-
-	ret = at76_get_current_bssid(priv);
-	if (ret < 0)
-		goto end_startibss;
-
-	ret = at76_get_current_channel(priv);
-	if (ret < 0)
-		goto end_startibss;
-
-	/* not sure what this is good for ??? */
-	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
-	priv->mib_buf.type = MIB_MAC_MGMT;
-	priv->mib_buf.size = 1;
-	priv->mib_buf.index = IBSS_CHANGE_OK_OFFSET;
-	ret = at76_set_mib(priv, &priv->mib_buf);
-	if (ret < 0) {
-		err("%s: set_mib (ibss change ok) failed: %d", priv->netdev->name, ret);
-		goto end_startibss;
-	}
-
-	netif_carrier_on(priv->netdev);
-	netif_start_queue(priv->netdev);
-
-      end_startibss:
-	mutex_unlock(&priv->mtx);
-}
-
-
 static void at76_work_submit_rx(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
@@ -6004,7 +5992,6 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev)
 	INIT_WORK(&priv->work_restart, at76_work_restart);
 	INIT_WORK(&priv->work_scan, at76_work_scan);
 	INIT_WORK(&priv->work_set_promisc, at76_work_set_promisc);
-	INIT_WORK(&priv->work_start_ibss, at76_work_start_ibss);
 	INIT_WORK(&priv->work_submit_rx, at76_work_submit_rx);
 
 	priv->open_count = 0;
diff --git a/at76_usb.h b/at76_usb.h
index 204fb12..396dfc4 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -483,7 +483,6 @@ struct at76_priv {
 	struct work_struct work_restart;
 	struct work_struct work_scan;
 	struct work_struct work_set_promisc;
-	struct work_struct work_start_ibss;
 	struct work_struct work_submit_rx;
 
 	int nr_submit_rx_tries;	/* number of tries to submit an rx urb left */




From proski at gnu.org  Wed Jun 13 09:37:13 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 03:37:13 -0400
Subject: [at76c503a-develop] [PATCH 2/2] Remove module parameters for the
	settings controlled by	iwpriv
In-Reply-To: <20070613073707.28252.72349.stgit@dv.roinet.com>
References: <20070613073707.28252.72349.stgit@dv.roinet.com>
Message-ID: <20070613073713.28252.3161.stgit@dv.roinet.com>

Module parameters are not well suited for device-specific settings.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   29 +++++------------------------
 1 files changed, 5 insertions(+), 24 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index b8709ad..d6a1e68 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -174,11 +174,6 @@ MODULE_DEVICE_TABLE(usb, dev_table);
 static int rx_copybreak = 200;
 static int scan_min_time = 10;
 static int scan_max_time = 120;
-static int scan_mode = SCAN_TYPE_ACTIVE;
-static int preamble_type = PREAMBLE_TYPE_LONG;
-static int auth_mode;
-static int international_roaming; /* = IR_OFF */
-static int default_iw_mode = IW_MODE_INFRA;
 
 /* the supported rates of this hardware, bit7 marks a basic rate */
 static const u8 hw_rates[] = { 0x82, 0x84, 0x0b, 0x16 };
@@ -4136,21 +4131,21 @@ static int at76_init_new_device(struct at76_priv *priv,
 	     mac2str(priv->mac_addr), priv->domain->name, priv->regulatory_domain);
 
 	/* initializing */
-	priv->international_roaming = international_roaming;
+	priv->international_roaming = IR_OFF;
 	priv->channel = DEF_CHANNEL;
-	priv->iw_mode = default_iw_mode;
+	priv->iw_mode = IW_MODE_INFRA;
 	memset(priv->essid, 0, IW_ESSID_MAX_SIZE);
 	priv->rts_threshold = DEF_RTS_THRESHOLD;
 	priv->frag_threshold = DEF_FRAG_THRESHOLD;
 	priv->short_retry_limit = DEF_SHORT_RETRY_LIMIT;
 	priv->txrate = TX_RATE_AUTO;
-	priv->preamble_type = preamble_type;
+	priv->preamble_type = PREAMBLE_TYPE_LONG;
 	priv->beacon_period = 100;
 	priv->beacons_last_qual = jiffies_to_msecs(jiffies);
-	priv->auth_mode = auth_mode ? WLAN_AUTH_SHARED_KEY : WLAN_AUTH_OPEN;
+	priv->auth_mode = WLAN_AUTH_OPEN;
 	priv->scan_min_time = scan_min_time;
 	priv->scan_max_time = scan_max_time;
-	priv->scan_mode = scan_mode;
+	priv->scan_mode = SCAN_TYPE_ACTIVE;
 
 	netdev->flags &= ~IFF_MULTICAST; /* not yet or never */
 	netdev->open = at76_open;
@@ -6257,20 +6252,6 @@ module_param_named(debug, at76_debug, int, 0600);
 MODULE_PARM_DESC(debug, "Debugging level");
 module_param(rx_copybreak, int, 0400);
 MODULE_PARM_DESC(rx_copybreak, "rx packet copy threshold");
-module_param(scan_min_time, int, 0400);
-MODULE_PARM_DESC(scan_min_time, "scan min channel time (default: 10)");
-module_param(scan_max_time, int, 0400);
-MODULE_PARM_DESC(scan_max_time, "scan max channel time (default: 120)");
-module_param(scan_mode, int, 0400);
-MODULE_PARM_DESC(scan_mode, "scan mode: 0 active (with ProbeReq, default), 1 passive");
-module_param(preamble_type, int, 0400);
-MODULE_PARM_DESC(preamble_type, "preamble type: 0 long (default), 1 short");
-module_param(auth_mode, int, 0400);
-MODULE_PARM_DESC(auth_mode, "authentication mode: 0 open system (default), 1 shared secret");
-module_param(international_roaming, int, 0400);
-MODULE_PARM_DESC(international_roaming, "enable international roaming: 0 (no, default), 1 (yes)");
-module_param(default_iw_mode, int, 0400);
-MODULE_PARM_DESC(default_iw_mode, "default IW mode for a new device: 1 (ad-hoc), 2 (infrastructure, def.), 6 (monitor mode)");
 
 module_init(at76_mod_init);
 module_exit(at76_mod_exit);




From proski at gnu.org  Wed Jun 13 09:59:00 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 03:59:00 -0400
Subject: [at76c503a-develop] [PATCH] Provide compatibility for older kernels
	in a separate file
Message-ID: <20070613075900.30273.12081.stgit@dv.roinet.com>

Remove all Linux 2.6.21 compatibility from the driver - it shouldn't be
there for kernel submission.  Move all compatibility code to a separate
file compat.h.  Include it forcedly with the "-include" option.  Add
a makefile option to disable config.h inclusion.

Provide compatibility as far back as Linux 2.6.19 - it's not really hard
once the infrastructure is in place.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 Makefile   |    4 ++++
 at76_usb.c |   40 +++++++---------------------------------
 compat.h   |   43 +++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 54 insertions(+), 33 deletions(-)

diff --git a/Makefile b/Makefile
index 665906c..7cb3b48 100644
--- a/Makefile
+++ b/Makefile
@@ -39,6 +39,10 @@ SPECFILE = at76_usb.spec
 
 DISTFILES = $(SRCS) Makefile README COPYING CHANGELOG kernel_patch.diff
 
+ifndef NO_COMPAT_HEADERS
+EXTRA_CFLAGS += -include $(obj)/compat.h
+endif
+
 # get the version from at76_usb.h
 ifndef M
 VERSION = $(shell sed -n 's/^\#define.*DRIVER_VERSION.*"\(.*\)".*$$/\1/p' at76_usb.h)
diff --git a/at76_usb.c b/at76_usb.c
index d6a1e68..5039288 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -5455,13 +5455,9 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 #endif /* IEEE_STANDARD */
 	}
 
-#ifdef SKB_WITH_OVERHEAD
 	skb_set_mac_header(skb, -(int)sizeof(struct ethhdr));
 	eth_hdr_p = (struct ethhdr *)skb_mac_header(skb);
-#else
-	eth_hdr_p = (struct ethhdr *)(skb->data - sizeof(struct ethhdr));
-	skb->mac.raw = (unsigned char *)eth_hdr_p;
-#endif
+
 	if (build_ethhdr) {
 		/* This needs to be done in this order (eth_hdr_p->h_dest may
 		 * overlap src_addr) */
@@ -5494,14 +5490,6 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 }
 
 
-#ifndef SKB_WITH_OVERHEAD
-static inline void skb_reset_mac_header(struct sk_buff *skb)
-{
-	skb->mac.raw = skb->data;
-}
-#endif
-
-
 /* check for fragmented data in priv->rx_skb. If the packet was no fragment
    or it was the last of a fragment set a skb containing the whole packet
    is returned for further processing. Otherwise we get NULL and are
@@ -5543,17 +5531,10 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 		 hex2str(priv->obuf, data,
 		    min((int)(sizeof(priv->obuf) - 1) / 2, 32), '\0'));
 
-#ifdef SKB_WITH_OVERHEAD
-	at76_dbg(DBG_RX_FRAGS_SKB, "%s: incoming skb: head %p data %p "
-		 "tail %d end %d len %d",
-		 priv->netdev->name, skb->head, skb->data, skb->tail,
-		 skb->end, skb->len);
-#else
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: incoming skb: head %p data %p "
-		 "tail %p end %p len %d",
-		 priv->netdev->name, skb->head, skb->data, skb->tail,
-		 skb->end, skb->len);
-#endif
+		 "tail %p end %p len %d", priv->netdev->name, skb->head,
+		 skb->data, skb_tail_pointer(skb), skb_end_pointer(skb),
+		 skb->len);
 
 	if (data_len < 0) {
 		/* make sure data starts in the buffer */
@@ -5587,17 +5568,10 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 	/* remove FCS at end */
 	skb_trim(skb, length);
 
-#ifdef SKB_WITH_OVERHEAD
-	at76_dbg(DBG_RX_FRAGS_SKB, "%s: trimmed skb: head %p data %p tail %d "
-		 "end %d len %d data %p data_len %d",
-		 priv->netdev->name, skb->head, skb->data, skb->tail,
-		 skb->end, skb->len, data, data_len);
-#else
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: trimmed skb: head %p data %p tail %p "
-		 "end %p len %d data %p data_len %d",
-		 priv->netdev->name, skb->head, skb->data, skb->tail,
-		 skb->end, skb->len, data, data_len);
-#endif
+		 "end %p len %d data %p data_len %d", priv->netdev->name,
+		 skb->head, skb->data, skb_tail_pointer(skb),
+		 skb_end_pointer(skb), skb->len, data, data_len);
 
 	/* look if we've got a chain for the sender address.
 	   afterwards optr points to first free or the oldest entry,
diff --git a/compat.h b/compat.h
new file mode 100644
index 0000000..32a66c7
--- /dev/null
+++ b/compat.h
@@ -0,0 +1,43 @@
+/* Compatibility layer for older kernels */
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#include <linux/skbuff.h>
+static inline unsigned char *skb_mac_header(const struct sk_buff *skb)
+{
+	return skb->mac.raw;
+}
+
+static inline void skb_reset_mac_header(struct sk_buff *skb)
+{
+	skb->mac.raw = skb->data;
+}
+
+static inline void skb_set_mac_header(struct sk_buff *skb, const int offset)
+{
+	skb->mac.raw = skb->data + offset;
+}
+
+static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
+{
+	return skb->end;
+}
+
+static inline unsigned char *skb_tail_pointer(const struct sk_buff *skb)
+{
+	return skb->tail;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#undef INIT_WORK
+#define INIT_WORK(_work, _func)						\
+	do {								\
+		INIT_LIST_HEAD(&(_work)->entry);			\
+		(_work)->pending = 0;					\
+		PREPARE_WORK((_work), (void (*)(void *))(_func),	\
+			     (void *)(_work));				\
+		init_timer(&(_work)->timer);				\
+	} while (0)
+#endif




From proski at gnu.org  Thu Jun 14 03:10:56 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:10:56 -0400
Subject: [at76c503a-develop] [PATCH 01/12] Put copyright into compat.h
Message-ID: <20070614011056.25709.48658.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 compat.h |   11 ++++++++++-
 1 files changed, 10 insertions(+), 1 deletions(-)

diff --git a/compat.h b/compat.h
index 32a66c7..7759f04 100644
--- a/compat.h
+++ b/compat.h
@@ -1,4 +1,13 @@
-/* Compatibility layer for older kernels */
+/*
+ * Compatibility code for older Linux kernels
+ *
+ * Copyright (c) 2007 Pavel Roskin <proski at gnu.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
 
 #include <linux/version.h>
 




From proski at gnu.org  Thu Jun 14 03:11:01 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:01 -0400
Subject: [at76c503a-develop] [PATCH 02/12] Add compat.h to the source file
	list in Makefile
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011101.25709.92807.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 Makefile |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/Makefile b/Makefile
index 7cb3b48..4ea2c55 100644
--- a/Makefile
+++ b/Makefile
@@ -33,7 +33,7 @@ KERNELRELEASE = $(shell sed -ne 's/"//g;s/^\#define UTS_RELEASE //p' \
 
 obj-m = at76_usb.o
 
-SRCS = at76_usb.c at76_usb.h at76_usb_ids.h
+SRCS = at76_usb.c at76_usb.h at76_usb_ids.h compat.h
 
 SPECFILE = at76_usb.spec
 




From proski at gnu.org  Thu Jun 14 03:11:06 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:06 -0400
Subject: [at76c503a-develop] [PATCH 03/12] Simplify dumping hex data
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011106.25709.10687.stgit@dv.roinet.com>

Use rotating buffer pool in mac2str() and hex2str().  This makes it
unnecessary to allocate any buffers for either function, and also allows
to use mac2str() more than once in the same expression.  Move mac2str()
and hex2str() closer together.

Replace hex2str() with mac2str() where appropriate.  For other hex2str()
calls, always use "-" separator to improve readability.  Check buffer
length in hex2str().

Reformat some expressions along the way.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  316 +++++++++++++++++++++++++-----------------------------------
 at76_usb.h |    1 
 2 files changed, 134 insertions(+), 183 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 5039288..edc002b 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -486,63 +486,48 @@ static inline void at76_iwevent_bss_disconnect(struct net_device *netdev)
 }
 
 
-#define BIN2HEX(x) ((x) < 10 ? '0'+(x) : (x)+'A'-10)
+#define HEX2STR_BUFFERS 4
+#define HEX2STR_MAX_LEN 64
+#define BIN2HEX(x) ((x) < 10 ? '0' + (x) : (x) + 'A' - 10)
 
-/* hexdump len many bytes from buf into obuf, separated by delim,
-   add a trailing \0 into obuf */
-static char *hex2str(char *obuf, void *buf, int len, char delim)
+/* Convert binary data into hex string */
+static char *hex2str(void *buf, int len)
 {
+	static atomic_t a = ATOMIC_INIT(0);
+	static char bufs[3 * HEX2STR_MAX_LEN + 1][HEX2STR_BUFFERS];
+	char *ret = bufs[atomic_inc_return(&a) & (HEX2STR_BUFFERS - 1)];
+	char *obuf = ret;
 	u8 *ibuf = buf;
-	char *ret = obuf;
+
+	if (len > HEX2STR_MAX_LEN)
+		len = HEX2STR_MAX_LEN;
+
+	if (len <= 0) {
+		ret[0] = '\0';
+		return ret;
+	}
 
 	while (len--) {
 		*obuf++ = BIN2HEX(*ibuf >> 4);
 		*obuf++ = BIN2HEX(*ibuf & 0xf);
-		if (delim != '\0')
-			*obuf++ = delim;
+		*obuf++ = '-';
 		ibuf++;
 	}
-	if (delim != '\0' && obuf > ret)
-		obuf--;		/* remove last inserted delimiter */
-	*obuf = '\0';
+	*(--obuf) = '\0';
 
 	return ret;
 }
 
 
-/* check if the given ssid is cloaked */
-static inline int at76_is_cloaked_ssid(u8 *ssid, int length)
-{
-	static const u8 zeros[32];
-
-	return (length == 0) ||
-	    (length == 1 && *ssid == ' ') ||
-	    (length > 0 && !memcmp(ssid, zeros, length));
-}
-
-
-static inline void at76_free_bss_list(struct at76_priv *priv)
-{
-	struct list_head *next, *ptr;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->bss_list_spinlock, flags);
-
-	priv->curr_bss = priv->new_bss = NULL;
-
-	list_for_each_safe(ptr, next, &priv->bss_list) {
-		list_del(ptr);
-		kfree(list_entry(ptr, struct bss_info, list));
-	}
-
-	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
-}
-
+#define MAC2STR_BUFFERS 4
 
 static inline char *mac2str(u8 *mac)
 {
-	static char str[6 * 3];
+	static atomic_t a = ATOMIC_INIT(0);
+	static char bufs[6 * 3][MAC2STR_BUFFERS];
+	char *str;
 
+	str = bufs[atomic_inc_return(&a) & (MAC2STR_BUFFERS - 1)];
 	sprintf(str, "%02x:%02x:%02x:%02x:%02x:%02x",
 		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 	return str;
@@ -578,6 +563,35 @@ static void at76_ledtrig_tx_activity(void)
 }
 
 
+/* check if the given ssid is cloaked */
+static inline int at76_is_cloaked_ssid(u8 *ssid, int length)
+{
+	static const u8 zeros[32];
+
+	return (length == 0) ||
+	    (length == 1 && *ssid == ' ') ||
+	    (length > 0 && !memcmp(ssid, zeros, length));
+}
+
+
+static inline void at76_free_bss_list(struct at76_priv *priv)
+{
+	struct list_head *next, *ptr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->bss_list_spinlock, flags);
+
+	priv->curr_bss = priv->new_bss = NULL;
+
+	list_for_each_safe(ptr, next, &priv->bss_list) {
+		list_del(ptr);
+		kfree(list_entry(ptr, struct bss_info, list));
+	}
+
+	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
+}
+
+
 static int at76_remap(struct usb_device *udev)
 {
 	int ret;
@@ -1144,8 +1158,7 @@ static int at76_dump_mib_mac_addr(struct at76_priv *priv)
 	dbg("%s: MIB MAC_ADDR: mac_addr %s res 0x%x 0x%x group_addr %s status %d %d %d %d",
 	       priv->netdev->name, mac2str(mac_addr->mac_addr),
 		   mac_addr->res[0], mac_addr->res[1],
-	       hex2str(priv->obuf, mac_addr->group_addr,
-		       min((int)(sizeof(priv->obuf)-1)/2, 4*ETH_ALEN), '\0'),
+	       hex2str(mac_addr->group_addr, 4 * ETH_ALEN),
 	       mac_addr->group_addr_status[0], mac_addr->group_addr_status[1],
 	       mac_addr->group_addr_status[2], mac_addr->group_addr_status[3]);
 
@@ -1174,25 +1187,16 @@ static int at76_dump_mib_mac_wep(struct at76_priv *priv)
 	}
 
 	dbg("%s: MIB MAC_WEP: priv_invoked %u def_key_id %u key_len %u "
-	       "excl_unencr %u wep_icv_err %u wep_excluded %u encr_level %u key %d: %s",
-	       priv->netdev->name, mac_wep->privacy_invoked,
-	       mac_wep->wep_default_key_id, mac_wep->wep_key_mapping_len,
-	       mac_wep->exclude_unencrypted,
-	       le32_to_cpu(mac_wep->wep_icv_error_count),
-	       le32_to_cpu(mac_wep->wep_excluded_count),
-	       mac_wep->encryption_level, mac_wep->wep_default_key_id,
-	       mac_wep->wep_default_key_id < 4 ? hex2str(priv->obuf,
-							 mac_wep->
-							 wep_default_keyvalue
-							 [mac_wep->
-							  wep_default_key_id],
-							 min((int)
-							     (sizeof(priv->obuf)
-							      - 1) / 2,
-							     mac_wep->
-							     encryption_level ==
-							     2 ? 13 : 5),
-							 '\0') :
+	    "excl_unencr %u wep_icv_err %u wep_excluded %u encr_level %u key %d: %s",
+	    priv->netdev->name, mac_wep->privacy_invoked,
+	    mac_wep->wep_default_key_id, mac_wep->wep_key_mapping_len,
+	    mac_wep->exclude_unencrypted,
+	    le32_to_cpu(mac_wep->wep_icv_error_count),
+	    le32_to_cpu(mac_wep->wep_excluded_count),
+	    mac_wep->encryption_level, mac_wep->wep_default_key_id,
+	    mac_wep->wep_default_key_id < 4 ?
+		hex2str(mac_wep->wep_default_keyvalue[mac_wep->wep_default_key_id],
+			mac_wep->encryption_level == 2 ? 13 : 5) :
 	       "<invalid key id>");
 
       err:
@@ -1241,9 +1245,7 @@ static int at76_dump_mib_mac_mgmt(struct at76_priv *priv)
 	       mac_mgmt->DTIM_period,
 	       mac_mgmt->CFP_period,
 	       mac2str(mac_mgmt->current_bssid),
-	       hex2str(priv->obuf, mac_mgmt->current_essid,
-		       min((int)(sizeof(priv->obuf) - 1) / 2,
-			   IW_ESSID_MAX_SIZE), '\0'),
+	       hex2str(mac_mgmt->current_essid, IW_ESSID_MAX_SIZE),
 	       mac_mgmt->current_bss_type,
 	       mac_mgmt->power_mgmt_mode,
 	       mac_mgmt->ibss_change,
@@ -1295,9 +1297,7 @@ static int at76_dump_mib_mac(struct at76_priv *priv)
 	       le16_to_cpu(mac->min_channel_time),
 	       le16_to_cpu(mac->max_channel_time),
 	       le16_to_cpu(mac->listen_interval),
-	       hex2str(priv->obuf, mac->desired_ssid,
-		       min((int)(sizeof(priv->obuf) - 1) / 2,
-			   IW_ESSID_MAX_SIZE), '\0'),
+	       hex2str(mac->desired_ssid, IW_ESSID_MAX_SIZE),
 	       mac2str(mac->desired_bssid), mac->desired_bsstype);
       err:
 	kfree(mac);
@@ -1405,22 +1405,22 @@ static int at76_get_mib_mdomain(struct at76_priv *priv, struct mib_mdomain *val)
 
 static void at76_dump_mib_mdomain(struct at76_priv *priv)
 {
-	char obuf1[2*14+1], obuf2[2*14+1]; /* to hexdump tx_powerlevel,
-					      channel_list */
 	int ret;
 	struct mib_mdomain mdomain;
 
-	if ((ret=at76_get_mib_mdomain(priv, &mdomain)) < 0) {
+	ret = at76_get_mib_mdomain(priv, &mdomain);
+	if (ret < 0) {
 		err("%s: at76_get_mib_mdomain returned %d", __FUNCTION__, ret);
 		return;
 	}
 
-	at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %s tx_powerlevel %s",
+	at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %s",
+		 priv->netdev->name,
+		 hex2str(mdomain.channel_list, sizeof(mdomain.channel_list)));
+
+	at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: tx_powerlevel %s",
 		 priv->netdev->name,
-		 hex2str(obuf1, mdomain.channel_list,
-			 (sizeof(obuf1) - 1) / 2, '\0'),
-		 hex2str(obuf2, mdomain.tx_powerlevel,
-			 (sizeof(obuf2) - 1) / 2, '\0'));
+		 hex2str(mdomain.tx_powerlevel, sizeof(mdomain.tx_powerlevel)));
 }
 
 
@@ -1740,8 +1740,7 @@ static int at76_send_mgmt_bulk(struct at76_priv *priv,
 		   implement a queue or silently modify the old msg */
 		err("%s: %s removed pending mgmt buffer %s",
 		    priv->netdev->name, __FUNCTION__,
-		    hex2str(priv->obuf, priv->next_mgmt_bulk,
-			    min((int)(sizeof(priv->obuf)) / 3, 64), ' '));
+		    hex2str(priv->next_mgmt_bulk, 64));
 		kfree(priv->next_mgmt_bulk);
 	}
 
@@ -1758,9 +1757,7 @@ static int at76_send_mgmt_bulk(struct at76_priv *priv,
 		at76_dbg(DBG_TX_MGMT, "%s: tx mgmt: wlen %d tx_rate %d pad %d %s",
 			 priv->netdev->name, le16_to_cpu(txbuf->wlength),
 			 txbuf->tx_rate, txbuf->padding,
-			 hex2str(priv->obuf, txbuf->packet,
-			    min((sizeof(priv->obuf) - 1) / 2,
-				(size_t) le16_to_cpu(txbuf->wlength)), '\0'));
+			 hex2str(txbuf->packet, le16_to_cpu(txbuf->wlength)));
 
 		/* txbuf was not consumed above -> send mgmt msg immediately */
 		memcpy(priv->bulk_out_buffer, txbuf,
@@ -1841,8 +1838,7 @@ static int at76_auth_req(struct at76_priv *priv, struct bss_info *bss,
 	if (seq_nr == 3) {
 		at76_dbg(DBG_TX_MGMT, "%s: AuthReq challenge: %s ...",
 			 priv->netdev->name,
-			 hex2str(priv->obuf, req->info_element,
-			     min((int)sizeof(priv->obuf) / 3, 18), ' '));
+			 hex2str(req->info_element, 18));
 	}
 
 	/* either send immediately (if no data tx is pending
@@ -1857,6 +1853,8 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	struct ieee80211_hdr_3addr *mgmt;
 	struct ieee80211_assoc_request *req;
 	struct ieee80211_info_element *tlv;
+	char essid[IW_ESSID_MAX_SIZE + 1];
+	int len;
 
 	at76_assert(bss != NULL);
 
@@ -1903,22 +1901,16 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	/* init. at76_priv tx header */
 	tx_buffer->wlength = cpu_to_le16((u8 *) tlv - (u8 *) mgmt);
 
-	{
-		/* output buffer for ssid and rates */
-		char orates[4 * 2 + 1];
-		int len;
-
-		tlv = req->info_element;
-		len = min_t(int, IW_ESSID_MAX_SIZE, tlv->len);
-		memcpy(priv->obuf, tlv->data, len);
-		priv->obuf[len] = '\0';
-		next_ie(&tlv); /* points to IE of rates now */
-		at76_dbg(DBG_TX_MGMT, "%s: AssocReq bssid %s capa x%04x ssid %s rates %s",
-			 priv->netdev->name, mac2str(mgmt->addr3),
-			 le16_to_cpu(req->capability), priv->obuf,
-			 hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
-			    '\0'));
-	}
+	tlv = req->info_element;
+	len = min_t(int, IW_ESSID_MAX_SIZE, tlv->len);
+	memcpy(essid, tlv->data, len);
+	essid[len] = '\0';
+	next_ie(&tlv); /* points to IE of rates now */
+	at76_dbg(DBG_TX_MGMT,
+		 "%s: AssocReq bssid %s capa x%04x ssid %s rates %s",
+		 priv->netdev->name, mac2str(mgmt->addr3),
+		 le16_to_cpu(req->capability), essid,
+		 hex2str(tlv->data, tlv->len));
 
 	/* either send immediately (if no data tx is pending
 	   or put it in pending list */
@@ -1935,6 +1927,8 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 	struct ieee80211_hdr_3addr *mgmt;
 	struct ieee80211_reassoc_request *req;
 	struct ieee80211_info_element *tlv;
+	char essid[IW_ESSID_MAX_SIZE + 1];
+	int len;
 
 	at76_assert(curr_bss != NULL);
 	at76_assert(new_bss != NULL);
@@ -1986,21 +1980,16 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 	/* init. at76_priv tx header */
 	tx_buffer->wlength = cpu_to_le16((u8 *)tlv-(u8 *)mgmt);
 
-	{
-		/* output buffer for rates and bssid */
-		char orates[4*2+1];
-		char ocurr[6*3+1];
-		tlv = req->info_element;
-		memcpy(priv->obuf, tlv->data, min(sizeof(priv->obuf),(size_t)tlv->len));
-		priv->obuf[IW_ESSID_MAX_SIZE] = '\0';
-		next_ie(&tlv); /* points to IE of rates now */
-		at76_dbg(DBG_TX_MGMT, "%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s",
-			 priv->netdev->name,
-			 hex2str(ocurr, req->current_ap, ETH_ALEN, ':'),
-			 mac2str(mgmt->addr3), le16_to_cpu(req->capability), priv->obuf,
-			 hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
-			    '\0'));
-	}
+	tlv = req->info_element;
+	len = min_t(int, IW_ESSID_MAX_SIZE, tlv->len);
+	memcpy(essid, tlv->data, len);
+	essid[len] = '\0';
+	next_ie(&tlv); /* points to IE of rates now */
+	at76_dbg(DBG_TX_MGMT,
+		 "%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s",
+		 priv->netdev->name, mac2str(req->current_ap),
+		 mac2str(mgmt->addr3), le16_to_cpu(req->capability), essid,
+		 hex2str(tlv->data, tlv->len));
 
 	/* either send immediately (if no data tx is pending
 	   or put it in pending list */
@@ -2090,7 +2079,6 @@ static void at76_dump_bss_table(struct at76_priv *priv)
 	struct bss_info *ptr;
 	unsigned long flags;
 	struct list_head *lptr;
-	char obuf_s[3*32];
 
 	spin_lock_irqsave(&priv->bss_list_spinlock, flags);
 
@@ -2104,13 +2092,9 @@ static void at76_dump_bss_table(struct at76_priv *priv)
 			 ptr, mac2str(ptr->bssid),
 			 ptr->channel,
 			 ptr->ssid,
-			 hex2str(priv->obuf, ptr->ssid,
-			       min((sizeof(priv->obuf) - 1) / 2,
-				   (size_t) ptr->ssid_len), '\0'),
+			 hex2str(ptr->ssid, ptr->ssid_len),
 			 ptr->capa,
-			 hex2str(obuf_s, ptr->rates,
-			       min(sizeof(obuf_s) / 3,
-				   (size_t) ptr->rates_len), ' '),
+			 hex2str(ptr->rates, ptr->rates_len),
 			 ptr->rssi, ptr->link_qual, ptr->noise_level);
 	}
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
@@ -2166,17 +2150,15 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 
 	case 1:
 		at76_assert(priv->international_roaming);
-		if ((ret=at76_get_mib_mdomain(priv, &mdomain)) < 0) {
+		if ((ret = at76_get_mib_mdomain(priv, &mdomain)) < 0) {
 			err("at76_get_mib_mdomain returned %d", ret);
 		} else {
-			char obuf1[2*14+1], obuf2[2*14+1];
-
 			at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %s "
 				 "tx_powerlevel %s", priv->netdev->name,
-				 hex2str(obuf1, mdomain.channel_list,
-					 (sizeof(obuf1) - 1) / 2, '\0'),
-				 hex2str(obuf2, mdomain.tx_powerlevel,
-					 (sizeof(obuf2) - 1) / 2, '\0'));
+				 hex2str(mdomain.channel_list,
+					 sizeof(mdomain.channel_list)),
+				 hex2str(mdomain.tx_powerlevel,
+					 sizeof(mdomain.tx_powerlevel)));
 			}
 		if ((ret = at76_start_scan(priv, 0, 1)) < 0) {
 			err("%s: %s: start_scan (ANY) failed with %d",
@@ -3828,21 +3810,15 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	tx_buffer->padding = at76_calc_padding(wlen);
 	submit_len = wlen + AT76_TX_HDRLEN + tx_buffer->padding;
 
-	{
-		at76_dbg(DBG_TX_DATA_CONTENT, "%s skb->data %s", priv->netdev->name,
-			 hex2str(priv->obuf, skb->data,
-			    min((int)(sizeof(priv->obuf) - 1) / 2, 32), '\0'));
-		at76_dbg(DBG_TX_DATA, "%s tx  wlen x%x pad x%x rate %d hdr %s",
-			 priv->netdev->name,
-			 le16_to_cpu(tx_buffer->wlength),
-			 tx_buffer->padding, tx_buffer->tx_rate,
-			 hex2str(priv->obuf, i802_11_hdr,
-			    min((sizeof(priv->obuf) - 1) / 2,
-				sizeof(struct ieee80211_hdr_3addr)), '\0'));
-		at76_dbg(DBG_TX_DATA_CONTENT, "%s payload %s", priv->netdev->name,
-			 hex2str(priv->obuf, payload,
-			    min((int)(sizeof(priv->obuf) - 1) / 2, 48), '\0'));
-	}
+	at76_dbg(DBG_TX_DATA_CONTENT, "%s skb->data %s", priv->netdev->name,
+		 hex2str(skb->data, 32));
+	at76_dbg(DBG_TX_DATA, "%s tx  wlen x%x pad x%x rate %d hdr %s",
+		 priv->netdev->name,
+		 le16_to_cpu(tx_buffer->wlength),
+		 tx_buffer->padding, tx_buffer->tx_rate,
+		 hex2str(i802_11_hdr, sizeof(*i802_11_hdr)));
+	at76_dbg(DBG_TX_DATA_CONTENT, "%s payload %s", priv->netdev->name,
+		 hex2str(payload, 48));
 
 	/* send stuff */
 	netif_stop_queue(netdev);
@@ -4612,9 +4588,7 @@ static int at76_startup_device(struct at76_priv *priv)
 
 		dbg("%s param: ssid %s (%s) mode %s ch %d wep %s key %d keylen %d",
 		       priv->netdev->name, ossid,
-		       hex2str(priv->obuf, priv->essid,
-			       min((int)(sizeof(priv->obuf)-1)/2,
-				   IW_ESSID_MAX_SIZE), '\0'),
+		       hex2str(priv->essid, IW_ESSID_MAX_SIZE),
 		       priv->iw_mode == IW_MODE_ADHOC ? "adhoc" : "infra",
 		       priv->channel,
 		       priv->wep_enabled ? "enabled" : "disabled",
@@ -4822,9 +4796,9 @@ static void at76_rx_mgmt_assoc(struct at76_priv *priv,
 	u16 capa = le16_to_cpu(resp->capability);
 	at76_dbg(DBG_RX_MGMT, "%s: rx AssocResp bssid %s capa x%04x status x%04x "
 		 "assoc_id x%04x rates %s",
-	    priv->netdev->name, mac2str(mgmt->addr3), capa, status, assoc_id,
-	    hex2str(priv->obuf, resp->info_element->data,
-		    min((size_t)resp->info_element->len, (sizeof(priv->obuf)-1)/2), '\0'));
+		 priv->netdev->name, mac2str(mgmt->addr3), capa, status,
+		 assoc_id, hex2str(resp->info_element->data,
+				   resp->info_element->len));
 	if (priv->istate == ASSOCIATING) {
 		at76_assert(priv->curr_bss != NULL);
 		if (priv->curr_bss == NULL)
@@ -4865,9 +4839,7 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *priv,
 	at76_dbg(DBG_RX_MGMT, "%s: rx ReAssocResp bssid %s capa x%04x status x%04x "
 		 "assoc_id x%04x rates %s",
 		 priv->netdev->name, mac2str(mgmt->addr3), capa, status, assoc_id,
-		 hex2str(priv->obuf, resp->info_element->data,
-		    min((size_t) resp->info_element->len,
-			(sizeof(priv->obuf) - 1) / 2), '\0'));
+		 hex2str(resp->info_element->data, resp->info_element->len));
 	if (priv->istate == REASSOCIATING) {
 		at76_assert(priv->new_bss != NULL);
 		if (priv->new_bss == NULL)
@@ -4915,8 +4887,7 @@ static void at76_rx_mgmt_disassoc(struct at76_priv *priv,
 	at76_dbg(DBG_RX_MGMT, "%s: rx DisAssoc bssid %s reason x%04x destination %s",
 		 priv->netdev->name, mac2str(mgmt->addr3),
 		 le16_to_cpu(resp->reason),
-		 hex2str(priv->obuf, mgmt->addr1,
-		    min((int)sizeof(priv->obuf) / 3, ETH_ALEN), ':'));
+		 mac2str(mgmt->addr1));
 	if (priv->istate == SCANNING || priv->istate == INIT)
 		return;
 
@@ -4968,15 +4939,12 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv, struct at76_rx_buffer *buf
 	at76_dbg(DBG_RX_MGMT, "%s: rx AuthFrame bssid %s alg %d seq_nr %d status %d "
 		 "destination %s",
 		 priv->netdev->name, mac2str(mgmt->addr3),
-		 alg, seq_nr, status,
-		 hex2str(priv->obuf, mgmt->addr1,
-		    min((int)sizeof(priv->obuf) / 3, ETH_ALEN), ':'));
+		 alg, seq_nr, status, mac2str(mgmt->addr1));
 
 	if (alg == WLAN_AUTH_SHARED_KEY && seq_nr == 2) {
 		at76_dbg(DBG_RX_MGMT, "%s: AuthFrame challenge %s ...",
 			 priv->netdev->name,
-			 hex2str(priv->obuf, resp->info_element,
-			    min((int)sizeof(priv->obuf) / 3, 18), ' '));
+			 hex2str(resp->info_element, 18));
 	}
 	if (priv->istate != AUTHENTICATING) {
 		info("%s: ignored AuthFrame in state %d",
@@ -5036,8 +5004,7 @@ static void at76_rx_mgmt_deauth(struct at76_priv *priv,
 		 "%s: rx DeAuth bssid %s reason x%04x destination %s",
 		 priv->netdev->name, mac2str(mgmt->addr3),
 		 le16_to_cpu(resp->reason),
-		 hex2str(priv->obuf, mgmt->addr1,
-		    min((int)sizeof(priv->obuf) / 3, ETH_ALEN), ':'));
+		 mac2str(mgmt->addr1));
 	if (priv->istate == DISASSOCIATING ||
 	    priv->istate == AUTHENTICATING ||
 	    priv->istate == ASSOCIATING ||
@@ -5200,9 +5167,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 				at76_dbg(DBG_RX_BEACON,
 					 "%s: SUPPORTED RATES %s",
 					 priv->netdev->name,
-					 hex2str(priv->obuf, tlv->data,
-					    min_t(int, (sizeof(priv->obuf)-1)/2,
-						  tlv->len), '\0'));
+					 hex2str(tlv->data, tlv->len));
 			}
 			break;
 
@@ -5221,9 +5186,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 		default:
 			at76_dbg(DBG_RX_BEACON, "%s: beacon IE id %d len %d %s",
 				 priv->netdev->name, tlv->id, tlv->len,
-				 hex2str(priv->obuf, tlv->data,
-				    min_t(int, (sizeof(priv->obuf)-1)/2,
-					  tlv->len), '\0'));
+				 hex2str(tlv->data, tlv->len));
 			break;
 		}
 
@@ -5337,9 +5300,7 @@ static void at76_rx_mgmt(struct at76_priv *priv, struct at76_rx_buffer *buf)
 
 	at76_dbg(DBG_RX_MGMT_CONTENT, "%s rx mgmt subtype x%x %s",
 		 priv->netdev->name, subtype,
-		 hex2str(priv->obuf, mgmt,
-		     min((sizeof(priv->obuf) - 1) / 2,
-			 (size_t) le16_to_cpu(buf->wlength)), '\0'));
+		 hex2str(mgmt, le16_to_cpu(buf->wlength)));
 
 	switch (subtype) {
 	case IEEE80211_STYPE_BEACON:
@@ -5413,8 +5374,7 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 	i802_11_hdr = (struct ieee80211_hdr_3addr *)skb->data;
 
 	dbg("%s: ENTRY skb len %d data %s", __FUNCTION__,
-	    skb->len, hex2str(priv->obuf, skb->data,
-			      min((int)sizeof(priv->obuf) / 3, 64), ' '));
+	    skb->len, hex2str(skb->data, 64));
 
 	skb_pull(skb, sizeof(struct ieee80211_hdr_3addr));
 
@@ -5478,15 +5438,9 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 		skb->protocol = htons(ETH_P_802_2);
 	}
 
-#ifdef DEBUG
-	char da[3*ETH_ALEN], sa[3*ETH_ALEN];
-#endif
 	dbg("%s: EXIT skb da %s sa %s proto x%04x len %d data %s", __FUNCTION__,
-	    hex2str(da, eth_hdr(skb)->h_dest, ETH_ALEN, ':'),
-	    hex2str(sa, eth_hdr(skb)->h_source, ETH_ALEN, ':'),
-	    ntohs(skb->protocol), skb->len,
-	    hex2str(priv->obuf, skb->data,
-		    min((int)sizeof(priv->obuf)/3,64), ' '));
+	    mac2str(eth_hdr(skb)->h_dest), mac2str(eth_hdr(skb)->h_source),
+	    ntohs(skb->protocol), skb->len, hex2str(skb->data, 64));
 }
 
 
@@ -5528,8 +5482,7 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 		 priv->netdev->name, frame_ctl,
 		 mac2str(i802_11_hdr->addr2),
 		 seqnr, fragnr, length, data_len,
-		 hex2str(priv->obuf, data,
-		    min((int)(sizeof(priv->obuf) - 1) / 2, 32), '\0'));
+		 hex2str(data, 32));
 
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: incoming skb: head %p data %p "
 		 "tail %p end %p len %d", priv->netdev->name, skb->head,
@@ -5889,8 +5842,7 @@ static void at76_rx_tasklet(unsigned long param)
 		 priv->netdev->name,
 		 buf->rx_rate, buf->rssi, buf->noise_level,
 		 buf->link_quality,
-		 hex2str(priv->obuf, i802_11_hdr,
-			 min((int)(sizeof(priv->obuf)-1)/2,48),'\0'));
+		 hex2str(i802_11_hdr, 48));
 	if (priv->istate == MONITORING) {
 		at76_rx_monitor_mode(priv);
 		goto finish;
diff --git a/at76_usb.h b/at76_usb.h
index 396dfc4..2a292b5 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -582,7 +582,6 @@ struct at76_priv {
 	struct fwentry *fwe;
 	unsigned int device_unplugged:1;
 	unsigned int netdev_registered:1;
-	char obuf[2 * 256 + 1];	/* global debug output buffer to reduce stack usage */
 	struct set_mib_buffer mib_buf;	/* global buffer for set_mib calls */
 
 	/* beacon counting */




From proski at gnu.org  Thu Jun 14 03:11:11 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:11 -0400
Subject: [at76c503a-develop] [PATCH 04/12] Fix more instances of bad
	formatting
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011111.25709.81220.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   60 ++++++++++++++++++++++++++++++++++++------------------------
 1 files changed, 36 insertions(+), 24 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index edc002b..af8369b 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -241,7 +241,7 @@ static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
 
 	memcpy(tmpbuf, buffer, bytes);
 
-	result = usb_control_msg(udev, usb_sndctrlpipe(udev,0),
+	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				 DFU_DNLOAD,
 				 USB_TYPE_CLASS | USB_DIR_OUT | USB_RECIP_INTERFACE,
 				 block,	/* Value */
@@ -299,7 +299,8 @@ static struct dfu_ctx *at76_dfu_alloc_ctx(struct usb_device *udev)
 {
 	struct dfu_ctx *ctx;
 
-	ctx = kmalloc(sizeof(struct dfu_ctx) + DFU_PACKETSIZE, GFP_KERNEL|GFP_DMA);
+	ctx = kmalloc(sizeof(struct dfu_ctx) + DFU_PACKETSIZE,
+		      GFP_KERNEL | GFP_DMA);
 	if (ctx) {
 		ctx->udev = udev;
 		ctx->buf = &(ctx[1]);
@@ -642,7 +643,7 @@ static inline int at76_get_hw_cfg_rfmd(struct usb_device *udev,
 static inline int get_hw_cfg_intersil(struct usb_device *udev,
 				      union at76_hwcfg *buf, int buf_size)
 {
-	return usb_control_msg(udev, usb_rcvctrlpipe(udev,0),
+	return usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			       0x33, INTERFACE_VENDOR_REQUEST_IN,
 			       ((0x09 << 8) | 0x02), 0,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
@@ -709,10 +710,10 @@ static int at76_get_hw_config(struct at76_priv *priv)
 static struct reg_domain const *at76_get_reg_domain(u16 code)
 {
 	static struct reg_domain const fd_tab[] = {
-		{0x10, "FCC (U.S)", 0x7ff},	/* ch 1-11 */
+		{0x10, "FCC (USA)", 0x7ff},	/* ch 1-11 */
 		{0x20, "IC (Canada)", 0x7ff},	/* ch 1-11 */
-		{0x30, "ETSI (Europe - (Spain+France)", 0x1fff},	/* ch 1-13 */
-		{0x31, "Spain", 0x600},	/* ch 10,11 */
+		{0x30, "ETSI (Europe except Spain and France)", 0x1fff},	/* ch 1-13 */
+		{0x31, "Spain", 0x600},		/* ch 10-11 */
 		{0x32, "France", 0x1e00},	/* ch 10-13 */
 		{0x40, "MKK (Japan)", 0x2000},	/* ch 14 */
 		{0x41, "MKK1 (Japan)", 0x3fff},	/* ch 1-14 */
@@ -1573,7 +1574,7 @@ static int at76_start_ibss(struct at76_priv *priv)
 
 	ret = at76_wait_completion(priv, CMD_START_IBSS);
 	if (ret != CMD_STATUS_COMPLETE) {
-		err("%s start_ibss failed to complete,%d",
+		err("%s start_ibss failed to complete, %d",
 		    priv->netdev->name, ret);
 		return ret;
 	}
@@ -1867,7 +1868,8 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	tlv = req->info_element;
 
 	/* make wireless header */
-	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_ASSOC_REQ);
+	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+				      IEEE80211_STYPE_ASSOC_REQ);
 
 	mgmt->duration_id = cpu_to_le16(0x8000);
 	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
@@ -1945,7 +1947,8 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 
 	/* make wireless header */
 	/* jal: encrypt this packet if wep_enabled is TRUE ??? */
-	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_REASSOC_REQ);
+	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+				      IEEE80211_STYPE_REASSOC_REQ);
 	mgmt->duration_id = cpu_to_le16(0x8000);
 	memcpy(mgmt->addr1, new_bss->bssid, ETH_ALEN);
 	memcpy(mgmt->addr2, priv->netdev->dev_addr, ETH_ALEN);
@@ -1978,7 +1981,7 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 	next_ie(&tlv);
 
 	/* init. at76_priv tx header */
-	tx_buffer->wlength = cpu_to_le16((u8 *)tlv-(u8 *)mgmt);
+	tx_buffer->wlength = cpu_to_le16((u8 *)tlv - (u8 *)mgmt);
 
 	tlv = req->info_element;
 	len = min_t(int, IW_ESSID_MAX_SIZE, tlv->len);
@@ -2015,7 +2018,8 @@ static int at76_disassoc_req(struct at76_priv *priv, struct bss_info *bss)
 	mgmt = &req->header;
 
 	/* make wireless header */
-	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_AUTH);
+	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+				      IEEE80211_STYPE_AUTH);
 	mgmt->duration_id = cpu_to_le16(0x8000);
 	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
 	memcpy(mgmt->addr2, priv->netdev->dev_addr, ETH_ALEN);
@@ -2252,7 +2256,7 @@ static void at76_delete_device(struct at76_priv *priv)
 	/* signal to _stop() that the device is gone */
 	priv->device_unplugged = 1;
 
-	at76_dbg(DBG_PROC_ENTRY, "%s: ENTER",__FUNCTION__);
+	at76_dbg(DBG_PROC_ENTRY, "%s: ENTER", __FUNCTION__);
 
 	if (priv->netdev_registered) {
 		unregister_netdev(priv->netdev);
@@ -3719,7 +3723,7 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	int submit_len;
 	struct at76_tx_buffer *tx_buffer = priv->bulk_out_buffer;
 	struct ieee80211_hdr_3addr *i802_11_hdr =
-	    (struct ieee80211_hdr_3addr *)&(tx_buffer->packet);
+	    (struct ieee80211_hdr_3addr *)(&tx_buffer->packet);
 	u8 *payload = tx_buffer->packet + sizeof(struct ieee80211_hdr_3addr);
 
 	if (netif_queue_stopped(netdev)) {
@@ -3757,8 +3761,10 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 		if (skb->data[2 * ETH_ALEN + 2] == rfc1042sig[0] &&
 		    skb->data[2 * ETH_ALEN + 2 + 1] == rfc1042sig[1]) {
 			/* higher layer delivered SNAP header - keep it */
-			memcpy(payload, skb->data + 2*ETH_ALEN+2, skb->len - 2*ETH_ALEN -2);
-			wlen = sizeof(struct ieee80211_hdr_3addr) + skb->len - 2*ETH_ALEN -2;
+			memcpy(payload, skb->data + 2 * ETH_ALEN + 2,
+			       skb->len - 2 * ETH_ALEN - 2);
+			wlen = sizeof(struct ieee80211_hdr_3addr) + skb->len -
+				   2 * ETH_ALEN - 2;
 		} else {
 			err("%s: %s: no support for non-SNAP 802.2 packets "
 			    "(DSAP x%02x SSAP x%02x cntrl x%02x)",
@@ -3773,9 +3779,9 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 		/* add RFC 1042 header in front */
 		memcpy(payload, rfc1042sig, sizeof(rfc1042sig));
 		memcpy(payload + sizeof(rfc1042sig),
-		       skb->data + 2*ETH_ALEN, skb->len - 2*ETH_ALEN);
+		       skb->data + 2 * ETH_ALEN, skb->len - 2 * ETH_ALEN);
 		wlen = sizeof(struct ieee80211_hdr_3addr) + sizeof(rfc1042sig) +
-			skb->len - 2*ETH_ALEN;
+		    skb->len - 2 * ETH_ALEN;
 	}
 
 	/* make wireless header */
@@ -5066,7 +5072,8 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 		if (priv->curr_bss == NULL)
 			goto rx_mgmt_beacon_end;
 		if (!compare_ether_addr(priv->curr_bss->bssid, mgmt->addr3)) {
-			mod_timer(&priv->mgmt_timer, jiffies+BEACON_TIMEOUT*HZ);
+			mod_timer(&priv->mgmt_timer,
+				  jiffies + BEACON_TIMEOUT * HZ);
 			priv->curr_bss->rssi = buf->rssi;
 			priv->beacons_received++;
 			goto rx_mgmt_beacon_end;
@@ -5089,9 +5096,11 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 
 	if (match == NULL) {
 		/* haven't found the bss in the list */
-		if ((match=kmalloc(sizeof(struct bss_info), GFP_ATOMIC)) == NULL) {
-			at76_dbg(DBG_BSS_TABLE, "%s: cannot kmalloc new bss info (%zd byte)",
-				    priv->netdev->name, sizeof(struct bss_info));
+		match = kmalloc(sizeof(struct bss_info), GFP_ATOMIC);
+		if (!match) {
+			at76_dbg(DBG_BSS_TABLE,
+				 "%s: cannot kmalloc new bss info (%zd byte)",
+				 priv->netdev->name, sizeof(struct bss_info));
 			goto rx_mgmt_beacon_end;
 		}
 		memset(match, 0, sizeof(*match));
@@ -5533,7 +5542,9 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 	/* determining the oldest entry doesn't cope with jiffies wrapping
 	   but I don't care to delete a young entry at these rare moments ... */
 
-	for(i=0,bptr=priv->rx_data,optr=NULL; i < NR_RX_DATA_BUF; i++,bptr++) {
+	bptr = priv->rx_data;
+	optr = NULL;
+	for (i = 0; i < NR_RX_DATA_BUF; i++, bptr++) {
 		if (bptr->skb != NULL) {
 			if (!compare_ether_addr(i802_11_hdr->addr2, bptr->sender))
 				break;
@@ -5561,14 +5572,15 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 		if (bptr->seqnr == seqnr) {
 			int left;
 			/* the fragment has the current sequence number */
-			if (((bptr->fragnr+1)&0xf) == fragnr) {
+			if (((bptr->fragnr + 1) & 0xf) == fragnr) {
 				bptr->last_rx = jiffies;
 				/* the next following fragment number ->
 				    add the data at the end */
 				/* is & 0xf necessary above ??? */
 
 				/* for test only ??? */
-				if ((left=skb_tailroom(bptr->skb)) < data_len) {
+				left = skb_tailroom(bptr->skb);
+				if (left < data_len) {
 					info("%s: only %d byte free (need %d)",
 					    priv->netdev->name, left, data_len);
 				} else




From proski at gnu.org  Thu Jun 14 03:11:17 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:17 -0400
Subject: [at76c503a-develop] [PATCH 05/12] Don't use double newline to
	separate functions
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011117.25709.95373.stgit@dv.roinet.com>

Lindent converts them to single newlines

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  170 ------------------------------------------------------------
 1 files changed, 0 insertions(+), 170 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index af8369b..f369c5f 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -225,7 +225,6 @@ struct dfu_ctx {
 	void *buf;
 };
 
-
 static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
 				   int block)
 {
@@ -252,7 +251,6 @@ static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
 	return result;
 }
 
-
 static int at76_dfu_get_status(struct dfu_ctx *ctx, struct dfu_status *status)
 {
 	int result;
@@ -269,7 +267,6 @@ static int at76_dfu_get_status(struct dfu_ctx *ctx, struct dfu_status *status)
 	return result;
 }
 
-
 static u8 at76_dfu_get_state(struct usb_device *udev, u8 *state)
 {
 	int result;
@@ -285,7 +282,6 @@ static u8 at76_dfu_get_state(struct usb_device *udev, u8 *state)
 	return result;
 }
 
-
 static inline u32 at76_get_timeout(struct dfu_status *s)
 {
 	u32 ret = (s->poll_timeout[2] << 16) | (s->poll_timeout[1] << 8) |
@@ -294,7 +290,6 @@ static inline u32 at76_get_timeout(struct dfu_status *s)
 	return ret;
 }
 
-
 static struct dfu_ctx *at76_dfu_alloc_ctx(struct usb_device *udev)
 {
 	struct dfu_ctx *ctx;
@@ -308,7 +303,6 @@ static struct dfu_ctx *at76_dfu_alloc_ctx(struct usb_device *udev)
 	return ctx;
 }
 
-
 /* if manifest_sync_timeout > 0 use this timeout (in msec) instead of the
    one reported by the device in state MANIFEST_SYNC */
 static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
@@ -448,7 +442,6 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 		return 0;
 }
 
-
 /* some abbrev. for wireless events */
 static inline void at76_iwevent_scan_complete(struct net_device *netdev)
 {
@@ -459,7 +452,6 @@ static inline void at76_iwevent_scan_complete(struct net_device *netdev)
 	at76_dbg(DBG_WE_EVENTS, "%s: SIOCGIWSCAN sent", netdev->name);
 }
 
-
 static inline void at76_iwevent_bss_connect(struct net_device *netdev,
 					    u8 *bssid)
 {
@@ -473,7 +465,6 @@ static inline void at76_iwevent_bss_connect(struct net_device *netdev,
 		 __FUNCTION__);
 }
 
-
 static inline void at76_iwevent_bss_disconnect(struct net_device *netdev)
 {
 	union iwreq_data wrqu;
@@ -486,7 +477,6 @@ static inline void at76_iwevent_bss_disconnect(struct net_device *netdev)
 		 __FUNCTION__);
 }
 
-
 #define HEX2STR_BUFFERS 4
 #define HEX2STR_MAX_LEN 64
 #define BIN2HEX(x) ((x) < 10 ? '0' + (x) : (x) + 'A' - 10)
@@ -519,7 +509,6 @@ static char *hex2str(void *buf, int len)
 	return ret;
 }
 
-
 #define MAC2STR_BUFFERS 4
 
 static inline char *mac2str(u8 *mac)
@@ -534,14 +523,12 @@ static inline char *mac2str(u8 *mac)
 	return str;
 }
 
-
 /* led trigger */
 static int tx_activity;
 static void at76_ledtrig_tx_timerfunc(unsigned long data);
 static DEFINE_TIMER(ledtrig_tx_timer, at76_ledtrig_tx_timerfunc, 0, 0);
 DEFINE_LED_TRIGGER(ledtrig_tx);
 
-
 static void at76_ledtrig_tx_timerfunc(unsigned long data)
 {
 	static int tx_lastactivity;
@@ -555,7 +542,6 @@ static void at76_ledtrig_tx_timerfunc(unsigned long data)
 	}
 }
 
-
 static void at76_ledtrig_tx_activity(void)
 {
 	tx_activity++;
@@ -563,7 +549,6 @@ static void at76_ledtrig_tx_activity(void)
 		mod_timer(&ledtrig_tx_timer, jiffies + msecs_to_jiffies(250));
 }
 
-
 /* check if the given ssid is cloaked */
 static inline int at76_is_cloaked_ssid(u8 *ssid, int length)
 {
@@ -574,7 +559,6 @@ static inline int at76_is_cloaked_ssid(u8 *ssid, int length)
 	    (length > 0 && !memcmp(ssid, zeros, length));
 }
 
-
 static inline void at76_free_bss_list(struct at76_priv *priv)
 {
 	struct list_head *next, *ptr;
@@ -592,7 +576,6 @@ static inline void at76_free_bss_list(struct at76_priv *priv)
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
 
-
 static int at76_remap(struct usb_device *udev)
 {
 	int ret;
@@ -604,7 +587,6 @@ static int at76_remap(struct usb_device *udev)
 	return 0;
 }
 
-
 static int at76_get_op_mode(struct usb_device *udev)
 {
 	int ret;
@@ -618,7 +600,6 @@ static int at76_get_op_mode(struct usb_device *udev)
 	return op_mode;
 }
 
-
 /* this loads a block of the second part of the firmware */
 static inline int at76_load_ext_fw_block(struct usb_device *udev, int i,
 					 void *buf, int bsize)
@@ -628,7 +609,6 @@ static inline int at76_load_ext_fw_block(struct usb_device *udev, int i,
 			       0x0802, i, buf, bsize, USB_CTRL_GET_TIMEOUT);
 }
 
-
 static inline int at76_get_hw_cfg_rfmd(struct usb_device *udev,
 				       union at76_hwcfg *buf, int buf_size)
 {
@@ -638,7 +618,6 @@ static inline int at76_get_hw_cfg_rfmd(struct usb_device *udev,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
 }
 
-
 /* Intersil boards use a different "value" for GetHWConfig requests */
 static inline int get_hw_cfg_intersil(struct usb_device *udev,
 				      union at76_hwcfg *buf, int buf_size)
@@ -649,7 +628,6 @@ static inline int get_hw_cfg_intersil(struct usb_device *udev,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
 }
 
-
 /* Get the hardware configuration for the adapter and place the appropriate
  * data in the appropriate fields of 'priv' (the GetHWConfig request and
  * interpretation of the result depends on the type of board we're dealing
@@ -706,7 +684,6 @@ static int at76_get_hw_config(struct at76_priv *priv)
 	return ret;
 }
 
-
 static struct reg_domain const *at76_get_reg_domain(u16 code)
 {
 	static struct reg_domain const fd_tab[] = {
@@ -733,7 +710,6 @@ static struct reg_domain const *at76_get_reg_domain(u16 code)
 	return (i >= tab_len) ? &unknown : &fd_tab[i];
 }
 
-
 static inline int at76_get_mib(struct usb_device *udev, u16 mib, void *buf,
 			       int buf_size)
 {
@@ -743,7 +719,6 @@ static inline int at76_get_mib(struct usb_device *udev, u16 mib, void *buf,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
 }
 
-
 /* Return positive number for status, negative for an error */
 static inline int at76_get_cmd_status(struct usb_device *udev, u8 cmd)
 {
@@ -759,7 +734,6 @@ static inline int at76_get_cmd_status(struct usb_device *udev, u8 cmd)
 	return stat_buf[5];
 }
 
-
 #define EXT_FW_BLOCK_SIZE 1024
 static int at76_download_external_fw(struct usb_device *udev, u8 *buf, int size)
 {
@@ -805,7 +779,6 @@ static int at76_download_external_fw(struct usb_device *udev, u8 *buf, int size)
 	return ret;
 }
 
-
 static int at76_set_card_command(struct usb_device *udev, int cmd, void *buf,
 				 int buf_size)
 {
@@ -832,7 +805,6 @@ static int at76_set_card_command(struct usb_device *udev, int cmd, void *buf,
 	return -ENOMEM;
 }
 
-
 #define MAKE_CMD_STATUS_CASE(c)	case (c): return #c
 static const char *at76_get_cmd_status_string(u8 cmd_status)
 {
@@ -851,7 +823,6 @@ static const char *at76_get_cmd_status_string(u8 cmd_status)
 	return "UNKNOWN";
 }
 
-
 /* TODO: should timeout */
 static int at76_wait_completion(struct at76_priv *priv, int cmd)
 {
@@ -880,7 +851,6 @@ static int at76_wait_completion(struct at76_priv *priv, int cmd)
 	return status;
 }
 
-
 static int at76_set_mib(struct at76_priv *priv, struct set_mib_buffer *buf)
 {
 	struct usb_device *udev = priv->udev;
@@ -913,7 +883,6 @@ static int at76_set_mib(struct at76_priv *priv, struct set_mib_buffer *buf)
 	return ret;
 }
 
-
 /* return < 0 on error, == 0 if no command sent, == 1 if cmd sent */
 static int at76_set_radio(struct at76_priv *priv, int on_off)
 {
@@ -931,7 +900,6 @@ static int at76_set_radio(struct at76_priv *priv, int on_off)
 	return ret;
 }
 
-
 /**
  * set_pm_mode - set current power save mode
  * (AT76_PM_OFF/AT76_PM_ON/AT76_PM_SMART)
@@ -954,7 +922,6 @@ static int at76_set_pm_mode(struct at76_priv *priv)
 	return ret;
 }
 
-
 /* sets the assoc id for power save mode */
 static int at76_set_associd(struct at76_priv *priv, u16 id)
 {
@@ -975,7 +942,6 @@ static int at76_set_associd(struct at76_priv *priv, u16 id)
 	return ret;
 }
 
-
 /* sets the listen interval for power save mode.
    really needed, as we have a similar parameter in the assocreq ??? */
 static int at76_set_listen_interval(struct at76_priv *priv, u16 interval)
@@ -998,7 +964,6 @@ static int at76_set_listen_interval(struct at76_priv *priv, u16 interval)
 	return ret;
 }
 
-
 static int at76_set_preamble(struct at76_priv *priv, u8 type)
 {
 	int ret = 0;
@@ -1015,7 +980,6 @@ static int at76_set_preamble(struct at76_priv *priv, u8 type)
 	return ret;
 }
 
-
 static int at76_set_frag(struct at76_priv *priv, u16 size)
 {
 	int ret = 0;
@@ -1032,7 +996,6 @@ static int at76_set_frag(struct at76_priv *priv, u16 size)
 	return ret;
 }
 
-
 static int at76_set_rts(struct at76_priv *priv, u16 size)
 {
 	int ret = 0;
@@ -1049,7 +1012,6 @@ static int at76_set_rts(struct at76_priv *priv, u16 size)
 	return ret;
 }
 
-
 static int at76_set_autorate_fallback(struct at76_priv *priv, int onoff)
 {
 	int ret = 0;
@@ -1066,7 +1028,6 @@ static int at76_set_autorate_fallback(struct at76_priv *priv, int onoff)
 	return ret;
 }
 
-
 /* set network device type for the current mode */
 static void at76_set_monitor_mode(struct at76_priv *priv)
 {
@@ -1081,7 +1042,6 @@ static void at76_set_monitor_mode(struct at76_priv *priv)
 	}
 }
 
-
 static int at76_add_mac_address(struct at76_priv *priv, void *addr)
 {
 	int ret = 0;
@@ -1099,7 +1059,6 @@ static int at76_add_mac_address(struct at76_priv *priv, void *addr)
 	return ret;
 }
 
-
 #if 0
 /* implemented to get promisc. mode working, but does not help.
    May still be useful for multicast eventually. */
@@ -1136,7 +1095,6 @@ static int set_group_address(struct at76_priv *priv, u8 *addr, int n)
 }
 #endif
 
-
 static int at76_dump_mib_mac_addr(struct at76_priv *priv)
 {
 	int ret = 0;
@@ -1169,7 +1127,6 @@ static int at76_dump_mib_mac_addr(struct at76_priv *priv)
 	return ret;
 }
 
-
 static int at76_dump_mib_mac_wep(struct at76_priv *priv)
 {
 	int ret = 0;
@@ -1206,7 +1163,6 @@ static int at76_dump_mib_mac_wep(struct at76_priv *priv)
 	return ret;
 }
 
-
 static int at76_dump_mib_mac_mgmt(struct at76_priv *priv)
 {
 	int ret = 0;
@@ -1260,7 +1216,6 @@ static int at76_dump_mib_mac_mgmt(struct at76_priv *priv)
 	return ret;
 }
 
-
 static int at76_dump_mib_mac(struct at76_priv *priv)
 {
 	int ret = 0;
@@ -1306,7 +1261,6 @@ static int at76_dump_mib_mac(struct at76_priv *priv)
 	return ret;
 }
 
-
 static int at76_dump_mib_phy(struct at76_priv *priv)
 {
 	int ret = 0;
@@ -1346,7 +1300,6 @@ static int at76_dump_mib_phy(struct at76_priv *priv)
 	return ret;
 }
 
-
 static int at76_dump_mib_local(struct at76_priv *priv)
 {
 	int ret = 0;
@@ -1376,7 +1329,6 @@ static int at76_dump_mib_local(struct at76_priv *priv)
 	return ret;
 }
 
-
 static int at76_get_mib_mdomain(struct at76_priv *priv, struct mib_mdomain *val)
 {
 	int ret = 0;
@@ -1403,7 +1355,6 @@ static int at76_get_mib_mdomain(struct at76_priv *priv, struct mib_mdomain *val)
 	return ret;
 }
 
-
 static void at76_dump_mib_mdomain(struct at76_priv *priv)
 {
 	int ret;
@@ -1424,7 +1375,6 @@ static void at76_dump_mib_mdomain(struct at76_priv *priv)
 		 hex2str(mdomain.tx_powerlevel, sizeof(mdomain.tx_powerlevel)));
 }
 
-
 static int at76_get_current_bssid(struct at76_priv *priv)
 {
 	int ret = 0;
@@ -1450,7 +1400,6 @@ static int at76_get_current_bssid(struct at76_priv *priv)
 	return ret;
 }
 
-
 static int at76_get_current_channel(struct at76_priv *priv)
 {
 	int ret = 0;
@@ -1472,7 +1421,6 @@ static int at76_get_current_channel(struct at76_priv *priv)
 	return ret;
 }
 
-
 /**
  * start_scan - start a scan
  *
@@ -1529,7 +1477,6 @@ static int at76_start_scan(struct at76_priv *priv, int use_essid, int ir_step)
 	return at76_set_card_command(priv->udev, CMD_SCAN, &scan, sizeof(scan));
 }
 
-
 /* Enable monitor mode */
 static int at76_start_monitor(struct at76_priv *priv)
 {
@@ -1550,7 +1497,6 @@ static int at76_start_monitor(struct at76_priv *priv)
 	return ret;
 }
 
-
 static int at76_start_ibss(struct at76_priv *priv)
 {
 	struct at76_req_ibss bss;
@@ -1603,7 +1549,6 @@ static int at76_start_ibss(struct at76_priv *priv)
 	return 0;
 }
 
-
 /* idx points into priv->bss */
 static int at76_join_bss(struct at76_priv *priv, struct bss_info *ptr)
 {
@@ -1626,7 +1571,6 @@ static int at76_join_bss(struct at76_priv *priv, struct bss_info *ptr)
 				     sizeof(struct at76_req_join));
 }
 
-
 /* calc. the padding from txbuf->wlength (which excludes the USB TX header)
    guess this is needed to compensate a flaw in the AT76C503A USB part ... */
 static inline int at76_calc_padding(int wlen)
@@ -1645,7 +1589,6 @@ static inline int at76_calc_padding(int wlen)
 	return 0;
 }
 
-
 /* we are doing a lot of things here in an interrupt. Need
    a bh handler (Watching TV with a TV card is probably
    a good test: if you see flickers, we are doing too much.
@@ -1663,7 +1606,6 @@ static void at76_read_bulk_callback(struct urb *urb)
 	return;
 }
 
-
 static void at76_write_bulk_callback(struct urb *urb)
 {
 	struct at76_priv *priv = urb->context;
@@ -1712,7 +1654,6 @@ static void at76_write_bulk_callback(struct urb *urb)
 		netif_wake_queue(priv->netdev);
 }
 
-
 /* send a management frame on bulk-out.
    txbuf->wlength must be set (in LE format !) */
 static int at76_send_mgmt_bulk(struct at76_priv *priv,
@@ -1783,14 +1724,12 @@ static int at76_send_mgmt_bulk(struct at76_priv *priv,
 	return ret;
 }
 
-
 /* Go to the next information element */
 static inline void next_ie(struct ieee80211_info_element **ie)
 {
 	*ie = (struct ieee80211_info_element *)(&(*ie)->data[(*ie)->len]);
 }
 
-
 /* challenge is the challenge string (in TLV format)
    we got with seq_nr 2 for shared secret authentication only and
    send in seq_nr 3 WEP encrypted to prove we have the correct WEP key;
@@ -1847,7 +1786,6 @@ static int at76_auth_req(struct at76_priv *priv, struct bss_info *bss,
 	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
-
 static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 {
 	struct at76_tx_buffer *tx_buffer;
@@ -1919,7 +1857,6 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
-
 /* we are currently associated to curr_bss and
    want to reassoc to new_bss */
 static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
@@ -1999,7 +1936,6 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
-
 static int at76_disassoc_req(struct at76_priv *priv, struct bss_info *bss)
 {
 	struct at76_tx_buffer *tx_buffer;
@@ -2039,7 +1975,6 @@ static int at76_disassoc_req(struct at76_priv *priv, struct bss_info *bss)
 	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
-
 /* the restart timer timed out */
 static void at76_restart_timeout(unsigned long par)
 {
@@ -2047,7 +1982,6 @@ static void at76_restart_timeout(unsigned long par)
 	schedule_work(&priv->work_restart);
 }
 
-
 /* we got to check the bss_list for old entries */
 static void at76_bss_list_timeout(unsigned long par)
 {
@@ -2077,7 +2011,6 @@ static void at76_bss_list_timeout(unsigned long par)
 	mod_timer(&priv->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
 }
 
-
 static void at76_dump_bss_table(struct at76_priv *priv)
 {
 	struct bss_info *ptr;
@@ -2104,7 +2037,6 @@ static void at76_dump_bss_table(struct at76_priv *priv)
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
 
-
 /* we got a timeout for a infrastructure mgmt packet */
 static void at76_mgmt_timeout(unsigned long par)
 {
@@ -2112,7 +2044,6 @@ static void at76_mgmt_timeout(unsigned long par)
 	schedule_work(&priv->work_mgmt_timeout);
 }
 
-
 /*
  * at76_work_mgmt_timeout_scan - expiry of management timer in istate SCANNING
  */
@@ -2200,7 +2131,6 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 	priv->scan_runs++;
 }
 
-
 /* Called after successful association */
 static void at76_work_assoc_done(struct work_struct *work)
 {
@@ -2245,7 +2175,6 @@ static void at76_work_assoc_done(struct work_struct *work)
 	mutex_unlock(&priv->mtx);
 }
 
-
 static void at76_delete_device(struct at76_priv *priv)
 {
 	int i;
@@ -2310,7 +2239,6 @@ static void at76_delete_device(struct at76_priv *priv)
 	at76_dbg(DBG_PROC_ENTRY, "%s: EXIT", __FUNCTION__);
 }
 
-
 static int at76_alloc_urbs(struct at76_priv *priv,
 			   struct usb_interface *interface)
 {
@@ -2384,7 +2312,6 @@ static int at76_alloc_urbs(struct at76_priv *priv,
 	return 0;
 }
 
-
 /* we only store the new mac address in netdev struct,
    it gets set when the netdev is opened. */
 static int at76_set_mac_address(struct net_device *netdev, void *addr)
@@ -2394,14 +2321,12 @@ static int at76_set_mac_address(struct net_device *netdev, void *addr)
 	return 1;
 }
 
-
 static struct net_device_stats *at76_get_stats(struct net_device *netdev)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
 	return &priv->stats;
 }
 
-
 static struct iw_statistics *at76_get_wireless_stats(struct net_device *netdev)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
@@ -2413,7 +2338,6 @@ static struct iw_statistics *at76_get_wireless_stats(struct net_device *netdev)
 	return &priv->wstats;
 }
 
-
 static void at76_set_multicast(struct net_device *netdev)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
@@ -2427,7 +2351,6 @@ static void at76_set_multicast(struct net_device *netdev)
 	}
 }
 
-
 /*******************************************************************************
  * at76_priv implementations of iw_handler functions:
  */
@@ -2465,7 +2388,6 @@ static int at76_iw_handler_commit(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_get_name(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    char *name, char *extra)
@@ -2475,7 +2397,6 @@ static int at76_iw_handler_get_name(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_set_freq(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_freq *freq, char *extra)
@@ -2527,7 +2448,6 @@ static int at76_iw_handler_set_freq(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_get_freq(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_freq *freq, char *extra)
@@ -2546,7 +2466,6 @@ static int at76_iw_handler_get_freq(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_set_mode(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    __u32 *mode, char *extra)
@@ -2567,7 +2486,6 @@ static int at76_iw_handler_set_mode(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_get_mode(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    __u32 * mode, char *extra)
@@ -2581,7 +2499,6 @@ static int at76_iw_handler_get_mode(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_get_range(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_point *data, char *extra)
@@ -2668,7 +2585,6 @@ static int at76_iw_handler_get_range(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_set_spy(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct iw_point *data, char *extra)
@@ -2687,7 +2603,6 @@ static int at76_iw_handler_set_spy(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_get_spy(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct iw_point *data, char *extra)
@@ -2707,7 +2622,6 @@ static int at76_iw_handler_get_spy(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_set_thrspy(struct net_device *netdev,
 				      struct iw_request_info *info,
 				      struct iw_point *data, char *extra)
@@ -2726,7 +2640,6 @@ static int at76_iw_handler_set_thrspy(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_get_thrspy(struct net_device *netdev,
 				      struct iw_request_info *info,
 				      struct iw_point *data, char *extra)
@@ -2745,7 +2658,6 @@ static int at76_iw_handler_get_thrspy(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_set_wap(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct sockaddr *ap_addr, char *extra)
@@ -2769,7 +2681,6 @@ static int at76_iw_handler_set_wap(struct net_device *netdev,
 	return -EIWCOMMIT;
 }
 
-
 static int at76_iw_handler_get_wap(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct sockaddr *ap_addr, char *extra)
@@ -2785,7 +2696,6 @@ static int at76_iw_handler_get_wap(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_set_scan(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    union iwreq_data *wrqu, char *extra)
@@ -2856,7 +2766,6 @@ static int at76_iw_handler_set_scan(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_get_scan(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_point *data, char *extra)
@@ -2982,7 +2891,6 @@ static int at76_iw_handler_get_scan(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_set_essid(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_point *data, char *extra)
@@ -3002,7 +2910,6 @@ static int at76_iw_handler_set_essid(struct net_device *netdev,
 	return -EIWCOMMIT;
 }
 
-
 static int at76_iw_handler_get_essid(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_point *data, char *extra)
@@ -3037,7 +2944,6 @@ static int at76_iw_handler_get_essid(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_set_rate(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_param *bitrate, char *extra)
@@ -3070,7 +2976,6 @@ static int at76_iw_handler_set_rate(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_get_rate(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_param *bitrate, char *extra)
@@ -3108,7 +3013,6 @@ static int at76_iw_handler_get_rate(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_set_rts(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct iw_param *rts, char *extra)
@@ -3132,7 +3036,6 @@ static int at76_iw_handler_set_rts(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_get_rts(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct iw_param *rts, char *extra)
@@ -3149,7 +3052,6 @@ static int at76_iw_handler_get_rts(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_set_frag(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_param *frag, char *extra)
@@ -3173,7 +3075,6 @@ static int at76_iw_handler_set_frag(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_handler_get_frag(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_param *frag, char *extra)
@@ -3190,7 +3091,6 @@ static int at76_iw_handler_get_frag(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_get_txpow(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_param *power, char *extra)
@@ -3206,7 +3106,6 @@ static int at76_iw_handler_get_txpow(struct net_device *netdev,
 	return 0;
 }
 
-
 /* jal: short retry is handled by the firmware (at least 0.90.x),
    while long retry is not (?) */
 static int at76_iw_handler_set_retry(struct net_device *netdev,
@@ -3232,7 +3131,6 @@ static int at76_iw_handler_set_retry(struct net_device *netdev,
 	return ret;
 }
 
-
 /* adapted (ripped) from atmel.c */
 static int at76_iw_handler_get_retry(struct net_device *netdev,
 				     struct iw_request_info *info,
@@ -3249,7 +3147,6 @@ static int at76_iw_handler_get_retry(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_set_encode(struct net_device *netdev,
 				      struct iw_request_info *info,
 				      struct iw_point *encoding,
@@ -3300,7 +3197,6 @@ static int at76_iw_handler_set_encode(struct net_device *netdev,
 	return -EIWCOMMIT;
 }
 
-
 static int at76_iw_handler_get_encode(struct net_device *netdev,
 				      struct iw_request_info *info,
 				      struct iw_point *encoding,
@@ -3340,7 +3236,6 @@ static int at76_iw_handler_get_encode(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_handler_set_power(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_param *prq, char *extra)
@@ -3376,7 +3271,6 @@ static int at76_iw_handler_set_power(struct net_device *netdev,
 	return err;
 }
 
-
 static int at76_iw_handler_get_power(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_param *power, char *extra)
@@ -3398,7 +3292,6 @@ static int at76_iw_handler_get_power(struct net_device *netdev,
 	return 0;
 }
 
-
 /*******************************************************************************
  * Private IOCTLS
  */
@@ -3424,7 +3317,6 @@ static int at76_iw_set_short_preamble(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_set_debug(struct net_device *netdev,
 			     struct iw_request_info *info,
 			     struct iw_point *data, char *extra)
@@ -3459,7 +3351,6 @@ static int at76_iw_set_debug(struct net_device *netdev,
 	return 0;
 }
 
-
 static int at76_iw_set_powersave_mode(struct net_device *netdev,
 				      struct iw_request_info *info, char *name,
 				      char *extra)
@@ -3481,7 +3372,6 @@ static int at76_iw_set_powersave_mode(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_set_scan_times(struct net_device *netdev,
 				  struct iw_request_info *info, char *name,
 				  char *extra)
@@ -3503,7 +3393,6 @@ static int at76_iw_set_scan_times(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_iw_set_scan_mode(struct net_device *netdev,
 				 struct iw_request_info *info, char *name,
 				 char *extra)
@@ -3525,7 +3414,6 @@ static int at76_iw_set_scan_mode(struct net_device *netdev,
 	return ret;
 }
 
-
 static int at76_set_iroaming(struct at76_priv *priv, int onoff)
 {
 	int ret = 0;
@@ -3543,7 +3431,6 @@ static int at76_set_iroaming(struct at76_priv *priv, int onoff)
 	return ret;
 }
 
-
 static int at76_iw_set_intl_roaming(struct net_device *netdev,
 				    struct iw_request_info *info, char *name,
 				    char *extra)
@@ -3568,7 +3455,6 @@ static int at76_iw_set_intl_roaming(struct net_device *netdev,
 	return ret;
 }
 
-
 /*******************************************************************************
  * structure that advertises the iw handlers of this driver
  */
@@ -3618,7 +3504,6 @@ static const iw_handler at76_priv_handlers[] = {
 	AT76_SET_PRIV(AT76_SET_INTL_ROAMING, at76_iw_set_intl_roaming),
 };
 
-
 /*******************************************************************************
  * structure that describes the private ioctls/iw handlers of this driver
  */
@@ -3651,7 +3536,6 @@ static const struct iw_priv_args at76_priv_args[] = {
 	 "intl_roaming"},
 };
 
-
 static const struct iw_handler_def at76_handler_def =
 {
 	.num_standard	= ARRAY_SIZE(at76_handlers),
@@ -3663,7 +3547,6 @@ static const struct iw_handler_def at76_handler_def =
 	.get_wireless_stats = at76_get_wireless_stats,
 };
 
-
 /* A short overview on Ethernet-II, 802.2, 802.3 and SNAP
    (taken from http://www.geocities.com/billalexander/ethernet.html):
 
@@ -3681,7 +3564,6 @@ Ethernet (a.k.a. Ethernet II)
 	 Type 0x06 0x00 = XNS
 	 Type 0x81 0x37 = Novell NetWare
 
-
 802.3
 
 	+---------+---------+---------+----------
@@ -3713,7 +3595,6 @@ static const u8 snapsig[] = { 0xaa, 0xaa, 0x03 };
  * a SNAP OID of 0 (0x00, 0x00, 0x00) */
 static const u8 rfc1042sig[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
 
-
 static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
@@ -3855,7 +3736,6 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	return ret;
 }
 
-
 static void at76_tx_timeout(struct net_device *netdev)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
@@ -3868,7 +3748,6 @@ static void at76_tx_timeout(struct net_device *netdev)
 	priv->stats.tx_errors++;
 }
 
-
 static int at76_submit_rx_urb(struct at76_priv *priv)
 {
 	int ret, size;
@@ -3924,7 +3803,6 @@ static int at76_submit_rx_urb(struct at76_priv *priv)
 	return ret;
 }
 
-
 static int at76_open(struct net_device *netdev)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
@@ -3965,7 +3843,6 @@ static int at76_open(struct net_device *netdev)
 	return ret < 0 ? ret : 0;
 }
 
-
 static int at76_stop(struct net_device *netdev)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
@@ -4012,7 +3889,6 @@ static int at76_stop(struct net_device *netdev)
 	return 0;
 }
 
-
 static void at76_ethtool_get_drvinfo(struct net_device *netdev,
 					 struct ethtool_drvinfo *info)
 {
@@ -4032,20 +3908,17 @@ static void at76_ethtool_get_drvinfo(struct net_device *netdev,
 		 priv->fwe->fw_version.patch, priv->fwe->fw_version.build);
 }
 
-
 static u32 at76_ethtool_get_link(struct net_device *netdev)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
 	return priv->istate == CONNECTED;
 }
 
-
 static struct ethtool_ops at76_ethtool_ops = {
 	.get_drvinfo = at76_ethtool_get_drvinfo,
 	.get_link = at76_ethtool_get_link,
 };
 
-
 /**
  * at76_init_new_device - continue device initialization after firmware download
  *
@@ -4162,7 +4035,6 @@ static int at76_init_new_device(struct at76_priv *priv,
 	return ret;
 }
 
-
 /* Download external firmware */
 static int at76_load_external_fw(struct usb_device *udev, struct fwentry *fwe)
 {
@@ -4193,7 +4065,6 @@ static int at76_load_external_fw(struct usb_device *udev, struct fwentry *fwe)
 	return 0;
 }
 
-
 /* Download internal firmware */
 static int at76_load_internal_fw(struct usb_device *udev, struct fwentry *fwe)
 {
@@ -4225,7 +4096,6 @@ static int at76_load_internal_fw(struct usb_device *udev, struct fwentry *fwe)
 	return ret;
 }
 
-
 static int at76_essid_matched(struct at76_priv *priv, struct bss_info *ptr)
 {
 	/* common criteria for both modi */
@@ -4239,7 +4109,6 @@ static int at76_essid_matched(struct at76_priv *priv, struct bss_info *ptr)
 	return ret;
 }
 
-
 static inline int at76_mode_matched(struct at76_priv *priv, struct bss_info *ptr)
 {
 	int ret;
@@ -4254,7 +4123,6 @@ static inline int at76_mode_matched(struct at76_priv *priv, struct bss_info *ptr
 	return ret;
 }
 
-
 static int at76_rates_matched(struct at76_priv *priv, struct bss_info *ptr)
 {
 	int i;
@@ -4284,7 +4152,6 @@ static int at76_rates_matched(struct at76_priv *priv, struct bss_info *ptr)
 		return 1;
 }
 
-
 static inline int at76_wep_matched(struct at76_priv *priv, struct bss_info *ptr)
 {
 	if (!priv->wep_enabled && ptr->capa & WLAN_CAPABILITY_PRIVACY) {
@@ -4298,7 +4165,6 @@ static inline int at76_wep_matched(struct at76_priv *priv, struct bss_info *ptr)
 	return 1;
 }
 
-
 static inline int at76_bssid_matched(struct at76_priv *priv,
 				     struct bss_info *ptr)
 {
@@ -4314,7 +4180,6 @@ static inline int at76_bssid_matched(struct at76_priv *priv,
 	}
 }
 
-
 /**
  * at76_match_bss - try to find a matching bss in priv->bss
  *
@@ -4351,7 +4216,6 @@ static struct bss_info *at76_match_bss(struct at76_priv *priv,
 	return ptr;
 }
 
-
 /* Try joining a BSS */
 static void at76_work_join(struct work_struct *work)
 {
@@ -4435,7 +4299,6 @@ static void at76_work_join(struct work_struct *work)
 	mutex_unlock(&priv->mtx);
 }
 
-
 /* Process scheduled events */
 static void at76_work_mgmt_timeout(struct work_struct *work)
 {
@@ -4542,7 +4405,6 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 	mutex_unlock(&priv->mtx);
 }
 
-
 static void at76_work_new_bss(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
@@ -4578,7 +4440,6 @@ static void at76_work_new_bss(struct work_struct *work)
 	mutex_unlock(&priv->mtx);
 }
 
-
 static int at76_startup_device(struct at76_priv *priv)
 {
 	struct at76_card_config *ccfg = &priv->card_config;
@@ -4704,7 +4565,6 @@ static int at76_startup_device(struct at76_priv *priv)
 	return 0;
 }
 
-
 static void at76_work_restart(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
@@ -4727,7 +4587,6 @@ static void at76_work_restart(struct work_struct *work)
 	mutex_unlock(&priv->mtx);
 }
 
-
 static void at76_work_scan(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
@@ -4755,7 +4614,6 @@ static void at76_work_scan(struct work_struct *work)
 	mutex_unlock(&priv->mtx);
 }
 
-
 static void at76_work_set_promisc(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
@@ -4778,7 +4636,6 @@ static void at76_work_set_promisc(struct work_struct *work)
 	mutex_unlock(&priv->mtx);
 }
 
-
 static void at76_work_submit_rx(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
@@ -4789,7 +4646,6 @@ static void at76_work_submit_rx(struct work_struct *work)
 	mutex_unlock(&priv->mtx);
 }
 
-
 /* we got an association response */
 static void at76_rx_mgmt_assoc(struct at76_priv *priv,
 			       struct at76_rx_buffer *buf)
@@ -4830,7 +4686,6 @@ static void at76_rx_mgmt_assoc(struct at76_priv *priv,
 	}
 }
 
-
 static void at76_rx_mgmt_reassoc(struct at76_priv *priv,
 				 struct at76_rx_buffer *buf)
 {
@@ -4882,7 +4737,6 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *priv,
 	}
 }
 
-
 static void at76_rx_mgmt_disassoc(struct at76_priv *priv,
 				  struct at76_rx_buffer *buf)
 {
@@ -4933,7 +4787,6 @@ static void at76_rx_mgmt_disassoc(struct at76_priv *priv,
 	/* ignore DisAssoc to other STA or from other BSSID */
 }
 
-
 static void at76_rx_mgmt_auth(struct at76_priv *priv, struct at76_rx_buffer *buf)
 {
 	struct ieee80211_auth *resp = (struct ieee80211_auth *)buf->packet;
@@ -4998,7 +4851,6 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv, struct at76_rx_buffer *buf
 	/* else: ignore AuthFrames to other recipients */
 }
 
-
 static void at76_rx_mgmt_deauth(struct at76_priv *priv,
 				struct at76_rx_buffer *buf)
 {
@@ -5040,7 +4892,6 @@ static void at76_rx_mgmt_deauth(struct at76_priv *priv,
 	}
 }
 
-
 static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 				struct at76_rx_buffer *buf)
 {
@@ -5220,7 +5071,6 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
 
-
 /* calc the link level from a given rx_buffer */
 static void at76_calc_level(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			    struct iw_quality *qual)
@@ -5233,7 +5083,6 @@ static void at76_calc_level(struct at76_priv *priv, struct at76_rx_buffer *buf,
 	qual->updated |= IW_QUAL_LEVEL_UPDATED;
 }
 
-
 /* calc the link quality from a given rx_buffer */
 static void at76_calc_qual(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			   struct iw_quality* qual)
@@ -5259,7 +5108,6 @@ static void at76_calc_qual(struct at76_priv *priv, struct at76_rx_buffer *buf,
 	qual->updated |= IW_QUAL_QUAL_UPDATED;
 }
 
-
 /* calc the noise quality from a given rx_buffer */
 static void at76_calc_noise(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			    struct iw_quality *qual)
@@ -5268,7 +5116,6 @@ static void at76_calc_noise(struct at76_priv *priv, struct at76_rx_buffer *buf,
 	qual->updated |= IW_QUAL_NOISE_INVALID;
 }
 
-
 static void at76_update_wstats(struct at76_priv *priv,
 			       struct at76_rx_buffer *buf)
 {
@@ -5287,7 +5134,6 @@ static void at76_update_wstats(struct at76_priv *priv,
 	}
 }
 
-
 static void at76_rx_mgmt(struct at76_priv *priv, struct at76_rx_buffer *buf)
 {
 	struct ieee80211_hdr_3addr *mgmt =
@@ -5345,7 +5191,6 @@ static void at76_rx_mgmt(struct at76_priv *priv, struct at76_rx_buffer *buf)
 	return;
 }
 
-
 static void at76_dbg_dumpbuf(const char *tag, const u8 *buf, int size)
 {
 	int i;
@@ -5364,7 +5209,6 @@ static void at76_dbg_dumpbuf(const char *tag, const u8 *buf, int size)
 	pr_debug("\n");
 }
 
-
 /* Convert the 802.11 header on a packet into an ethernet-style header
  * (basically, pretend we're an ethernet card receiving ethernet packets)
  *
@@ -5452,7 +5296,6 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 	    ntohs(skb->protocol), skb->len, hex2str(skb->data, 64));
 }
 
-
 /* check for fragmented data in priv->rx_skb. If the packet was no fragment
    or it was the last of a fragment set a skb containing the whole packet
    is returned for further processing. Otherwise we get NULL and are
@@ -5670,7 +5513,6 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 	}
 }
 
-
 /* rx interrupt: we expect the complete data buffer in priv->rx_skb */
 static void at76_rx_data(struct at76_priv *priv)
 {
@@ -5716,7 +5558,6 @@ static void at76_rx_data(struct at76_priv *priv)
 	return;
 }
 
-
 static void at76_rx_monitor_mode(struct at76_priv *priv)
 {
 	struct at76_rx_radiotap *rt;
@@ -5779,7 +5620,6 @@ static void at76_rx_monitor_mode(struct at76_priv *priv)
 	stats->rx_bytes += length;
 }
 
-
 /**
  * at76_iwspy_update - check if we spy on the sender address of buf and update stats
  */
@@ -5803,7 +5643,6 @@ static void at76_iwspy_update(struct at76_priv *priv, struct at76_rx_buffer *buf
 	spin_unlock_bh(&(priv->spy_spinlock));
 }
 
-
 static void at76_rx_tasklet(unsigned long param)
 {
 	struct at76_priv *priv = (struct at76_priv *)param;
@@ -5825,7 +5664,6 @@ static void at76_rx_tasklet(unsigned long param)
 		return;
 	}
 
-
 	if (!urb || !priv->rx_skb || !netdev || !priv->rx_skb->data)
 		return;
 
@@ -5896,7 +5734,6 @@ static void at76_rx_tasklet(unsigned long param)
 	return;
 }
 
-
 static struct at76_priv *at76_alloc_new_device(struct usb_device *udev)
 {
 	struct net_device *netdev;
@@ -5965,7 +5802,6 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev)
 	return priv;
 }
 
-
 /* Load firmware into kernel memory and parse it */
 static struct fwentry *at76_load_firmware(struct usb_device *udev,
 					  int board_type)
@@ -6028,7 +5864,6 @@ static struct fwentry *at76_load_firmware(struct usb_device *udev,
 	return fwe;
 }
 
-
 static int at76_probe(struct usb_interface *interface,
 		      const struct usb_device_id *id)
 {
@@ -6128,7 +5963,6 @@ static int at76_probe(struct usb_interface *interface,
 	return ret;
 }
 
-
 static void at76_disconnect(struct usb_interface *interface)
 {
 	struct at76_priv *priv;
@@ -6145,7 +5979,6 @@ static void at76_disconnect(struct usb_interface *interface)
 	info(DRIVER_NAME " disconnected");
 }
 
-
 /* structure for registering this driver with the USB subsystem */
 static struct usb_driver at76_driver = {
 	.name = DRIVER_NAME,
@@ -6154,7 +5987,6 @@ static struct usb_driver at76_driver = {
 	.id_table = dev_table,
 };
 
-
 static int __init at76_mod_init(void)
 {
 	int result;
@@ -6171,7 +6003,6 @@ static int __init at76_mod_init(void)
 	return result;
 }
 
-
 static void __exit at76_mod_exit(void)
 {
 	int i;
@@ -6185,7 +6016,6 @@ static void __exit at76_mod_exit(void)
 	led_trigger_unregister_simple(ledtrig_tx);
 }
 
-
 module_param_named(debug, at76_debug, int, 0600);
 MODULE_PARM_DESC(debug, "Debugging level");
 module_param(rx_copybreak, int, 0400);




From proski at gnu.org  Thu Jun 14 03:11:22 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:22 -0400
Subject: [at76c503a-develop] [PATCH 06/12] Convert wireless handler
	initialization to use a macro
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011122.25709.89028.stgit@dv.roinet.com>

This avoids extra long lines and makes the code survive Lindent without
getting ugly.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   62 +++++++++++++++++++++++++++++++-----------------------------
 1 files changed, 32 insertions(+), 30 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index f369c5f..a37bdde 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -3455,41 +3455,43 @@ static int at76_iw_set_intl_roaming(struct net_device *netdev,
 	return ret;
 }
 
+#define AT76_SET_HANDLER(h, f) [h - SIOCIWFIRST] = (iw_handler) f
+
 /*******************************************************************************
  * structure that advertises the iw handlers of this driver
  */
 static const iw_handler	at76_handlers[] =
 {
-	[SIOCSIWCOMMIT-SIOCIWFIRST] = (iw_handler) at76_iw_handler_commit,
-	[SIOCGIWNAME  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_name,
-	[SIOCSIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_freq,
-	[SIOCGIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_freq,
-	[SIOCSIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_mode,
-	[SIOCGIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_mode,
-	[SIOCGIWRANGE -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_range,
-	[SIOCSIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_spy,
-	[SIOCGIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_spy,
-	[SIOCSIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_thrspy,
-	[SIOCGIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_thrspy,
-	[SIOCSIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_wap,
-	[SIOCGIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_wap,
-	[SIOCSIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_scan,
-	[SIOCGIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_scan,
-	[SIOCSIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_essid,
-	[SIOCGIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_essid,
-	[SIOCSIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rate,
-	[SIOCGIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rate,
-	[SIOCSIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rts,
-	[SIOCGIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rts,
-	[SIOCSIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_frag,
-	[SIOCGIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_frag,
-	[SIOCGIWTXPOW -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_txpow,
-	[SIOCSIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_retry,
-	[SIOCGIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_retry,
-	[SIOCSIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_encode,
-	[SIOCGIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_encode,
-	[SIOCSIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_power,
-	[SIOCGIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_power,
+	AT76_SET_HANDLER(SIOCSIWCOMMIT, at76_iw_handler_commit),
+	AT76_SET_HANDLER(SIOCGIWNAME, at76_iw_handler_get_name),
+	AT76_SET_HANDLER(SIOCSIWFREQ, at76_iw_handler_set_freq),
+	AT76_SET_HANDLER(SIOCGIWFREQ, at76_iw_handler_get_freq),
+	AT76_SET_HANDLER(SIOCSIWMODE, at76_iw_handler_set_mode),
+	AT76_SET_HANDLER(SIOCGIWMODE, at76_iw_handler_get_mode),
+	AT76_SET_HANDLER(SIOCGIWRANGE, at76_iw_handler_get_range),
+	AT76_SET_HANDLER(SIOCSIWSPY, at76_iw_handler_set_spy),
+	AT76_SET_HANDLER(SIOCGIWSPY, at76_iw_handler_get_spy),
+	AT76_SET_HANDLER(SIOCSIWTHRSPY, at76_iw_handler_set_thrspy),
+	AT76_SET_HANDLER(SIOCGIWTHRSPY, at76_iw_handler_get_thrspy),
+	AT76_SET_HANDLER(SIOCSIWAP, at76_iw_handler_set_wap),
+	AT76_SET_HANDLER(SIOCGIWAP, at76_iw_handler_get_wap),
+	AT76_SET_HANDLER(SIOCSIWSCAN, at76_iw_handler_set_scan),
+	AT76_SET_HANDLER(SIOCGIWSCAN, at76_iw_handler_get_scan),
+	AT76_SET_HANDLER(SIOCSIWESSID, at76_iw_handler_set_essid),
+	AT76_SET_HANDLER(SIOCGIWESSID, at76_iw_handler_get_essid),
+	AT76_SET_HANDLER(SIOCSIWRATE, at76_iw_handler_set_rate),
+	AT76_SET_HANDLER(SIOCGIWRATE, at76_iw_handler_get_rate),
+	AT76_SET_HANDLER(SIOCSIWRTS, at76_iw_handler_set_rts),
+	AT76_SET_HANDLER(SIOCGIWRTS, at76_iw_handler_get_rts),
+	AT76_SET_HANDLER(SIOCSIWFRAG, at76_iw_handler_set_frag),
+	AT76_SET_HANDLER(SIOCGIWFRAG, at76_iw_handler_get_frag),
+	AT76_SET_HANDLER(SIOCGIWTXPOW, at76_iw_handler_get_txpow),
+	AT76_SET_HANDLER(SIOCSIWRETRY, at76_iw_handler_set_retry),
+	AT76_SET_HANDLER(SIOCGIWRETRY, at76_iw_handler_get_retry),
+	AT76_SET_HANDLER(SIOCSIWENCODE, at76_iw_handler_set_encode),
+	AT76_SET_HANDLER(SIOCGIWENCODE, at76_iw_handler_get_encode),
+	AT76_SET_HANDLER(SIOCSIWPOWER, at76_iw_handler_set_power),
+	AT76_SET_HANDLER(SIOCGIWPOWER, at76_iw_handler_get_power)
 };
 
 #define AT76_SET_PRIV(h, f) [h - SIOCIWFIRSTPRIV] = (iw_handler) f




From proski at gnu.org  Thu Jun 14 03:11:27 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:27 -0400
Subject: [at76c503a-develop] [PATCH 07/12] Simplify capability setting in
	(re)accociation requests
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011127.25709.88807.stgit@dv.roinet.com>

Avoid using two tertiary operators in one expression.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   22 ++++++++++++++--------
 1 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index a37bdde..f54d99e 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1794,6 +1794,7 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	struct ieee80211_info_element *tlv;
 	char essid[IW_ESSID_MAX_SIZE + 1];
 	int len;
+	u16 capa;
 
 	at76_assert(bss != NULL);
 
@@ -1819,10 +1820,12 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	   Agere-based AP with optional WEP transmits encrypted frames
 	   to us.  AP only set the Privacy bit in their capabilities
 	   if WEP is mandatory in the BSS! */
-	req->capability = cpu_to_le16(bss->capa |
-				      (priv->wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
-				      (priv->preamble_type == PREAMBLE_TYPE_SHORT ?
-				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+	capa = bss->capa;
+	if (priv->wep_enabled)
+		capa |= WLAN_CAPABILITY_PRIVACY;
+	if (priv->preamble_type == PREAMBLE_TYPE_SHORT)
+		capa |= WLAN_CAPABILITY_SHORT_PREAMBLE;
+	req->capability = cpu_to_le16(capa);
 
 	req->listen_interval = cpu_to_le16(2 * bss->beacon_interval);
 
@@ -1868,6 +1871,7 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 	struct ieee80211_info_element *tlv;
 	char essid[IW_ESSID_MAX_SIZE + 1];
 	int len;
+	int capa;
 
 	at76_assert(curr_bss != NULL);
 	at76_assert(new_bss != NULL);
@@ -1896,10 +1900,12 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 	   Agere-based AP with optional WEP transmits encrypted frames
 	   to us.  AP only set the Privacy bit in their capabilities
 	   if WEP is mandatory in the BSS! */
-	req->capability = cpu_to_le16(new_bss->capa |
-				      (priv->wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
-				      (priv->preamble_type == PREAMBLE_TYPE_SHORT ?
-				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+	capa = new_bss->capa;
+	if (priv->wep_enabled)
+		capa |= WLAN_CAPABILITY_PRIVACY;
+	if (priv->preamble_type == PREAMBLE_TYPE_SHORT)
+		capa |= WLAN_CAPABILITY_SHORT_PREAMBLE;
+	req->capability = cpu_to_le16(capa);
 
 	req->listen_interval = cpu_to_le16(2 * new_bss->beacon_interval);
 




From proski at gnu.org  Thu Jun 14 03:11:32 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:32 -0400
Subject: [at76c503a-develop] [PATCH 08/12] Run at76_usb.c throut Lindent
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011132.25709.55251.stgit@dv.roinet.com>

Intervene in some places to make the result readable

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  827 ++++++++++++++++++++++++++++++++----------------------------
 1 files changed, 446 insertions(+), 381 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index f54d99e..6064171 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -47,15 +47,15 @@
 static int at76_debug = DBG_DEFAULTS;
 
 static struct fwentry firmwares[] = {
-	[0]			      = { "" },
-	[BOARDTYPE_503_INTERSIL_3861] = { "atmel_at76c503-i3861.bin" },
-	[BOARDTYPE_503_INTERSIL_3863] = { "atmel_at76c503-i3863.bin" },
-	[BOARDTYPE_503_RFMD]	      = { "atmel_at76c503-rfmd.bin" },
-	[BOARDTYPE_503_RFMD_ACC]      = { "atmel_at76c503-rfmd-acc.bin" },
-	[BOARDTYPE_505_RFMD]	      = { "atmel_at76c505-rfmd.bin" },
-	[BOARDTYPE_505_RFMD_2958]     = { "atmel_at76c505-rfmd2958.bin" },
-	[BOARDTYPE_505A_RFMD_2958]    = { "atmel_at76c505a-rfmd2958.bin" },
-	[BOARDTYPE_505AMX_RFMD]       = { "atmel_at76c505amx-rfmd.bin" },
+	[0] = {""},
+	[BOARDTYPE_503_INTERSIL_3861] = {"atmel_at76c503-i3861.bin"},
+	[BOARDTYPE_503_INTERSIL_3863] = {"atmel_at76c503-i3863.bin"},
+	[BOARDTYPE_503_RFMD] = {"atmel_at76c503-rfmd.bin"},
+	[BOARDTYPE_503_RFMD_ACC] = {"atmel_at76c503-rfmd-acc.bin"},
+	[BOARDTYPE_505_RFMD] = {"atmel_at76c505-rfmd.bin"},
+	[BOARDTYPE_505_RFMD_2958] = {"atmel_at76c505-rfmd2958.bin"},
+	[BOARDTYPE_505A_RFMD_2958] = {"atmel_at76c505a-rfmd2958.bin"},
+	[BOARDTYPE_505AMX_RFMD] = {"atmel_at76c505amx-rfmd.bin"},
 };
 
 static struct usb_device_id dev_table[] = {
@@ -177,11 +177,13 @@ static int scan_max_time = 120;
 
 /* the supported rates of this hardware, bit7 marks a basic rate */
 static const u8 hw_rates[] = { 0x82, 0x84, 0x0b, 0x16 };
+
 /* The frequency of each channel in MHz */
 static const long channel_frequency[] = {
 	2412, 2417, 2422, 2427, 2432, 2437, 2442,
 	2447, 2452, 2457, 2462, 2467, 2472, 2484
 };
+
 #define NUM_CHANNELS ARRAY_SIZE(channel_frequency)
 
 /* Firmware download */
@@ -240,13 +242,9 @@ static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
 
 	memcpy(tmpbuf, buffer, bytes);
 
-	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-				 DFU_DNLOAD,
-				 USB_TYPE_CLASS | USB_DIR_OUT | USB_RECIP_INTERFACE,
-				 block,	/* Value */
-				 0,	/* Index */
-				 tmpbuf,	/* Buffer */
-				 bytes,	/* Size */
+	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), DFU_DNLOAD,
+				 USB_TYPE_CLASS | USB_DIR_OUT |
+				 USB_RECIP_INTERFACE, block, 0, tmpbuf, bytes,
 				 HZ);
 	return result;
 }
@@ -256,14 +254,10 @@ static int at76_dfu_get_status(struct dfu_ctx *ctx, struct dfu_status *status)
 	int result;
 	struct usb_device *udev = ctx->udev;
 
-	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
-				 DFU_GETSTATUS,
-				 USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,
-				 0,	/* Value */
-				 0,	/* Index */
-				 status,	/* Buffer */
-				 sizeof(struct dfu_status),	/* Size */
-				 HZ);
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATUS,
+				 USB_TYPE_CLASS | USB_DIR_IN |
+				 USB_RECIP_INTERFACE, 0, 0, status,
+				 sizeof(struct dfu_status), HZ);
 	return result;
 }
 
@@ -271,21 +265,16 @@ static u8 at76_dfu_get_state(struct usb_device *udev, u8 *state)
 {
 	int result;
 
-	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
-				 DFU_GETSTATE,	/* Request */
-				 USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,
-				 0,	/* Value */
-				 0,	/* Index */
-				 state,	/* Buffer */
-				 1,	/* Size */
-				 HZ);
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATE,
+				 USB_TYPE_CLASS | USB_DIR_IN |
+				 USB_RECIP_INTERFACE, 0, 0, state, 1, HZ);
 	return result;
 }
 
 static inline u32 at76_get_timeout(struct dfu_status *s)
 {
 	u32 ret = (s->poll_timeout[2] << 16) | (s->poll_timeout[1] << 8) |
-		  (s->poll_timeout[0]);
+	    (s->poll_timeout[0]);
 
 	return ret;
 }
@@ -315,7 +304,9 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 	int is_done = 0;
 	u8 dfu_state = 0;
 	u32 dfu_timeout = 0;
-	int dfu_block_bytes = 0, dfu_bytes_left = dfu_len, dfu_buffer_offset = 0;
+	int dfu_block_bytes = 0;
+	int dfu_bytes_left = dfu_len;
+	int dfu_buffer_offset = 0;
 	int dfu_block_cnt = 0;
 
 	at76_dbg(DBG_DFU, "%s( %p, %u, %d)", __FUNCTION__, dfu_buffer,
@@ -352,7 +343,8 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 				dfu_timeout = at76_get_timeout(dfu_stat_buf);
 				need_dfu_state = 0;
 			} else
-				err("at76_dfu_get_status failed with %d", status);
+				err("at76_dfu_get_status failed with %d",
+				    status);
 			break;
 
 		case STATE_DFU_DOWNLOAD_BUSY:
@@ -360,7 +352,8 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 			need_dfu_state = 1;
 
 			at76_dbg(DBG_DFU, "DFU: Resetting device");
-			schedule_timeout_interruptible(msecs_to_jiffies(dfu_timeout));
+			schedule_timeout_interruptible(msecs_to_jiffies
+						       (dfu_timeout));
 			break;
 
 		case STATE_DFU_DOWNLOAD_IDLE:
@@ -377,14 +370,15 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 			dfu_bytes_left -= dfu_block_bytes;
 			status = at76_dfu_download_block(ctx,
 							 dfu_buffer +
-							   dfu_buffer_offset,
+							 dfu_buffer_offset,
 							 dfu_block_bytes,
 							 dfu_block_cnt);
 			dfu_buffer_offset += dfu_block_bytes;
 			dfu_block_cnt++;
 
 			if (!DFU_USB_SUCCESS(status))
-				err("dfu_download_block failed with %d", status);
+				err("dfu_download_block failed with %d",
+				    status);
 			need_dfu_state = 1;
 			break;
 
@@ -403,8 +397,10 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 				if (manifest_sync_timeout > 0)
 					dfu_timeout = manifest_sync_timeout;
 
-				at76_dbg(DBG_DFU, "DFU: Waiting for manifest phase");
-				schedule_timeout_interruptible(msecs_to_jiffies(dfu_timeout));
+				at76_dbg(DBG_DFU,
+					 "DFU: Waiting for manifest phase");
+				schedule_timeout_interruptible(msecs_to_jiffies
+							       (dfu_timeout));
 			}
 			break;
 
@@ -653,7 +649,8 @@ static int at76_get_hw_config(struct at76_priv *priv)
 
 	case BOARDTYPE_503_RFMD:
 	case BOARDTYPE_503_RFMD_ACC:
-		ret = at76_get_hw_cfg_rfmd(priv->udev, hwcfg, sizeof(hwcfg->r3));
+		ret =
+		    at76_get_hw_cfg_rfmd(priv->udev, hwcfg, sizeof(hwcfg->r3));
 		if (ret < 0)
 			break;
 		memcpy(priv->mac_addr, hwcfg->r3.mac_addr, ETH_ALEN);
@@ -663,7 +660,8 @@ static int at76_get_hw_config(struct at76_priv *priv)
 	case BOARDTYPE_505_RFMD:
 	case BOARDTYPE_505_RFMD_2958:
 	case BOARDTYPE_505A_RFMD_2958:
-		ret = at76_get_hw_cfg_rfmd(priv->udev, hwcfg, sizeof(hwcfg->r5));
+		ret = at76_get_hw_cfg_rfmd(priv->udev, hwcfg,
+					   sizeof(hwcfg->r5));
 		if (ret < 0)
 			break;
 		memcpy(priv->mac_addr, hwcfg->r5.mac_addr, ETH_ALEN);
@@ -690,7 +688,7 @@ static struct reg_domain const *at76_get_reg_domain(u16 code)
 		{0x10, "FCC (USA)", 0x7ff},	/* ch 1-11 */
 		{0x20, "IC (Canada)", 0x7ff},	/* ch 1-11 */
 		{0x30, "ETSI (Europe except Spain and France)", 0x1fff},	/* ch 1-13 */
-		{0x31, "Spain", 0x600},		/* ch 10-11 */
+		{0x31, "Spain", 0x600},	/* ch 10-11 */
 		{0x32, "France", 0x1e00},	/* ch 10-13 */
 		{0x40, "MKK (Japan)", 0x2000},	/* ch 14 */
 		{0x41, "MKK1 (Japan)", 0x3fff},	/* ch 1-14 */
@@ -832,7 +830,8 @@ static int at76_wait_completion(struct at76_priv *priv, int cmd)
 	do {
 		status = at76_get_cmd_status(priv->udev, cmd);
 		if (status < 0) {
-			err("%s: at76_get_cmd_status failed: %d", netdev->name, status);
+			err("%s: at76_get_cmd_status failed: %d", netdev->name,
+			    status);
 			break;
 		}
 
@@ -869,12 +868,14 @@ static int at76_set_mib(struct at76_priv *priv, struct set_mib_buffer *buf)
 				      cmd_buf,
 				      sizeof(struct at76_command) +
 				      buf->size + 4, USB_CTRL_GET_TIMEOUT);
-		if (ret >= 0)
-			if ((ret = at76_wait_completion(priv, CMD_SET_MIB)) !=
-			    CMD_STATUS_COMPLETE) {
-				info("%s: set_mib: at76_wait_completion failed with %d", priv->netdev->name, ret);
+		if (ret >= 0) {
+			ret = at76_wait_completion(priv, CMD_SET_MIB);
+			if (ret != CMD_STATUS_COMPLETE) {
+				info("%s: set_mib: at76_wait_completion failed "
+				     "with %d", priv->netdev->name, ret);
 				ret = -EIO;
 			}
+		}
 		kfree(cmd_buf);
 		return ret;
 	} else
@@ -891,7 +892,8 @@ static int at76_set_radio(struct at76_priv *priv, int on_off)
 	if (priv->radio_on != on_off) {
 		ret = at76_set_card_command(priv->udev, CMD_RADIO, NULL, 0);
 		if (ret < 0) {
-			err("%s: at76_set_card_command(CMD_RADIO) failed: %d", priv->netdev->name, ret);
+			err("%s: at76_set_card_command(CMD_RADIO) failed: %d",
+			    priv->netdev->name, ret);
 		} else
 			ret = 1;
 		priv->radio_on = on_off;
@@ -917,7 +919,8 @@ static int at76_set_pm_mode(struct at76_priv *priv)
 
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (pm_mode) failed: %d", priv->netdev->name, ret);
+		err("%s: set_mib (pm_mode) failed: %d", priv->netdev->name,
+		    ret);
 	}
 	return ret;
 }
@@ -937,7 +940,8 @@ static int at76_set_associd(struct at76_priv *priv, u16 id)
 
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (associd) failed: %d", priv->netdev->name, ret);
+		err("%s: set_mib (associd) failed: %d", priv->netdev->name,
+		    ret);
 	}
 	return ret;
 }
@@ -975,7 +979,8 @@ static int at76_set_preamble(struct at76_priv *priv, u8 type)
 	priv->mib_buf.data[0] = type;
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (preamble) failed: %d", priv->netdev->name, ret);
+		err("%s: set_mib (preamble) failed: %d", priv->netdev->name,
+		    ret);
 	}
 	return ret;
 }
@@ -988,10 +993,11 @@ static int at76_set_frag(struct at76_priv *priv, u16 size)
 	priv->mib_buf.type = MIB_MAC;
 	priv->mib_buf.size = 2;
 	priv->mib_buf.index = FRAGMENTATION_OFFSET;
-	*(__le16 *) priv->mib_buf.data = cpu_to_le16(size);
+	*(__le16 *)priv->mib_buf.data = cpu_to_le16(size);
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (frag threshold) failed: %d", priv->netdev->name, ret);
+		err("%s: set_mib (frag threshold) failed: %d",
+		    priv->netdev->name, ret);
 	}
 	return ret;
 }
@@ -1004,7 +1010,7 @@ static int at76_set_rts(struct at76_priv *priv, u16 size)
 	priv->mib_buf.type = MIB_MAC;
 	priv->mib_buf.size = 2;
 	priv->mib_buf.index = RTS_OFFSET;
-	*(__le16 *) priv->mib_buf.data = cpu_to_le16(size);
+	*(__le16 *)priv->mib_buf.data = cpu_to_le16(size);
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
 		err("%s: set_mib (rts) failed: %d", priv->netdev->name, ret);
@@ -1023,7 +1029,8 @@ static int at76_set_autorate_fallback(struct at76_priv *priv, int onoff)
 	priv->mib_buf.data[0] = onoff;
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (autorate fallback) failed: %d", priv->netdev->name, ret);
+		err("%s: set_mib (autorate fallback) failed: %d",
+		    priv->netdev->name, ret);
 	}
 	return ret;
 }
@@ -1109,17 +1116,17 @@ static int at76_dump_mib_mac_addr(struct at76_priv *priv)
 	ret = at76_get_mib(priv->udev, MIB_MAC_ADD,
 			   mac_addr, sizeof(struct mib_mac_addr));
 	if (ret < 0) {
-		err("%s: at76_get_mib (MAC_ADDR) failed: %d", priv->netdev->name,
-		    ret);
+		err("%s: at76_get_mib (MAC_ADDR) failed: %d",
+		    priv->netdev->name, ret);
 		goto err;
 	}
 
-	dbg("%s: MIB MAC_ADDR: mac_addr %s res 0x%x 0x%x group_addr %s status %d %d %d %d",
-	       priv->netdev->name, mac2str(mac_addr->mac_addr),
-		   mac_addr->res[0], mac_addr->res[1],
-	       hex2str(mac_addr->group_addr, 4 * ETH_ALEN),
-	       mac_addr->group_addr_status[0], mac_addr->group_addr_status[1],
-	       mac_addr->group_addr_status[2], mac_addr->group_addr_status[3]);
+	dbg("%s: MIB MAC_ADDR: mac_addr %s res 0x%x 0x%x group_addr %s status "
+	    "%d %d %d %d", priv->netdev->name, mac2str(mac_addr->mac_addr),
+	    mac_addr->res[0], mac_addr->res[1],
+	    hex2str(mac_addr->group_addr, 4 * ETH_ALEN),
+	    mac_addr->group_addr_status[0], mac_addr->group_addr_status[1],
+	    mac_addr->group_addr_status[2], mac_addr->group_addr_status[3]);
 
       err:
 	kfree(mac_addr);
@@ -1140,7 +1147,8 @@ static int at76_dump_mib_mac_wep(struct at76_priv *priv)
 	ret = at76_get_mib(priv->udev, MIB_MAC_WEP, mac_wep,
 			   sizeof(struct mib_mac_wep));
 	if (ret < 0) {
-		err("%s: at76_get_mib (MAC_WEP) failed: %d", priv->netdev->name, ret);
+		err("%s: at76_get_mib (MAC_WEP) failed: %d", priv->netdev->name,
+		    ret);
 		goto err;
 	}
 
@@ -1153,9 +1161,9 @@ static int at76_dump_mib_mac_wep(struct at76_priv *priv)
 	    le32_to_cpu(mac_wep->wep_excluded_count),
 	    mac_wep->encryption_level, mac_wep->wep_default_key_id,
 	    mac_wep->wep_default_key_id < 4 ?
-		hex2str(mac_wep->wep_default_keyvalue[mac_wep->wep_default_key_id],
-			mac_wep->encryption_level == 2 ? 13 : 5) :
-	       "<invalid key id>");
+	    hex2str(mac_wep->wep_default_keyvalue[mac_wep->wep_default_key_id],
+		    mac_wep->encryption_level == 2 ? 13 : 5) :
+	    "<invalid key id>");
 
       err:
 	kfree(mac_wep);
@@ -1185,31 +1193,30 @@ static int at76_dump_mib_mac_mgmt(struct at76_priv *priv)
 	country_string[3] = '\0';
 
 	dbg("%s: MIB MAC_MGMT: beacon_period %d CFP_max_duration %d "
-	       "medium_occupancy_limit %d station_id 0x%x ATIM_window %d "
-	       "CFP_mode %d privacy_opt_impl %d DTIM_period %d CFP_period %d "
-	       "current_bssid %s current_essid %s current_bss_type %d "
-	       "pm_mode %d ibss_change %d res %d "
-	       "multi_domain_capability_implemented %d "
-	       "international_roaming %d country_string %s",
-	       priv->netdev->name,
-	       le16_to_cpu(mac_mgmt->beacon_period),
-	       le16_to_cpu(mac_mgmt->CFP_max_duration),
-	       le16_to_cpu(mac_mgmt->medium_occupancy_limit),
-	       le16_to_cpu(mac_mgmt->station_id),
-	       le16_to_cpu(mac_mgmt->ATIM_window),
-	       mac_mgmt->CFP_mode,
-	       mac_mgmt->privacy_option_implemented,
-	       mac_mgmt->DTIM_period,
-	       mac_mgmt->CFP_period,
-	       mac2str(mac_mgmt->current_bssid),
-	       hex2str(mac_mgmt->current_essid, IW_ESSID_MAX_SIZE),
-	       mac_mgmt->current_bss_type,
-	       mac_mgmt->power_mgmt_mode,
-	       mac_mgmt->ibss_change,
-	       mac_mgmt->res,
-	       mac_mgmt->multi_domain_capability_implemented,
-	       mac_mgmt->multi_domain_capability_enabled,
-	       country_string);
+	    "medium_occupancy_limit %d station_id 0x%x ATIM_window %d "
+	    "CFP_mode %d privacy_opt_impl %d DTIM_period %d CFP_period %d "
+	    "current_bssid %s current_essid %s current_bss_type %d "
+	    "pm_mode %d ibss_change %d res %d "
+	    "multi_domain_capability_implemented %d "
+	    "international_roaming %d country_string %s",
+	    priv->netdev->name,
+	    le16_to_cpu(mac_mgmt->beacon_period),
+	    le16_to_cpu(mac_mgmt->CFP_max_duration),
+	    le16_to_cpu(mac_mgmt->medium_occupancy_limit),
+	    le16_to_cpu(mac_mgmt->station_id),
+	    le16_to_cpu(mac_mgmt->ATIM_window),
+	    mac_mgmt->CFP_mode,
+	    mac_mgmt->privacy_option_implemented,
+	    mac_mgmt->DTIM_period,
+	    mac_mgmt->CFP_period,
+	    mac2str(mac_mgmt->current_bssid),
+	    hex2str(mac_mgmt->current_essid, IW_ESSID_MAX_SIZE),
+	    mac_mgmt->current_bss_type,
+	    mac_mgmt->power_mgmt_mode,
+	    mac_mgmt->ibss_change,
+	    mac_mgmt->res,
+	    mac_mgmt->multi_domain_capability_implemented,
+	    mac_mgmt->multi_domain_capability_enabled, country_string);
       err:
 	kfree(mac_mgmt);
       exit:
@@ -1233,28 +1240,28 @@ static int at76_dump_mib_mac(struct at76_priv *priv)
 	}
 
 	dbg("%s: MIB MAC: max_tx_msdu_lifetime %d max_rx_lifetime %d "
-	       "frag_threshold %d rts_threshold %d cwmin %d cwmax %d "
-	       "short_retry_time %d long_retry_time %d scan_type %d "
-	       "scan_channel %d probe_delay %u min_channel_time %d "
-	       "max_channel_time %d listen_int %d desired_ssid %s "
-	       "desired_bssid %s desired_bsstype %d",
-	       priv->netdev->name,
-	       le32_to_cpu(mac->max_tx_msdu_lifetime),
-	       le32_to_cpu(mac->max_rx_lifetime),
-	       le16_to_cpu(mac->frag_threshold),
-	       le16_to_cpu(mac->rts_threshold),
-	       le16_to_cpu(mac->cwmin),
-	       le16_to_cpu(mac->cwmax),
-	       mac->short_retry_time,
-	       mac->long_retry_time,
-	       mac->scan_type,
-	       mac->scan_channel,
-	       le16_to_cpu(mac->probe_delay),
-	       le16_to_cpu(mac->min_channel_time),
-	       le16_to_cpu(mac->max_channel_time),
-	       le16_to_cpu(mac->listen_interval),
-	       hex2str(mac->desired_ssid, IW_ESSID_MAX_SIZE),
-	       mac2str(mac->desired_bssid), mac->desired_bsstype);
+	    "frag_threshold %d rts_threshold %d cwmin %d cwmax %d "
+	    "short_retry_time %d long_retry_time %d scan_type %d "
+	    "scan_channel %d probe_delay %u min_channel_time %d "
+	    "max_channel_time %d listen_int %d desired_ssid %s "
+	    "desired_bssid %s desired_bsstype %d",
+	    priv->netdev->name,
+	    le32_to_cpu(mac->max_tx_msdu_lifetime),
+	    le32_to_cpu(mac->max_rx_lifetime),
+	    le16_to_cpu(mac->frag_threshold),
+	    le16_to_cpu(mac->rts_threshold),
+	    le16_to_cpu(mac->cwmin),
+	    le16_to_cpu(mac->cwmax),
+	    mac->short_retry_time,
+	    mac->long_retry_time,
+	    mac->scan_type,
+	    mac->scan_channel,
+	    le16_to_cpu(mac->probe_delay),
+	    le16_to_cpu(mac->min_channel_time),
+	    le16_to_cpu(mac->max_channel_time),
+	    le16_to_cpu(mac->listen_interval),
+	    hex2str(mac->desired_ssid, IW_ESSID_MAX_SIZE),
+	    mac2str(mac->desired_bssid), mac->desired_bsstype);
       err:
 	kfree(mac);
       exit:
@@ -1278,22 +1285,22 @@ static int at76_dump_mib_phy(struct at76_priv *priv)
 	}
 
 	dbg("%s: MIB PHY: ed_threshold %d slot_time %d sifs_time %d "
-	       "preamble_length %d plcp_header_length %d mpdu_max_length %d "
-	       "cca_mode_supported %d operation_rate_set "
-	       "0x%x 0x%x 0x%x 0x%x channel_id %d current_cca_mode %d "
-	       "phy_type %d current_reg_domain %d",
-	       priv->netdev->name,
-	       le32_to_cpu(phy->ed_threshold),
-	       le16_to_cpu(phy->slot_time),
-	       le16_to_cpu(phy->sifs_time),
-	       le16_to_cpu(phy->preamble_length),
-	       le16_to_cpu(phy->plcp_header_length),
-	       le16_to_cpu(phy->mpdu_max_length),
-	       le16_to_cpu(phy->cca_mode_supported),
-	       phy->operation_rate_set[0], phy->operation_rate_set[1],
-	       phy->operation_rate_set[2], phy->operation_rate_set[3],
-	       phy->channel_id,
-	       phy->current_cca_mode, phy->phy_type, phy->current_reg_domain);
+	    "preamble_length %d plcp_header_length %d mpdu_max_length %d "
+	    "cca_mode_supported %d operation_rate_set "
+	    "0x%x 0x%x 0x%x 0x%x channel_id %d current_cca_mode %d "
+	    "phy_type %d current_reg_domain %d",
+	    priv->netdev->name,
+	    le32_to_cpu(phy->ed_threshold),
+	    le16_to_cpu(phy->slot_time),
+	    le16_to_cpu(phy->sifs_time),
+	    le16_to_cpu(phy->preamble_length),
+	    le16_to_cpu(phy->plcp_header_length),
+	    le16_to_cpu(phy->mpdu_max_length),
+	    le16_to_cpu(phy->cca_mode_supported),
+	    phy->operation_rate_set[0], phy->operation_rate_set[1],
+	    phy->operation_rate_set[2], phy->operation_rate_set[3],
+	    phy->channel_id,
+	    phy->current_cca_mode, phy->phy_type, phy->current_reg_domain);
       err:
 	kfree(phy);
       exit:
@@ -1318,11 +1325,11 @@ static int at76_dump_mib_local(struct at76_priv *priv)
 	}
 
 	dbg("%s: MIB PHY: beacon_enable %d txautorate_fallback %d "
-	       "ssid_size %d promiscuous_mode %d preamble_type %d",
-	       priv->netdev->name,
-	       local->beacon_enable,
-	       local->txautorate_fallback,
-	       local->ssid_size, local->promiscuous_mode, local->preamble_type);
+	    "ssid_size %d promiscuous_mode %d preamble_type %d",
+	    priv->netdev->name,
+	    local->beacon_enable,
+	    local->txautorate_fallback,
+	    local->ssid_size, local->promiscuous_mode, local->preamble_type);
       err:
 	kfree(local);
       exit:
@@ -1411,7 +1418,8 @@ static int at76_get_current_channel(struct at76_priv *priv)
 	}
 	ret = at76_get_mib(priv->udev, MIB_PHY, phy, sizeof(struct mib_phy));
 	if (ret < 0) {
-		err("%s: at76_get_mib(MIB_PHY) failed: %d", priv->netdev->name, ret);
+		err("%s: at76_get_mib(MIB_PHY) failed: %d", priv->netdev->name,
+		    ret);
 		goto err;
 	}
 	priv->channel = phy->channel_id;
@@ -1540,7 +1548,8 @@ static int at76_start_ibss(struct at76_priv *priv)
 	priv->mib_buf.index = IBSS_CHANGE_OK_OFFSET;
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (ibss change ok) failed: %d", priv->netdev->name, ret);
+		err("%s: set_mib (ibss change ok) failed: %d",
+		    priv->netdev->name, ret);
 		return ret;
 	}
 
@@ -1564,9 +1573,10 @@ static int at76_join_bss(struct at76_priv *priv, struct bss_info *ptr)
 	join.channel = ptr->channel;
 	join.timeout = cpu_to_le16(2000);
 
-	at76_dbg(DBG_PROGRESS, "%s join addr %s ssid %s type %d ch %d timeout %d",
-		 priv->netdev->name, mac2str(join.bssid),
-		 join.essid, join.bss_type, join.channel, le16_to_cpu(join.timeout));
+	at76_dbg(DBG_PROGRESS,
+		 "%s join addr %s ssid %s type %d ch %d timeout %d",
+		 priv->netdev->name, mac2str(join.bssid), join.essid,
+		 join.bss_type, join.channel, le16_to_cpu(join.timeout));
 	return at76_set_card_command(priv->udev, CMD_JOIN, &join,
 				     sizeof(struct at76_req_join));
 }
@@ -1620,7 +1630,7 @@ static void at76_write_bulk_callback(struct urb *urb)
 				 "%s - nonzero write bulk status received: %d",
 				 __FUNCTION__, urb->status);
 		} else
-			return; /* urb has been unlinked */
+			return;	/* urb has been unlinked */
 		stats->tx_errors++;
 	} else
 		stats->tx_packets++;
@@ -1642,8 +1652,7 @@ static void at76_write_bulk_callback(struct urb *urb)
 				  priv->bulk_out_buffer,
 				  le16_to_cpu(mgmt_buf->wlength) +
 				  mgmt_buf->padding + AT76_TX_HDRLEN,
-				  at76_write_bulk_callback,
-				  priv);
+				  at76_write_bulk_callback, priv);
 		ret = usb_submit_urb(priv->write_urb, GFP_ATOMIC);
 		if (ret) {
 			err("%s: %s error in tx submit urb: %d",
@@ -1696,7 +1705,8 @@ static int at76_send_mgmt_bulk(struct at76_priv *priv,
 			    priv->netdev->name, __FUNCTION__, urb_status);
 		}
 
-		at76_dbg(DBG_TX_MGMT, "%s: tx mgmt: wlen %d tx_rate %d pad %d %s",
+		at76_dbg(DBG_TX_MGMT,
+			 "%s: tx mgmt: wlen %d tx_rate %d pad %d %s",
 			 priv->netdev->name, le16_to_cpu(txbuf->wlength),
 			 txbuf->tx_rate, txbuf->padding,
 			 hex2str(txbuf->packet, le16_to_cpu(txbuf->wlength)));
@@ -1711,8 +1721,7 @@ static int at76_send_mgmt_bulk(struct at76_priv *priv,
 				  le16_to_cpu(txbuf->wlength) +
 				  txbuf->padding +
 				  AT76_TX_HDRLEN,
-				  at76_write_bulk_callback,
-				  priv);
+				  at76_write_bulk_callback, priv);
 		ret = usb_submit_urb(priv->write_urb, GFP_ATOMIC);
 		if (ret) {
 			err("%s: %s error in tx submit urb: %d",
@@ -1754,8 +1763,9 @@ static int at76_auth_req(struct at76_priv *priv, struct bss_info *bss,
 
 	/* make wireless header */
 	/* first auth msg is not encrypted, only the second (seq_nr == 3) */
-	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH |
-		(seq_nr == 3 ? IEEE80211_FCTL_PROTECTED : 0));
+	mgmt->frame_ctl =
+	    cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH |
+			(seq_nr == 3 ? IEEE80211_FCTL_PROTECTED : 0));
 
 	mgmt->duration_id = cpu_to_le16(0x8000);
 	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
@@ -1777,8 +1787,7 @@ static int at76_auth_req(struct at76_priv *priv, struct bss_info *bss,
 		 le16_to_cpu(req->algorithm), le16_to_cpu(req->transaction));
 	if (seq_nr == 3) {
 		at76_dbg(DBG_TX_MGMT, "%s: AuthReq challenge: %s ...",
-			 priv->netdev->name,
-			 hex2str(req->info_element, 18));
+			 priv->netdev->name, hex2str(req->info_element, 18));
 	}
 
 	/* either send immediately (if no data tx is pending
@@ -1842,13 +1851,13 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	next_ie(&tlv);		/* tlv points behind the supp_rates field */
 
 	/* init. at76_priv tx header */
-	tx_buffer->wlength = cpu_to_le16((u8 *) tlv - (u8 *) mgmt);
+	tx_buffer->wlength = cpu_to_le16((u8 *)tlv - (u8 *)mgmt);
 
 	tlv = req->info_element;
 	len = min_t(int, IW_ESSID_MAX_SIZE, tlv->len);
 	memcpy(essid, tlv->data, len);
 	essid[len] = '\0';
-	next_ie(&tlv); /* points to IE of rates now */
+	next_ie(&tlv);		/* points to IE of rates now */
 	at76_dbg(DBG_TX_MGMT,
 		 "%s: AssocReq bssid %s capa x%04x ssid %s rates %s",
 		 priv->netdev->name, mac2str(mgmt->addr3),
@@ -1930,7 +1939,7 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 	len = min_t(int, IW_ESSID_MAX_SIZE, tlv->len);
 	memcpy(essid, tlv->data, len);
 	essid[len] = '\0';
-	next_ie(&tlv); /* points to IE of rates now */
+	next_ie(&tlv);		/* points to IE of rates now */
 	at76_dbg(DBG_TX_MGMT,
 		 "%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s",
 		 priv->netdev->name, mac2str(req->current_ap),
@@ -2079,7 +2088,8 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 
 		/* the first cmd status after scan start is always a IDLE ->
 		   start the timer to poll again until COMPLETED */
-		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
+		at76_dbg(DBG_MGMT_TIMER,
+			 "%s:%d: starting mgmt_timer for %d ticks",
 			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 		return;
@@ -2100,12 +2110,13 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 					 sizeof(mdomain.channel_list)),
 				 hex2str(mdomain.tx_powerlevel,
 					 sizeof(mdomain.tx_powerlevel)));
-			}
+		}
 		if ((ret = at76_start_scan(priv, 0, 1)) < 0) {
 			err("%s: %s: start_scan (ANY) failed with %d",
 			    priv->netdev->name, __FUNCTION__, ret);
 		}
-		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
+		at76_dbg(DBG_MGMT_TIMER,
+			 "%s:%d: starting mgmt_timer for %d ticks",
 			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 		break;
@@ -2115,7 +2126,8 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 			err("%s: %s: start_scan (SSID) failed with %d",
 			    priv->netdev->name, __FUNCTION__, ret);
 		}
-		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
+		at76_dbg(DBG_MGMT_TIMER,
+			 "%s:%d: starting mgmt_timer for %d ticks",
 			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 		break;
@@ -2141,23 +2153,25 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 static void at76_work_assoc_done(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_assoc_done);
+					      work_assoc_done);
 
 	mutex_lock(&priv->mtx);
 
-	at76_assert(priv->istate == ASSOCIATING || priv->istate == REASSOCIATING);
+	at76_assert(priv->istate == ASSOCIATING
+		    || priv->istate == REASSOCIATING);
 	if (priv->iw_mode == IW_MODE_INFRA) {
 		at76_assert(priv->curr_bss != NULL);
 		if (priv->curr_bss != NULL && priv->pm_mode != AT76_PM_OFF) {
 			/* calculate the listen interval in units of
 			   beacon intervals of the curr_bss */
 			u32 pm_period_beacon = (priv->pm_period >> 10) /
-						priv->curr_bss->beacon_interval;
+			    priv->curr_bss->beacon_interval;
 
 			pm_period_beacon = max(pm_period_beacon, 2u);
 			pm_period_beacon = min(pm_period_beacon, 0xffffu);
 
-			at76_dbg(DBG_PM, "%s: pm_mode %d assoc id x%x listen int %d",
+			at76_dbg(DBG_PM,
+				 "%s: pm_mode %d assoc id x%x listen int %d",
 				 priv->netdev->name, priv->pm_mode,
 				 priv->curr_bss->assoc_id, pm_period_beacon);
 
@@ -2239,8 +2253,9 @@ static void at76_delete_device(struct at76_priv *priv)
 			dev_kfree_skb(priv->rx_data[i].skb);
 			priv->rx_data[i].skb = NULL;
 		}
-	at76_dbg(DBG_PROC_ENTRY, "%s: before freeing priv/netdev", __FUNCTION__);
-	free_netdev(priv->netdev); /* priv is in netdev */
+	at76_dbg(DBG_PROC_ENTRY, "%s: before freeing priv/netdev",
+		 __FUNCTION__);
+	free_netdev(priv->netdev);	/* priv is in netdev */
 
 	at76_dbg(DBG_PROC_ENTRY, "%s: EXIT", __FUNCTION__);
 }
@@ -2256,15 +2271,15 @@ static int at76_alloc_urbs(struct at76_priv *priv,
 	at76_dbg(DBG_PROC_ENTRY, "%s: ENTER", __FUNCTION__);
 
 	at76_dbg(DBG_URB, "%s: NumEndpoints %d ", __FUNCTION__,
-	    interface->altsetting[0].desc.bNumEndpoints);
+		 interface->altsetting[0].desc.bNumEndpoints);
 
 	iface_desc = interface->cur_altsetting;
 	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
 		endpoint = &iface_desc->endpoint[i].desc;
 
 		at76_dbg(DBG_URB, "%s: %d. endpoint: addr x%x attr x%x",
-		    __FUNCTION__,
-		    i, endpoint->bEndpointAddress, endpoint->bmAttributes);
+			 __FUNCTION__,
+			 i, endpoint->bEndpointAddress, endpoint->bmAttributes);
 
 		if ((endpoint->bEndpointAddress & 0x80) &&
 		    ((endpoint->bmAttributes & 3) == 0x02)) {
@@ -2288,15 +2303,18 @@ static int at76_alloc_urbs(struct at76_priv *priv,
 			}
 			buffer_size = sizeof(struct at76_tx_buffer) +
 			    MAX_PADDING_SIZE;
-			priv->bulk_out_endpointAddr = endpoint->bEndpointAddress;
-			priv->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);
+			priv->bulk_out_endpointAddr =
+			    endpoint->bEndpointAddress;
+			priv->bulk_out_buffer =
+			    kmalloc(buffer_size, GFP_KERNEL);
 			if (!priv->bulk_out_buffer) {
 				err("couldn't allocate bulk_out_buffer");
 				return -ENOMEM;
 			}
 			usb_fill_bulk_urb(priv->write_urb, udev,
 					  usb_sndbulkpipe(udev,
-						      endpoint->bEndpointAddress),
+							  endpoint->
+							  bEndpointAddress),
 					  priv->bulk_out_buffer, buffer_size,
 					  at76_write_bulk_callback, priv);
 		}
@@ -2410,8 +2428,8 @@ static int at76_iw_handler_set_freq(struct net_device *netdev,
 	struct at76_priv *priv = netdev_priv(netdev);
 	int chan = -1;
 	int ret = -EIWCOMMIT;
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - freq.m %d freq.e %d", netdev->name,
-	    freq->m, freq->e);
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - freq.m %d freq.e %d",
+		 netdev->name, freq->m, freq->e);
 
 	if ((freq->e == 0) && (freq->m <= 1000)) {
 		/* Setting by channel number */
@@ -2448,7 +2466,8 @@ static int at76_iw_handler_set_freq(struct net_device *netdev,
 
 	if (ret == -EIWCOMMIT) {
 		priv->channel = chan;
-		at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - ch %d", netdev->name, chan);
+		at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - ch %d", netdev->name,
+			 chan);
 	}
 
 	return ret;
@@ -2467,7 +2486,8 @@ static int at76_iw_handler_get_freq(struct net_device *netdev,
 		at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - freq %ld x 10e%d",
 			 netdev->name, channel_frequency[priv->channel - 1], 6);
 	}
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - ch %d", netdev->name, priv->channel);
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - ch %d", netdev->name,
+		 priv->channel);
 
 	return 0;
 }
@@ -2486,7 +2506,7 @@ static int at76_iw_handler_set_mode(struct net_device *netdev,
 		ret = -EINVAL;
 	} else {
 		priv->iw_mode = *mode;
-		if( priv->iw_mode != IW_MODE_INFRA)
+		if (priv->iw_mode != IW_MODE_INFRA)
 			priv->pm_mode = AT76_PM_OFF;
 	}
 	return ret;
@@ -2494,7 +2514,7 @@ static int at76_iw_handler_set_mode(struct net_device *netdev,
 
 static int at76_iw_handler_get_mode(struct net_device *netdev,
 				    struct iw_request_info *info,
-				    __u32 * mode, char *extra)
+				    __u32 *mode, char *extra)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
 
@@ -2810,7 +2830,8 @@ static int at76_iw_handler_get_scan(struct net_device *netdev,
 		iwe->u.data.flags = 1;
 
 		curr_pos = iwe_stream_add_point(curr_pos,
-			extra + IW_SCAN_MAX_DATA, iwe, curr_bss->ssid);
+						extra + IW_SCAN_MAX_DATA, iwe,
+						curr_bss->ssid);
 
 		iwe->cmd = SIOCGIWMODE;
 		iwe->u.mode = (curr_bss->capa & WLAN_CAPABILITY_IBSS) ?
@@ -2957,7 +2978,8 @@ static int at76_iw_handler_set_rate(struct net_device *netdev,
 	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = -EIWCOMMIT;
 
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRATE - %d", netdev->name, bitrate->value);
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRATE - %d", netdev->name,
+		 bitrate->value);
 
 	switch (bitrate->value) {
 	case -1:
@@ -3067,7 +3089,8 @@ static int at76_iw_handler_set_frag(struct net_device *netdev,
 	int fthr = frag->value;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWFRAG - value %d, disabled %s",
-		 netdev->name, frag->value, (frag->disabled) ? "true" : "false");
+		 netdev->name, frag->value,
+		 (frag->disabled) ? "true" : "false");
 
 	if (frag->disabled)
 		fthr = MAX_FRAG_THRESHOLD;
@@ -3075,7 +3098,7 @@ static int at76_iw_handler_set_frag(struct net_device *netdev,
 	if ((fthr < MIN_FRAG_THRESHOLD) || (fthr > MAX_FRAG_THRESHOLD)) {
 		ret = -EINVAL;
 	} else {
-		priv->frag_threshold = fthr & ~0x1; /* get an even value */
+		priv->frag_threshold = fthr & ~0x1;	/* get an even value */
 	}
 
 	return ret;
@@ -3092,7 +3115,8 @@ static int at76_iw_handler_get_frag(struct net_device *netdev,
 	frag->fixed = 1;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFRAG - value %d, disabled %s",
-		 netdev->name, frag->value, (frag->disabled) ? "true" : "false");
+		 netdev->name, frag->value,
+		 (frag->disabled) ? "true" : "false");
 
 	return 0;
 }
@@ -3155,8 +3179,7 @@ static int at76_iw_handler_get_retry(struct net_device *netdev,
 
 static int at76_iw_handler_set_encode(struct net_device *netdev,
 				      struct iw_request_info *info,
-				      struct iw_point *encoding,
-				      char *extra)
+				      struct iw_point *encoding, char *extra)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
 	int index = (encoding->flags & IW_ENCODE_INDEX) - 1;
@@ -3165,11 +3188,12 @@ static int at76_iw_handler_set_encode(struct net_device *netdev,
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - enc.flags %08x "
 		 "pointer %p len %d", netdev->name, encoding->flags,
 		 encoding->pointer, encoding->length);
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - old wepstate: enabled %s key_id %d "
-		 "auth_mode %s",
-		 netdev->name, (priv->wep_enabled) ? "true" : "false",
-		 priv->wep_key_id,
-		 (priv->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
+	at76_dbg(DBG_IOCTL,
+		 "%s: SIOCSIWENCODE - old wepstate: enabled %s key_id %d "
+		 "auth_mode %s", netdev->name,
+		 (priv->wep_enabled) ? "true" : "false", priv->wep_key_id,
+		 (priv->auth_mode ==
+		  WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
 
 	/* take the old default key if index is invalid */
 	if ((index < 0) || (index >= WEP_KEYS))
@@ -3194,19 +3218,20 @@ static int at76_iw_handler_set_encode(struct net_device *netdev,
 	if (encoding->flags & IW_ENCODE_OPEN)
 		priv->auth_mode = WLAN_AUTH_OPEN;
 
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - new wepstate: enabled %s key_id %d "
-		 "key_len %d auth_mode %s",
-		 netdev->name, (priv->wep_enabled) ? "true" : "false",
-		 priv->wep_key_id + 1, priv->wep_keys_len[priv->wep_key_id],
-		 (priv->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
+	at76_dbg(DBG_IOCTL,
+		 "%s: SIOCSIWENCODE - new wepstate: enabled %s key_id %d "
+		 "key_len %d auth_mode %s", netdev->name,
+		 (priv->wep_enabled) ? "true" : "false", priv->wep_key_id + 1,
+		 priv->wep_keys_len[priv->wep_key_id],
+		 (priv->auth_mode ==
+		  WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
 
 	return -EIWCOMMIT;
 }
 
 static int at76_iw_handler_get_encode(struct net_device *netdev,
 				      struct iw_request_info *info,
-				      struct iw_point *encoding,
-				      char *extra)
+				      struct iw_point *encoding, char *extra)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
 	int index = (encoding->flags & IW_ENCODE_INDEX) - 1;
@@ -3230,14 +3255,15 @@ static int at76_iw_handler_get_encode(struct net_device *netdev,
 	}
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWENCODE - enc.flags %08x "
-		"pointer %p len %d", netdev->name, encoding->flags,
-		encoding->pointer, encoding->length);
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWENCODE - wepstate: enabled %s key_id %d "
-		"key_len %d auth_mode %s",
-		netdev->name, (priv->wep_enabled) ? "true" : "false",
-		priv->wep_key_id + 1, priv->wep_keys_len[priv->wep_key_id],
-		(priv->auth_mode == WLAN_AUTH_SHARED_KEY) ?
-			"restricted" : "open");
+		 "pointer %p len %d", netdev->name, encoding->flags,
+		 encoding->pointer, encoding->length);
+	at76_dbg(DBG_IOCTL,
+		 "%s: SIOCGIWENCODE - wepstate: enabled %s key_id %d "
+		 "key_len %d auth_mode %s", netdev->name,
+		 (priv->wep_enabled) ? "true" : "false", priv->wep_key_id + 1,
+		 priv->wep_keys_len[priv->wep_key_id],
+		 (priv->auth_mode ==
+		  WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
 
 	return 0;
 }
@@ -3249,9 +3275,10 @@ static int at76_iw_handler_set_power(struct net_device *netdev,
 	int err = -EIWCOMMIT;
 	struct at76_priv *priv = netdev_priv(netdev);
 
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWPOWER - disabled %s flags x%x value x%x",
-		 netdev->name, (prq->disabled) ? "true" : "false",
-		 prq->flags, prq->value);
+	at76_dbg(DBG_IOCTL,
+		 "%s: SIOCSIWPOWER - disabled %s flags x%x value x%x",
+		 netdev->name, (prq->disabled) ? "true" : "false", prq->flags,
+		 prq->value);
 
 	if (prq->disabled) {
 		priv->pm_mode = AT76_PM_OFF;
@@ -3291,7 +3318,8 @@ static int at76_iw_handler_get_power(struct net_device *netdev,
 	}
 	power->flags |= IW_POWER_ALL_R;
 
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWPOWER - disabled %s flags x%x value x%x",
+	at76_dbg(DBG_IOCTL,
+		 "%s: SIOCGIWPOWER - disabled %s flags x%x value x%x",
 		 netdev->name, (power->disabled) ? "true" : "false",
 		 power->flags, power->value);
 
@@ -3338,19 +3366,19 @@ static int at76_iw_set_debug(struct net_device *netdev,
 		}
 
 		dbg("%s: AT76_SET_DEBUG input %d: %s -> x%x",
-		       netdev->name, data->length, extra, val);
+		    netdev->name, data->length, extra, val);
 	} else {
 		val = DBG_DEFAULTS;
 	}
 
 	dbg("%s: AT76_SET_DEBUG, old 0x%x  new 0x%x",
-	       netdev->name, at76_debug, val);
+	    netdev->name, at76_debug, val);
 
 	/* jal: some more output to pin down lockups */
 	dbg("%s: netif running %d queue_stopped %d carrier_ok %d",
-	       netdev->name,
-	       netif_running(netdev),
-	       netif_queue_stopped(netdev), netif_carrier_ok(netdev));
+	    netdev->name,
+	    netif_running(netdev),
+	    netif_queue_stopped(netdev), netif_carrier_ok(netdev));
 
 	at76_debug = val;
 
@@ -3431,7 +3459,8 @@ static int at76_set_iroaming(struct at76_priv *priv, int onoff)
 	priv->mib_buf.data[0] = (priv->international_roaming ? 1 : 0);
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (intl_roaming_enable) failed: %d", priv->netdev->name, ret);
+		err("%s: set_mib (intl_roaming_enable) failed: %d",
+		    priv->netdev->name, ret);
 	}
 
 	return ret;
@@ -3466,8 +3495,7 @@ static int at76_iw_set_intl_roaming(struct net_device *netdev,
 /*******************************************************************************
  * structure that advertises the iw handlers of this driver
  */
-static const iw_handler	at76_handlers[] =
-{
+static const iw_handler at76_handlers[] = {
 	AT76_SET_HANDLER(SIOCSIWCOMMIT, at76_iw_handler_commit),
 	AT76_SET_HANDLER(SIOCGIWNAME, at76_iw_handler_get_name),
 	AT76_SET_HANDLER(SIOCSIWFREQ, at76_iw_handler_set_freq),
@@ -3544,14 +3572,13 @@ static const struct iw_priv_args at76_priv_args[] = {
 	 "intl_roaming"},
 };
 
-static const struct iw_handler_def at76_handler_def =
-{
-	.num_standard	= ARRAY_SIZE(at76_handlers),
-	.num_private	= ARRAY_SIZE(at76_priv_handlers),
+static const struct iw_handler_def at76_handler_def = {
+	.num_standard = ARRAY_SIZE(at76_handlers),
+	.num_private = ARRAY_SIZE(at76_priv_handlers),
 	.num_private_args = ARRAY_SIZE(at76_priv_args),
-	.standard	= at76_handlers,
-	.private	= at76_priv_handlers,
-	.private_args	= at76_priv_args,
+	.standard = at76_handlers,
+	.private = at76_priv_handlers,
+	.private_args = at76_priv_args,
 	.get_wireless_stats = at76_get_wireless_stats,
 };
 
@@ -3638,14 +3665,14 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 		return 0;
 	}
 
-	at76_ledtrig_tx_activity(); /* tell the ledtrigger we send a packet */
+	at76_ledtrig_tx_activity();	/* tell the ledtrigger we send a packet */
 
 	/* we can get rid of memcpy, if we set netdev->hard_header_len
 	   to 8 + sizeof(struct ieee80211_hdr_3addr), because then we have
 	   enough space
 	   at76_dbg(DBG_TX, "skb->data - skb->head = %d", skb->data - skb->head); */
 
-	if (ntohs(*(__be16 *) (skb->data + 2 * ETH_ALEN)) <= 1518) {
+	if (ntohs(*(__be16 *)(skb->data + 2 * ETH_ALEN)) <= 1518) {
 		/* this is a 802.3 packet */
 		if (skb->data[2 * ETH_ALEN + 2] == rfc1042sig[0] &&
 		    skb->data[2 * ETH_ALEN + 2 + 1] == rfc1042sig[1]) {
@@ -3653,7 +3680,7 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 			memcpy(payload, skb->data + 2 * ETH_ALEN + 2,
 			       skb->len - 2 * ETH_ALEN - 2);
 			wlen = sizeof(struct ieee80211_hdr_3addr) + skb->len -
-				   2 * ETH_ALEN - 2;
+			    2 * ETH_ALEN - 2;
 		} else {
 			err("%s: %s: no support for non-SNAP 802.2 packets "
 			    "(DSAP x%02x SSAP x%02x cntrl x%02x)",
@@ -3720,9 +3747,10 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	netdev->trans_start = jiffies;
 
 	usb_fill_bulk_urb(priv->write_urb, priv->udev,
-			 usb_sndbulkpipe(priv->udev, priv->bulk_out_endpointAddr),
-			 tx_buffer, submit_len,
-			 at76_write_bulk_callback, priv);
+			  usb_sndbulkpipe(priv->udev,
+					  priv->bulk_out_endpointAddr),
+			  tx_buffer, submit_len, at76_write_bulk_callback,
+			  priv);
 	ret = usb_submit_urb(priv->write_urb, GFP_ATOMIC);
 	if (ret) {
 		stats->tx_errors++;
@@ -3730,8 +3758,10 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 		if (ret == -EINVAL)
 			err("-EINVAL: urb %p urb->hcpriv %p urb->complete %p",
 			    priv->write_urb,
-			    priv->write_urb ? priv->write_urb->hcpriv : (void *)-1,
-			    priv->write_urb ? priv->write_urb->complete : (void *)-1);
+			    priv->write_urb ? priv->write_urb->
+			    hcpriv : (void *)-1,
+			    priv->write_urb ? priv->write_urb->
+			    complete : (void *)-1);
 		goto err;
 	}
 
@@ -3769,7 +3799,8 @@ static int at76_submit_rx_urb(struct at76_priv *priv)
 	if (skb == NULL) {
 		skb = dev_alloc_skb(sizeof(struct at76_rx_buffer));
 		if (skb == NULL) {
-			err("%s: unable to allocate rx skbuff.", priv->netdev->name);
+			err("%s: unable to allocate rx skbuff.",
+			    priv->netdev->name);
 			ret = -ENOMEM;
 			goto exit;
 		}
@@ -3781,15 +3812,18 @@ static int at76_submit_rx_urb(struct at76_priv *priv)
 
 	size = skb_tailroom(skb);
 	usb_fill_bulk_urb(priv->read_urb, priv->udev,
-			 usb_rcvbulkpipe(priv->udev, priv->bulk_in_endpointAddr),
-			 skb_put(skb, size), size,
-			 at76_read_bulk_callback, priv);
+			  usb_rcvbulkpipe(priv->udev,
+					  priv->bulk_in_endpointAddr),
+			  skb_put(skb, size), size, at76_read_bulk_callback,
+			  priv);
 	ret = usb_submit_urb(priv->read_urb, GFP_ATOMIC);
 	if (ret < 0) {
 		if (ret == -ENODEV)
-			at76_dbg(DBG_DEVSTART, "usb_submit_urb returned -ENODEV");
+			at76_dbg(DBG_DEVSTART,
+				 "usb_submit_urb returned -ENODEV");
 		else
-			err("%s: rx, usb_submit_urb failed: %d", priv->netdev->name, ret);
+			err("%s: rx, usb_submit_urb failed: %d",
+			    priv->netdev->name, ret);
 	}
 
       exit:
@@ -3800,8 +3834,9 @@ static int at76_submit_rx_urb(struct at76_priv *priv)
 			if (--priv->nr_submit_rx_tries > 0)
 				schedule_work(&priv->work_submit_rx);
 			else {
-				err("%s: giving up to submit rx urb after %d failures -"
-				    " please unload the driver and/or power cycle the device",
+				err("%s: giving up to submit rx urb after %d "
+				    "failures - please unload the driver "
+				    "and/or power cycle the device",
 				    priv->netdev->name, NR_SUBMIT_RX_TRIES);
 			}
 		}
@@ -3898,7 +3933,7 @@ static int at76_stop(struct net_device *netdev)
 }
 
 static void at76_ethtool_get_drvinfo(struct net_device *netdev,
-					 struct ethtool_drvinfo *info)
+				     struct ethtool_drvinfo *info)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
 
@@ -3961,8 +3996,7 @@ static int at76_init_new_device(struct at76_priv *priv,
 
 	if ((req_fw_version.major == 0) &&
 	    (req_fw_version.minor == 0) &&
-	    (req_fw_version.patch == 0) &&
-	    (req_fw_version.build == 0)) {
+	    (req_fw_version.patch == 0) && (req_fw_version.build == 0)) {
 		err("firmware version consists of all zeroes");
 		err("this probably means that the ext. fw was not loaded correctly");
 		ret = -ENODEV;
@@ -3977,8 +4011,7 @@ static int at76_init_new_device(struct at76_priv *priv,
 
 	info("firmware version %d.%d.%d #%d (fcs_len %d)",
 	     req_fw_version.major, req_fw_version.minor,
-	     req_fw_version.patch, req_fw_version.build,
-	     priv->rx_data_fcs_len);
+	     req_fw_version.patch, req_fw_version.build, priv->rx_data_fcs_len);
 
 	/* MAC address */
 	ret = at76_get_hw_config(priv);
@@ -3991,7 +4024,8 @@ static int at76_init_new_device(struct at76_priv *priv,
 	/* init. netdev->dev_addr */
 	memcpy(netdev->dev_addr, priv->mac_addr, ETH_ALEN);
 	info("device's MAC %s, regulatory domain %s (id %d)",
-	     mac2str(priv->mac_addr), priv->domain->name, priv->regulatory_domain);
+	     mac2str(priv->mac_addr), priv->domain->name,
+	     priv->regulatory_domain);
 
 	/* initializing */
 	priv->international_roaming = IR_OFF;
@@ -4010,7 +4044,7 @@ static int at76_init_new_device(struct at76_priv *priv,
 	priv->scan_max_time = scan_max_time;
 	priv->scan_mode = SCAN_TYPE_ACTIVE;
 
-	netdev->flags &= ~IFF_MULTICAST; /* not yet or never */
+	netdev->flags &= ~IFF_MULTICAST;	/* not yet or never */
 	netdev->open = at76_open;
 	netdev->stop = at76_stop;
 	netdev->get_stats = at76_get_stats;
@@ -4109,15 +4143,17 @@ static int at76_essid_matched(struct at76_priv *priv, struct bss_info *ptr)
 	/* common criteria for both modi */
 
 	int ret = (priv->essid_size == 0 /* ANY ssid */  ||
-		      (priv->essid_size == ptr->ssid_len &&
-		       !memcmp(priv->essid, ptr->ssid, ptr->ssid_len)));
+		   (priv->essid_size == ptr->ssid_len &&
+		    !memcmp(priv->essid, ptr->ssid, ptr->ssid_len)));
 	if (!ret)
-		at76_dbg(DBG_BSS_MATCH, "%s bss table entry %p: essid didn't match",
+		at76_dbg(DBG_BSS_MATCH,
+			 "%s bss table entry %p: essid didn't match",
 			 priv->netdev->name, ptr);
 	return ret;
 }
 
-static inline int at76_mode_matched(struct at76_priv *priv, struct bss_info *ptr)
+static inline int at76_mode_matched(struct at76_priv *priv,
+				    struct bss_info *ptr)
 {
 	int ret;
 
@@ -4126,7 +4162,8 @@ static inline int at76_mode_matched(struct at76_priv *priv, struct bss_info *ptr
 	else
 		ret = ptr->capa & WLAN_CAPABILITY_ESS;
 	if (!ret)
-		at76_dbg(DBG_BSS_MATCH, "%s bss table entry %p: mode didn't match",
+		at76_dbg(DBG_BSS_MATCH,
+			 "%s bss table entry %p: mode didn't match",
 			 priv->netdev->name, ptr);
 	return ret;
 }
@@ -4153,7 +4190,8 @@ static int at76_rates_matched(struct at76_priv *priv, struct bss_info *ptr)
 	/* if we use short preamble, the bss must support it */
 	if (priv->preamble_type == PREAMBLE_TYPE_SHORT &&
 	    !(ptr->capa & WLAN_CAPABILITY_SHORT_PREAMBLE)) {
-		at76_dbg(DBG_BSS_MATCH, "%s: %p does not support short preamble",
+		at76_dbg(DBG_BSS_MATCH,
+			 "%s: %p does not support short preamble",
 			 priv->netdev->name, ptr);
 		return 0;
 	} else
@@ -4164,7 +4202,8 @@ static inline int at76_wep_matched(struct at76_priv *priv, struct bss_info *ptr)
 {
 	if (!priv->wep_enabled && ptr->capa & WLAN_CAPABILITY_PRIVACY) {
 		/* we have disabled WEP, but the BSS signals privacy */
-		at76_dbg(DBG_BSS_MATCH, "%s: bss table entry %p: requires encryption",
+		at76_dbg(DBG_BSS_MATCH,
+			 "%s: bss table entry %p: requires encryption",
 			 priv->netdev->name, ptr);
 		return 0;
 	}
@@ -4180,9 +4219,11 @@ static inline int at76_bssid_matched(struct at76_priv *priv,
 	    !compare_ether_addr(ptr->bssid, priv->wanted_bssid)) {
 		return 1;
 	} else {
-		at76_dbg(DBG_BSS_MATCH, "%s: requested bssid - %s does not match",
+		at76_dbg(DBG_BSS_MATCH,
+			 "%s: requested bssid - %s does not match",
 			 priv->netdev->name, mac2str(priv->wanted_bssid));
-		at76_dbg(DBG_BSS_MATCH, "      AP bssid - %s of bss table entry %p",
+		at76_dbg(DBG_BSS_MATCH,
+			 "      AP bssid - %s of bss table entry %p",
 			 mac2str(ptr->bssid), ptr);
 		return 0;
 	}
@@ -4228,7 +4269,7 @@ static struct bss_info *at76_match_bss(struct at76_priv *priv,
 static void at76_work_join(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_join);
+					      work_join);
 	int ret;
 	unsigned long flags;
 
@@ -4286,7 +4327,8 @@ static void at76_work_join(struct work_struct *work)
 			/* send auth req */
 			priv->istate = AUTHENTICATING;
 			at76_auth_req(priv, priv->curr_bss, 1, NULL);
-			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
+			at76_dbg(DBG_MGMT_TIMER,
+				 "%s:%d: starting mgmt_timer + HZ",
 				 __FUNCTION__, __LINE__);
 			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		}
@@ -4311,14 +4353,14 @@ static void at76_work_join(struct work_struct *work)
 static void at76_work_mgmt_timeout(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_mgmt_timeout);
+					      work_mgmt_timeout);
 
 	mutex_lock(&priv->mtx);
 
 	/* timeouts are normal in SCANNING state, otherwise report */
 	if ((priv->istate != SCANNING) || (at76_debug & DBG_MGMT_TIMER))
-		at76_dbg(DBG_PROGRESS, "%s: timeout, state %d", priv->netdev->name,
-			 priv->istate);
+		at76_dbg(DBG_PROGRESS, "%s: timeout, state %d",
+			 priv->netdev->name, priv->istate);
 
 	switch (priv->istate) {
 
@@ -4349,7 +4391,8 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 	case AUTHENTICATING:
 		if (priv->retries-- >= 0) {
 			at76_auth_req(priv, priv->curr_bss, 1, NULL);
-			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
+			at76_dbg(DBG_MGMT_TIMER,
+				 "%s:%d: starting mgmt_timer + HZ",
 				 __FUNCTION__, __LINE__);
 			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		} else {
@@ -4362,7 +4405,8 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 	case ASSOCIATING:
 		if (priv->retries-- >= 0) {
 			at76_assoc_req(priv, priv->curr_bss);
-			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
+			at76_dbg(DBG_MGMT_TIMER,
+				 "%s:%d: starting mgmt_timer + HZ",
 				 __FUNCTION__, __LINE__);
 			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		} else {
@@ -4394,7 +4438,8 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 	case DISASSOCIATING:
 		if (priv->retries-- >= 0) {
 			at76_disassoc_req(priv, priv->curr_bss);
-			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
+			at76_dbg(DBG_MGMT_TIMER,
+				 "%s:%d: starting mgmt_timer + HZ",
 				 __FUNCTION__, __LINE__);
 			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		} else {
@@ -4416,7 +4461,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 static void at76_work_new_bss(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_new_bss);
+					      work_new_bss);
 	int ret;
 	struct net_device *netdev = priv->netdev;
 	struct mib_mac_mgmt mac_mgmt;
@@ -4424,7 +4469,7 @@ static void at76_work_new_bss(struct work_struct *work)
 	mutex_lock(&priv->mtx);
 
 	ret = at76_get_mib(priv->udev, MIB_MAC_MGMT, &mac_mgmt,
-		      sizeof(struct mib_mac_mgmt));
+			   sizeof(struct mib_mac_mgmt));
 	if (ret < 0) {
 		err("%s: at76_get_mib failed: %d", netdev->name, ret);
 		goto new_bss_clean;
@@ -4442,7 +4487,8 @@ static void at76_work_new_bss(struct work_struct *work)
 	priv->mib_buf.index = IBSS_CHANGE_OK_OFFSET;
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0)
-		err("%s: set_mib (ibss change ok) failed: %d", netdev->name, ret);
+		err("%s: set_mib (ibss change ok) failed: %d", netdev->name,
+		    ret);
 
       new_bss_clean:
 	mutex_unlock(&priv->mtx);
@@ -4461,34 +4507,30 @@ static int at76_startup_device(struct at76_priv *priv)
 		memcpy(ossid, priv->essid, priv->essid_size);
 		ossid[priv->essid_size] = '\0';
 
-		dbg("%s param: ssid %s (%s) mode %s ch %d wep %s key %d keylen %d",
-		       priv->netdev->name, ossid,
-		       hex2str(priv->essid, IW_ESSID_MAX_SIZE),
-		       priv->iw_mode == IW_MODE_ADHOC ? "adhoc" : "infra",
-		       priv->channel,
-		       priv->wep_enabled ? "enabled" : "disabled",
-		       priv->wep_key_id, priv->wep_keys_len[priv->wep_key_id]);
+		dbg("%s param: ssid %s (%s) mode %s ch %d wep %s key %d "
+		    "keylen %d", priv->netdev->name, ossid,
+		    hex2str(priv->essid, IW_ESSID_MAX_SIZE),
+		    priv->iw_mode == IW_MODE_ADHOC ? "adhoc" : "infra",
+		    priv->channel, priv->wep_enabled ? "enabled" : "disabled",
+		    priv->wep_key_id, priv->wep_keys_len[priv->wep_key_id]);
 		dbg("%s param: preamble %s rts %d retry %d frag %d "
-		       "txrate %s auth_mode %d",
-		       priv->netdev->name,
-		       priv->preamble_type == PREAMBLE_TYPE_SHORT ? "short" : "long",
-		       priv->rts_threshold, priv->short_retry_limit,
-		       priv->frag_threshold,
-		       priv->txrate == TX_RATE_1MBIT ? "1MBit" :
-		       priv->txrate == TX_RATE_2MBIT ? "2MBit" :
-		       priv->txrate == TX_RATE_5_5MBIT ? "5.5MBit" :
-		       priv->txrate == TX_RATE_11MBIT ? "11MBit" :
-		       priv->txrate == TX_RATE_AUTO ? "auto" : "<invalid>",
-		       priv->auth_mode);
+		    "txrate %s auth_mode %d", priv->netdev->name,
+		    priv->preamble_type ==
+		    PREAMBLE_TYPE_SHORT ? "short" : "long", priv->rts_threshold,
+		    priv->short_retry_limit, priv->frag_threshold,
+		    priv->txrate == TX_RATE_1MBIT ? "1MBit" : priv->txrate ==
+		    TX_RATE_2MBIT ? "2MBit" : priv->txrate ==
+		    TX_RATE_5_5MBIT ? "5.5MBit" : priv->txrate ==
+		    TX_RATE_11MBIT ? "11MBit" : priv->txrate ==
+		    TX_RATE_AUTO ? "auto" : "<invalid>", priv->auth_mode);
 		dbg("%s param: pm_mode %d pm_period %d auth_mode %s "
-		       "scan_times %d %d scan_mode %s international_roaming %d",
-		       priv->netdev->name,
-		       priv->pm_mode, priv->pm_period,
-		       priv->auth_mode == WLAN_AUTH_OPEN ?
-		       "open" : "shared_secret",
-		       priv->scan_min_time, priv->scan_max_time,
-		       priv->scan_mode == SCAN_TYPE_ACTIVE ? "active" : "passive",
-		       priv->international_roaming);
+		    "scan_times %d %d scan_mode %s international_roaming %d",
+		    priv->netdev->name, priv->pm_mode, priv->pm_period,
+		    priv->auth_mode ==
+		    WLAN_AUTH_OPEN ? "open" : "shared_secret",
+		    priv->scan_min_time, priv->scan_max_time,
+		    priv->scan_mode == SCAN_TYPE_ACTIVE ? "active" : "passive",
+		    priv->international_roaming);
 	}
 
 	memset(ccfg, 0, sizeof(struct at76_card_config));
@@ -4528,7 +4570,8 @@ static int at76_startup_device(struct at76_priv *priv)
 	ret = at76_set_card_command(priv->udev, CMD_STARTUP, &priv->card_config,
 				    sizeof(struct at76_card_config));
 	if (ret < 0) {
-		err("%s: at76_set_card_command failed: %d", priv->netdev->name, ret);
+		err("%s: at76_set_card_command failed: %d", priv->netdev->name,
+		    ret);
 		return ret;
 	}
 
@@ -4540,22 +4583,29 @@ static int at76_startup_device(struct at76_priv *priv)
 	if (at76_set_radio(priv, 1) == 1)
 		at76_wait_completion(priv, CMD_RADIO);
 
-	if ((ret = at76_set_preamble(priv, priv->preamble_type)) < 0)
+	ret = at76_set_preamble(priv, priv->preamble_type);
+	if (ret < 0)
 		return ret;
 
-	if ((ret = at76_set_frag(priv, priv->frag_threshold)) < 0)
+	ret = at76_set_frag(priv, priv->frag_threshold);
+	if (ret < 0)
 		return ret;
 
-	if ((ret = at76_set_rts(priv, priv->rts_threshold)) < 0)
+	ret = at76_set_rts(priv, priv->rts_threshold);
+	if (ret < 0)
 		return ret;
 
-	if ((ret = at76_set_autorate_fallback(priv, priv->txrate == TX_RATE_AUTO ? 1 : 0)) < 0)
+	ret = at76_set_autorate_fallback(priv,
+					 priv->txrate == TX_RATE_AUTO ? 1 : 0);
+	if (ret < 0)
 		return ret;
 
-	if ((ret = at76_set_pm_mode(priv)) < 0)
+	ret = at76_set_pm_mode(priv);
+	if (ret < 0)
 		return ret;
 
-	if ((ret = at76_set_iroaming(priv, priv->international_roaming)) < 0)
+	ret = at76_set_iroaming(priv, priv->international_roaming);
+	if (ret < 0)
 		return ret;
 
 	at76_set_monitor_mode(priv);
@@ -4576,7 +4626,7 @@ static int at76_startup_device(struct at76_priv *priv)
 static void at76_work_restart(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_restart);
+					      work_restart);
 
 	mutex_lock(&priv->mtx);
 
@@ -4598,7 +4648,7 @@ static void at76_work_restart(struct work_struct *work)
 static void at76_work_scan(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_scan);
+					      work_scan);
 	int ret;
 
 	mutex_lock(&priv->mtx);
@@ -4614,7 +4664,8 @@ static void at76_work_scan(struct work_struct *work)
 		err("%s: %s: start_scan failed with %d",
 		    priv->netdev->name, __FUNCTION__, ret);
 	} else {
-		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
+		at76_dbg(DBG_MGMT_TIMER,
+			 "%s:%d: starting mgmt_timer for %d ticks",
 			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
 		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 	}
@@ -4625,7 +4676,7 @@ static void at76_work_scan(struct work_struct *work)
 static void at76_work_set_promisc(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_set_promisc);
+					      work_set_promisc);
 	int ret = 0;
 
 	mutex_lock(&priv->mtx);
@@ -4647,7 +4698,7 @@ static void at76_work_set_promisc(struct work_struct *work)
 static void at76_work_submit_rx(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
-					     work_submit_rx);
+					      work_submit_rx);
 
 	mutex_lock(&priv->mtx);
 	at76_submit_rx_urb(priv);
@@ -4664,11 +4715,11 @@ static void at76_rx_mgmt_assoc(struct at76_priv *priv,
 	u16 assoc_id = le16_to_cpu(resp->aid);
 	u16 status = le16_to_cpu(resp->status);
 	u16 capa = le16_to_cpu(resp->capability);
-	at76_dbg(DBG_RX_MGMT, "%s: rx AssocResp bssid %s capa x%04x status x%04x "
-		 "assoc_id x%04x rates %s",
-		 priv->netdev->name, mac2str(mgmt->addr3), capa, status,
-		 assoc_id, hex2str(resp->info_element->data,
-				   resp->info_element->len));
+	at76_dbg(DBG_RX_MGMT,
+		 "%s: rx AssocResp bssid %s capa x%04x status x%04x "
+		 "assoc_id x%04x rates %s", priv->netdev->name,
+		 mac2str(mgmt->addr3), capa, status, assoc_id,
+		 hex2str(resp->info_element->data, resp->info_element->len));
 	if (priv->istate == ASSOCIATING) {
 		at76_assert(priv->curr_bss != NULL);
 		if (priv->curr_bss == NULL)
@@ -4705,9 +4756,10 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *priv,
 	u16 status = le16_to_cpu(resp->status);
 	u16 assoc_id = le16_to_cpu(resp->aid);
 
-	at76_dbg(DBG_RX_MGMT, "%s: rx ReAssocResp bssid %s capa x%04x status x%04x "
-		 "assoc_id x%04x rates %s",
-		 priv->netdev->name, mac2str(mgmt->addr3), capa, status, assoc_id,
+	at76_dbg(DBG_RX_MGMT,
+		 "%s: rx ReAssocResp bssid %s capa x%04x status x%04x "
+		 "assoc_id x%04x rates %s", priv->netdev->name,
+		 mac2str(mgmt->addr3), capa, status, assoc_id,
 		 hex2str(resp->info_element->data, resp->info_element->len));
 	if (priv->istate == REASSOCIATING) {
 		at76_assert(priv->new_bss != NULL);
@@ -4752,10 +4804,10 @@ static void at76_rx_mgmt_disassoc(struct at76_priv *priv,
 	    (struct ieee80211_disassoc *)buf->packet;
 	struct ieee80211_hdr_3addr *mgmt = &resp->header;
 
-	at76_dbg(DBG_RX_MGMT, "%s: rx DisAssoc bssid %s reason x%04x destination %s",
+	at76_dbg(DBG_RX_MGMT,
+		 "%s: rx DisAssoc bssid %s reason x%04x destination %s",
 		 priv->netdev->name, mac2str(mgmt->addr3),
-		 le16_to_cpu(resp->reason),
-		 mac2str(mgmt->addr1));
+		 le16_to_cpu(resp->reason), mac2str(mgmt->addr1));
 	if (priv->istate == SCANNING || priv->istate == INIT)
 		return;
 
@@ -4795,7 +4847,8 @@ static void at76_rx_mgmt_disassoc(struct at76_priv *priv,
 	/* ignore DisAssoc to other STA or from other BSSID */
 }
 
-static void at76_rx_mgmt_auth(struct at76_priv *priv, struct at76_rx_buffer *buf)
+static void at76_rx_mgmt_auth(struct at76_priv *priv,
+			      struct at76_rx_buffer *buf)
 {
 	struct ieee80211_auth *resp = (struct ieee80211_auth *)buf->packet;
 	struct ieee80211_hdr_3addr *mgmt = &resp->header;
@@ -4803,15 +4856,14 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv, struct at76_rx_buffer *buf
 	int alg = le16_to_cpu(resp->algorithm);
 	int status = le16_to_cpu(resp->status);
 
-	at76_dbg(DBG_RX_MGMT, "%s: rx AuthFrame bssid %s alg %d seq_nr %d status %d "
-		 "destination %s",
-		 priv->netdev->name, mac2str(mgmt->addr3),
+	at76_dbg(DBG_RX_MGMT,
+		 "%s: rx AuthFrame bssid %s alg %d seq_nr %d status %d "
+		 "destination %s", priv->netdev->name, mac2str(mgmt->addr3),
 		 alg, seq_nr, status, mac2str(mgmt->addr1));
 
 	if (alg == WLAN_AUTH_SHARED_KEY && seq_nr == 2) {
 		at76_dbg(DBG_RX_MGMT, "%s: AuthFrame challenge %s ...",
-			 priv->netdev->name,
-			 hex2str(resp->info_element, 18));
+			 priv->netdev->name, hex2str(resp->info_element, 18));
 	}
 	if (priv->istate != AUTHENTICATING) {
 		info("%s: ignored AuthFrame in state %d",
@@ -4844,14 +4896,16 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv, struct at76_rx_buffer *buf
 			priv->retries = ASSOC_RETRIES;
 			priv->istate = ASSOCIATING;
 			at76_assoc_req(priv, priv->curr_bss);
-			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
+			at76_dbg(DBG_MGMT_TIMER,
+				 "%s:%d: starting mgmt_timer + HZ",
 				 __FUNCTION__, __LINE__);
 			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 			return;
 		}
 
 		at76_assert(seq_nr == 2);
-		at76_auth_req(priv, priv->curr_bss, seq_nr + 1, resp->info_element);
+		at76_auth_req(priv, priv->curr_bss, seq_nr + 1,
+			      resp->info_element);
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
 			 __FUNCTION__, __LINE__);
 		mod_timer(&priv->mgmt_timer, jiffies + HZ);
@@ -4869,13 +4923,11 @@ static void at76_rx_mgmt_deauth(struct at76_priv *priv,
 	at76_dbg(DBG_RX_MGMT | DBG_PROGRESS,
 		 "%s: rx DeAuth bssid %s reason x%04x destination %s",
 		 priv->netdev->name, mac2str(mgmt->addr3),
-		 le16_to_cpu(resp->reason),
-		 mac2str(mgmt->addr1));
+		 le16_to_cpu(resp->reason), mac2str(mgmt->addr1));
 	if (priv->istate == DISASSOCIATING ||
 	    priv->istate == AUTHENTICATING ||
 	    priv->istate == ASSOCIATING ||
-	    priv->istate == REASSOCIATING  ||
-	    priv->istate == CONNECTED) {
+	    priv->istate == REASSOCIATING || priv->istate == CONNECTED) {
 		at76_assert(priv->curr_bss != NULL);
 		if (priv->curr_bss == NULL)
 			return;
@@ -5000,14 +5052,16 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 	 * bytes are useful, hence the have_ssid etc optimizations. */
 
 	while (keep_going &&
-	       ((&tlv->data[tlv->len] - (u8 *)bdata->info_element) <= varpar_len)) {
+	       ((&tlv->data[tlv->len] - (u8 *)bdata->info_element) <=
+		varpar_len)) {
 
 		switch (tlv->id) {
 
 		case MFIE_TYPE_SSID:
 			len = min_t(int, IW_ESSID_MAX_SIZE, tlv->len);
 			if (!have_ssid && ((new_entry) ||
-					   !at76_is_cloaked_ssid(tlv->data, len))) {
+					   !at76_is_cloaked_ssid(tlv->data,
+								 len))) {
 				/* we copy only if this is a new entry,
 				   or the incoming SSID is not a cloaked SSID. This
 				   will protect us from overwriting a real SSID read
@@ -5073,7 +5127,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 	at76_dbg(DBG_RX_BEACON, "%s: Finished processing beacon data",
 		 priv->netdev->name);
 
-	match->last_rx = jiffies; /* record last rx of beacon */
+	match->last_rx = jiffies;	/* record last rx of beacon */
 
       rx_mgmt_beacon_end:
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
@@ -5083,7 +5137,8 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 static void at76_calc_level(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			    struct iw_quality *qual)
 {
-	int max_rssi = 42;	/* just a guess for now, might be different for other chips */
+	/* just a guess for now, might be different for other chips */
+	int max_rssi = 42;
 
 	qual->level = (buf->rssi * 100 / max_rssi);
 	if (qual->level > 100)
@@ -5093,7 +5148,7 @@ static void at76_calc_level(struct at76_priv *priv, struct at76_rx_buffer *buf,
 
 /* calc the link quality from a given rx_buffer */
 static void at76_calc_qual(struct at76_priv *priv, struct at76_rx_buffer *buf,
-			   struct iw_quality* qual)
+			   struct iw_quality *qual)
 {
 	if ((priv->fwe->board_type == BOARDTYPE_503_INTERSIL_3861) ||
 	    (priv->fwe->board_type == BOARDTYPE_503_INTERSIL_3863)) {
@@ -5151,8 +5206,10 @@ static void at76_rx_mgmt(struct at76_priv *priv, struct at76_rx_buffer *buf)
 	/* update wstats */
 	if (priv->istate != INIT && priv->istate != SCANNING) {
 		/* jal: this is a dirty hack needed by Tim in ad-hoc mode */
-		if (priv->iw_mode == IW_MODE_ADHOC || (priv->curr_bss != NULL &&
-		     !compare_ether_addr(mgmt->addr3, priv->curr_bss->bssid))) {
+		if (priv->iw_mode == IW_MODE_ADHOC ||
+		    (priv->curr_bss != NULL
+		     && !compare_ether_addr(mgmt->addr3,
+					    priv->curr_bss->bssid))) {
 			/* Data packets always seem to have a 0 link level, so we
 			   only read link quality info from management packets.
 			   Atmel driver actually averages the present, and previous
@@ -5253,14 +5310,14 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 	} else if (!memcmp(skb->data, snapsig, sizeof(snapsig))) {
 		/* SNAP frame - collapse it */
 		skb_pull(skb, sizeof(rfc1042sig) + 2);
-		proto = *(__be16 *) (skb->data - 2);
+		proto = *(__be16 *)(skb->data - 2);
 	} else {
 #ifdef IEEE_STANDARD
 		/* According to all standards, we should assume the data
 		 * portion contains 802.2 LLC information, so we should give it
 		 * an 802.3 header (which has the same implications) */
 		proto = htons(skb->len);
-#else /* IEEE_STANDARD */
+#else				/* IEEE_STANDARD */
 		/* Unfortunately, it appears no actual 802.11 implementations
 		 * follow any standards specs.  They all appear to put a
 		 * 16-bit ethertype after the 802.11 header instead, so we take
@@ -5273,7 +5330,7 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 		   IEEE_STANDARD ... */
 		proto = *(__be16 *)(skb->data);
 		skb_pull(skb, 2);
-#endif /* IEEE_STANDARD */
+#endif				/* IEEE_STANDARD */
 	}
 
 	skb_set_mac_header(skb, -(int)sizeof(struct ethhdr));
@@ -5337,11 +5394,10 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 	struct rx_data_buf *bptr, *optr;
 	unsigned long oldest = ~0UL;
 
-	at76_dbg(DBG_RX_FRAGS, "%s: rx data frame_ctl %04x addr2 %s seq/frag %d/%d "
-		 "length %d data %d: %s ...",
-		 priv->netdev->name, frame_ctl,
-		 mac2str(i802_11_hdr->addr2),
-		 seqnr, fragnr, length, data_len,
+	at76_dbg(DBG_RX_FRAGS,
+		 "%s: rx data frame_ctl %04x addr2 %s seq/frag %d/%d "
+		 "length %d data %d: %s ...", priv->netdev->name, frame_ctl,
+		 mac2str(i802_11_hdr->addr2), seqnr, fragnr, length, data_len,
 		 hex2str(data, 32));
 
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: incoming skb: head %p data %p "
@@ -5357,7 +5413,8 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 
 	if (fragnr == 0 && !(frame_ctl & IEEE80211_FCTL_MOREFRAGS)) {
 		/* unfragmented packet received */
-		if (length < rx_copybreak && (skb = dev_alloc_skb(length)) != NULL) {
+		if (length < rx_copybreak
+		    && (skb = dev_alloc_skb(length)) != NULL) {
 			memcpy(skb_put(skb, length),
 			       priv->rx_skb->data + AT76_RX_HDRLEN, length);
 		} else {
@@ -5397,16 +5454,16 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 	optr = NULL;
 	for (i = 0; i < NR_RX_DATA_BUF; i++, bptr++) {
 		if (bptr->skb != NULL) {
-			if (!compare_ether_addr(i802_11_hdr->addr2, bptr->sender))
+			if (!compare_ether_addr(i802_11_hdr->addr2,
+						bptr->sender))
 				break;
-			else
-				if (optr == NULL) {
+			else if (optr == NULL) {
+				optr = bptr;
+				oldest = bptr->last_rx;
+			} else {
+				if (bptr->last_rx < oldest)
 					optr = bptr;
-					oldest = bptr->last_rx;
-				} else {
-					if (bptr->last_rx < oldest)
-						optr = bptr;
-				}
+			}
 		} else {
 			optr = bptr;
 			oldest = 0UL;
@@ -5426,32 +5483,35 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 			if (((bptr->fragnr + 1) & 0xf) == fragnr) {
 				bptr->last_rx = jiffies;
 				/* the next following fragment number ->
-				    add the data at the end */
+				   add the data at the end */
 				/* is & 0xf necessary above ??? */
 
 				/* for test only ??? */
 				left = skb_tailroom(bptr->skb);
 				if (left < data_len) {
 					info("%s: only %d byte free (need %d)",
-					    priv->netdev->name, left, data_len);
+					     priv->netdev->name, left,
+					     data_len);
 				} else
 					memcpy(skb_put(bptr->skb, data_len),
 					       data, data_len);
 				bptr->fragnr = fragnr;
-				if (!(frame_ctl &
-				      IEEE80211_FCTL_MOREFRAGS)) {
+				if (!(frame_ctl & IEEE80211_FCTL_MOREFRAGS)) {
 					/* this was the last fragment - send it */
 					skb = bptr->skb;
-					bptr->skb = NULL; /* free the entry */
-					at76_dbg(DBG_RX_FRAGS, "%s: last frag of seq %d",
+					bptr->skb = NULL;	/* free the entry */
+					at76_dbg(DBG_RX_FRAGS,
+						 "%s: last frag of seq %d",
 						 priv->netdev->name, seqnr);
 					return skb;
 				} else
 					return NULL;
 			} else {
 				/* wrong fragment number -> ignore it */
-				at76_dbg(DBG_RX_FRAGS, "%s: frag nr does not match: %d+1 != %d",
-					 priv->netdev->name, bptr->fragnr, fragnr);
+				at76_dbg(DBG_RX_FRAGS,
+					 "%s: frag nr does not match: %d+1 != %d",
+					 priv->netdev->name, bptr->fragnr,
+					 fragnr);
 				return NULL;
 			}
 		} else {
@@ -5460,9 +5520,11 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 				/* it's the start of a new chain - replace the
 				   old one by this */
 				/* bptr->sender has the correct value already */
-				at76_dbg(DBG_RX_FRAGS, "%s: start of new seq %d, "
-					 "removing old seq %d", priv->netdev->name,
-					 seqnr, bptr->seqnr);
+				at76_dbg(DBG_RX_FRAGS,
+					 "%s: start of new seq %d, "
+					 "removing old seq %d",
+					 priv->netdev->name, seqnr,
+					 bptr->seqnr);
 				bptr->seqnr = seqnr;
 				bptr->fragnr = 0;
 				bptr->last_rx = jiffies;
@@ -5473,9 +5535,11 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 			} else {
 				/* it from the middle of a new chain ->
 				   delete the old entry and skip the new one */
-				at76_dbg(DBG_RX_FRAGS, "%s: middle of new seq %d (%d) "
-					 "removing old seq %d", priv->netdev->name,
-					 seqnr, fragnr, bptr->seqnr);
+				at76_dbg(DBG_RX_FRAGS,
+					 "%s: middle of new seq %d (%d) "
+					 "removing old seq %d",
+					 priv->netdev->name, seqnr, fragnr,
+					 bptr->seqnr);
 				dev_kfree_skb(bptr->skb);
 				bptr->skb = NULL;
 			}
@@ -5487,7 +5551,8 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 
 		if (fragnr != 0) {
 			/* this is not the begin of a fragment chain ... */
-			at76_dbg(DBG_RX_FRAGS, "%s: no chain for non-first fragment (%d)",
+			at76_dbg(DBG_RX_FRAGS,
+				 "%s: no chain for non-first fragment (%d)",
 				 priv->netdev->name, fragnr);
 			return NULL;
 		}
@@ -5501,16 +5566,18 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 			optr->skb = priv->rx_skb;
 			priv->rx_skb = skb;
 
-			at76_dbg(DBG_RX_FRAGS, "%s: free old contents: sender %s seq/frag %d/%d",
+			at76_dbg(DBG_RX_FRAGS,
+				 "%s: free old contents: sender %s seq/frag %d/%d",
 				 priv->netdev->name, mac2str(optr->sender),
 				 optr->seqnr, optr->fragnr);
 
 		} else {
 			/* take the skb from priv->rx_skb */
 			optr->skb = priv->rx_skb;
-			priv->rx_skb = NULL; /* let at76_submit_rx_urb() allocate a new skb */
+			priv->rx_skb = NULL;	/* let at76_submit_rx_urb() allocate a new skb */
 
-			at76_dbg(DBG_RX_FRAGS, "%s: use a free entry", priv->netdev->name);
+			at76_dbg(DBG_RX_FRAGS, "%s: use a free entry",
+				 priv->netdev->name);
 		}
 		memcpy(optr->sender, i802_11_hdr->addr2, ETH_ALEN);
 		optr->seqnr = seqnr;
@@ -5582,7 +5649,8 @@ static void at76_rx_monitor_mode(struct at76_priv *priv)
 
 	if (length < priv->rx_data_fcs_len) {
 		/* buffer contains no data */
-		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE: rx skb without data",
+		at76_dbg(DBG_MONITOR_MODE,
+			 "%s: MONITOR MODE: rx skb without data",
 			 priv->netdev->name);
 		return;
 	}
@@ -5628,10 +5696,9 @@ static void at76_rx_monitor_mode(struct at76_priv *priv)
 	stats->rx_bytes += length;
 }
 
-/**
- * at76_iwspy_update - check if we spy on the sender address of buf and update stats
- */
-static void at76_iwspy_update(struct at76_priv *priv, struct at76_rx_buffer *buf)
+/* check if we spy on the sender address in buf and update stats */
+static void at76_iwspy_update(struct at76_priv *priv,
+			      struct at76_rx_buffer *buf)
 {
 	struct ieee80211_hdr_3addr *hdr =
 	    (struct ieee80211_hdr_3addr *)buf->packet;
@@ -5696,11 +5763,10 @@ static void at76_rx_tasklet(unsigned long param)
 		return;
 	}
 
-	at76_dbg(DBG_RX_ATMEL_HDR, "%s: rx frame: rate %d rssi %d noise %d link %d %s",
-		 priv->netdev->name,
-		 buf->rx_rate, buf->rssi, buf->noise_level,
-		 buf->link_quality,
-		 hex2str(i802_11_hdr, 48));
+	at76_dbg(DBG_RX_ATMEL_HDR,
+		 "%s: rx frame: rate %d rssi %d noise %d link %d %s",
+		 priv->netdev->name, buf->rx_rate, buf->rssi, buf->noise_level,
+		 buf->link_quality, hex2str(i802_11_hdr, 48));
 	if (priv->istate == MONITORING) {
 		at76_rx_monitor_mode(priv);
 		goto finish;
@@ -5930,14 +5996,13 @@ static int at76_probe(struct usb_interface *interface,
 	if ((fwe->fw_version.major > 0 || fwe->fw_version.minor >= 100)
 	    || (op_mode == OPMODE_NORMAL_NIC_WITH_FLASH)) {
 		ret = at76_get_mib(udev, MIB_FW_VERSION,
-				   &req_fw_version,
-				   sizeof(req_fw_version));
+				   &req_fw_version, sizeof(req_fw_version));
 		if ((ret < 0)
 		    || ((req_fw_version.major == 0)
 			&& (req_fw_version.minor == 0)
 			&& (req_fw_version.patch == 0)
 			&& (req_fw_version.build == 0)))
-		need_ext_fw = 1;
+			need_ext_fw = 1;
 	} else {
 		/* No way to check firmware version, reload to be sure */
 		need_ext_fw = 1;




From proski at gnu.org  Thu Jun 14 03:11:37 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:37 -0400
Subject: [at76c503a-develop] [PATCH 09/12] Save results of usb_sndbulkpipe()
	and usb_rcvbulkpipe()
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011137.25709.15564.stgit@dv.roinet.com>

Calculate the pipe numbers on startup and keep them in at76_priv instead
of keeping the endpoint numbers.  Pipe numbers don't change.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   36 +++++++++++++-----------------------
 at76_usb.h |    4 ++--
 2 files changed, 15 insertions(+), 25 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 6064171..c763457 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1647,9 +1647,7 @@ static void at76_write_bulk_callback(struct urb *urb)
 		       le16_to_cpu(mgmt_buf->wlength) +
 		       offsetof(struct at76_tx_buffer, packet));
 		usb_fill_bulk_urb(priv->write_urb, priv->udev,
-				  usb_sndbulkpipe(priv->udev,
-						  priv->bulk_out_endpointAddr),
-				  priv->bulk_out_buffer,
+				  priv->tx_bulk_pipe, priv->bulk_out_buffer,
 				  le16_to_cpu(mgmt_buf->wlength) +
 				  mgmt_buf->padding + AT76_TX_HDRLEN,
 				  at76_write_bulk_callback, priv);
@@ -1715,13 +1713,10 @@ static int at76_send_mgmt_bulk(struct at76_priv *priv,
 		memcpy(priv->bulk_out_buffer, txbuf,
 		       le16_to_cpu(txbuf->wlength) + AT76_TX_HDRLEN);
 		usb_fill_bulk_urb(priv->write_urb, priv->udev,
-				  usb_sndbulkpipe(priv->udev,
-						  priv->bulk_out_endpointAddr),
-				  priv->bulk_out_buffer,
-				  le16_to_cpu(txbuf->wlength) +
-				  txbuf->padding +
-				  AT76_TX_HDRLEN,
-				  at76_write_bulk_callback, priv);
+				  priv->tx_bulk_pipe, priv->bulk_out_buffer,
+				  le16_to_cpu(txbuf->wlength) + txbuf->padding +
+				  AT76_TX_HDRLEN, at76_write_bulk_callback,
+				  priv);
 		ret = usb_submit_urb(priv->write_urb, GFP_ATOMIC);
 		if (ret) {
 			err("%s: %s error in tx submit urb: %d",
@@ -2290,7 +2285,8 @@ static int at76_alloc_urbs(struct at76_priv *priv,
 				err("No free urbs available");
 				return -ENOMEM;
 			}
-			priv->bulk_in_endpointAddr = endpoint->bEndpointAddress;
+			priv->rx_bulk_pipe =
+			    usb_rcvbulkpipe(udev, endpoint->bEndpointAddress);
 		}
 
 		if (((endpoint->bEndpointAddress & 0x80) == 0x00) &&
@@ -2303,18 +2299,16 @@ static int at76_alloc_urbs(struct at76_priv *priv,
 			}
 			buffer_size = sizeof(struct at76_tx_buffer) +
 			    MAX_PADDING_SIZE;
-			priv->bulk_out_endpointAddr =
-			    endpoint->bEndpointAddress;
-			priv->bulk_out_buffer =
+			priv->tx_bulk_pipe =
+			    usb_sndbulkpipe(udev, endpoint->bEndpointAddress),
+			    priv->bulk_out_buffer =
 			    kmalloc(buffer_size, GFP_KERNEL);
 			if (!priv->bulk_out_buffer) {
 				err("couldn't allocate bulk_out_buffer");
 				return -ENOMEM;
 			}
 			usb_fill_bulk_urb(priv->write_urb, udev,
-					  usb_sndbulkpipe(udev,
-							  endpoint->
-							  bEndpointAddress),
+					  priv->tx_bulk_pipe,
 					  priv->bulk_out_buffer, buffer_size,
 					  at76_write_bulk_callback, priv);
 		}
@@ -3746,9 +3740,7 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	netif_stop_queue(netdev);
 	netdev->trans_start = jiffies;
 
-	usb_fill_bulk_urb(priv->write_urb, priv->udev,
-			  usb_sndbulkpipe(priv->udev,
-					  priv->bulk_out_endpointAddr),
+	usb_fill_bulk_urb(priv->write_urb, priv->udev, priv->tx_bulk_pipe,
 			  tx_buffer, submit_len, at76_write_bulk_callback,
 			  priv);
 	ret = usb_submit_urb(priv->write_urb, GFP_ATOMIC);
@@ -3811,9 +3803,7 @@ static int at76_submit_rx_urb(struct at76_priv *priv)
 	}
 
 	size = skb_tailroom(skb);
-	usb_fill_bulk_urb(priv->read_urb, priv->udev,
-			  usb_rcvbulkpipe(priv->udev,
-					  priv->bulk_in_endpointAddr),
+	usb_fill_bulk_urb(priv->read_urb, priv->udev, priv->rx_bulk_pipe,
 			  skb_put(skb, size), size, at76_read_bulk_callback,
 			  priv);
 	ret = usb_submit_urb(priv->read_urb, GFP_ATOMIC);
diff --git a/at76_usb.h b/at76_usb.h
index 2a292b5..aeabc4a 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -465,12 +465,12 @@ struct at76_priv {
 	struct iw_statistics wstats;
 
 	struct sk_buff *rx_skb;	/* skbuff for receiving packets */
-	__u8 bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
+	unsigned int rx_bulk_pipe;	/* bulk in endpoint */
 
 	void *bulk_out_buffer;	/* the buffer to send data */
 	struct urb *write_urb;	/* the urb used to send data */
 	struct urb *read_urb;
-	__u8 bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
+	unsigned int tx_bulk_pipe;	/* bulk out endpoint */
 
 	int open_count;		/* number of times this port has been opened */
 	struct mutex mtx;	/* locks this structure */




From proski at gnu.org  Thu Jun 14 03:11:42 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:42 -0400
Subject: [at76c503a-develop] [PATCH 10/12] Improve info messages,
	avoid printing full path
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011142.25709.39171.stgit@dv.roinet.com>

Never use __FILE__, as it prints full path to the driver, which is
rarely needed.  Use DRIVER_NAME instead.

Replace all occurrences of info() with printk() calls.  Ensure that the
messages are properly formatted and use the netdevice name if possible.

Print MAC address, firmware version and regulatory domain after the
device is registered, so we can provide the device name.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   97 ++++++++++++++++++++++++++++++++----------------------------
 at76_usb.h |    2 +
 2 files changed, 53 insertions(+), 46 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index c763457..d363ff9 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -871,8 +871,9 @@ static int at76_set_mib(struct at76_priv *priv, struct set_mib_buffer *buf)
 		if (ret >= 0) {
 			ret = at76_wait_completion(priv, CMD_SET_MIB);
 			if (ret != CMD_STATUS_COMPLETE) {
-				info("%s: set_mib: at76_wait_completion failed "
-				     "with %d", priv->netdev->name, ret);
+				printk(KERN_INFO
+				       "%s: set_mib: at76_wait_completion failed "
+				       "with %d\n", priv->netdev->name, ret);
 				ret = -EIO;
 			}
 		}
@@ -1400,7 +1401,8 @@ static int at76_get_current_bssid(struct at76_priv *priv)
 		goto err;
 	}
 	memcpy(priv->bssid, mac_mgmt->current_bssid, ETH_ALEN);
-	info("using BSSID %s", mac2str(priv->bssid));
+	printk(KERN_INFO "%s: using BSSID %s\n", priv->netdev->name,
+	       mac2str(priv->bssid));
       err:
 	kfree(mac_mgmt);
       exit:
@@ -2451,9 +2453,10 @@ static int at76_iw_handler_set_freq(struct net_device *netdev,
 		ret = -EINVAL;
 	} else if (!priv->international_roaming) {
 		if (!(priv->domain->channel_map & (1 << (chan - 1)))) {
-			info("%s: channel %d not allowed for domain %s "
-			     "(and international_roaming is OFF)",
-			     priv->netdev->name, chan, priv->domain->name);
+			printk(KERN_INFO
+			       "%s: channel %d not allowed for domain %s "
+			       "(and international_roaming is OFF)\n",
+			       priv->netdev->name, chan, priv->domain->name);
 			ret = -EINVAL;
 		}
 	}
@@ -3999,10 +4002,6 @@ static int at76_init_new_device(struct at76_priv *priv,
 	else
 		priv->rx_data_fcs_len = 4;
 
-	info("firmware version %d.%d.%d #%d (fcs_len %d)",
-	     req_fw_version.major, req_fw_version.minor,
-	     req_fw_version.patch, req_fw_version.build, priv->rx_data_fcs_len);
-
 	/* MAC address */
 	ret = at76_get_hw_config(priv);
 	if (ret < 0) {
@@ -4013,9 +4012,6 @@ static int at76_init_new_device(struct at76_priv *priv,
 	priv->domain = at76_get_reg_domain(priv->regulatory_domain);
 	/* init. netdev->dev_addr */
 	memcpy(netdev->dev_addr, priv->mac_addr, ETH_ALEN);
-	info("device's MAC %s, regulatory domain %s (id %d)",
-	     mac2str(priv->mac_addr), priv->domain->name,
-	     priv->regulatory_domain);
 
 	/* initializing */
 	priv->international_roaming = IR_OFF;
@@ -4057,9 +4053,17 @@ static int at76_init_new_device(struct at76_priv *priv,
 		    priv->netdev->name, ret);
 		goto error;
 	}
-	info("registered %s", priv->netdev->name);
 	priv->netdev_registered = 1;
 
+	printk(KERN_INFO "%s: MAC address %s\n", netdev->name,
+	       mac2str(priv->mac_addr));
+	printk(KERN_INFO "%s: firmware version %d.%d.%d #%d (fcs_len %d)\n",
+	       netdev->name, req_fw_version.major, req_fw_version.minor,
+	       req_fw_version.patch, req_fw_version.build,
+	       priv->rx_data_fcs_len);
+	printk(KERN_INFO "%s: regulatory domain %s (id %d)\n", netdev->name,
+	       priv->domain->name, priv->regulatory_domain);
+
 	/* we let this timer run the whole time this driver instance lives */
 	mod_timer(&priv->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
 
@@ -4091,7 +4095,7 @@ static int at76_load_external_fw(struct usb_device *udev, struct fwentry *fwe)
 	}
 
 	if (fwe->board_type == BOARDTYPE_505A_RFMD_2958) {
-		info("200 ms delay for board type 7");
+		at76_dbg(DBG_DEVSTART, "200 ms delay for board type 7");
 		schedule_timeout_interruptible(HZ / 5 + 1);
 	}
 	return 0;
@@ -4290,9 +4294,10 @@ static void at76_work_join(struct work_struct *work)
 				err("%s join_bss completed with %d",
 				    priv->netdev->name, ret);
 			else
-				info("%s join_bss ssid %s timed out",
-				     priv->netdev->name,
-				     mac2str(priv->curr_bss->bssid));
+				printk(KERN_INFO
+				       "%s: join_bss ssid %s timed out\n",
+				       priv->netdev->name,
+				       mac2str(priv->curr_bss->bssid));
 
 			/* retry next BSS immediately */
 			schedule_work(&priv->work_join);
@@ -4365,8 +4370,8 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 
 	case CONNECTED:	/* we haven't received the beacon of this BSS for
 				   BEACON_TIMEOUT seconds */
-		info("%s: lost beacon bssid %s",
-		     priv->netdev->name, mac2str(priv->curr_bss->bssid));
+		printk(KERN_INFO "%s: lost beacon bssid %s\n",
+		       priv->netdev->name, mac2str(priv->curr_bss->bssid));
 		/* jal: starting mgmt_timer in ad-hoc mode is questionable,
 		   but I'll leave it here to track down another lockup problem */
 		if (priv->iw_mode != IW_MODE_ADHOC) {
@@ -4730,8 +4735,8 @@ static void at76_rx_mgmt_assoc(struct at76_priv *priv,
 		}
 		del_timer_sync(&priv->mgmt_timer);
 	} else {
-		info("%s: AssocResp in state %d ignored",
-		     priv->netdev->name, priv->istate);
+		printk(KERN_INFO "%s: AssocResp in state %d ignored\n",
+		       priv->netdev->name, priv->istate);
 	}
 }
 
@@ -4782,8 +4787,8 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *priv,
 			schedule_work(&priv->work_join);
 		}
 	} else {
-		info("%s: ReAssocResp in state %d ignored",
-		     priv->netdev->name, priv->istate);
+		printk(KERN_INFO "%s: ReAssocResp in state %d ignored\n",
+		       priv->netdev->name, priv->istate);
 	}
 }
 
@@ -4830,8 +4835,8 @@ static void at76_rx_mgmt_disassoc(struct at76_priv *priv,
 			schedule_work(&priv->work_join);
 		} else {
 			/* ignore DisAssoc in states AUTH, ASSOC */
-			info("%s: DisAssoc in state %d ignored",
-			     priv->netdev->name, priv->istate);
+			printk(KERN_INFO "%s: DisAssoc in state %d ignored\n",
+			       priv->netdev->name, priv->istate);
 		}
 	}
 	/* ignore DisAssoc to other STA or from other BSSID */
@@ -4856,13 +4861,13 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv,
 			 priv->netdev->name, hex2str(resp->info_element, 18));
 	}
 	if (priv->istate != AUTHENTICATING) {
-		info("%s: ignored AuthFrame in state %d",
-		     priv->netdev->name, priv->istate);
+		printk(KERN_INFO "%s: ignored AuthFrame in state %d\n",
+		       priv->netdev->name, priv->istate);
 		return;
 	}
 	if (priv->auth_mode != alg) {
-		info("%s: ignored AuthFrame for alg %d",
-		     priv->netdev->name, alg);
+		printk(KERN_INFO "%s: ignored AuthFrame for alg %d\n",
+		       priv->netdev->name, alg);
 		return;
 	}
 
@@ -4937,8 +4942,8 @@ static void at76_rx_mgmt_deauth(struct at76_priv *priv,
 		/* ignore DeAuth to other STA or from other BSSID */
 	} else {
 		/* ignore DeAuth in states SCANNING */
-		info("%s: DeAuth in state %d ignored",
-		     priv->netdev->name, priv->istate);
+		printk(KERN_INFO "%s: DeAuth in state %d ignored\n",
+		       priv->netdev->name, priv->istate);
 	}
 }
 
@@ -5239,8 +5244,8 @@ static void at76_rx_mgmt(struct at76_priv *priv, struct at76_rx_buffer *buf)
 		break;
 
 	default:
-		info("%s: mgmt, but not beacon, subtype = %x",
-		     priv->netdev->name, subtype);
+		printk(KERN_INFO "%s: mgmt, but not beacon, subtype = %x\n",
+		       priv->netdev->name, subtype);
 	}
 
 	return;
@@ -5257,7 +5262,7 @@ static void at76_dbg_dumpbuf(const char *tag, const u8 *buf, int size)
 		if ((i % 8) == 0) {
 			if (i)
 				pr_debug("\n");
-			pr_debug(__FILE__ ": %s: ", tag);
+			pr_debug(DRIVER_NAME ": %s: ", tag);
 		}
 		pr_debug("%02x ", buf[i]);
 	}
@@ -5397,7 +5402,8 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 
 	if (data_len < 0) {
 		/* make sure data starts in the buffer */
-		info("%s: data frame too short", priv->netdev->name);
+		printk(KERN_INFO "%s: data frame too short\n",
+		       priv->netdev->name);
 		return NULL;
 	}
 
@@ -5479,9 +5485,10 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 				/* for test only ??? */
 				left = skb_tailroom(bptr->skb);
 				if (left < data_len) {
-					info("%s: only %d byte free (need %d)",
-					     priv->netdev->name, left,
-					     data_len);
+					printk(KERN_INFO
+					       "%s: only %d byte free (need %d)\n",
+					       priv->netdev->name, left,
+					       data_len);
 				} else
 					memcpy(skb_put(bptr->skb, data_len),
 					       data, data_len);
@@ -5789,8 +5796,8 @@ static void at76_rx_tasklet(unsigned long param)
 		break;
 
 	default:
-		info("%s: it's a frame from mars: %2x", priv->netdev->name,
-		     frame_ctl);
+		printk(KERN_INFO "%s: it's a frame from mars: %2x\n",
+		       priv->netdev->name, frame_ctl);
 	}
       finish:
 	at76_submit_rx_urb(priv);
@@ -6037,9 +6044,9 @@ static void at76_disconnect(struct usb_interface *interface)
 	if (!priv)
 		return;
 
-	info("%s disconnecting", priv->netdev->name);
+	printk(KERN_INFO "%s: disconnecting\n", priv->netdev->name);
 	at76_delete_device(priv);
-	info(DRIVER_NAME " disconnected");
+	printk(KERN_INFO DRIVER_NAME ": disconnected\n");
 }
 
 /* structure for registering this driver with the USB subsystem */
@@ -6054,7 +6061,7 @@ static int __init at76_mod_init(void)
 {
 	int result;
 
-	info(DRIVER_DESC " " DRIVER_VERSION " loading");
+	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION " loading\n");
 
 	/* register this driver with the USB subsystem */
 	result = usb_register(&at76_driver);
@@ -6070,7 +6077,7 @@ static void __exit at76_mod_exit(void)
 {
 	int i;
 
-	info(DRIVER_DESC " " DRIVER_VERSION " unloading");
+	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION " unloading\n");
 	usb_deregister(&at76_driver);
 	for (i = 0; i < ARRAY_SIZE(firmwares); i++) {
 		if (firmwares[i].fw)
diff --git a/at76_usb.h b/at76_usb.h
index aeabc4a..9a8c327 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -682,7 +682,7 @@ struct at76_rx_radiotap {
 #define at76_dbg(bits, format, arg...) \
 	do { \
 		if (at76_debug & (bits)) \
-		printk(KERN_DEBUG __FILE__ ": " format "\n" , ## arg);\
+		printk(KERN_DEBUG DRIVER_NAME ": " format "\n" , ## arg);\
 	} while (0)
 
 #define at76_assert(x) \




From proski at gnu.org  Thu Jun 14 03:11:47 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:47 -0400
Subject: [at76c503a-develop] [PATCH 11/12] Change SET_NET_DEVICE to use
	interface->dev
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011147.25709.49751.stgit@dv.roinet.com>

This way, /sys/class/net/ethX/device/driver points to at76_usb driver
rather than usb driver.  This is consistent with other network drivers.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index d363ff9..8704872 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -5818,7 +5818,6 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev)
 		return NULL;
 	}
 
-	SET_NETDEV_DEV(netdev, &udev->dev);
 	priv = netdev_priv(netdev);
 	memset(priv, 0, sizeof(*priv));
 
@@ -6019,6 +6018,7 @@ static int at76_probe(struct usb_interface *interface,
 		goto error;
 	}
 
+	SET_NETDEV_DEV(priv->netdev, &interface->dev);
 	usb_set_intfdata(interface, priv);
 	priv->fwe = fwe;
 




From proski at gnu.org  Thu Jun 14 03:11:52 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:11:52 -0400
Subject: [at76c503a-develop] [PATCH 12/12] Use usb_make_path() for bus info
	in ethtool output
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070614011152.25709.3972.stgit@dv.roinet.com>

usb_make_path() is used to construct stable device path.  This is used
in other USB based network drivers.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    3 +--
 1 files changed, 1 insertions(+), 2 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 8704872..86e20fc 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -3935,8 +3935,7 @@ static void at76_ethtool_get_drvinfo(struct net_device *netdev,
 	strncpy(info->version, DRIVER_VERSION, sizeof(info->version));
 	info->version[sizeof(info->version) - 1] = '\0';
 
-	snprintf(info->bus_info, sizeof(info->bus_info) - 1, "usb%d:%d",
-		 priv->udev->bus->busnum, priv->udev->devnum);
+	usb_make_path(priv->udev, info->bus_info, sizeof(info->bus_info));
 
 	snprintf(info->fw_version, sizeof(info->fw_version) - 1,
 		 "%d.%d.%d-%d",




From proski at gnu.org  Thu Jun 14 03:40:29 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 13 Jun 2007 21:40:29 -0400
Subject: [at76c503a-develop] Status of the driver
Message-ID: <1181785229.26025.21.camel@dv>

Hello!

I could finally get the driver reindented.  This is important not just
because the code looks better, but also because all further changes can
be run through Lindent without having to format them manually.  Some
debug statements look bad, but they looked bad before, and they should
eventually be removed, as the code gets more stable and documented.

I removed all module parameters that can be set with iwpriv.  I can
imagine that wireless developers will try to get us remove even more,
but it's an important step.

I wanted to integrate workqueues and times, but I'm not sure it's really
worth the trouble.  There is no such thing as "wait and reschedule".
But there is such thing as taking control over scheduling.  This is more
work that I thought.  The workqueues are used for 802.11 MAC
implementation, so they will be discarded if the driver is ported to
mac80211.  I may still try it, but it depends.

All that means that the the driver should be ready for another
submission attempt once my patches are applied.

I have enabled the compat.h mechanism I used in other drivers, which
allows pristine driver sources to be compiled for older kernels.  I
could backport the driver as far back as Linux 2.6.18.  Going further
back is trickier.

Considering that backward compatibility turned out to be an easier goal,
we may want to make another public release.  I suggest calling it 0.20,
since it's a major upgrade, at least in terms of stability.  This would
allow us to have the code tested.

-- 
Regards,
Pavel Roskin



From agx at sigxcpu.org  Fri Jun 15 09:18:16 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Fri, 15 Jun 2007 09:18:16 +0200
Subject: [at76c503a-develop] [PATCH 01/12] Put copyright into compat.h
In-Reply-To: <20070614011056.25709.48658.stgit@dv.roinet.com>
References: <20070614011056.25709.48658.stgit@dv.roinet.com>
Message-ID: <20070615071816.GA30833@bogon.ms20.nix>

Hi Pavel,
On Wed, Jun 13, 2007 at 09:10:56PM -0400, Pavel Roskin wrote:
> Signed-off-by: Pavel Roskin <proski at gnu.org>
Whole series applied and pushed out, thanks!
Cheers,
 -- Guido


From proski at gnu.org  Sat Jun 16 09:38:31 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 16 Jun 2007 03:38:31 -0400
Subject: [at76c503a-develop] [PATCH 02/10] Add full support for "auto"
	preamble
In-Reply-To: <20070616073826.13212.1752.stgit@dv.roinet.com>
References: <20070616073826.13212.1752.stgit@dv.roinet.com>
Message-ID: <20070616073831.13212.30445.stgit@dv.roinet.com>

Don't assume that there are just two settings, "long" and "short". 
Provide textual description in the output of "iwpriv get_preamble" in
the same format as in ipw2100 and ipw2200.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   19 +++++++++----------
 at76_usb.h |    7 ++++---
 2 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 8c28534..abdaf50 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -184,6 +184,8 @@ static const long channel_frequency[] = {
 	2447, 2452, 2457, 2462, 2467, 2472, 2484
 };
 
+static const char *const preambles[] = { "long", "short", "auto" };
+
 #define NUM_CHANNELS ARRAY_SIZE(channel_frequency)
 
 /* Firmware download */
@@ -1829,7 +1831,7 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	capa = bss->capa;
 	if (priv->wep_enabled)
 		capa |= WLAN_CAPABILITY_PRIVACY;
-	if (priv->preamble_type == PREAMBLE_TYPE_SHORT)
+	if (priv->preamble_type != PREAMBLE_TYPE_LONG)
 		capa |= WLAN_CAPABILITY_SHORT_PREAMBLE;
 	req->capability = cpu_to_le16(capa);
 
@@ -1909,7 +1911,7 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 	capa = new_bss->capa;
 	if (priv->wep_enabled)
 		capa |= WLAN_CAPABILITY_PRIVACY;
-	if (priv->preamble_type == PREAMBLE_TYPE_SHORT)
+	if (priv->preamble_type != PREAMBLE_TYPE_LONG)
 		capa |= WLAN_CAPABILITY_SHORT_PREAMBLE;
 	req->capability = cpu_to_le16(capa);
 
@@ -3337,9 +3339,7 @@ static int at76_iw_set_short_preamble(struct net_device *netdev,
 	at76_dbg(DBG_IOCTL, "%s: AT76_SET_SHORT_PREAMBLE, %d",
 		 netdev->name, val);
 
-	if (val < 0 || val > 2) {
-		/* allow value of 2 - in the win98 driver it stands
-		   for "auto preamble" ...? */
+	if (val < PREAMBLE_TYPE_LONG || val > PREAMBLE_TYPE_AUTO) {
 		ret = -EINVAL;
 	} else {
 		priv->preamble_type = val;
@@ -3353,9 +3353,9 @@ static int at76_iw_get_short_preamble(struct net_device *netdev,
 				      union iwreq_data *wrqu, char *extra)
 {
 	struct at76_priv *priv = netdev_priv(netdev);
-	int *param = (int *)extra;
 
-	param[0] = priv->preamble_type;
+	snprintf(wrqu->name, sizeof(wrqu->name), "%s (%d)",
+		 preambles[priv->preamble_type], priv->preamble_type);
 	return 0;
 }
 
@@ -3616,7 +3616,7 @@ static const struct iw_priv_args at76_priv_args[] = {
 	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_preamble"},
 
 	{AT76_GET_SHORT_PREAMBLE,
-	 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_preamble"},
+	 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | 10, "get_preamble"},
 
 	/* we must pass the new debug mask as a string, because iwpriv cannot
 	 * parse hex numbers starting with 0x :-(  */
@@ -4594,8 +4594,7 @@ static int at76_startup_device(struct at76_priv *priv)
 		    priv->wep_key_id, priv->wep_keys_len[priv->wep_key_id]);
 		dbg("%s param: preamble %s rts %d retry %d frag %d "
 		    "txrate %s auth_mode %d", priv->netdev->name,
-		    priv->preamble_type ==
-		    PREAMBLE_TYPE_SHORT ? "short" : "long", priv->rts_threshold,
+		    preambles[priv->preamble_type], priv->rts_threshold,
 		    priv->short_retry_limit, priv->frag_threshold,
 		    priv->txrate == TX_RATE_1MBIT ? "1MBit" : priv->txrate ==
 		    TX_RATE_2MBIT ? "2MBit" : priv->txrate ==
diff --git a/at76_usb.h b/at76_usb.h
index 532b2f8..63d0c23 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -28,7 +28,7 @@
 #define DRIVER_VERSION "0.15dev"
 
 /* our private ioctl's */
-/* preamble length (0 - long, 1 - short) */
+/* preamble length (0 - long, 1 - short, 2 - auto) */
 #define AT76_SET_SHORT_PREAMBLE  (SIOCIWFIRSTPRIV + 0)
 #define AT76_GET_SHORT_PREAMBLE  (SIOCIWFIRSTPRIV + 1)
 /* which debug channels are enabled */
@@ -93,8 +93,9 @@
 #define INFRASTRUCTURE_MODE 2
 
 /* values for struct mib_local, field preamble_type */
-#define PREAMBLE_TYPE_SHORT 1
 #define PREAMBLE_TYPE_LONG  0
+#define PREAMBLE_TYPE_SHORT 1
+#define PREAMBLE_TYPE_AUTO 2
 
 /* values for tx_rate */
 #define TX_RATE_1MBIT   0
@@ -513,7 +514,7 @@ struct at76_priv {
 	int radio_on;
 	int promisc;
 
-	int preamble_type;	/* 0 - long preamble, 1 - short preamble */
+	int preamble_type;	/* 0 - long, 1 - short, 2 - auto */
 	int auth_mode;		/* authentication type: 0 open, 1 shared key */
 	int txrate;		/* 0,1,2,3 = 1,2,5.5,11 MBit, 4 is auto-fallback */
 	int frag_threshold;	/* threshold for fragmentation of tx packets */




From proski at gnu.org  Sat Jun 16 09:38:26 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 16 Jun 2007 03:38:26 -0400
Subject: [at76c503a-develop] [PATCH 01/10] Implement "get" counterparts for
	iwpriv calls
Message-ID: <20070616073826.13212.1752.stgit@dv.roinet.com>

Rename all iwpriv calls to start with "get" or "set" for consistency. 
Eliminate gap in the ioctl numbers.

Rename "intl_roaming" to "intl_scan", because it's really affects
scanning only.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  119 +++++++++++++++++++++++++++++++++++++++++++++++++++---------
 at76_usb.h |   30 +++++++++------
 2 files changed, 120 insertions(+), 29 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 86e20fc..8c28534 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -3348,6 +3348,17 @@ static int at76_iw_set_short_preamble(struct net_device *netdev,
 	return ret;
 }
 
+static int at76_iw_get_short_preamble(struct net_device *netdev,
+				      struct iw_request_info *info,
+				      union iwreq_data *wrqu, char *extra)
+{
+	struct at76_priv *priv = netdev_priv(netdev);
+	int *param = (int *)extra;
+
+	param[0] = priv->preamble_type;
+	return 0;
+}
+
 static int at76_iw_set_debug(struct net_device *netdev,
 			     struct iw_request_info *info,
 			     struct iw_point *data, char *extra)
@@ -3382,6 +3393,14 @@ static int at76_iw_set_debug(struct net_device *netdev,
 	return 0;
 }
 
+static int at76_iw_get_debug(struct net_device *netdev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	snprintf(wrqu->name, sizeof(wrqu->name), "0x%08x", at76_debug);
+	return 0;
+}
+
 static int at76_iw_set_powersave_mode(struct net_device *netdev,
 				      struct iw_request_info *info, char *name,
 				      char *extra)
@@ -3403,6 +3422,17 @@ static int at76_iw_set_powersave_mode(struct net_device *netdev,
 	return ret;
 }
 
+static int at76_iw_get_powersave_mode(struct net_device *netdev,
+				      struct iw_request_info *info,
+				      union iwreq_data *wrqu, char *extra)
+{
+	struct at76_priv *priv = netdev_priv(netdev);
+	int *param = (int *)extra;
+
+	param[0] = priv->pm_mode;
+	return 0;
+}
+
 static int at76_iw_set_scan_times(struct net_device *netdev,
 				  struct iw_request_info *info, char *name,
 				  char *extra)
@@ -3424,6 +3454,18 @@ static int at76_iw_set_scan_times(struct net_device *netdev,
 	return ret;
 }
 
+static int at76_iw_get_scan_times(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  union iwreq_data *wrqu, char *extra)
+{
+	struct at76_priv *priv = netdev_priv(netdev);
+	int *param = (int *)extra;
+
+	param[0] = priv->scan_min_time;
+	param[1] = priv->scan_max_time;
+	return 0;
+}
+
 static int at76_iw_set_scan_mode(struct net_device *netdev,
 				 struct iw_request_info *info, char *name,
 				 char *extra)
@@ -3445,6 +3487,17 @@ static int at76_iw_set_scan_mode(struct net_device *netdev,
 	return ret;
 }
 
+static int at76_iw_get_scan_mode(struct net_device *netdev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu, char *extra)
+{
+	struct at76_priv *priv = netdev_priv(netdev);
+	int *param = (int *)extra;
+
+	param[0] = priv->scan_mode;
+	return 0;
+}
+
 static int at76_set_iroaming(struct at76_priv *priv, int onoff)
 {
 	int ret = 0;
@@ -3487,6 +3540,17 @@ static int at76_iw_set_intl_roaming(struct net_device *netdev,
 	return ret;
 }
 
+static int at76_iw_get_intl_roaming(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    union iwreq_data *wrqu, char *extra)
+{
+	struct at76_priv *priv = netdev_priv(netdev);
+	int *param = (int *)extra;
+
+	param[0] = priv->international_roaming;
+	return 0;
+}
+
 #define AT76_SET_HANDLER(h, f) [h - SIOCIWFIRST] = (iw_handler) f
 
 /*******************************************************************************
@@ -3530,43 +3594,64 @@ static const iw_handler at76_handlers[] = {
 /*structure that advertises the private iw handlers of this driver */
 static const iw_handler at76_priv_handlers[] = {
 	AT76_SET_PRIV(AT76_SET_SHORT_PREAMBLE, at76_iw_set_short_preamble),
+	AT76_SET_PRIV(AT76_GET_SHORT_PREAMBLE, at76_iw_get_short_preamble),
 	AT76_SET_PRIV(AT76_SET_DEBUG, at76_iw_set_debug),
+	AT76_SET_PRIV(AT76_GET_DEBUG, at76_iw_get_debug),
 	AT76_SET_PRIV(AT76_SET_POWERSAVE_MODE, at76_iw_set_powersave_mode),
+	AT76_SET_PRIV(AT76_GET_POWERSAVE_MODE, at76_iw_get_powersave_mode),
 	AT76_SET_PRIV(AT76_SET_SCAN_TIMES, at76_iw_set_scan_times),
+	AT76_SET_PRIV(AT76_GET_SCAN_TIMES, at76_iw_get_scan_times),
 	AT76_SET_PRIV(AT76_SET_SCAN_MODE, at76_iw_set_scan_mode),
+	AT76_SET_PRIV(AT76_GET_SCAN_MODE, at76_iw_get_scan_mode),
 	AT76_SET_PRIV(AT76_SET_INTL_ROAMING, at76_iw_set_intl_roaming),
+	AT76_SET_PRIV(AT76_GET_INTL_ROAMING, at76_iw_get_intl_roaming),
 };
 
 /*******************************************************************************
  * structure that describes the private ioctls/iw handlers of this driver
  */
 static const struct iw_priv_args at76_priv_args[] = {
+	/* 0 - long, 1 - short */
 	{AT76_SET_SHORT_PREAMBLE,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 "short_preamble"},	/* 0 - long, 1 -short */
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_preamble"},
+
+	{AT76_GET_SHORT_PREAMBLE,
+	 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_preamble"},
 
+	/* we must pass the new debug mask as a string, because iwpriv cannot
+	 * parse hex numbers starting with 0x :-(  */
 	{AT76_SET_DEBUG,
-	 /* we must pass the new debug mask as a string,
-	  * 'cause iwpriv cannot parse hex numbers
-	  * starting with 0x :-(  */
-	 IW_PRIV_TYPE_CHAR | 10, 0,
-	 "set_debug"},		/* set debug value */
+	 IW_PRIV_TYPE_CHAR | 10, 0, "set_debug"},
+
+	{AT76_GET_DEBUG,
+	 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | 10, "get_debug"},
 
+	/* 1 - active, 2 - power save, 3 - smart power save */
 	{AT76_SET_POWERSAVE_MODE,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 "powersave_mode"},	/* 1 - active, 2 - power save,
-				   3 - smart power save */
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_powersave"},
+
+	{AT76_GET_POWERSAVE_MODE,
+	 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_powersave"},
+
+	/* min_channel_time, max_channel_time */
 	{AT76_SET_SCAN_TIMES,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0,
-	 "scan_times"},		/* min_channel_time,
-				   max_channel_time */
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "set_scan_times"},
+
+	{AT76_GET_SCAN_TIMES,
+	 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, "get_scan_times"},
+
+	/* 0 - active, 1 - passive scan */
 	{AT76_SET_SCAN_MODE,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 "scan_mode"},		/* 0 - active, 1 - passive scan */
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_scan_mode"},
+
+	{AT76_GET_SCAN_MODE,
+	 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_scan_mode"},
 
 	{AT76_SET_INTL_ROAMING,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 "intl_roaming"},
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_intl_scan"},
+
+	{AT76_GET_INTL_ROAMING,
+	 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_intl_scan"}
 };
 
 static const struct iw_handler_def at76_handler_def = {
diff --git a/at76_usb.h b/at76_usb.h
index 9a8c327..532b2f8 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -28,18 +28,24 @@
 #define DRIVER_VERSION "0.15dev"
 
 /* our private ioctl's */
-/* set preamble length*/
-#define AT76_SET_SHORT_PREAMBLE  (SIOCIWFIRSTPRIV + 0x0)
-/* set debug parameter */
-#define AT76_SET_DEBUG           (SIOCIWFIRSTPRIV + 0x2)
-/* set power save mode (incl. the Atmel proprietary smart save mode */
-#define AT76_SET_POWERSAVE_MODE  (SIOCIWFIRSTPRIV + 0x4)
-/* set min and max channel times for scan */
-#define AT76_SET_SCAN_TIMES      (SIOCIWFIRSTPRIV + 0x6)
-/* set scan mode */
-#define AT76_SET_SCAN_MODE       (SIOCIWFIRSTPRIV + 0x8)
-/* set international roaming */
-#define AT76_SET_INTL_ROAMING    (SIOCIWFIRSTPRIV + 0x10)
+/* preamble length (0 - long, 1 - short) */
+#define AT76_SET_SHORT_PREAMBLE  (SIOCIWFIRSTPRIV + 0)
+#define AT76_GET_SHORT_PREAMBLE  (SIOCIWFIRSTPRIV + 1)
+/* which debug channels are enabled */
+#define AT76_SET_DEBUG           (SIOCIWFIRSTPRIV + 2)
+#define AT76_GET_DEBUG           (SIOCIWFIRSTPRIV + 3)
+/* power save mode (incl. the Atmel proprietary smart save mode) */
+#define AT76_SET_POWERSAVE_MODE  (SIOCIWFIRSTPRIV + 4)
+#define AT76_GET_POWERSAVE_MODE  (SIOCIWFIRSTPRIV + 5)
+/* min and max channel times for scan */
+#define AT76_SET_SCAN_TIMES      (SIOCIWFIRSTPRIV + 6)
+#define AT76_GET_SCAN_TIMES      (SIOCIWFIRSTPRIV + 7)
+/* scan mode (0 - active, 1 - passive) */
+#define AT76_SET_SCAN_MODE       (SIOCIWFIRSTPRIV + 8)
+#define AT76_GET_SCAN_MODE       (SIOCIWFIRSTPRIV + 9)
+/* international roaming (0 - disabled, 1 - enabled */
+#define AT76_SET_INTL_ROAMING    (SIOCIWFIRSTPRIV + 10)
+#define AT76_GET_INTL_ROAMING    (SIOCIWFIRSTPRIV + 11)
 
 #define DEVICE_VENDOR_REQUEST_OUT    0x40
 #define DEVICE_VENDOR_REQUEST_IN     0xc0




From proski at gnu.org  Sat Jun 16 09:38:36 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 16 Jun 2007 03:38:36 -0400
Subject: [at76c503a-develop] [PATCH 03/10] Eliminate macros containing
	offsetof for MIB structures
In-Reply-To: <20070616073826.13212.1752.stgit@dv.roinet.com>
References: <20070616073826.13212.1752.stgit@dv.roinet.com>
Message-ID: <20070616073836.13212.71987.stgit@dv.roinet.com>

They make it harder to check correctness of MIB requests.  For instance,
STATION_ID_OFFSET doesn't show that it's an offset in struct
mib_mac_mgmt, so it's not obvious if priv->mib_buf.type is set to
MIB_MAC_MGMT correctly.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   21 +++++++++++----------
 at76_usb.h |   18 ------------------
 2 files changed, 11 insertions(+), 28 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index abdaf50..49747c1 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -916,7 +916,7 @@ static int at76_set_pm_mode(struct at76_priv *priv)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_MAC_MGMT;
 	priv->mib_buf.size = 1;
-	priv->mib_buf.index = POWER_MGMT_MODE_OFFSET;
+	priv->mib_buf.index = offsetof(struct mib_mac_mgmt, power_mgmt_mode);
 
 	priv->mib_buf.data[0] = priv->pm_mode;
 
@@ -936,7 +936,7 @@ static int at76_set_associd(struct at76_priv *priv, u16 id)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_MAC_MGMT;
 	priv->mib_buf.size = 2;
-	priv->mib_buf.index = STATION_ID_OFFSET;
+	priv->mib_buf.index = offsetof(struct mib_mac_mgmt, station_id);
 
 	priv->mib_buf.data[0] = id & 0xff;
 	priv->mib_buf.data[1] = id >> 8;
@@ -958,7 +958,7 @@ static int at76_set_listen_interval(struct at76_priv *priv, u16 interval)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_MAC;
 	priv->mib_buf.size = 2;
-	priv->mib_buf.index = STATION_ID_OFFSET;
+	priv->mib_buf.index = offsetof(struct mib_mac_mgmt, station_id);
 
 	priv->mib_buf.data[0] = interval & 0xff;
 	priv->mib_buf.data[1] = interval >> 8;
@@ -978,7 +978,7 @@ static int at76_set_preamble(struct at76_priv *priv, u8 type)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_LOCAL;
 	priv->mib_buf.size = 1;
-	priv->mib_buf.index = PREAMBLE_TYPE_OFFSET;
+	priv->mib_buf.index = offsetof(struct mib_local, preamble_type);
 	priv->mib_buf.data[0] = type;
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
@@ -995,7 +995,7 @@ static int at76_set_frag(struct at76_priv *priv, u16 size)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_MAC;
 	priv->mib_buf.size = 2;
-	priv->mib_buf.index = FRAGMENTATION_OFFSET;
+	priv->mib_buf.index = offsetof(struct mib_mac, frag_threshold);
 	*(__le16 *)priv->mib_buf.data = cpu_to_le16(size);
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
@@ -1012,7 +1012,7 @@ static int at76_set_rts(struct at76_priv *priv, u16 size)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_MAC;
 	priv->mib_buf.size = 2;
-	priv->mib_buf.index = RTS_OFFSET;
+	priv->mib_buf.index = offsetof(struct mib_mac, rts_threshold);
 	*(__le16 *)priv->mib_buf.data = cpu_to_le16(size);
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
@@ -1028,7 +1028,7 @@ static int at76_set_autorate_fallback(struct at76_priv *priv, int onoff)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_LOCAL;
 	priv->mib_buf.size = 1;
-	priv->mib_buf.index = TX_AUTORATE_FALLBACK_OFFSET;
+	priv->mib_buf.index = offsetof(struct mib_local, txautorate_fallback);
 	priv->mib_buf.data[0] = onoff;
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
@@ -1549,7 +1549,7 @@ static int at76_start_ibss(struct at76_priv *priv)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_MAC_MGMT;
 	priv->mib_buf.size = 1;
-	priv->mib_buf.index = IBSS_CHANGE_OK_OFFSET;
+	priv->mib_buf.index = offsetof(struct mib_mac_mgmt, ibss_change);
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
 		err("%s: set_mib (ibss change ok) failed: %d",
@@ -3505,7 +3505,8 @@ static int at76_set_iroaming(struct at76_priv *priv, int onoff)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_MAC_MGMT;
 	priv->mib_buf.size = 1;
-	priv->mib_buf.index = IROAMING_OFFSET;
+	priv->mib_buf.index =
+	    offsetof(struct mib_mac_mgmt, multi_domain_capability_enabled);
 	priv->mib_buf.data[0] = (priv->international_roaming ? 1 : 0);
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
@@ -4563,7 +4564,7 @@ static void at76_work_new_bss(struct work_struct *work)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_MAC_MGMT;
 	priv->mib_buf.size = 1;
-	priv->mib_buf.index = IBSS_CHANGE_OK_OFFSET;
+	priv->mib_buf.index = offsetof(struct mib_mac_mgmt, ibss_change);
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0)
 		err("%s: set_mib (ibss change ok) failed: %d", netdev->name,
diff --git a/at76_usb.h b/at76_usb.h
index 63d0c23..46a2d7a 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -113,24 +113,6 @@
 #define IR_OFF        0
 #define IR_ON         1
 
-/* offsets into the MIBs we use to configure the device */
-#define TX_AUTORATE_FALLBACK_OFFSET offsetof(struct mib_local,txautorate_fallback)
-#define FRAGMENTATION_OFFSET        offsetof(struct mib_mac,frag_threshold)
-#define PREAMBLE_TYPE_OFFSET        offsetof(struct mib_local,preamble_type)
-#define RTS_OFFSET                  offsetof(struct mib_mac, rts_threshold)
-
-/* valid only for rfmd and 505 !*/
-#define IBSS_CHANGE_OK_OFFSET       offsetof(struct mib_mac_mgmt, ibss_change)
-#define IROAMING_IMPL_OFFSET	    offsetof(struct mib_mac_mgmt, multi_domain_capability_implemented)
-#define IROAMING_OFFSET \
-  offsetof(struct mib_mac_mgmt, multi_domain_capability_enabled)
-/* the AssocID */
-#define STATION_ID_OFFSET           offsetof(struct mib_mac_mgmt, station_id)
-#define POWER_MGMT_MODE_OFFSET      offsetof(struct mib_mac_mgmt, power_mgmt_mode)
-#define LISTEN_INTERVAL_OFFSET      offsetof(struct mib_mac, listen_interval)
-
-#define PRIVACY_OPT_IMPL            offsetof(struct mib_mac_mgmt, privacy_option_implemented)
-
 struct hwcfg_r505 {
 	u8 cr39_values[14];
 	u8 reserved1[14];




From proski at gnu.org  Sat Jun 16 09:38:46 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 16 Jun 2007 03:38:46 -0400
Subject: [at76c503a-develop] [PATCH 05/10] Remove unneeded parentheses and
	operators when	accessing "packet" field
In-Reply-To: <20070616073826.13212.1752.stgit@dv.roinet.com>
References: <20070616073826.13212.1752.stgit@dv.roinet.com>
Message-ID: <20070616073846.13212.42177.stgit@dv.roinet.com>

Use AT76_TX_HDRLEN in one place where it wasn't used.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   13 ++++++-------
 1 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index c8312b0..2d17558 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1646,8 +1646,7 @@ static void at76_write_bulk_callback(struct urb *urb)
 		/* we don't copy the padding bytes, but add them
 		   to the length */
 		memcpy(priv->bulk_out_buffer, mgmt_buf,
-		       le16_to_cpu(mgmt_buf->wlength) +
-		       offsetof(struct at76_tx_buffer, packet));
+		       le16_to_cpu(mgmt_buf->wlength) + AT76_TX_HDRLEN);
 		usb_fill_bulk_urb(priv->write_urb, priv->udev,
 				  priv->tx_bulk_pipe, priv->bulk_out_buffer,
 				  le16_to_cpu(mgmt_buf->wlength) +
@@ -1755,7 +1754,7 @@ static int at76_auth_req(struct at76_priv *priv, struct bss_info *bss,
 	if (!tx_buffer)
 		return -ENOMEM;
 
-	req = (struct ieee80211_auth *)(&tx_buffer->packet);
+	req = (struct ieee80211_auth *)tx_buffer->packet;
 	mgmt = &req->header;
 
 	/* make wireless header */
@@ -1808,7 +1807,7 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	if (!tx_buffer)
 		return -ENOMEM;
 
-	req = (struct ieee80211_assoc_request *)(&tx_buffer->packet);
+	req = (struct ieee80211_assoc_request *)tx_buffer->packet;
 	mgmt = &req->header;
 	tlv = req->info_element;
 
@@ -1888,7 +1887,7 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 	if (!tx_buffer)
 		return -ENOMEM;
 
-	req = (struct ieee80211_reassoc_request *)(&tx_buffer->packet);
+	req = (struct ieee80211_reassoc_request *)tx_buffer->packet;
 	mgmt = &req->header;
 	tlv = req->info_element;
 
@@ -1962,7 +1961,7 @@ static int at76_disassoc_req(struct at76_priv *priv, struct bss_info *bss)
 	if (!tx_buffer)
 		return -ENOMEM;
 
-	req = (struct ieee80211_disassoc *)(&tx_buffer->packet);
+	req = (struct ieee80211_disassoc *)tx_buffer->packet;
 	mgmt = &req->header;
 
 	/* make wireless header */
@@ -3720,7 +3719,7 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	int submit_len;
 	struct at76_tx_buffer *tx_buffer = priv->bulk_out_buffer;
 	struct ieee80211_hdr_3addr *i802_11_hdr =
-	    (struct ieee80211_hdr_3addr *)(&tx_buffer->packet);
+	    (struct ieee80211_hdr_3addr *)tx_buffer->packet;
 	u8 *payload = tx_buffer->packet + sizeof(struct ieee80211_hdr_3addr);
 
 	if (netif_queue_stopped(netdev)) {




From proski at gnu.org  Sat Jun 16 09:38:41 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 16 Jun 2007 03:38:41 -0400
Subject: [at76c503a-develop] [PATCH 04/10] Always use cpu_to_le16 to
	populate priv->mib_buf.data	with 16-bit data
In-Reply-To: <20070616073826.13212.1752.stgit@dv.roinet.com>
References: <20070616073826.13212.1752.stgit@dv.roinet.com>
Message-ID: <20070616073841.13212.34272.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    6 ++----
 1 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 49747c1..c8312b0 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -938,8 +938,7 @@ static int at76_set_associd(struct at76_priv *priv, u16 id)
 	priv->mib_buf.size = 2;
 	priv->mib_buf.index = offsetof(struct mib_mac_mgmt, station_id);
 
-	priv->mib_buf.data[0] = id & 0xff;
-	priv->mib_buf.data[1] = id >> 8;
+	*(__le16 *)priv->mib_buf.data = cpu_to_le16(id);
 
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
@@ -960,8 +959,7 @@ static int at76_set_listen_interval(struct at76_priv *priv, u16 interval)
 	priv->mib_buf.size = 2;
 	priv->mib_buf.index = offsetof(struct mib_mac_mgmt, station_id);
 
-	priv->mib_buf.data[0] = interval & 0xff;
-	priv->mib_buf.data[1] = interval >> 8;
+	*(__le16 *)priv->mib_buf.data = cpu_to_le16(interval);
 
 	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {




From proski at gnu.org  Sat Jun 16 09:38:56 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 16 Jun 2007 03:38:56 -0400
Subject: [at76c503a-develop] [PATCH 07/10] Reuse at76_set_card_command()
	from at76_set_mib()
In-Reply-To: <20070616073826.13212.1752.stgit@dv.roinet.com>
References: <20070616073826.13212.1752.stgit@dv.roinet.com>
Message-ID: <20070616073856.13212.15628.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   37 +++++++++++--------------------------
 1 files changed, 11 insertions(+), 26 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 51e9ff3..99f6eb6 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -856,35 +856,20 @@ static int at76_wait_completion(struct at76_priv *priv, int cmd)
 
 static int at76_set_mib(struct at76_priv *priv, struct set_mib_buffer *buf)
 {
-	struct usb_device *udev = priv->udev;
 	int ret;
-	struct at76_command *cmd_buf = kmalloc(sizeof(struct at76_command) +
-					       buf->size + 4, GFP_KERNEL);
 
-	if (cmd_buf) {
-		cmd_buf->cmd = CMD_SET_MIB;
-		cmd_buf->reserved = 0;
-		cmd_buf->size = cpu_to_le16(buf->size + 4);
-		memcpy(&(cmd_buf[1]), buf, buf->size + 4);
-		ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-				      0x0e, DEVICE_VENDOR_REQUEST_OUT,
-				      0, 0,
-				      cmd_buf,
-				      sizeof(struct at76_command) +
-				      buf->size + 4, USB_CTRL_GET_TIMEOUT);
-		if (ret >= 0) {
-			ret = at76_wait_completion(priv, CMD_SET_MIB);
-			if (ret != CMD_STATUS_COMPLETE) {
-				printk(KERN_INFO
-				       "%s: set_mib: at76_wait_completion failed "
-				       "with %d\n", priv->netdev->name, ret);
-				ret = -EIO;
-			}
-		}
-		kfree(cmd_buf);
+	ret = at76_set_card_command(priv->udev,
+				    CMD_SET_MIB, buf, buf->size + 4);
+	if (ret < 0)
 		return ret;
-	} else
-		ret = -ENOMEM;
+
+	ret = at76_wait_completion(priv, CMD_SET_MIB);
+	if (ret != CMD_STATUS_COMPLETE) {
+		printk(KERN_INFO
+		       "%s: set_mib: at76_wait_completion failed "
+		       "with %d\n", priv->netdev->name, ret);
+		ret = -EIO;
+	}
 
 	return ret;
 }




From proski at gnu.org  Sat Jun 16 09:38:51 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 16 Jun 2007 03:38:51 -0400
Subject: [at76c503a-develop] [PATCH 06/10] Use consistent timeout in
	usb_control_msg()
In-Reply-To: <20070616073826.13212.1752.stgit@dv.roinet.com>
References: <20070616073826.13212.1752.stgit@dv.roinet.com>
Message-ID: <20070616073851.13212.65328.stgit@dv.roinet.com>

The timeout argument is in microseconds, not in jiffies.  Use
USB_CTRL_GET_TIMEOUT in all usb_control_msg() calls.  It's 5 seconds,
and should be enough even for the slowest devices.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    8 +++++---
 1 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 2d17558..51e9ff3 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -247,7 +247,7 @@ static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
 	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), DFU_DNLOAD,
 				 USB_TYPE_CLASS | USB_DIR_OUT |
 				 USB_RECIP_INTERFACE, block, 0, tmpbuf, bytes,
-				 HZ);
+				 USB_CTRL_GET_TIMEOUT);
 	return result;
 }
 
@@ -259,7 +259,8 @@ static int at76_dfu_get_status(struct dfu_ctx *ctx, struct dfu_status *status)
 	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATUS,
 				 USB_TYPE_CLASS | USB_DIR_IN |
 				 USB_RECIP_INTERFACE, 0, 0, status,
-				 sizeof(struct dfu_status), HZ);
+				 sizeof(struct dfu_status),
+				 USB_CTRL_GET_TIMEOUT);
 	return result;
 }
 
@@ -269,7 +270,8 @@ static u8 at76_dfu_get_state(struct usb_device *udev, u8 *state)
 
 	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATE,
 				 USB_TYPE_CLASS | USB_DIR_IN |
-				 USB_RECIP_INTERFACE, 0, 0, state, 1, HZ);
+				 USB_RECIP_INTERFACE, 0, 0, state, 1,
+				 USB_CTRL_GET_TIMEOUT);
 	return result;
 }
 




From proski at gnu.org  Sat Jun 16 09:39:02 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 16 Jun 2007 03:39:02 -0400
Subject: [at76c503a-develop] [PATCH 08/10] Simplify at76_set_card_command()
In-Reply-To: <20070616073826.13212.1752.stgit@dv.roinet.com>
References: <20070616073826.13212.1752.stgit@dv.roinet.com>
Message-ID: <20070616073902.13212.84259.stgit@dv.roinet.com>

Add "data" field to struct at76_command to avoid dubious code to access
data beyound the end of structure.  Don't make handle 0-byte buffer as a
special case.  Avoid extra indentation.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   29 +++++++++++++----------------
 at76_usb.h |    1 +
 2 files changed, 14 insertions(+), 16 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 99f6eb6..3e555e2 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -788,23 +788,20 @@ static int at76_set_card_command(struct usb_device *udev, int cmd, void *buf,
 	struct at76_command *cmd_buf = kmalloc(sizeof(struct at76_command) +
 					       buf_size, GFP_KERNEL);
 
-	if (cmd_buf) {
-		cmd_buf->cmd = cmd;
-		cmd_buf->reserved = 0;
-		cmd_buf->size = cpu_to_le16(buf_size);
-		if (buf_size > 0)
-			memcpy(&(cmd_buf[1]), buf, buf_size);
-		ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-				      0x0e, DEVICE_VENDOR_REQUEST_OUT,
-				      0, 0,
-				      cmd_buf,
-				      sizeof(struct at76_command) +
-				      buf_size, USB_CTRL_GET_TIMEOUT);
-		kfree(cmd_buf);
-		return ret;
-	}
+	if (!cmd_buf)
+		return -ENOMEM;
 
-	return -ENOMEM;
+	cmd_buf->cmd = cmd;
+	cmd_buf->reserved = 0;
+	cmd_buf->size = cpu_to_le16(buf_size);
+	memcpy(cmd_buf->data, buf, buf_size);
+
+	ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x0e,
+			      DEVICE_VENDOR_REQUEST_OUT, 0, 0, cmd_buf,
+			      sizeof(struct at76_command) + buf_size,
+			      USB_CTRL_GET_TIMEOUT);
+	kfree(cmd_buf);
+	return ret;
 }
 
 #define MAKE_CMD_STATUS_CASE(c)	case (c): return #c
diff --git a/at76_usb.h b/at76_usb.h
index 46a2d7a..0854ad7 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -178,6 +178,7 @@ struct at76_command {
 	u8 cmd;
 	u8 reserved;
 	__le16 size;
+	u8 data[0];
 } __attribute__ ((packed));
 
 /* the length of the Atmel firmware specific rx header before IEEE 802.11 starts */




From proski at gnu.org  Sat Jun 16 09:39:07 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 16 Jun 2007 03:39:07 -0400
Subject: [at76c503a-develop] [PATCH 09/10] Eliminate struct dfu_ctx
In-Reply-To: <20070616073826.13212.1752.stgit@dv.roinet.com>
References: <20070616073826.13212.1752.stgit@dv.roinet.com>
Message-ID: <20070616073907.13212.23295.stgit@dv.roinet.com>

There is no point in having that structure.  Whatever was inside is
allocated and used individually now.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   71 +++++++++++++++++-------------------------------------------
 1 files changed, 20 insertions(+), 51 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 3e555e2..0555356 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -221,40 +221,25 @@ struct dfu_status {
 	unsigned char string;
 } __attribute__ ((packed));
 
-/* driver independent download context */
-struct dfu_ctx {
-	struct usb_device *udev;
-	u8 dfu_state;
-	struct dfu_status dfu_status;
-	void *buf;
-};
-
-static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
-				   int block)
+static int at76_dfu_download_block(struct usb_device *udev, u8 *buffer,
+				   int bytes, int block)
 {
 	int result;
-	u8 *tmpbuf = ctx->buf;
-	struct usb_device *udev = ctx->udev;
 
 	at76_dbg(DBG_DFU, "dfu_download_block(): buffer=%p, bytes=%d, block=%d",
 		 buffer, bytes, block);
 
-	if (tmpbuf == NULL)
-		return -ENOMEM;
-
-	memcpy(tmpbuf, buffer, bytes);
-
 	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), DFU_DNLOAD,
 				 USB_TYPE_CLASS | USB_DIR_OUT |
-				 USB_RECIP_INTERFACE, block, 0, tmpbuf, bytes,
+				 USB_RECIP_INTERFACE, block, 0, buffer, bytes,
 				 USB_CTRL_GET_TIMEOUT);
 	return result;
 }
 
-static int at76_dfu_get_status(struct dfu_ctx *ctx, struct dfu_status *status)
+static int at76_dfu_get_status(struct usb_device *udev,
+			       struct dfu_status *status)
 {
 	int result;
-	struct usb_device *udev = ctx->udev;
 
 	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATUS,
 				 USB_TYPE_CLASS | USB_DIR_IN |
@@ -283,26 +268,13 @@ static inline u32 at76_get_timeout(struct dfu_status *s)
 	return ret;
 }
 
-static struct dfu_ctx *at76_dfu_alloc_ctx(struct usb_device *udev)
-{
-	struct dfu_ctx *ctx;
-
-	ctx = kmalloc(sizeof(struct dfu_ctx) + DFU_PACKETSIZE,
-		      GFP_KERNEL | GFP_DMA);
-	if (ctx) {
-		ctx->udev = udev;
-		ctx->buf = &(ctx[1]);
-	}
-	return ctx;
-}
-
 /* if manifest_sync_timeout > 0 use this timeout (in msec) instead of the
    one reported by the device in state MANIFEST_SYNC */
 static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 				u32 dfu_len, int manifest_sync_timeout)
 {
-	struct dfu_ctx *ctx;
-	struct dfu_status *dfu_stat_buf;
+	u8 *dmabuf;
+	struct dfu_status dfu_stat_buf;
 	int status = 0;
 	int need_dfu_state = 1;
 	int is_done = 0;
@@ -321,30 +293,27 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 		return -EINVAL;
 	}
 
-	ctx = at76_dfu_alloc_ctx(udev);
-	if (ctx == NULL)
+	dmabuf = kmalloc(DFU_PACKETSIZE, GFP_KERNEL | GFP_DMA);
+	if (dmabuf == NULL)
 		return -ENOMEM;
 
-	dfu_stat_buf = &ctx->dfu_status;
-
 	do {
 		if (need_dfu_state) {
-			status = at76_dfu_get_state(ctx->udev, &ctx->dfu_state);
+			status = at76_dfu_get_state(udev, &dfu_state);
 			if (!DFU_USB_SUCCESS(status)) {
 				err("DFU: Failed to get DFU state: %d", status);
 				goto exit;
 			}
-			dfu_state = ctx->dfu_state;
 			need_dfu_state = 0;
 		}
 
 		switch (dfu_state) {
 		case STATE_DFU_DOWNLOAD_SYNC:
 			at76_dbg(DBG_DFU, "STATE_DFU_DOWNLOAD_SYNC");
-			status = at76_dfu_get_status(ctx, dfu_stat_buf);
+			status = at76_dfu_get_status(udev, &dfu_stat_buf);
 			if (DFU_USB_SUCCESS(status)) {
-				dfu_state = dfu_stat_buf->state;
-				dfu_timeout = at76_get_timeout(dfu_stat_buf);
+				dfu_state = dfu_stat_buf.state;
+				dfu_timeout = at76_get_timeout(&dfu_stat_buf);
 				need_dfu_state = 0;
 			} else
 				err("at76_dfu_get_status failed with %d",
@@ -372,9 +341,9 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 				dfu_block_bytes = DFU_PACKETSIZE;
 
 			dfu_bytes_left -= dfu_block_bytes;
-			status = at76_dfu_download_block(ctx,
-							 dfu_buffer +
-							 dfu_buffer_offset,
+			memcpy(dmabuf, dfu_buffer + dfu_buffer_offset,
+			       dfu_block_bytes);
+			status = at76_dfu_download_block(udev, dmabuf,
 							 dfu_block_bytes,
 							 dfu_block_cnt);
 			dfu_buffer_offset += dfu_block_bytes;
@@ -389,11 +358,11 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 		case STATE_DFU_MANIFEST_SYNC:
 			at76_dbg(DBG_DFU, "STATE_DFU_MANIFEST_SYNC");
 
-			status = at76_dfu_get_status(ctx, dfu_stat_buf);
+			status = at76_dfu_get_status(udev, &dfu_stat_buf);
 
 			if (DFU_USB_SUCCESS(status)) {
-				dfu_state = dfu_stat_buf->state;
-				dfu_timeout = at76_get_timeout(dfu_stat_buf);
+				dfu_state = dfu_stat_buf.state;
+				dfu_timeout = at76_get_timeout(&dfu_stat_buf);
 				need_dfu_state = 0;
 
 				/* override the timeout from the status response,
@@ -435,7 +404,7 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 	} while (!is_done && DFU_USB_SUCCESS(status));
 
       exit:
-	kfree(ctx);
+	kfree(dmabuf);
 	if (status < 0)
 		return status;
 	else




From proski at gnu.org  Sat Jun 16 09:39:12 2007
From: proski at gnu.org (Pavel Roskin)
Date: Sat, 16 Jun 2007 03:39:12 -0400
Subject: [at76c503a-develop] [PATCH 10/10] Clean up code for internal
	firmware download
In-Reply-To: <20070616073826.13212.1752.stgit@dv.roinet.com>
References: <20070616073826.13212.1752.stgit@dv.roinet.com>
Message-ID: <20070616073912.13212.50126.stgit@dv.roinet.com>

Use min() where needed.  Expand DFU_USB_SUCCESS.  Rename "result" and
"status" to more traditional "ret".

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   83 +++++++++++++++++++++++++++---------------------------------
 1 files changed, 37 insertions(+), 46 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 0555356..f0042f3 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -212,7 +212,6 @@ static const char *const preambles[] = { "long", "short", "auto" };
 #define DFU_ABORT			6
 
 #define DFU_PACKETSIZE 1024
-#define DFU_USB_SUCCESS(a) ((a) >= 0)
 
 struct dfu_status {
 	unsigned char status;
@@ -224,40 +223,38 @@ struct dfu_status {
 static int at76_dfu_download_block(struct usb_device *udev, u8 *buffer,
 				   int bytes, int block)
 {
-	int result;
+	int ret;
 
 	at76_dbg(DBG_DFU, "dfu_download_block(): buffer=%p, bytes=%d, block=%d",
 		 buffer, bytes, block);
 
-	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), DFU_DNLOAD,
-				 USB_TYPE_CLASS | USB_DIR_OUT |
-				 USB_RECIP_INTERFACE, block, 0, buffer, bytes,
-				 USB_CTRL_GET_TIMEOUT);
-	return result;
+	ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), DFU_DNLOAD,
+			      USB_TYPE_CLASS | USB_DIR_OUT |
+			      USB_RECIP_INTERFACE, block, 0, buffer, bytes,
+			      USB_CTRL_GET_TIMEOUT);
+	return ret;
 }
 
 static int at76_dfu_get_status(struct usb_device *udev,
 			       struct dfu_status *status)
 {
-	int result;
+	int ret;
 
-	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATUS,
-				 USB_TYPE_CLASS | USB_DIR_IN |
-				 USB_RECIP_INTERFACE, 0, 0, status,
-				 sizeof(struct dfu_status),
-				 USB_CTRL_GET_TIMEOUT);
-	return result;
+	ret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATUS,
+			      USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,
+			      0, 0, status, sizeof(struct dfu_status),
+			      USB_CTRL_GET_TIMEOUT);
+	return ret;
 }
 
 static u8 at76_dfu_get_state(struct usb_device *udev, u8 *state)
 {
-	int result;
+	int ret;
 
-	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATE,
-				 USB_TYPE_CLASS | USB_DIR_IN |
-				 USB_RECIP_INTERFACE, 0, 0, state, 1,
-				 USB_CTRL_GET_TIMEOUT);
-	return result;
+	ret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATE,
+			      USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,
+			      0, 0, state, 1, USB_CTRL_GET_TIMEOUT);
+	return ret;
 }
 
 static inline u32 at76_get_timeout(struct dfu_status *s)
@@ -275,7 +272,7 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 {
 	u8 *dmabuf;
 	struct dfu_status dfu_stat_buf;
-	int status = 0;
+	int ret = 0;
 	int need_dfu_state = 1;
 	int is_done = 0;
 	u8 dfu_state = 0;
@@ -299,9 +296,9 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 
 	do {
 		if (need_dfu_state) {
-			status = at76_dfu_get_state(udev, &dfu_state);
-			if (!DFU_USB_SUCCESS(status)) {
-				err("DFU: Failed to get DFU state: %d", status);
+			ret = at76_dfu_get_state(udev, &dfu_state);
+			if (ret < 0) {
+				err("DFU: Failed to get DFU state: %d", ret);
 				goto exit;
 			}
 			need_dfu_state = 0;
@@ -310,14 +307,13 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 		switch (dfu_state) {
 		case STATE_DFU_DOWNLOAD_SYNC:
 			at76_dbg(DBG_DFU, "STATE_DFU_DOWNLOAD_SYNC");
-			status = at76_dfu_get_status(udev, &dfu_stat_buf);
-			if (DFU_USB_SUCCESS(status)) {
+			ret = at76_dfu_get_status(udev, &dfu_stat_buf);
+			if (ret >= 0) {
 				dfu_state = dfu_stat_buf.state;
 				dfu_timeout = at76_get_timeout(&dfu_stat_buf);
 				need_dfu_state = 0;
 			} else
-				err("at76_dfu_get_status failed with %d",
-				    status);
+				err("at76_dfu_get_status failed with %d", ret);
 			break;
 
 		case STATE_DFU_DOWNLOAD_BUSY:
@@ -335,32 +331,27 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 		case STATE_DFU_IDLE:
 			at76_dbg(DBG_DFU, "DFU IDLE");
 
-			if (dfu_bytes_left <= DFU_PACKETSIZE)
-				dfu_block_bytes = dfu_bytes_left;
-			else
-				dfu_block_bytes = DFU_PACKETSIZE;
-
+			dfu_block_bytes = min(dfu_bytes_left, DFU_PACKETSIZE);
 			dfu_bytes_left -= dfu_block_bytes;
 			memcpy(dmabuf, dfu_buffer + dfu_buffer_offset,
 			       dfu_block_bytes);
-			status = at76_dfu_download_block(udev, dmabuf,
-							 dfu_block_bytes,
-							 dfu_block_cnt);
+			ret = at76_dfu_download_block(udev, dmabuf,
+						      dfu_block_bytes,
+						      dfu_block_cnt);
 			dfu_buffer_offset += dfu_block_bytes;
 			dfu_block_cnt++;
 
-			if (!DFU_USB_SUCCESS(status))
-				err("dfu_download_block failed with %d",
-				    status);
+			if (ret < 0)
+				err("dfu_download_block failed with %d", ret);
 			need_dfu_state = 1;
 			break;
 
 		case STATE_DFU_MANIFEST_SYNC:
 			at76_dbg(DBG_DFU, "STATE_DFU_MANIFEST_SYNC");
 
-			status = at76_dfu_get_status(udev, &dfu_stat_buf);
+			ret = at76_dfu_get_status(udev, &dfu_stat_buf);
 
-			if (DFU_USB_SUCCESS(status)) {
+			if (ret >= 0) {
 				dfu_state = dfu_stat_buf.state;
 				dfu_timeout = at76_get_timeout(&dfu_stat_buf);
 				need_dfu_state = 0;
@@ -393,20 +384,20 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 
 		case STATE_DFU_ERROR:
 			at76_dbg(DBG_DFU, "STATE_DFU_ERROR");
-			status = -EPIPE;
+			ret = -EPIPE;
 			break;
 
 		default:
 			at76_dbg(DBG_DFU, "DFU UNKNOWN STATE (%d)", dfu_state);
-			status = -EINVAL;
+			ret = -EINVAL;
 			break;
 		}
-	} while (!is_done && DFU_USB_SUCCESS(status));
+	} while (!is_done && (ret >= 0));
 
       exit:
 	kfree(dmabuf);
-	if (status < 0)
-		return status;
+	if (ret < 0)
+		return ret;
 	else
 		return 0;
 }




From agx at sigxcpu.org  Sat Jun 16 13:49:40 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Sat, 16 Jun 2007 13:49:40 +0200
Subject: [at76c503a-develop] [PATCH 01/10] Implement "get" counterparts
	for iwpriv calls
In-Reply-To: <20070616073826.13212.1752.stgit@dv.roinet.com>
References: <20070616073826.13212.1752.stgit@dv.roinet.com>
Message-ID: <20070616114940.GB3194@bogon.ms20.nix>

On Sat, Jun 16, 2007 at 03:38:26AM -0400, Pavel Roskin wrote:
> Rename all iwpriv calls to start with "get" or "set" for consistency. 
> Eliminate gap in the ioctl numbers.
Whole series applied and pushed out, thanks!
 -- Guido


From proski at gnu.org  Thu Jun 21 05:55:59 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:55:59 -0400
Subject: [at76c503a-develop] [PATCH 01/12] Fix recent breakage in
	at76_set_listen_interval()
Message-ID: <20070621035559.18384.52869.stgit@dv.roinet.com>

An offset was substituted from a wrong macro.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index f0042f3..9cfe3bb 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -901,7 +901,7 @@ static int at76_set_listen_interval(struct at76_priv *priv, u16 interval)
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_MAC;
 	priv->mib_buf.size = 2;
-	priv->mib_buf.index = offsetof(struct mib_mac_mgmt, station_id);
+	priv->mib_buf.index = offsetof(struct mib_mac, listen_interval);
 
 	*(__le16 *)priv->mib_buf.data = cpu_to_le16(interval);
 




From proski at gnu.org  Thu Jun 21 05:56:04 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:04 -0400
Subject: [at76c503a-develop] [PATCH 02/12] Replace a work/timer combination
	for restarts with a	delayed work
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035604.18384.48590.stgit@dv.roinet.com>

Decrease the delay to half second.  It's enough to cover all requests
from one iwconfig command, and improves the response time.

Cancel the delayed work in at76_stop().  We don't need any restarts if
the interface is down.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   26 +++++++-------------------
 at76_usb.h |    4 +---
 2 files changed, 8 insertions(+), 22 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 9cfe3bb..686777c 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1930,13 +1930,6 @@ static int at76_disassoc_req(struct at76_priv *priv, struct bss_info *bss)
 	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
-/* the restart timer timed out */
-static void at76_restart_timeout(unsigned long par)
-{
-	struct at76_priv *priv = (struct at76_priv *)par;
-	schedule_work(&priv->work_restart);
-}
-
 /* we got to check the bss_list for old entries */
 static void at76_bss_list_timeout(unsigned long par)
 {
@@ -2182,7 +2175,6 @@ static void at76_delete_device(struct at76_priv *priv)
 	at76_free_bss_list(priv);
 	del_timer_sync(&priv->bss_list_timer);
 	del_timer_sync(&priv->mgmt_timer);
-	del_timer_sync(&priv->restart_timer);
 
 	if (priv->istate == CONNECTED) {
 		at76_iwevent_bss_disconnect(priv->netdev);
@@ -2343,10 +2335,9 @@ static int at76_iw_handler_commit(struct net_device *netdev,
 		netif_stop_queue(priv->netdev);
 	}
 
-	/* do the restart after two seconds to catch
-	 * following ioctl's (from more params of iwconfig)
-	 * in _one_ restart */
-	mod_timer(&priv->restart_timer, jiffies + 2 * HZ);
+	/* Wait half second before the restart to process subsequent
+	 * requests from the same iwconfig in a single restart */
+	schedule_delayed_work(&priv->dwork_restart, HZ / 2);
 
 	return 0;
 }
@@ -3898,7 +3889,7 @@ static int at76_open(struct net_device *netdev)
 
 	priv->open_count++;
 
-	schedule_work(&priv->work_restart);
+	schedule_delayed_work(&priv->dwork_restart, 0);
 
 	at76_dbg(DBG_PROC_ENTRY, "at76_open end");
       err:
@@ -3932,6 +3923,7 @@ static int at76_stop(struct net_device *netdev)
 	}
 
 	del_timer_sync(&priv->mgmt_timer);
+	cancel_delayed_work(&priv->dwork_restart);
 
 	spin_lock_irqsave(&priv->mgmt_spinlock, flags);
 	if (priv->next_mgmt_bulk) {
@@ -4646,7 +4638,7 @@ static int at76_startup_device(struct at76_priv *priv)
 static void at76_work_restart(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
-					      work_restart);
+					      dwork_restart.work);
 
 	mutex_lock(&priv->mtx);
 
@@ -5854,17 +5846,13 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev)
 	INIT_WORK(&priv->work_join, at76_work_join);
 	INIT_WORK(&priv->work_mgmt_timeout, at76_work_mgmt_timeout);
 	INIT_WORK(&priv->work_new_bss, at76_work_new_bss);
-	INIT_WORK(&priv->work_restart, at76_work_restart);
 	INIT_WORK(&priv->work_scan, at76_work_scan);
 	INIT_WORK(&priv->work_set_promisc, at76_work_set_promisc);
 	INIT_WORK(&priv->work_submit_rx, at76_work_submit_rx);
+	INIT_DELAYED_WORK(&priv->dwork_restart, at76_work_restart);
 
 	priv->open_count = 0;
 
-	init_timer(&priv->restart_timer);
-	priv->restart_timer.data = (unsigned long)priv;
-	priv->restart_timer.function = at76_restart_timeout;
-
 	init_timer(&priv->mgmt_timer);
 	priv->mgmt_timer.data = (unsigned long)priv;
 	priv->mgmt_timer.function = at76_mgmt_timeout;
diff --git a/at76_usb.h b/at76_usb.h
index 0854ad7..67ab610 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -470,10 +470,10 @@ struct at76_priv {
 	struct work_struct work_join;
 	struct work_struct work_mgmt_timeout;
 	struct work_struct work_new_bss;
-	struct work_struct work_restart;
 	struct work_struct work_scan;
 	struct work_struct work_set_promisc;
 	struct work_struct work_submit_rx;
+	struct delayed_work dwork_restart;
 
 	int nr_submit_rx_tries;	/* number of tries to submit an rx urb left */
 	struct tasklet_struct rx_tasklet;
@@ -540,8 +540,6 @@ struct at76_priv {
 	} scan_state;
 	time_t last_scan;
 
-	struct timer_list restart_timer;	/* the timer we use to delay the restart a bit */
-
 	struct timer_list mgmt_timer;	/* the timer we use to repeat auth_req etc. */
 	int retries;		/* counts backwards while re-trying to send auth/assoc_req's */
 	u8 pm_mode;		/* power management mode: AT76_PM_{OFF, ON, SMART} */




From proski at gnu.org  Thu Jun 21 05:56:10 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:10 -0400
Subject: [at76c503a-develop] [PATCH 03/12] Minor comment fixes
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035610.18384.1976.stgit@dv.roinet.com>

Avoid multi-line comments before functions if a single line comment is
sufficient.  Multi-line comments are better suited for larger blocks of
code.

Capitalize comments for functions.  Remove some obsolete or wrong
comments.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  101 +++++++++++++++++++++++++++---------------------------------
 1 files changed, 45 insertions(+), 56 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 686777c..e48cd70 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -40,7 +40,7 @@
 #include "at76_usb.h"
 #include "at76_usb_ids.h"
 
-/* Version Information */
+/* Version information */
 #define DRIVER_NAME "at76_usb"
 #define DRIVER_DESC "Atmel at76x USB Wireless LAN Driver"
 
@@ -170,15 +170,15 @@ static struct usb_device_id dev_table[] = {
 
 MODULE_DEVICE_TABLE(usb, dev_table);
 
-/* module parameters */
+/* Module parameters */
 static int rx_copybreak = 200;
 static int scan_min_time = 10;
 static int scan_max_time = 120;
 
-/* the supported rates of this hardware, bit7 marks a basic rate */
+/* Supported rates of this hardware, bit 7 marks basic rates */
 static const u8 hw_rates[] = { 0x82, 0x84, 0x0b, 0x16 };
 
-/* The frequency of each channel in MHz */
+/* Frequency of each channel in MHz */
 static const long channel_frequency[] = {
 	2412, 2417, 2422, 2427, 2432, 2437, 2442,
 	2447, 2452, 2457, 2462, 2467, 2472, 2484
@@ -265,8 +265,8 @@ static inline u32 at76_get_timeout(struct dfu_status *s)
 	return ret;
 }
 
-/* if manifest_sync_timeout > 0 use this timeout (in msec) instead of the
-   one reported by the device in state MANIFEST_SYNC */
+/* Load internal firmware from the buffer.  If manifest_sync_timeout > 0, use
+ * its value in msec in the MANIFEST_SYNC state.  */
 static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 				u32 dfu_len, int manifest_sync_timeout)
 {
@@ -402,7 +402,7 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 		return 0;
 }
 
-/* some abbrev. for wireless events */
+/* Report that the scan results are ready */
 static inline void at76_iwevent_scan_complete(struct net_device *netdev)
 {
 	union iwreq_data wrqu;
@@ -483,7 +483,7 @@ static inline char *mac2str(u8 *mac)
 	return str;
 }
 
-/* led trigger */
+/* LED trigger */
 static int tx_activity;
 static void at76_ledtrig_tx_timerfunc(unsigned long data);
 static DEFINE_TIMER(ledtrig_tx_timer, at76_ledtrig_tx_timerfunc, 0, 0);
@@ -509,7 +509,7 @@ static void at76_ledtrig_tx_activity(void)
 		mod_timer(&ledtrig_tx_timer, jiffies + msecs_to_jiffies(250));
 }
 
-/* check if the given ssid is cloaked */
+/* Check if the given ssid is cloaked */
 static inline int at76_is_cloaked_ssid(u8 *ssid, int length)
 {
 	static const u8 zeros[32];
@@ -560,7 +560,7 @@ static int at76_get_op_mode(struct usb_device *udev)
 	return op_mode;
 }
 
-/* this loads a block of the second part of the firmware */
+/* Load a block of the second part of the firmware */
 static inline int at76_load_ext_fw_block(struct usb_device *udev, int i,
 					 void *buf, int bsize)
 {
@@ -588,10 +588,9 @@ static inline int get_hw_cfg_intersil(struct usb_device *udev,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
 }
 
-/* Get the hardware configuration for the adapter and place the appropriate
- * data in the appropriate fields of 'priv' (the GetHWConfig request and
- * interpretation of the result depends on the type of board we're dealing
- * with) */
+/* Get the hardware configuration for the adapter and put it to the appropriate
+ * fields of 'priv' (the GetHWConfig request and interpretation of the result
+ * depends on the board type) */
 static int at76_get_hw_config(struct at76_priv *priv)
 {
 	int ret;
@@ -782,12 +781,13 @@ static const char *at76_get_cmd_status_string(u8 cmd_status)
 	return "UNKNOWN";
 }
 
-/* TODO: should timeout */
+/* Wait until the command is completed */
 static int at76_wait_completion(struct at76_priv *priv, int cmd)
 {
 	struct net_device *netdev = priv->netdev;
 	int status = 0;
 
+	/* TODO: should timeout */
 	do {
 		status = at76_get_cmd_status(priv->udev, cmd);
 		if (status < 0) {
@@ -831,7 +831,7 @@ static int at76_set_mib(struct at76_priv *priv, struct set_mib_buffer *buf)
 	return ret;
 }
 
-/* return < 0 on error, == 0 if no command sent, == 1 if cmd sent */
+/* Return < 0 on error, == 0 if no command sent, == 1 if cmd sent */
 static int at76_set_radio(struct at76_priv *priv, int on_off)
 {
 	int ret;
@@ -849,10 +849,7 @@ static int at76_set_radio(struct at76_priv *priv, int on_off)
 	return ret;
 }
 
-/**
- * set_pm_mode - set current power save mode
- * (AT76_PM_OFF/AT76_PM_ON/AT76_PM_SMART)
- */
+/* Set current power save mode (AT76_PM_OFF/AT76_PM_ON/AT76_PM_SMART) */
 static int at76_set_pm_mode(struct at76_priv *priv)
 {
 	int ret = 0;
@@ -872,7 +869,7 @@ static int at76_set_pm_mode(struct at76_priv *priv)
 	return ret;
 }
 
-/* sets the assoc id for power save mode */
+/* Set the association id for power save mode */
 static int at76_set_associd(struct at76_priv *priv, u16 id)
 {
 	int ret = 0;
@@ -892,8 +889,7 @@ static int at76_set_associd(struct at76_priv *priv, u16 id)
 	return ret;
 }
 
-/* sets the listen interval for power save mode.
-   really needed, as we have a similar parameter in the assocreq ??? */
+/* Set the listen interval for power save mode */
 static int at76_set_listen_interval(struct at76_priv *priv, u16 interval)
 {
 	int ret = 0;
@@ -980,7 +976,7 @@ static int at76_set_autorate_fallback(struct at76_priv *priv, int onoff)
 	return ret;
 }
 
-/* set network device type for the current mode */
+/* Set network device type for the current mode */
 static void at76_set_monitor_mode(struct at76_priv *priv)
 {
 	if (priv->iw_mode == IW_MODE_MONITOR) {
@@ -1012,7 +1008,7 @@ static int at76_add_mac_address(struct at76_priv *priv, void *addr)
 }
 
 #if 0
-/* implemented to get promisc. mode working, but does not help.
+/* Implemented to get promisc. mode working, but does not help.
    May still be useful for multicast eventually. */
 static int set_group_address(struct at76_priv *priv, u8 *addr, int n)
 {
@@ -1376,7 +1372,7 @@ static int at76_get_current_channel(struct at76_priv *priv)
 }
 
 /**
- * start_scan - start a scan
+ * at76_start_scan - start a scan
  *
  * @use_essid - use the configured ESSID in non passive mode
  * @ir_step - international roaming step (0, 1)
@@ -1504,7 +1500,7 @@ static int at76_start_ibss(struct at76_priv *priv)
 	return 0;
 }
 
-/* idx points into priv->bss */
+/* Request card to join BSS in managed or ad-hoc mode */
 static int at76_join_bss(struct at76_priv *priv, struct bss_info *ptr)
 {
 	struct at76_req_join join;
@@ -1527,8 +1523,8 @@ static int at76_join_bss(struct at76_priv *priv, struct bss_info *ptr)
 				     sizeof(struct at76_req_join));
 }
 
-/* calc. the padding from txbuf->wlength (which excludes the USB TX header)
-   guess this is needed to compensate a flaw in the AT76C503A USB part ... */
+/* Calculate padding from txbuf->wlength (which excludes the USB TX header),
+   likely to compensate a flaw in the AT76C503A USB part ... */
 static inline int at76_calc_padding(int wlen)
 {
 	/* add the USB TX header */
@@ -1545,7 +1541,7 @@ static inline int at76_calc_padding(int wlen)
 	return 0;
 }
 
-/* we are doing a lot of things here in an interrupt. Need
+/* We are doing a lot of things here in an interrupt. Need
    a bh handler (Watching TV with a TV card is probably
    a good test: if you see flickers, we are doing too much.
    Currently I do see flickers... even with our tasklet :-( )
@@ -1606,7 +1602,7 @@ static void at76_write_bulk_callback(struct urb *urb)
 		netif_wake_queue(priv->netdev);
 }
 
-/* send a management frame on bulk-out.
+/* Send a management frame on bulk-out.
    txbuf->wlength must be set (in LE format !) */
 static int at76_send_mgmt_bulk(struct at76_priv *priv,
 			       struct at76_tx_buffer *txbuf)
@@ -1679,7 +1675,7 @@ static inline void next_ie(struct ieee80211_info_element **ie)
 	*ie = (struct ieee80211_info_element *)(&(*ie)->data[(*ie)->len]);
 }
 
-/* challenge is the challenge string (in TLV format)
+/* Challenge is the challenge string (in TLV format)
    we got with seq_nr 2 for shared secret authentication only and
    send in seq_nr 3 WEP encrypted to prove we have the correct WEP key;
    otherwise it is NULL */
@@ -1809,8 +1805,7 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
-/* we are currently associated to curr_bss and
-   want to reassoc to new_bss */
+/* We are currently associated to curr_bss and want to reassoc to new_bss */
 static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 			    struct bss_info *new_bss)
 {
@@ -1930,7 +1925,7 @@ static int at76_disassoc_req(struct at76_priv *priv, struct bss_info *bss)
 	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
-/* we got to check the bss_list for old entries */
+/* We got to check the bss_list for old entries */
 static void at76_bss_list_timeout(unsigned long par)
 {
 	struct at76_priv *priv = (struct at76_priv *)par;
@@ -1985,16 +1980,14 @@ static void at76_dump_bss_table(struct at76_priv *priv)
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
 
-/* we got a timeout for a infrastructure mgmt packet */
+/* We got a timeout for a infrastructure mgmt packet */
 static void at76_mgmt_timeout(unsigned long par)
 {
 	struct at76_priv *priv = (struct at76_priv *)par;
 	schedule_work(&priv->work_mgmt_timeout);
 }
 
-/*
- * at76_work_mgmt_timeout_scan - expiry of management timer in istate SCANNING
- */
+/* Expiry of management timer in istate SCANNING */
 static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 {
 	int status, ret;
@@ -2267,7 +2260,7 @@ static int at76_alloc_urbs(struct at76_priv *priv,
 	return 0;
 }
 
-/* we only store the new mac address in netdev struct,
+/* We only store the new mac address in netdev struct,
    it gets set when the netdev is opened. */
 static int at76_set_mac_address(struct net_device *netdev, void *addr)
 {
@@ -3092,7 +3085,7 @@ static int at76_iw_handler_set_retry(struct net_device *netdev,
 	return ret;
 }
 
-/* adapted (ripped) from atmel.c */
+/* Adapted (ripped) from atmel.c */
 static int at76_iw_handler_get_retry(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_param *retry, char *extra)
@@ -3486,9 +3479,7 @@ static int at76_iw_get_intl_roaming(struct net_device *netdev,
 
 #define AT76_SET_HANDLER(h, f) [h - SIOCIWFIRST] = (iw_handler) f
 
-/*******************************************************************************
- * structure that advertises the iw handlers of this driver
- */
+/* Standard wireless handlers */
 static const iw_handler at76_handlers[] = {
 	AT76_SET_HANDLER(SIOCSIWCOMMIT, at76_iw_handler_commit),
 	AT76_SET_HANDLER(SIOCGIWNAME, at76_iw_handler_get_name),
@@ -3524,7 +3515,7 @@ static const iw_handler at76_handlers[] = {
 
 #define AT76_SET_PRIV(h, f) [h - SIOCIWFIRSTPRIV] = (iw_handler) f
 
-/*structure that advertises the private iw handlers of this driver */
+/* Private wireless handlers */
 static const iw_handler at76_priv_handlers[] = {
 	AT76_SET_PRIV(AT76_SET_SHORT_PREAMBLE, at76_iw_set_short_preamble),
 	AT76_SET_PRIV(AT76_GET_SHORT_PREAMBLE, at76_iw_get_short_preamble),
@@ -3540,9 +3531,7 @@ static const iw_handler at76_priv_handlers[] = {
 	AT76_SET_PRIV(AT76_GET_INTL_ROAMING, at76_iw_get_intl_roaming),
 };
 
-/*******************************************************************************
- * structure that describes the private ioctls/iw handlers of this driver
- */
+/* Names and arguments of private wireless handlers */
 static const struct iw_priv_args at76_priv_args[] = {
 	/* 0 - long, 1 - short */
 	{AT76_SET_SHORT_PREAMBLE,
@@ -4717,7 +4706,7 @@ static void at76_work_submit_rx(struct work_struct *work)
 	mutex_unlock(&priv->mtx);
 }
 
-/* we got an association response */
+/* We got an association response */
 static void at76_rx_mgmt_assoc(struct at76_priv *priv,
 			       struct at76_rx_buffer *buf)
 {
@@ -5145,7 +5134,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
 
-/* calc the link level from a given rx_buffer */
+/* Calculate the link level from a given rx_buffer */
 static void at76_calc_level(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			    struct iw_quality *qual)
 {
@@ -5158,7 +5147,7 @@ static void at76_calc_level(struct at76_priv *priv, struct at76_rx_buffer *buf,
 	qual->updated |= IW_QUAL_LEVEL_UPDATED;
 }
 
-/* calc the link quality from a given rx_buffer */
+/* Calculate the link quality from a given rx_buffer */
 static void at76_calc_qual(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			   struct iw_quality *qual)
 {
@@ -5183,7 +5172,7 @@ static void at76_calc_qual(struct at76_priv *priv, struct at76_rx_buffer *buf,
 	qual->updated |= IW_QUAL_QUAL_UPDATED;
 }
 
-/* calc the noise quality from a given rx_buffer */
+/* Calculate the noise quality from a given rx_buffer */
 static void at76_calc_noise(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			    struct iw_quality *qual)
 {
@@ -5373,7 +5362,7 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 	    ntohs(skb->protocol), skb->len, hex2str(skb->data, 64));
 }
 
-/* check for fragmented data in priv->rx_skb. If the packet was no fragment
+/* Check for fragmented data in priv->rx_skb. If the packet was no fragment
    or it was the last of a fragment set a skb containing the whole packet
    is returned for further processing. Otherwise we get NULL and are
    done and the packet is either stored inside the fragment buffer
@@ -5602,7 +5591,7 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 	}
 }
 
-/* rx interrupt: we expect the complete data buffer in priv->rx_skb */
+/* Rx interrupt: we expect the complete data buffer in priv->rx_skb */
 static void at76_rx_data(struct at76_priv *priv)
 {
 	struct net_device *netdev = priv->netdev;
@@ -5710,7 +5699,7 @@ static void at76_rx_monitor_mode(struct at76_priv *priv)
 	stats->rx_bytes += length;
 }
 
-/* check if we spy on the sender address in buf and update stats */
+/* Check if we spy on the sender address in buf and update stats */
 static void at76_iwspy_update(struct at76_priv *priv,
 			      struct at76_rx_buffer *buf)
 {
@@ -6062,7 +6051,7 @@ static void at76_disconnect(struct usb_interface *interface)
 	printk(KERN_INFO DRIVER_NAME ": disconnected\n");
 }
 
-/* structure for registering this driver with the USB subsystem */
+/* Structure for registering this driver with the USB subsystem */
 static struct usb_driver at76_driver = {
 	.name = DRIVER_NAME,
 	.probe = at76_probe,




From proski at gnu.org  Thu Jun 21 05:56:15 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:15 -0400
Subject: [at76c503a-develop] [PATCH 04/12] Remove unneeded parentheses when
	taking an address
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035615.18384.28066.stgit@dv.roinet.com>

It's uncommon to see them in the kernel.  Dereferencing a pointer has
priority over taking an address, and it's well known.  Parentheses don't
make the code more readable if it looks differently from other drivers.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   32 ++++++++++++++++----------------
 1 files changed, 16 insertions(+), 16 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index e48cd70..8ca14d2 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -2545,10 +2545,10 @@ static int at76_iw_handler_set_spy(struct net_device *netdev,
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWSPY - number of addresses %d",
 		 netdev->name, data->length);
 
-	spin_lock_bh(&(priv->spy_spinlock));
+	spin_lock_bh(&priv->spy_spinlock);
 	ret = iw_handler_set_spy(priv->netdev, info, (union iwreq_data *)data,
 				 extra);
-	spin_unlock_bh(&(priv->spy_spinlock));
+	spin_unlock_bh(&priv->spy_spinlock);
 
 	return ret;
 }
@@ -2561,10 +2561,10 @@ static int at76_iw_handler_get_spy(struct net_device *netdev,
 	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = 0;
 
-	spin_lock_bh(&(priv->spy_spinlock));
+	spin_lock_bh(&priv->spy_spinlock);
 	ret = iw_handler_get_spy(priv->netdev, info,
 				 (union iwreq_data *)data, extra);
-	spin_unlock_bh(&(priv->spy_spinlock));
+	spin_unlock_bh(&priv->spy_spinlock);
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWSPY - number of addresses %d",
 		 netdev->name, data->length);
@@ -2582,10 +2582,10 @@ static int at76_iw_handler_set_thrspy(struct net_device *netdev,
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWTHRSPY - number of addresses %d)",
 		 netdev->name, data->length);
 
-	spin_lock_bh(&(priv->spy_spinlock));
+	spin_lock_bh(&priv->spy_spinlock);
 	ret = iw_handler_set_thrspy(netdev, info, (union iwreq_data *)data,
 				    extra);
-	spin_unlock_bh(&(priv->spy_spinlock));
+	spin_unlock_bh(&priv->spy_spinlock);
 
 	return ret;
 }
@@ -2597,10 +2597,10 @@ static int at76_iw_handler_get_thrspy(struct net_device *netdev,
 	struct at76_priv *priv = netdev_priv(netdev);
 	int ret;
 
-	spin_lock_bh(&(priv->spy_spinlock));
+	spin_lock_bh(&priv->spy_spinlock);
 	ret = iw_handler_get_thrspy(netdev, info, (union iwreq_data *)data,
 				    extra);
-	spin_unlock_bh(&(priv->spy_spinlock));
+	spin_unlock_bh(&priv->spy_spinlock);
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWTHRSPY - number of addresses %d)",
 		 netdev->name, data->length);
@@ -2677,14 +2677,14 @@ static int at76_iw_handler_set_scan(struct net_device *netdev,
 	priv->scan_state = SCAN_IN_PROGRESS;
 
 	/* stop pending management stuff */
-	del_timer_sync(&(priv->mgmt_timer));
+	del_timer_sync(&priv->mgmt_timer);
 
-	spin_lock_irqsave(&(priv->mgmt_spinlock), flags);
+	spin_lock_irqsave(&priv->mgmt_spinlock, flags);
 	if (priv->next_mgmt_bulk) {
 		kfree(priv->next_mgmt_bulk);
 		priv->next_mgmt_bulk = NULL;
 	}
-	spin_unlock_irqrestore(&(priv->mgmt_spinlock), flags);
+	spin_unlock_irqrestore(&priv->mgmt_spinlock, flags);
 
 	if (netif_running(priv->netdev)) {
 		/* pause network activity */
@@ -2737,9 +2737,9 @@ static int at76_iw_handler_get_scan(struct net_device *netdev,
 		/* scan not yet finished */
 		return -EAGAIN;
 
-	spin_lock_irqsave(&(priv->bss_list_spinlock), flags);
+	spin_lock_irqsave(&priv->bss_list_spinlock, flags);
 
-	list_for_each_safe(lptr, nptr, &(priv->bss_list)) {
+	list_for_each_safe(lptr, nptr, &priv->bss_list) {
 		curr_bss = list_entry(lptr, struct bss_info, list);
 
 		iwe->cmd = SIOCGIWAP;
@@ -2833,7 +2833,7 @@ static int at76_iw_handler_get_scan(struct net_device *netdev,
 
 	}
 
-	spin_unlock_irqrestore(&(priv->bss_list_spinlock), flags);
+	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 
 	data->length = (curr_pos - extra);
 	data->flags = 0;
@@ -5713,12 +5713,12 @@ static void at76_iwspy_update(struct at76_priv *priv,
 	qual.noise = 0;
 	at76_calc_level(priv, buf, &qual);
 
-	spin_lock_bh(&(priv->spy_spinlock));
+	spin_lock_bh(&priv->spy_spinlock);
 
 	if (priv->spy_data.spy_number > 0) {
 		wireless_spy_update(priv->netdev, hdr->addr2, &qual);
 	}
-	spin_unlock_bh(&(priv->spy_spinlock));
+	spin_unlock_bh(&priv->spy_spinlock);
 }
 
 static void at76_rx_tasklet(unsigned long param)




From proski at gnu.org  Thu Jun 21 05:56:20 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:20 -0400
Subject: [at76c503a-develop] [PATCH 05/12] Implement 5 second timeout in
	at76_wait_completion()
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035620.18384.60186.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    8 +++++++-
 at76_usb.h |    2 ++
 2 files changed, 9 insertions(+), 1 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 8ca14d2..3b1a1a4 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -786,8 +786,8 @@ static int at76_wait_completion(struct at76_priv *priv, int cmd)
 {
 	struct net_device *netdev = priv->netdev;
 	int status = 0;
+	unsigned long timeout = jiffies + CMD_COMPLETION_TIMEOUT;
 
-	/* TODO: should timeout */
 	do {
 		status = at76_get_cmd_status(priv->udev, cmd);
 		if (status < 0) {
@@ -806,6 +806,12 @@ static int at76_wait_completion(struct at76_priv *priv, int cmd)
 			schedule_timeout_interruptible(HZ / 10);	/* 100 ms */
 		} else
 			break;
+		if (time_after(jiffies, timeout)) {
+			err("%s: timeout waiting for cmd %d completion",
+			    netdev->name, cmd);
+			status = -ETIMEDOUT;
+			break;
+		}
 	} while (1);
 
 	return status;
diff --git a/at76_usb.h b/at76_usb.h
index 67ab610..691b837 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -621,6 +621,8 @@ struct at76_rx_radiotap {
 #define BEACON_TIMEOUT 10
 /* the interval in ticks we poll if scan is completed */
 #define SCAN_POLL_INTERVAL (HZ/4)
+/* the interval in ticks to wait for a command to be completed */
+#define CMD_COMPLETION_TIMEOUT (5 * HZ)
 
 #define DEF_RTS_THRESHOLD 1536
 #define DEF_FRAG_THRESHOLD 1536




From proski at gnu.org  Thu Jun 21 05:56:25 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:25 -0400
Subject: [at76c503a-develop] [PATCH 06/12] Avoid assignments inside
	conditions, they are hard to read
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035625.18384.622.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   45 ++++++++++++++++++++++++++++++---------------
 1 files changed, 30 insertions(+), 15 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 3b1a1a4..3e84c7b 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -719,7 +719,8 @@ static int at76_download_external_fw(struct usb_device *udev, u8 *buf, int size)
 		at76_dbg(DBG_DEVSTART,
 			 "ext fw, size left = %5d, bsize = %4d, i = %2d",
 			 size, bsize, i);
-		if ((ret = at76_load_ext_fw_block(udev, i, block, bsize)) < 0) {
+		ret = at76_load_ext_fw_block(udev, i, block, bsize);
+		if (ret < 0) {
 			err("loading %dth firmware block failed: %d", i, ret);
 			goto exit;
 		}
@@ -730,7 +731,8 @@ static int at76_download_external_fw(struct usb_device *udev, u8 *buf, int size)
 
 	/* for fw >= 0.100, the device needs
 	   an extra empty block: */
-	if ((ret = at76_load_ext_fw_block(udev, i, block, 0)) < 0) {
+	ret = at76_load_ext_fw_block(udev, i, block, 0);
+	if (ret < 0) {
 		err("loading %dth firmware block failed: %d", ret, i);
 		goto exit;
 	}
@@ -1623,7 +1625,8 @@ static int at76_send_mgmt_bulk(struct at76_priv *priv,
 
 	spin_lock_irqsave(&priv->mgmt_spinlock, flags);
 
-	if ((urb_status = priv->write_urb->status) == -EINPROGRESS) {
+	urb_status = priv->write_urb->status;
+	if (urb_status == -EINPROGRESS) {
 		oldbuf = priv->next_mgmt_bulk;	/* to kfree below */
 		priv->next_mgmt_bulk = txbuf;
 		txbuf = NULL;
@@ -1999,7 +2002,8 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 	int status, ret;
 	struct mib_mdomain mdomain;
 
-	if ((status = at76_get_cmd_status(priv->udev, CMD_SCAN)) < 0) {
+	status = at76_get_cmd_status(priv->udev, CMD_SCAN);
+	if (status < 0) {
 		err("%s: %s: at76_get_cmd_status failed with %d",
 		    priv->netdev->name, __FUNCTION__, status);
 		status = CMD_STATUS_IN_PROGRESS;
@@ -2033,7 +2037,8 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 
 	case 1:
 		at76_assert(priv->international_roaming);
-		if ((ret = at76_get_mib_mdomain(priv, &mdomain)) < 0) {
+		ret = at76_get_mib_mdomain(priv, &mdomain);
+		if (ret < 0) {
 			err("at76_get_mib_mdomain returned %d", ret);
 		} else {
 			at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %s "
@@ -2043,7 +2048,8 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 				 hex2str(mdomain.tx_powerlevel,
 					 sizeof(mdomain.tx_powerlevel)));
 		}
-		if ((ret = at76_start_scan(priv, 0, 1)) < 0) {
+		ret = at76_start_scan(priv, 0, 1);
+		if (ret < 0) {
 			err("%s: %s: start_scan (ANY) failed with %d",
 			    priv->netdev->name, __FUNCTION__, ret);
 		}
@@ -2054,7 +2060,8 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 		break;
 
 	case 2:
-		if ((ret = at76_start_scan(priv, 1, 1)) < 0) {
+		ret = at76_start_scan(priv, 1, 1);
+		if (ret < 0) {
 			err("%s: %s: start_scan (SSID) failed with %d",
 			    priv->netdev->name, __FUNCTION__, ret);
 		}
@@ -3877,7 +3884,8 @@ static int at76_open(struct net_device *netdev)
 	priv->last_scan = jiffies;
 	priv->nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;	/* init counter */
 
-	if ((ret = at76_submit_rx_urb(priv)) < 0) {
+	ret = at76_submit_rx_urb(priv);
+	if (ret < 0) {
 		err("%s: open: submit_rx_urb failed: %d", netdev->name, ret);
 		goto err;
 	}
@@ -3988,7 +3996,8 @@ static int at76_init_new_device(struct at76_priv *priv,
 	at76_dbg(DBG_DEVSTART, "USB interface: %d endpoints",
 		 interface->cur_altsetting->desc.bNumEndpoints);
 
-	if ((ret = at76_alloc_urbs(priv, interface)) < 0)
+	ret = at76_alloc_urbs(priv, interface);
+	if (ret < 0)
 		goto error;
 
 	/* get firmware version */
@@ -4131,11 +4140,13 @@ static int at76_load_internal_fw(struct usb_device *udev, struct fwentry *fwe)
 	at76_dbg(DBG_DEVSTART, "sending REMAP");
 
 	/* no REMAP for 505A (see SF driver) */
-	if (need_remap)
-		if ((ret = at76_remap(udev)) < 0) {
+	if (need_remap) {
+		ret = at76_remap(udev);
+		if (ret < 0) {
 			err("sending REMAP failed with %d", ret);
 			goto end_internal_fw;
 		}
+	}
 
 	at76_dbg(DBG_DEVSTART, "sleeping for 2 seconds");
 	schedule_timeout_interruptible(2 * HZ + 1);
@@ -4295,7 +4306,8 @@ static void at76_work_join(struct work_struct *work)
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 
 	if (priv->curr_bss != NULL) {
-		if ((ret = at76_join_bss(priv, priv->curr_bss)) < 0) {
+		ret = at76_join_bss(priv, priv->curr_bss);
+		if (ret < 0) {
 			err("%s: join_bss failed with %d",
 			    priv->netdev->name, ret);
 			goto end_join;
@@ -4667,7 +4679,8 @@ static void at76_work_scan(struct work_struct *work)
 		at76_free_bss_list(priv);
 
 	priv->scan_runs = 2;
-	if ((ret = at76_start_scan(priv, 0, 1)) < 0) {
+	ret = at76_start_scan(priv, 0, 1);
+	if (ret < 0) {
 		err("%s: %s: start_scan failed with %d",
 		    priv->netdev->name, __FUNCTION__, ret);
 	} else {
@@ -5614,7 +5627,8 @@ static void at76_rx_data(struct at76_priv *priv)
 	if (at76_debug & DBG_RX_DATA_CONTENT)
 		at76_dbg_dumpbuf("packet", skb->data + AT76_RX_HDRLEN, length);
 
-	if ((skb = at76_check_for_rx_frags(priv)) == NULL)
+	skb = at76_check_for_rx_frags(priv);
+	if (skb == NULL)
 		return;
 
 	/* if an skb is returned, the at76_rx_buffer and the FCS is already removed */
@@ -5666,7 +5680,8 @@ static void at76_rx_monitor_mode(struct at76_priv *priv)
 
 	skblen = sizeof(struct at76_rx_radiotap) + length;
 
-	if ((skb = dev_alloc_skb(skblen)) == NULL) {
+	skb = dev_alloc_skb(skblen);
+	if (skb == NULL) {
 		err("%s: MONITOR MODE: dev_alloc_skb for radiotap header "
 		    "returned NULL", priv->netdev->name);
 		return;




From proski at gnu.org  Thu Jun 21 05:56:30 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:30 -0400
Subject: [at76c503a-develop] [PATCH 07/12] Re-examine and simplify code
	where "return" is followed	by "else"
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035630.18384.71112.stgit@dv.roinet.com>

Try to make the code flow more linear.  Handle easy cases early.  This
avoids unnecessary identation and a complex tree structure of the code.

In at76_iw_handler_get_power(), an at76_dbg() call was supposed to cover
the "disabled" case but would not actually be called.  Fix it.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  199 +++++++++++++++++++++++++++++-------------------------------
 1 files changed, 96 insertions(+), 103 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 3e84c7b..d6572f7 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -396,10 +396,10 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 
       exit:
 	kfree(dmabuf);
-	if (ret < 0)
-		return ret;
-	else
-		return 0;
+	if (ret >= 0)
+		ret = 0;
+
+	return ret;
 }
 
 /* Report that the scan results are ready */
@@ -3247,17 +3247,14 @@ static int at76_iw_handler_get_power(struct net_device *netdev,
 {
 	struct at76_priv *priv = netdev_priv(netdev);
 
-	if ((power->disabled = (priv->pm_mode == AT76_PM_OFF)))
-		return 0;
-	else {
-		power->flags = IW_POWER_PERIOD;
+	power->disabled = (priv->pm_mode == AT76_PM_OFF);
+	if (!power->disabled) {
+		power->flags = IW_POWER_PERIOD | IW_POWER_ALL_R;
 		power->value = priv->pm_period;
 	}
-	power->flags |= IW_POWER_ALL_R;
 
-	at76_dbg(DBG_IOCTL,
-		 "%s: SIOCGIWPOWER - disabled %s flags x%x value x%x",
-		 netdev->name, (power->disabled) ? "true" : "false",
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWPOWER - %s flags x%x value x%x",
+		 netdev->name, power->disabled ? "disabled" : "enabled",
 		 power->flags, power->value);
 
 	return 0;
@@ -5501,113 +5498,109 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 		if (bptr->seqnr == seqnr) {
 			int left;
 			/* the fragment has the current sequence number */
-			if (((bptr->fragnr + 1) & 0xf) == fragnr) {
-				bptr->last_rx = jiffies;
-				/* the next following fragment number ->
-				   add the data at the end */
-				/* is & 0xf necessary above ??? */
-
-				/* for test only ??? */
-				left = skb_tailroom(bptr->skb);
-				if (left < data_len) {
-					printk(KERN_INFO
-					       "%s: only %d byte free (need %d)\n",
-					       priv->netdev->name, left,
-					       data_len);
-				} else
-					memcpy(skb_put(bptr->skb, data_len),
-					       data, data_len);
-				bptr->fragnr = fragnr;
-				if (!(frame_ctl & IEEE80211_FCTL_MOREFRAGS)) {
-					/* this was the last fragment - send it */
-					skb = bptr->skb;
-					bptr->skb = NULL;	/* free the entry */
-					at76_dbg(DBG_RX_FRAGS,
-						 "%s: last frag of seq %d",
-						 priv->netdev->name, seqnr);
-					return skb;
-				} else
-					return NULL;
-			} else {
+			if (((bptr->fragnr + 1) & 0xf) != fragnr) {
 				/* wrong fragment number -> ignore it */
+				/* is & 0xf necessary above ??? */
 				at76_dbg(DBG_RX_FRAGS,
 					 "%s: frag nr does not match: %d+1 != %d",
 					 priv->netdev->name, bptr->fragnr,
 					 fragnr);
 				return NULL;
 			}
-		} else {
-			/* got another sequence number */
-			if (fragnr == 0) {
-				/* it's the start of a new chain - replace the
-				   old one by this */
-				/* bptr->sender has the correct value already */
-				at76_dbg(DBG_RX_FRAGS,
-					 "%s: start of new seq %d, "
-					 "removing old seq %d",
-					 priv->netdev->name, seqnr,
-					 bptr->seqnr);
-				bptr->seqnr = seqnr;
-				bptr->fragnr = 0;
-				bptr->last_rx = jiffies;
-				/* swap bptr->skb and priv->rx_skb */
-				skb = bptr->skb;
-				bptr->skb = priv->rx_skb;
-				priv->rx_skb = skb;
-			} else {
-				/* it from the middle of a new chain ->
-				   delete the old entry and skip the new one */
-				at76_dbg(DBG_RX_FRAGS,
-					 "%s: middle of new seq %d (%d) "
-					 "removing old seq %d",
-					 priv->netdev->name, seqnr, fragnr,
-					 bptr->seqnr);
-				dev_kfree_skb(bptr->skb);
-				bptr->skb = NULL;
-			}
-			return NULL;
-		}
-	} else {
-		/* if we didn't find a chain for the sender address optr
-		   points either to the first free or the oldest entry */
+			bptr->last_rx = jiffies;
+			/* the next following fragment number ->
+			   add the data at the end */
 
-		if (fragnr != 0) {
-			/* this is not the begin of a fragment chain ... */
-			at76_dbg(DBG_RX_FRAGS,
-				 "%s: no chain for non-first fragment (%d)",
-				 priv->netdev->name, fragnr);
-			return NULL;
+			/* for test only ??? */
+			left = skb_tailroom(bptr->skb);
+			if (left < data_len) {
+				printk(KERN_INFO
+				       "%s: only %d byte free (need %d)\n",
+				       priv->netdev->name, left, data_len);
+			} else
+				memcpy(skb_put(bptr->skb, data_len), data,
+				       data_len);
+			bptr->fragnr = fragnr;
+			if (frame_ctl & IEEE80211_FCTL_MOREFRAGS)
+				return NULL;
+
+			/* this was the last fragment - send it */
+			skb = bptr->skb;
+			bptr->skb = NULL;	/* free the entry */
+			at76_dbg(DBG_RX_FRAGS, "%s: last frag of seq %d",
+				 priv->netdev->name, seqnr);
+			return skb;
 		}
-		at76_assert(optr != NULL);
-		if (optr == NULL)
-			return NULL;
-
-		if (optr->skb != NULL) {
-			/* swap the skb's */
-			skb = optr->skb;
-			optr->skb = priv->rx_skb;
-			priv->rx_skb = skb;
 
+		/* got another sequence number */
+		if (fragnr == 0) {
+			/* it's the start of a new chain - replace the
+			   old one by this */
+			/* bptr->sender has the correct value already */
 			at76_dbg(DBG_RX_FRAGS,
-				 "%s: free old contents: sender %s seq/frag %d/%d",
-				 priv->netdev->name, mac2str(optr->sender),
-				 optr->seqnr, optr->fragnr);
-
+				 "%s: start of new seq %d, removing old seq %d",
+				 priv->netdev->name, seqnr, bptr->seqnr);
+			bptr->seqnr = seqnr;
+			bptr->fragnr = 0;
+			bptr->last_rx = jiffies;
+			/* swap bptr->skb and priv->rx_skb */
+			skb = bptr->skb;
+			bptr->skb = priv->rx_skb;
+			priv->rx_skb = skb;
 		} else {
-			/* take the skb from priv->rx_skb */
-			optr->skb = priv->rx_skb;
-			priv->rx_skb = NULL;	/* let at76_submit_rx_urb() allocate a new skb */
-
-			at76_dbg(DBG_RX_FRAGS, "%s: use a free entry",
-				 priv->netdev->name);
+			/* it from the middle of a new chain ->
+			   delete the old entry and skip the new one */
+			at76_dbg(DBG_RX_FRAGS,
+				 "%s: middle of new seq %d (%d) "
+				 "removing old seq %d",
+				 priv->netdev->name, seqnr, fragnr,
+				 bptr->seqnr);
+			dev_kfree_skb(bptr->skb);
+			bptr->skb = NULL;
 		}
-		memcpy(optr->sender, i802_11_hdr->addr2, ETH_ALEN);
-		optr->seqnr = seqnr;
-		optr->fragnr = 0;
-		optr->last_rx = jiffies;
+		return NULL;
+	}
 
+	/* if we didn't find a chain for the sender address, optr
+	   points either to the first free or the oldest entry */
+
+	if (fragnr != 0) {
+		/* this is not the begin of a fragment chain ... */
+		at76_dbg(DBG_RX_FRAGS,
+			 "%s: no chain for non-first fragment (%d)",
+			 priv->netdev->name, fragnr);
 		return NULL;
 	}
+	at76_assert(optr != NULL);
+	if (optr == NULL)
+		return NULL;
+
+	if (optr->skb != NULL) {
+		/* swap the skb's */
+		skb = optr->skb;
+		optr->skb = priv->rx_skb;
+		priv->rx_skb = skb;
+
+		at76_dbg(DBG_RX_FRAGS,
+			 "%s: free old contents: sender %s seq/frag %d/%d",
+			 priv->netdev->name, mac2str(optr->sender),
+			 optr->seqnr, optr->fragnr);
+
+	} else {
+		/* take the skb from priv->rx_skb */
+		optr->skb = priv->rx_skb;
+		/* let at76_submit_rx_urb() allocate a new skb */
+		priv->rx_skb = NULL;
+
+		at76_dbg(DBG_RX_FRAGS, "%s: use a free entry",
+			 priv->netdev->name);
+	}
+	memcpy(optr->sender, i802_11_hdr->addr2, ETH_ALEN);
+	optr->seqnr = seqnr;
+	optr->fragnr = 0;
+	optr->last_rx = jiffies;
+
+	return NULL;
 }
 
 /* Rx interrupt: we expect the complete data buffer in priv->rx_skb */




From proski at gnu.org  Thu Jun 21 05:56:35 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:35 -0400
Subject: [at76c503a-develop] [PATCH 08/12] Don't print hex numbers starting
	with "x", use more common "0x"
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035635.18384.97288.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   43 ++++++++++++++++++++++---------------------
 1 files changed, 22 insertions(+), 21 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index d6572f7..ffc517e 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1804,7 +1804,7 @@ static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 	essid[len] = '\0';
 	next_ie(&tlv);		/* points to IE of rates now */
 	at76_dbg(DBG_TX_MGMT,
-		 "%s: AssocReq bssid %s capa x%04x ssid %s rates %s",
+		 "%s: AssocReq bssid %s capa 0x%04x ssid %s rates %s",
 		 priv->netdev->name, mac2str(mgmt->addr3),
 		 le16_to_cpu(req->capability), essid,
 		 hex2str(tlv->data, tlv->len));
@@ -1885,7 +1885,7 @@ static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 	essid[len] = '\0';
 	next_ie(&tlv);		/* points to IE of rates now */
 	at76_dbg(DBG_TX_MGMT,
-		 "%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s",
+		 "%s: ReAssocReq curr %s new %s capa 0x%04x ssid %s rates %s",
 		 priv->netdev->name, mac2str(req->current_ap),
 		 mac2str(mgmt->addr3), le16_to_cpu(req->capability), essid,
 		 hex2str(tlv->data, tlv->len));
@@ -1977,7 +1977,7 @@ static void at76_dump_bss_table(struct at76_priv *priv)
 	list_for_each(lptr, &priv->bss_list) {
 		ptr = list_entry(lptr, struct bss_info, list);
 		pr_debug("0x%p: bssid %s channel %d ssid %s (%s)"
-			 " capa x%04x rates %s rssi %d link %d noise %d",
+			 " capa 0x%04x rates %s rssi %d link %d noise %d",
 			 ptr, mac2str(ptr->bssid),
 			 ptr->channel,
 			 ptr->ssid,
@@ -2110,7 +2110,7 @@ static void at76_work_assoc_done(struct work_struct *work)
 			pm_period_beacon = min(pm_period_beacon, 0xffffu);
 
 			at76_dbg(DBG_PM,
-				 "%s: pm_mode %d assoc id x%x listen int %d",
+				 "%s: pm_mode %d assoc id 0x%x listen int %d",
 				 priv->netdev->name, priv->pm_mode,
 				 priv->curr_bss->assoc_id, pm_period_beacon);
 
@@ -2215,7 +2215,7 @@ static int at76_alloc_urbs(struct at76_priv *priv,
 	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
 		endpoint = &iface_desc->endpoint[i].desc;
 
-		at76_dbg(DBG_URB, "%s: %d. endpoint: addr x%x attr x%x",
+		at76_dbg(DBG_URB, "%s: %d. endpoint: addr 0x%x attr 0x%x",
 			 __FUNCTION__,
 			 i, endpoint->bEndpointAddress, endpoint->bmAttributes);
 
@@ -3082,7 +3082,7 @@ static int at76_iw_handler_set_retry(struct net_device *netdev,
 	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = -EIWCOMMIT;
 
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRETRY disabled %d  flags x%x val %d",
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRETRY disabled %d  flags 0x%x val %d",
 		 netdev->name, retry->disabled, retry->flags, retry->value);
 
 	if (!retry->disabled && (retry->flags & IW_RETRY_LIMIT)) {
@@ -3213,7 +3213,7 @@ static int at76_iw_handler_set_power(struct net_device *netdev,
 	struct at76_priv *priv = netdev_priv(netdev);
 
 	at76_dbg(DBG_IOCTL,
-		 "%s: SIOCSIWPOWER - disabled %s flags x%x value x%x",
+		 "%s: SIOCSIWPOWER - disabled %s flags 0x%x value 0x%x",
 		 netdev->name, (prq->disabled) ? "true" : "false", prq->flags,
 		 prq->value);
 
@@ -3253,7 +3253,7 @@ static int at76_iw_handler_get_power(struct net_device *netdev,
 		power->value = priv->pm_period;
 	}
 
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWPOWER - %s flags x%x value x%x",
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWPOWER - %s flags 0x%x value 0x%x",
 		 netdev->name, power->disabled ? "disabled" : "enabled",
 		 power->flags, power->value);
 
@@ -3308,7 +3308,7 @@ static int at76_iw_set_debug(struct net_device *netdev,
 			val = DBG_DEFAULTS;
 		}
 
-		dbg("%s: AT76_SET_DEBUG input %d: %s -> x%x",
+		dbg("%s: AT76_SET_DEBUG input %d: %s -> 0x%x",
 		    netdev->name, data->length, extra, val);
 	} else {
 		val = DBG_DEFAULTS;
@@ -3697,7 +3697,7 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 			    2 * ETH_ALEN - 2;
 		} else {
 			err("%s: %s: no support for non-SNAP 802.2 packets "
-			    "(DSAP x%02x SSAP x%02x cntrl x%02x)",
+			    "(DSAP 0x%02x SSAP 0x%02x cntrl 0x%02x)",
 			    priv->netdev->name, __FUNCTION__,
 			    skb->data[2 * ETH_ALEN + 2],
 			    skb->data[2 * ETH_ALEN + 2 + 1],
@@ -3748,7 +3748,7 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 
 	at76_dbg(DBG_TX_DATA_CONTENT, "%s skb->data %s", priv->netdev->name,
 		 hex2str(skb->data, 32));
-	at76_dbg(DBG_TX_DATA, "%s tx  wlen x%x pad x%x rate %d hdr %s",
+	at76_dbg(DBG_TX_DATA, "%s tx  wlen 0x%x pad 0x%x rate %d hdr %s",
 		 priv->netdev->name,
 		 le16_to_cpu(tx_buffer->wlength),
 		 tx_buffer->padding, tx_buffer->tx_rate,
@@ -4733,8 +4733,8 @@ static void at76_rx_mgmt_assoc(struct at76_priv *priv,
 	u16 status = le16_to_cpu(resp->status);
 	u16 capa = le16_to_cpu(resp->capability);
 	at76_dbg(DBG_RX_MGMT,
-		 "%s: rx AssocResp bssid %s capa x%04x status x%04x "
-		 "assoc_id x%04x rates %s", priv->netdev->name,
+		 "%s: rx AssocResp bssid %s capa 0x%04x status 0x%04x "
+		 "assoc_id 0x%04x rates %s", priv->netdev->name,
 		 mac2str(mgmt->addr3), capa, status, assoc_id,
 		 hex2str(resp->info_element->data, resp->info_element->len));
 	if (priv->istate == ASSOCIATING) {
@@ -4774,8 +4774,8 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *priv,
 	u16 assoc_id = le16_to_cpu(resp->aid);
 
 	at76_dbg(DBG_RX_MGMT,
-		 "%s: rx ReAssocResp bssid %s capa x%04x status x%04x "
-		 "assoc_id x%04x rates %s", priv->netdev->name,
+		 "%s: rx ReAssocResp bssid %s capa 0x%04x status 0x%04x "
+		 "assoc_id 0x%04x rates %s", priv->netdev->name,
 		 mac2str(mgmt->addr3), capa, status, assoc_id,
 		 hex2str(resp->info_element->data, resp->info_element->len));
 	if (priv->istate == REASSOCIATING) {
@@ -4822,7 +4822,7 @@ static void at76_rx_mgmt_disassoc(struct at76_priv *priv,
 	struct ieee80211_hdr_3addr *mgmt = &resp->header;
 
 	at76_dbg(DBG_RX_MGMT,
-		 "%s: rx DisAssoc bssid %s reason x%04x destination %s",
+		 "%s: rx DisAssoc bssid %s reason 0x%04x destination %s",
 		 priv->netdev->name, mac2str(mgmt->addr3),
 		 le16_to_cpu(resp->reason), mac2str(mgmt->addr1));
 	if (priv->istate == SCANNING || priv->istate == INIT)
@@ -4938,7 +4938,7 @@ static void at76_rx_mgmt_deauth(struct at76_priv *priv,
 	struct ieee80211_hdr_3addr *mgmt = &resp->header;
 
 	at76_dbg(DBG_RX_MGMT | DBG_PROGRESS,
-		 "%s: rx DeAuth bssid %s reason x%04x destination %s",
+		 "%s: rx DeAuth bssid %s reason 0x%04x destination %s",
 		 priv->netdev->name, mac2str(mgmt->addr3),
 		 le16_to_cpu(resp->reason), mac2str(mgmt->addr1));
 	if (priv->istate == DISASSOCIATING ||
@@ -5235,7 +5235,7 @@ static void at76_rx_mgmt(struct at76_priv *priv, struct at76_rx_buffer *buf)
 		}
 	}
 
-	at76_dbg(DBG_RX_MGMT_CONTENT, "%s rx mgmt subtype x%x %s",
+	at76_dbg(DBG_RX_MGMT_CONTENT, "%s rx mgmt subtype 0x%x %s",
 		 priv->netdev->name, subtype,
 		 hex2str(mgmt, le16_to_cpu(buf->wlength)));
 
@@ -5373,9 +5373,10 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 		skb->protocol = htons(ETH_P_802_2);
 	}
 
-	dbg("%s: EXIT skb da %s sa %s proto x%04x len %d data %s", __FUNCTION__,
-	    mac2str(eth_hdr(skb)->h_dest), mac2str(eth_hdr(skb)->h_source),
-	    ntohs(skb->protocol), skb->len, hex2str(skb->data, 64));
+	dbg("%s: EXIT skb da %s sa %s proto 0x%04x len %d data %s",
+	    __FUNCTION__, mac2str(eth_hdr(skb)->h_dest),
+	    mac2str(eth_hdr(skb)->h_source), ntohs(skb->protocol), skb->len,
+	    hex2str(skb->data, 64));
 }
 
 /* Check for fragmented data in priv->rx_skb. If the packet was no fragment




From proski at gnu.org  Thu Jun 21 05:56:40 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:40 -0400
Subject: [at76c503a-develop] [PATCH 09/12] Rename functions ending with
	"matched" to start with	"at76_match"
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035640.18384.57895.stgit@dv.roinet.com>

It's more natural to use a common prefix, not suffix, for similar
functions.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   20 ++++++++------------
 1 files changed, 8 insertions(+), 12 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index ffc517e..c8ce70b 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -4153,7 +4153,7 @@ static int at76_load_internal_fw(struct usb_device *udev, struct fwentry *fwe)
 	return ret;
 }
 
-static int at76_essid_matched(struct at76_priv *priv, struct bss_info *ptr)
+static int at76_match_essid(struct at76_priv *priv, struct bss_info *ptr)
 {
 	/* common criteria for both modi */
 
@@ -4167,8 +4167,7 @@ static int at76_essid_matched(struct at76_priv *priv, struct bss_info *ptr)
 	return ret;
 }
 
-static inline int at76_mode_matched(struct at76_priv *priv,
-				    struct bss_info *ptr)
+static inline int at76_match_mode(struct at76_priv *priv, struct bss_info *ptr)
 {
 	int ret;
 
@@ -4183,7 +4182,7 @@ static inline int at76_mode_matched(struct at76_priv *priv,
 	return ret;
 }
 
-static int at76_rates_matched(struct at76_priv *priv, struct bss_info *ptr)
+static int at76_match_rates(struct at76_priv *priv, struct bss_info *ptr)
 {
 	int i;
 	u8 *rate;
@@ -4213,7 +4212,7 @@ static int at76_rates_matched(struct at76_priv *priv, struct bss_info *ptr)
 		return 1;
 }
 
-static inline int at76_wep_matched(struct at76_priv *priv, struct bss_info *ptr)
+static inline int at76_match_wep(struct at76_priv *priv, struct bss_info *ptr)
 {
 	if (!priv->wep_enabled && ptr->capa & WLAN_CAPABILITY_PRIVACY) {
 		/* we have disabled WEP, but the BSS signals privacy */
@@ -4227,8 +4226,7 @@ static inline int at76_wep_matched(struct at76_priv *priv, struct bss_info *ptr)
 	return 1;
 }
 
-static inline int at76_bssid_matched(struct at76_priv *priv,
-				     struct bss_info *ptr)
+static inline int at76_match_bssid(struct at76_priv *priv, struct bss_info *ptr)
 {
 	if (!priv->wanted_bssid_valid ||
 	    !compare_ether_addr(ptr->bssid, priv->wanted_bssid)) {
@@ -4262,11 +4260,9 @@ static struct bss_info *at76_match_bss(struct at76_priv *priv,
 	curr = last != NULL ? last->list.next : priv->bss_list.next;
 	while (curr != &priv->bss_list) {
 		ptr = list_entry(curr, struct bss_info, list);
-		if (at76_essid_matched(priv, ptr) &&
-		    at76_mode_matched(priv, ptr) &&
-		    at76_wep_matched(priv, ptr) &&
-		    at76_rates_matched(priv, ptr) &&
-		    at76_bssid_matched(priv, ptr))
+		if (at76_match_essid(priv, ptr) && at76_match_mode(priv, ptr)
+		    && at76_match_wep(priv, ptr) && at76_match_rates(priv, ptr)
+		    && at76_match_bssid(priv, ptr))
 			break;
 		curr = curr->next;
 	}




From proski at gnu.org  Thu Jun 21 05:56:45 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:45 -0400
Subject: [at76c503a-develop] [PATCH 10/12] Rename set_group_address to
	at76_set_group_address, clean it up
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035645.18384.28304.stgit@dv.roinet.com>

Although that function is commented out, it would be better to make it
look like other functions.  Remove "#if 1", it's confusing.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    5 ++---
 1 files changed, 2 insertions(+), 3 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index c8ce70b..0368f5a 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1018,7 +1018,7 @@ static int at76_add_mac_address(struct at76_priv *priv, void *addr)
 #if 0
 /* Implemented to get promisc. mode working, but does not help.
    May still be useful for multicast eventually. */
-static int set_group_address(struct at76_priv *priv, u8 *addr, int n)
+static int at76_set_group_address(struct at76_priv *priv, u8 *addr, int n)
 {
 	int ret = 0;
 
@@ -1033,7 +1033,7 @@ static int set_group_address(struct at76_priv *priv, u8 *addr, int n)
 		err("%s: set_mib (MIB_MAC_ADD, group_addr) failed: %d",
 		    priv->netdev->name, ret);
 	}
-#if 1
+
 	/* I do not know anything about the group_addr_status field... (oku) */
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_MAC_ADD;
@@ -1046,7 +1046,6 @@ static int set_group_address(struct at76_priv *priv, u8 *addr, int n)
 		err("%s: set_mib (MIB_MAC_ADD, group_addr_status) failed: %d",
 		    priv->netdev->name, ret);
 	}
-#endif
 	return ret;
 }
 #endif




From proski at gnu.org  Thu Jun 21 05:56:50 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:50 -0400
Subject: [at76c503a-develop] [PATCH 11/12] Rename get_hw_cfg_intersil()
	to	at76_get_hw_cfg_intersil()
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035650.18384.66399.stgit@dv.roinet.com>

This function was missed earlier because it's always inlined.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    7 ++++---
 1 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 0368f5a..16b82c8 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -579,8 +579,8 @@ static inline int at76_get_hw_cfg_rfmd(struct usb_device *udev,
 }
 
 /* Intersil boards use a different "value" for GetHWConfig requests */
-static inline int get_hw_cfg_intersil(struct usb_device *udev,
-				      union at76_hwcfg *buf, int buf_size)
+static inline int at76_get_hw_cfg_intersil(struct usb_device *udev,
+					   union at76_hwcfg *buf, int buf_size)
 {
 	return usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			       0x33, INTERFACE_VENDOR_REQUEST_IN,
@@ -603,7 +603,8 @@ static int at76_get_hw_config(struct at76_priv *priv)
 
 	case BOARDTYPE_503_INTERSIL_3861:
 	case BOARDTYPE_503_INTERSIL_3863:
-		ret = get_hw_cfg_intersil(priv->udev, hwcfg, sizeof(hwcfg->i));
+		ret = at76_get_hw_cfg_intersil(priv->udev, hwcfg,
+					       sizeof(hwcfg->i));
 		if (ret < 0)
 			break;
 		memcpy(priv->mac_addr, hwcfg->i.mac_addr, ETH_ALEN);




From proski at gnu.org  Thu Jun 21 05:56:56 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 20 Jun 2007 23:56:56 -0400
Subject: [at76c503a-develop] [PATCH 12/12] Convert management timer/work to
	a delayed work
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070621035655.18384.58408.stgit@dv.roinet.com>

This is likely not the final approch, as the code handles several
different timeouts and may need to be split.  Anyway, it would be easier
to split a single delayed work than a timer and a work.

When handling beacons, cancel the work first, as we want the timeout
handler to be deferred.  The delayed workqueue API doesn't seem to
provide a nicer way to do it.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   65 +++++++++++++++++++++++++++---------------------------------
 at76_usb.h |    3 +--
 2 files changed, 30 insertions(+), 38 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 16b82c8..4bb671a 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -1989,13 +1989,6 @@ static void at76_dump_bss_table(struct at76_priv *priv)
 	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
 
-/* We got a timeout for a infrastructure mgmt packet */
-static void at76_mgmt_timeout(unsigned long par)
-{
-	struct at76_priv *priv = (struct at76_priv *)par;
-	schedule_work(&priv->work_mgmt_timeout);
-}
-
 /* Expiry of management timer in istate SCANNING */
 static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 {
@@ -2027,7 +2020,7 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 		at76_dbg(DBG_MGMT_TIMER,
 			 "%s:%d: starting mgmt_timer for %d ticks",
 			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		schedule_delayed_work(&priv->dwork_mgmt, SCAN_POLL_INTERVAL);
 		return;
 	}
 
@@ -2056,7 +2049,7 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 		at76_dbg(DBG_MGMT_TIMER,
 			 "%s:%d: starting mgmt_timer for %d ticks",
 			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		schedule_delayed_work(&priv->dwork_mgmt, SCAN_POLL_INTERVAL);
 		break;
 
 	case 2:
@@ -2068,7 +2061,7 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 		at76_dbg(DBG_MGMT_TIMER,
 			 "%s:%d: starting mgmt_timer for %d ticks",
 			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		schedule_delayed_work(&priv->dwork_mgmt, SCAN_POLL_INTERVAL);
 		break;
 
 	case 3:
@@ -2180,7 +2173,7 @@ static void at76_delete_device(struct at76_priv *priv)
 
 	at76_free_bss_list(priv);
 	del_timer_sync(&priv->bss_list_timer);
-	del_timer_sync(&priv->mgmt_timer);
+	cancel_delayed_work(&priv->dwork_mgmt);
 
 	if (priv->istate == CONNECTED) {
 		at76_iwevent_bss_disconnect(priv->netdev);
@@ -2328,7 +2321,7 @@ static int at76_iw_handler_commit(struct net_device *netdev,
 	if (priv->istate != INIT) {
 		priv->istate = INIT;
 		/* stop pending management stuff */
-		del_timer_sync(&priv->mgmt_timer);
+		cancel_delayed_work(&priv->dwork_mgmt);
 
 		spin_lock_irqsave(&priv->mgmt_spinlock, flags);
 		if (priv->next_mgmt_bulk) {
@@ -2690,7 +2683,7 @@ static int at76_iw_handler_set_scan(struct net_device *netdev,
 	priv->scan_state = SCAN_IN_PROGRESS;
 
 	/* stop pending management stuff */
-	del_timer_sync(&priv->mgmt_timer);
+	cancel_delayed_work(&priv->dwork_mgmt);
 
 	spin_lock_irqsave(&priv->mgmt_spinlock, flags);
 	if (priv->next_mgmt_bulk) {
@@ -3922,7 +3915,7 @@ static int at76_stop(struct net_device *netdev)
 		usb_kill_urb(priv->read_urb);
 	}
 
-	del_timer_sync(&priv->mgmt_timer);
+	cancel_delayed_work(&priv->dwork_mgmt);
 	cancel_delayed_work(&priv->dwork_restart);
 
 	spin_lock_irqsave(&priv->mgmt_spinlock, flags);
@@ -4335,7 +4328,7 @@ static void at76_work_join(struct work_struct *work)
 			netif_carrier_on(priv->netdev);
 			netif_start_queue(priv->netdev);
 			/* just to be sure */
-			del_timer_sync(&priv->mgmt_timer);
+			cancel_delayed_work(&priv->dwork_mgmt);
 		} else {
 			/* send auth req */
 			priv->istate = AUTHENTICATING;
@@ -4343,7 +4336,7 @@ static void at76_work_join(struct work_struct *work)
 			at76_dbg(DBG_MGMT_TIMER,
 				 "%s:%d: starting mgmt_timer + HZ",
 				 __FUNCTION__, __LINE__);
-			mod_timer(&priv->mgmt_timer, jiffies + HZ);
+			schedule_delayed_work(&priv->dwork_mgmt, HZ);
 		}
 		goto end_join;
 	}
@@ -4366,7 +4359,7 @@ static void at76_work_join(struct work_struct *work)
 static void at76_work_mgmt_timeout(struct work_struct *work)
 {
 	struct at76_priv *priv = container_of(work, struct at76_priv,
-					      work_mgmt_timeout);
+					      dwork_mgmt.work);
 
 	mutex_lock(&priv->mtx);
 
@@ -4407,7 +4400,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 			at76_dbg(DBG_MGMT_TIMER,
 				 "%s:%d: starting mgmt_timer + HZ",
 				 __FUNCTION__, __LINE__);
-			mod_timer(&priv->mgmt_timer, jiffies + HZ);
+			schedule_delayed_work(&priv->dwork_mgmt, HZ);
 		} else {
 			/* try to get next matching BSS */
 			priv->istate = JOINING;
@@ -4421,7 +4414,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 			at76_dbg(DBG_MGMT_TIMER,
 				 "%s:%d: starting mgmt_timer + HZ",
 				 __FUNCTION__, __LINE__);
-			mod_timer(&priv->mgmt_timer, jiffies + HZ);
+			schedule_delayed_work(&priv->dwork_mgmt, HZ);
 		} else {
 			/* jal: TODO: we may be authenticated to several
 			   BSS and may try to associate to the next of them here
@@ -4445,7 +4438,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 		}
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
 			 __FUNCTION__, __LINE__);
-		mod_timer(&priv->mgmt_timer, jiffies + HZ);
+		schedule_delayed_work(&priv->dwork_mgmt, HZ);
 		break;
 
 	case DISASSOCIATING:
@@ -4454,7 +4447,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 			at76_dbg(DBG_MGMT_TIMER,
 				 "%s:%d: starting mgmt_timer + HZ",
 				 __FUNCTION__, __LINE__);
-			mod_timer(&priv->mgmt_timer, jiffies + HZ);
+			schedule_delayed_work(&priv->dwork_mgmt, HZ);
 		} else {
 			/* we scan again ... */
 			priv->istate = SCANNING;
@@ -4680,7 +4673,7 @@ static void at76_work_scan(struct work_struct *work)
 		at76_dbg(DBG_MGMT_TIMER,
 			 "%s:%d: starting mgmt_timer for %d ticks",
 			 __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		schedule_delayed_work(&priv->dwork_mgmt, SCAN_POLL_INTERVAL);
 	}
 
 	mutex_unlock(&priv->mtx);
@@ -4751,7 +4744,7 @@ static void at76_rx_mgmt_assoc(struct at76_priv *priv,
 			priv->istate = JOINING;
 			schedule_work(&priv->work_join);
 		}
-		del_timer_sync(&priv->mgmt_timer);
+		cancel_delayed_work(&priv->dwork_mgmt);
 	} else {
 		printk(KERN_INFO "%s: AssocResp in state %d ignored\n",
 		       priv->netdev->name, priv->istate);
@@ -4800,7 +4793,7 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *priv,
 				 priv->netdev->name, mac2str(priv->bssid));
 			schedule_work(&priv->work_assoc_done);
 		} else {
-			del_timer_sync(&priv->mgmt_timer);
+			cancel_delayed_work(&priv->dwork_mgmt);
 			priv->istate = JOINING;
 			schedule_work(&priv->work_join);
 		}
@@ -4848,7 +4841,7 @@ static void at76_rx_mgmt_disassoc(struct at76_priv *priv,
 				netif_stop_queue(priv->netdev);
 				at76_iwevent_bss_disconnect(priv->netdev);
 			}
-			del_timer_sync(&priv->mgmt_timer);
+			cancel_delayed_work(&priv->dwork_mgmt);
 			priv->istate = JOINING;
 			schedule_work(&priv->work_join);
 		} else {
@@ -4898,7 +4891,7 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv,
 		/* this is a AuthFrame from the BSS we are connected or
 		   trying to connect to, directed to us */
 		if (status != WLAN_STATUS_SUCCESS) {
-			del_timer_sync(&priv->mgmt_timer);
+			cancel_delayed_work(&priv->dwork_mgmt);
 			/* try to join next bss */
 			priv->istate = JOINING;
 			schedule_work(&priv->work_join);
@@ -4912,7 +4905,7 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv,
 			at76_dbg(DBG_MGMT_TIMER,
 				 "%s:%d: starting mgmt_timer + HZ",
 				 __FUNCTION__, __LINE__);
-			mod_timer(&priv->mgmt_timer, jiffies + HZ);
+			schedule_delayed_work(&priv->dwork_mgmt, HZ);
 			return;
 		}
 
@@ -4921,7 +4914,7 @@ static void at76_rx_mgmt_auth(struct at76_priv *priv,
 			      resp->info_element);
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
 			 __FUNCTION__, __LINE__);
-		mod_timer(&priv->mgmt_timer, jiffies + HZ);
+		schedule_delayed_work(&priv->dwork_mgmt, HZ);
 	}
 	/* else: ignore AuthFrames to other recipients */
 }
@@ -4955,7 +4948,7 @@ static void at76_rx_mgmt_deauth(struct at76_priv *priv,
 			}
 			priv->istate = JOINING;
 			schedule_work(&priv->work_join);
-			del_timer_sync(&priv->mgmt_timer);
+			cancel_delayed_work(&priv->dwork_mgmt);
 		}
 		/* ignore DeAuth to other STA or from other BSSID */
 	} else {
@@ -4996,8 +4989,12 @@ static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 		if (priv->curr_bss == NULL)
 			goto rx_mgmt_beacon_end;
 		if (!compare_ether_addr(priv->curr_bss->bssid, mgmt->addr3)) {
-			mod_timer(&priv->mgmt_timer,
-				  jiffies + BEACON_TIMEOUT * HZ);
+			/* We got our AP's beacon, defer the timeout handler.
+			   Kill pending work first, as schedule_delayed_work()
+			   won't do it. */
+			cancel_delayed_work(&priv->dwork_mgmt);
+			schedule_delayed_work(&priv->dwork_mgmt,
+					      jiffies + BEACON_TIMEOUT * HZ);
 			priv->curr_bss->rssi = buf->rssi;
 			priv->beacons_received++;
 			goto rx_mgmt_beacon_end;
@@ -5844,19 +5841,15 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev)
 	mutex_init(&priv->mtx);
 	INIT_WORK(&priv->work_assoc_done, at76_work_assoc_done);
 	INIT_WORK(&priv->work_join, at76_work_join);
-	INIT_WORK(&priv->work_mgmt_timeout, at76_work_mgmt_timeout);
 	INIT_WORK(&priv->work_new_bss, at76_work_new_bss);
 	INIT_WORK(&priv->work_scan, at76_work_scan);
 	INIT_WORK(&priv->work_set_promisc, at76_work_set_promisc);
 	INIT_WORK(&priv->work_submit_rx, at76_work_submit_rx);
 	INIT_DELAYED_WORK(&priv->dwork_restart, at76_work_restart);
+	INIT_DELAYED_WORK(&priv->dwork_mgmt, at76_work_mgmt_timeout);
 
 	priv->open_count = 0;
 
-	init_timer(&priv->mgmt_timer);
-	priv->mgmt_timer.data = (unsigned long)priv;
-	priv->mgmt_timer.function = at76_mgmt_timeout;
-
 	spin_lock_init(&priv->mgmt_spinlock);
 	priv->next_mgmt_bulk = NULL;
 	priv->istate = INIT;
diff --git a/at76_usb.h b/at76_usb.h
index 691b837..111a5ee 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -468,12 +468,12 @@ struct at76_priv {
 	/* work queues */
 	struct work_struct work_assoc_done;
 	struct work_struct work_join;
-	struct work_struct work_mgmt_timeout;
 	struct work_struct work_new_bss;
 	struct work_struct work_scan;
 	struct work_struct work_set_promisc;
 	struct work_struct work_submit_rx;
 	struct delayed_work dwork_restart;
+	struct delayed_work dwork_mgmt;
 
 	int nr_submit_rx_tries;	/* number of tries to submit an rx urb left */
 	struct tasklet_struct rx_tasklet;
@@ -540,7 +540,6 @@ struct at76_priv {
 	} scan_state;
 	time_t last_scan;
 
-	struct timer_list mgmt_timer;	/* the timer we use to repeat auth_req etc. */
 	int retries;		/* counts backwards while re-trying to send auth/assoc_req's */
 	u8 pm_mode;		/* power management mode: AT76_PM_{OFF, ON, SMART} */
 	u32 pm_period;		/* power manag. period in us */




From agx at sigxcpu.org  Wed Jun 27 16:21:39 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Wed, 27 Jun 2007 17:21:39 +0300
Subject: [at76c503a-develop] [PATCH 01/12] Fix recent breakage in
	at76_set_listen_interval()
In-Reply-To: <20070621035559.18384.52869.stgit@dv.roinet.com>
References: <20070621035559.18384.52869.stgit@dv.roinet.com>
Message-ID: <20070627142139.GA10514@bogon.ms20.nix>

Hi Pavel,
On Wed, Jun 20, 2007 at 11:55:59PM -0400, Pavel Roskin wrote:
> An offset was substituted from a wrong macro.
Applied and pushed out, sorry for the delay.
Cheers,
 -- Guido


