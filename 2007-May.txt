From proski at gnu.org  Tue May  1 05:09:27 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 30 Apr 2007 23:09:27 -0400
Subject: [at76c503a-develop] [PATCH 1/3] Protect at76_usb_ids.h against
	double inclusion
Message-ID: <20070501030927.8538.88824.stgit@dv.roinet.com>

Even though it's unlikely to happen, it's a good style, and the lack of
such protection can raise some eyebrows.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb_ids.h |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/at76_usb_ids.h b/at76_usb_ids.h
index 6bec5e5..3bbe0a6 100644
--- a/at76_usb_ids.h
+++ b/at76_usb_ids.h
@@ -9,6 +9,9 @@
  * the License, or (at your option) any later version.
  */
 
+#ifndef _AT76_USB_IDS_H
+#define _AT76_USB_IDS_H
+
 #define VENDOR_ID_3COM                  0x0506
 #define VENDOR_ID_ACTIONTEC             0x1668
 #define VENDOR_ID_ADDTRON               0x05dd
@@ -107,3 +110,5 @@
 #define BOARDTYPE_505_RFMD_2958     6
 #define BOARDTYPE_505A_RFMD_2958    7
 #define BOARDTYPE_505AMX_RFMD       8
+
+#endif /* _AT76_USB_IDS_H */




From proski at gnu.org  Tue May  1 05:09:32 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 30 Apr 2007 23:09:32 -0400
Subject: [at76c503a-develop] [PATCH 2/3] Typo fixes, minor comment changes
In-Reply-To: <20070501030927.8538.88824.stgit@dv.roinet.com>
References: <20070501030927.8538.88824.stgit@dv.roinet.com>
Message-ID: <20070501030932.8538.47062.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c     |   11 +++++------
 at76_usb_ids.h |    2 +-
 2 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index e2e39ae..c36985c 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -5,7 +5,7 @@
  * Copyright (c) 2004 Joerg Albert <joerg.albert at gmx.de>
  * Copyright (c) 2004 Nick Jones
  * Copyright (c) 2004 Balint Seeber <n0_5p4m_p13453 at hotmail.com>
- * Copyritht (c) 2007 Guido Guenther <agx at sigxcpu.org>
+ * Copyright (c) 2007 Guido Guenther <agx at sigxcpu.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -3118,7 +3118,7 @@ rx_mgmt_beacon_end:
 static void at76_calc_level(struct at76_priv *dev, struct at76_rx_buffer *buf,
 		       struct iw_quality *qual)
 {
-	int max_rssi = 42;	/* just a gues for now, might be different for other chips */
+	int max_rssi = 42;	/* just a guess for now, might be different for other chips */
 
 	qual->level = (buf->rssi * 100 / max_rssi);
 	if (qual->level > 100)
@@ -4509,7 +4509,6 @@ static int at76_iw_handler_set_freq(struct net_device *netdev,
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - freq.m %d freq.e %d", netdev->name,
 	    freq->m, freq->e);
 
-	/* modelled on orinoco.c */
 	if ((freq->e == 0) && (freq->m <= 1000)) {
 		/* Setting by channel number */
 		chan = freq->m;
@@ -5742,7 +5741,7 @@ static void at76_delete_device(struct at76_priv *dev)
 			dev->rx_data[i].skb = NULL;
 		}
 	at76_dbg(DBG_PROC_ENTRY, "%s: before freeing dev/netdev", __FUNCTION__);
-	free_netdev(dev->netdev); /* dev is in net_dev */
+	free_netdev(dev->netdev); /* dev is in netdev */
 
 	at76_dbg(DBG_PROC_ENTRY, "%s: EXIT", __FUNCTION__);
 }
@@ -5900,7 +5899,7 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 
 
 /**
- * at76_init_new_device - continue device intialization after firmware download
+ * at76_init_new_device - continue device initialization after firmware download
  *
  * FIXME: We may have to move the register_netdev into at76_alloc_new_device,
  * because hotplug may try to configure the netdev _before_ (or parallel to)
@@ -6029,7 +6028,7 @@ static int at76_get_fw_info(u8 *fw_data, int fw_size,
 /* fw structure (all numbers are little_endian)
    offset  length  description
    0       4       crc 32 (seed ~0, no post, all gaps are zeros, header included)
-   4       4       board type (see at76_usb.h)
+   4       4       board type (see at76_usb_ids.h)
    8       4       version (major<<24|middle<<16|minor<<8|build)
    c       4       offset of printable string (id) area from begin of image
                    (must be \0 terminated !)
diff --git a/at76_usb_ids.h b/at76_usb_ids.h
index 3bbe0a6..a37fd45 100644
--- a/at76_usb_ids.h
+++ b/at76_usb_ids.h
@@ -1,7 +1,7 @@
 /*
  * USB IDs for the at76c503/at76c505 USB driver
  *
- * Copyritht (c) 2007 Guido Guenther <agx at sigxcpu.org>
+ * Copyright (c) 2007 Guido Guenther <agx at sigxcpu.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as




From proski at gnu.org  Tue May  1 05:09:37 2007
From: proski at gnu.org (Pavel Roskin)
Date: Mon, 30 Apr 2007 23:09:37 -0400
Subject: [at76c503a-develop] [PATCH 3/3] Fix crash when no firmware needs to
	be loaded
In-Reply-To: <20070501030927.8538.88824.stgit@dv.roinet.com>
References: <20070501030927.8538.88824.stgit@dv.roinet.com>
Message-ID: <20070501030937.8538.38634.stgit@dv.roinet.com>

If the firmware download is not needed (typically after the driver has
been loaded and unloaded), SET_NETDEV_DEV would be called after
register_netdev().  This would create some inconsistency in the network
device, which can cause kernel oops when it's unregistered on disconnect
or module unload.

Call SET_NETDEV_DEV immediately after the network device is allocated.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index c36985c..a1f9131 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -5833,6 +5833,7 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 		return NULL;
 	}
 
+	SET_NETDEV_DEV(netdev, &udev->dev);
 	dev = netdev_priv(netdev);
 	memset(dev, 0, sizeof(*dev));
 
@@ -6208,7 +6209,6 @@ static int at76_do_probe(struct usb_device *udev, u8 *fw_data, int fw_size,
 		}
 	}
 
-	SET_NETDEV_DEV(dev->netdev, &intf->dev);
 	return 0;
 
 error:




From proski at gnu.org  Tue May  1 06:15:58 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 01 May 2007 00:15:58 -0400
Subject: [at76c503a-develop] Status of the driver
Message-ID: <1177992958.7931.38.camel@dv>

Hello!

I've just fixed a very bad bug in the driver.  Basically, it would cause
kernel oops if the at76_usb module is loaded and unloaded twice.

What happens is that the firmware doesn't need to be downloaded on the
second module load.  Thus, the device registration is not rescheduled,
but called immediately.  The problem is, it happens before
SET_NETDEV_DEV, which confuses the network layer and ultimately crashes
the kernel on device unregistration.

I've been aware of that bug for a long time, and I feel much better
about submitting the driver now that the bug is fixed.

It looks like that the firmware download was rescheduled to avoid that
bug.  Perhaps it doesn't need to be rescheduled anymore.  That's
something we could try.

My other serious concern is that the monitor mode is implemented on top
of scan.  That's quite weird.  As a result, the device switches between
different channels in the monitor mode instead of staying on the user
selected channel.  At very least, the monitor mode should stay on the
same channel.  Ideally, it should be completely separate from scanning.

We also need to integrate timers into workqueues.  It makes no sense to
reschedule events twice.  That should be easy.

On the more cosmetic side, I'd like to rename "dev" to "priv" whenever
it's used for the private data.  That's the standard convention in the
network devices.  In fact, "dev" is often used for the network device.
The driver is quite inconsistent now.  It uses "dev" and "priv" for
private data, whereas the network device uses "netdev" and sometimes
"dev".

Also, it would be nice to integrate at76_do_probe() into at76_probe().
This split is quite illogical.  It splits similar code between two
functions.  In fact, "interface" is not passed to at76_do_probe() and
has to be calculated.  The resulting function could be split in a more
reasonable way.

I think I'll send some patches as RFC (request for comments) or RFT
(request for testing).

I tried to find the suggestions by Johannes, but I'm afraid I'm missing
some of his later e-mails.  Of the suggestions I could find, only two
seem still relevant:

Re-indent the code.  I don't think we can do it wholesale, as it would
damage some intentional formatting.  Bet there are still occurrences of
very long lines and missing spaces around operators.  While at that, we
should probably remove some debugging code.  I, for one, never trust
debugging code written by others.

Convert semaphores to mutexes.  That should be easy, as we only have one
semaphore.  Semaphores are clearly a thing of the past.  All new
wireless drivers are using mutexes.

Guido, could you please check if I missed anything of Johannes'
suggestions?

-- 
Regards,
Pavel Roskin



From agx at sigxcpu.org  Tue May  1 14:34:24 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Tue, 1 May 2007 14:34:24 +0200
Subject: [at76c503a-develop] Status of the driver
In-Reply-To: <1177992958.7931.38.camel@dv>
References: <1177992958.7931.38.camel@dv>
Message-ID: <20070501123424.GA12038@bogon.ms20.nix>

Hi Pavel.
On Tue, May 01, 2007 at 12:15:58AM -0400, Pavel Roskin wrote:
> I've just fixed a very bad bug in the driver.  Basically, it would cause
> kernel oops if the at76_usb module is loaded and unloaded twice.
Great!

[..snip..]
> My other serious concern is that the monitor mode is implemented on top
> of scan.  That's quite weird.  As a result, the device switches between
> different channels in the monitor mode instead of staying on the user
> selected channel.  At very least, the monitor mode should stay on the
> same channel.  Ideally, it should be completely separate from scanning.
That would be nice but can maybe be fixed up later.

> We also need to integrate timers into workqueues.  It makes no sense to
> reschedule events twice.  That should be easy.
Agreed.

> On the more cosmetic side, I'd like to rename "dev" to "priv" whenever
> it's used for the private data.  That's the standard convention in the
> network devices.  In fact, "dev" is often used for the network device.
> The driver is quite inconsistent now.  It uses "dev" and "priv" for
> private data, whereas the network device uses "netdev" and sometimes
> "dev".
Yes, the current naming is very inconsistent and hurts the eye. I used
priv for everything new but the old stuff should be renamed too, at
least step by step.

> Also, it would be nice to integrate at76_do_probe() into at76_probe().
> This split is quite illogical.  It splits similar code between two
Agreed.

> I tried to find the suggestions by Johannes, but I'm afraid I'm missing
> some of his later e-mails.  Of the suggestions I could find, only two
> seem still relevant:
> 
> Re-indent the code.  I don't think we can do it wholesale, as it would
> damage some intentional formatting.  Bet there are still occurrences of
> very long lines and missing spaces around operators.  While at that, we
> should probably remove some debugging code.  I, for one, never trust
> debugging code written by others.
I reindentet much of the code using lindent a while ago, there shouldn't
be too many bad spots left but those remaining should indeed be cleaned
up. I wouldn't be sad to see the debugging code go, we can always keep
it on a separate branch if we want the code to stay around.

> Convert semaphores to mutexes.  That should be easy, as we only have one
> semaphore.  Semaphores are clearly a thing of the past.  All new
> wireless drivers are using mutexes.
> 
> Guido, could you please check if I missed anything of Johannes'
> suggestions?
- reorder code for less function prototypes
- remove module parameters that can be set by iwpriv
- pass struct at76_priv to at76_get_fw_info and fill that in instead of
  using that many parameters
and
- move static u8 snapsig/rfc1042sig/hw_rates/channel_frequency out of
  the header file
which I just fixed.

I think that's about it.
Cheers,
 -- Guido



From agx at sigxcpu.org  Tue May  1 14:35:16 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Tue, 1 May 2007 14:35:16 +0200
Subject: [at76c503a-develop] [PATCH 1/3] Protect at76_usb_ids.h against
	double inclusion
In-Reply-To: <20070501030927.8538.88824.stgit@dv.roinet.com>
References: <20070501030927.8538.88824.stgit@dv.roinet.com>
Message-ID: <20070501123516.GB12038@bogon.ms20.nix>

On Mon, Apr 30, 2007 at 11:09:27PM -0400, Pavel Roskin wrote:
> Even though it's unlikely to happen, it's a good style, and the lack of
> such protection can raise some eyebrows.
I applied the whole series.
Cheers,
 -- Guido


From proski at gnu.org  Wed May  2 02:00:46 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 01 May 2007 20:00:46 -0400
Subject: [at76c503a-develop] [PATCH 2/6] Rename at76_get_fw_info() to
	at76_parse_fw(), fully rewrite
In-Reply-To: <20070502000041.14011.47848.stgit@dv.roinet.com>
References: <20070502000041.14011.47848.stgit@dv.roinet.com>
Message-ID: <20070502000046.14011.14661.stgit@dv.roinet.com>

Use a structure to describe the firmware header.  Don't pass any
arguments fpr output, just pass the pointer to the private data.  Move
some debugging output there to avoid code duplication.

Parse firmware even if it doesn't need to be loaded.  Keep firmware
version information in the private data.  It's still re-read from the
card, but now we have a valid version earlier.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  149 +++++++++++++++++-------------------------------------------
 at76_usb.h |   13 +++++
 2 files changed, 55 insertions(+), 107 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 649b1ce..59d9129 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -6028,58 +6028,43 @@ static int at76_init_new_device(struct at76_priv *dev)
 }
 
 
-/**
- * at76_get_fw_info - disassembles the firmware image
- *
- * get version, str, internal and external fw part.
- * returns 0 on success, < 0 on error
- */
-static int at76_get_fw_info(u8 *fw_data, int fw_size,
-				u32 *board, u32 *version, char **str,
-				u8 **int_fw, int *int_fw_size,
-				u8 **ext_fw, int *ext_fw_size)
-{
-/* fw structure (all numbers are little_endian)
-   offset  length  description
-   0       4       crc 32 (seed ~0, no post, all gaps are zeros, header included)
-   4       4       board type (see at76_usb_ids.h)
-   8       4       version (major<<24|middle<<16|minor<<8|build)
-   c       4       offset of printable string (id) area from begin of image
-                   (must be \0 terminated !)
-  10       4       offset of internal fw part area
-  14       4       length of internal fw part
-  18       4       offset of external fw part area (may be first byte _behind_
-                   image in case we have no external part)
-  1c       4       length of external fw part
-*/
-
-	__le32 val;
+/* Parse the firmware image */
+static int at76_parse_fw(struct at76_priv *dev, u8 *fw_data, int fw_size,
+			 int board_type)
+{
+	char *str;
+	struct at76_fw_header *fw = (struct at76_fw_header *)fw_data;
 
-	if (fw_size < 0x21) {
-		err("fw too short (x%x)", fw_size);
+	if (fw_size <= sizeof(*fw)) {
+		err("firmware is too short (0x%x)", fw_size);
 		return -EFAULT;
 	}
 
-	/* crc currently not checked */
-
-	memcpy(&val, fw_data + 4, 4);
-	*board = le32_to_cpu(val);
-
-	memcpy(&val, fw_data + 8, 4);
-	*version = le32_to_cpu(val);
-
-	memcpy(&val, fw_data + 0xc, 4);
-	*str = fw_data + le32_to_cpu(val);
-
-	memcpy(&val, fw_data + 0x10, 4);
-	*int_fw = fw_data + le32_to_cpu(val);
-	memcpy(&val, fw_data + 0x14, 4);
-	*int_fw_size = le32_to_cpu(val);
+	/* CRC currently not checked */
+	dev->board_type = le32_to_cpu(fw->board_type);
+	dev->fw_version.major = fw->major;
+	dev->fw_version.minor = fw->minor;
+	dev->fw_version.patch = fw->patch;
+	dev->fw_version.build = fw->build;
+	str = (char *)fw_data + le32_to_cpu(fw->str_offset);
+	dev->intfw = (u8 *)fw + le32_to_cpu(fw->int_fw_offset);
+	dev->intfw_size = le32_to_cpu(fw->int_fw_len);
+	dev->extfw = (u8 *)fw + le32_to_cpu(fw->ext_fw_offset);
+	dev->extfw_size = le32_to_cpu(fw->ext_fw_len);
+
+	at76_dbg(DBG_DEVSTART, "firmware board %u version %u.%u.%u#%u "
+		 "(int %x:%tx, ext %x:%tx)", dev->board_type,
+		 dev->fw_version.major, dev->fw_version.minor,
+		 dev->fw_version.patch, dev->fw_version.build,
+		 dev->intfw_size, dev->intfw - fw_data,
+		 dev->extfw_size, dev->extfw - fw_data);
+	at76_dbg(DBG_DEVSTART, "firmware id %s", str);
 
-	memcpy(&val, fw_data + 0x18, 4);
-	*ext_fw = fw_data + le32_to_cpu(val);
-	memcpy(&val, fw_data + 0x1c, 4);
-	*ext_fw_size = le32_to_cpu(val);
+	if (dev->board_type != board_type) {
+		err("inconsistent board types %u != %u", board_type,
+		    dev->board_type);
+		return -EINVAL;
+	}
 
 	return 0;
 }
@@ -6094,8 +6079,6 @@ static int at76_probe(struct usb_interface *interface,
 	const struct firmware *fw = firmwares[board_type].fw;
 	struct usb_device *udev = interface_to_usbdev(interface);
 	int op_mode;
-	char *id_str;
-	u32 version;
 
 	if (fw == NULL) {
 		at76_dbg(DBG_FW, "downloading firmware %s", fw_name);
@@ -6115,7 +6098,7 @@ static int at76_probe(struct usb_interface *interface,
 
 	if ((dev = at76_alloc_new_device(udev, (u8) board_type)) == NULL) {
 		ret = -ENOMEM;
-		goto error;
+		goto error_alloc;
 	}
 
 	op_mode = at76_get_op_mode(udev);
@@ -6135,41 +6118,17 @@ static int at76_probe(struct usb_interface *interface,
 		goto error;
 	}
 
+	/* parse the firmware */
+	ret = at76_parse_fw(dev, fw->data, fw->size, board_type);
+	if (ret)
+		goto error;
+
 	if (op_mode != OPMODE_NORMAL_NIC_WITH_FLASH
 	    && op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {
-
-		at76_dbg(DBG_DEVSTART, "need to download firmware");
-
-		/* parse the firmware */
-		ret = at76_get_fw_info(fw->data, fw->size,
-				       &dev->board_type, &version, &id_str,
-				       &dev->intfw, &dev->intfw_size,
-				       &dev->extfw, &dev->extfw_size);
-		if (ret)
-			goto error;
-
-		at76_dbg(DBG_DEVSTART,
-			 "firmware board %u version %u.%u.%u#%u "
-			 "(int %x:%tx, ext %x:%tx)", dev->board_type,
-			 version >> 24, (version >> 16) & 0xff,
-			 (version >> 8) & 0xff, version & 0xff, dev->intfw_size,
-			 dev->intfw - fw->data, dev->extfw_size,
-			 dev->extfw - fw->data);
-		if (*id_str)
-			at76_dbg(DBG_DEVSTART, "firmware id %s", id_str);
-
-		if (dev->board_type != board_type) {
-			err("inconsistent board types %u != %u", board_type,
-			    dev->board_type);
-			at76_delete_device(dev);
-			goto error;
-		}
-
 		/* download internal firmware part */
 		at76_dbg(DBG_DEVSTART, "downloading internal firmware");
 		dev->istate = INTFW_DOWNLOAD;
 		schedule_work(&dev->work_internal_fw);
-
 	} else {
 		/* Internal firmware already inside the device.  Get firmware
 		 * version to test if external firmware is loaded.
@@ -6178,17 +6137,9 @@ static int at76_probe(struct usb_interface *interface,
 		 * at76_get_op_mode() fail too :-( */
 		int force_fw_dwl = 0;
 
-		/* parse the firmware */
-		ret = at76_get_fw_info(fw->data, fw->size,
-				       &dev->board_type, &version, &id_str,
-				       &dev->intfw, &dev->intfw_size,
-				       &dev->extfw, &dev->extfw_size);
-		if (ret)
-			goto error;
-
 		/* if version >= 0.100.x.y or device with built-in flash we can
 		 * query the device for the fw version */
-		if (version >= ((0 << 24) | (100 << 16))
+		if ((dev->fw_version.major > 0 || dev->fw_version.minor >= 100)
 		    || (op_mode == OPMODE_NORMAL_NIC_WITH_FLASH)) {
 			ret = at76_get_mib(udev, MIB_FW_VERSION,
 					   &dev->fw_version,
@@ -6210,36 +6161,20 @@ static int at76_probe(struct usb_interface *interface,
 				at76_dbg(DBG_DEVSTART,
 					 "cannot get firmware (ret %d) or all zeros "
 					 "- download external firmware", ret);
-			at76_dbg(DBG_DEVSTART,
-				 "firmware board %u version %u.%u.%u#%u "
-				 "(int %x:%tx, ext %x:%tx)", dev->board_type,
-				 version >> 24, (version >> 16) & 0xff,
-				 (version >> 8) & 0xff, version & 0xff,
-				 dev->intfw_size, dev->intfw - fw->data,
-				 dev->extfw_size, dev->extfw - fw->data);
-			if (*id_str)
-				at76_dbg(DBG_DEVSTART, "firmware id %s",
-					 id_str);
-
-			if (dev->board_type != board_type) {
-				err("inconsistent board types %u != %u",
-				    board_type, dev->board_type);
-				at76_delete_device(dev);
-				goto error;
-			}
 
 			dev->istate = EXTFW_DOWNLOAD;
 			schedule_work(&dev->work_external_fw);
 		} else {
 			dev->istate = INIT;
-			if ((ret = at76_init_new_device(dev)) < 0) {
+			if ((ret = at76_init_new_device(dev)) < 0)
 				goto error;
-			}
 		}
 	}
 	return 0;
 
       error:
+	at76_delete_device(dev);
+      error_alloc:
 	usb_put_dev(udev);
 	return ret;
 }
diff --git a/at76_usb.h b/at76_usb.h
index a74b3c5..97f46d6 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -364,6 +364,19 @@ struct mib_mdomain {
 	u8 channel_list[14];	/* 0 for invalid channels */
 } __attribute__ ((packed));
 
+struct at76_fw_header {
+	__le32 crc;			/* CRC32 of the whole image */
+	__le32 board_type;		/* firmware compatibility code */
+	u8 build;			/* firmware build number */
+	u8 patch;			/* firmware patch level */
+	u8 minor;			/* firmware minor version */
+	u8 major;			/* firmware major version */
+	__le32 str_offset;		/* offset of the copyright string */
+	__le32 int_fw_offset;		/* internal firmware image offset */
+	__le32 int_fw_len;		/* internal firmware image length */
+	__le32 ext_fw_offset;		/* external firmware image offset */
+	__le32 ext_fw_len;		/* external firmware image length */
+} __attribute__ ((packed));
 
 /* states in infrastructure mode */
 enum infra_state {




From proski at gnu.org  Wed May  2 02:00:41 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 01 May 2007 20:00:41 -0400
Subject: [at76c503a-develop] [PATCH 1/6] Merge at76_do_probe() into
	at76_probe()
Message-ID: <20070502000041.14011.47848.stgit@dv.roinet.com>

The split was artificial, not across a logical boundary. 
at76_do_probe() was only called by at76_probe() in one place.  Both
functions were dealing with similar issues.  The "interface" variable
wasn't passed to at76_do_probe(), it was calculated from altconfig.
Reformat the resulting function.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |  160 +++++++++++++++++++++++++++---------------------------------
 1 files changed, 73 insertions(+), 87 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 83eb5d3..649b1ce 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -6084,19 +6084,33 @@ static int at76_get_fw_info(u8 *fw_data, int fw_size,
 	return 0;
 }
 
-/**
- * at76_do_probe - have a look at the firmware
- */
-static int at76_do_probe(struct usb_device *udev, u8 *fw_data, int fw_size,
-			     u32 board_type)
+static int at76_probe(struct usb_interface *interface,
+		      const struct usb_device_id *id)
 {
-	struct usb_interface *intf = udev->actconfig->interface[0];
 	int ret;
-	struct at76_priv *dev = NULL;
+	struct at76_priv *dev;
+	int board_type = (int)id->driver_info;
+	const char *const fw_name = firmwares[board_type].fwname;
+	const struct firmware *fw = firmwares[board_type].fw;
+	struct usb_device *udev = interface_to_usbdev(interface);
 	int op_mode;
 	char *id_str;
 	u32 version;
 
+	if (fw == NULL) {
+		at76_dbg(DBG_FW, "downloading firmware %s", fw_name);
+		ret = request_firmware(&fw, fw_name, &udev->dev);
+		if (ret == 0) {
+			at76_dbg(DBG_FW, "got it.");
+		} else {
+			err("firmware %s not found.", fw_name);
+			err("You may need to download the firmware from "
+			    "https://developer.berlios.de/projects/at76c503a/");
+			return ret;
+		}
+	} else
+		at76_dbg(DBG_FW, "re-using previously loaded fw");
+
 	usb_get_dev(udev);
 
 	if ((dev = at76_alloc_new_device(udev, (u8) board_type)) == NULL) {
@@ -6106,8 +6120,8 @@ static int at76_do_probe(struct usb_device *udev, u8 *fw_data, int fw_size,
 
 	op_mode = at76_get_op_mode(udev);
 
-	usb_set_intfdata(intf, dev);
-	dev->interface = intf;
+	usb_set_intfdata(interface, dev);
+	dev->interface = interface;
 
 	at76_dbg(DBG_DEVSTART, "opmode %d", op_mode);
 
@@ -6121,65 +6135,64 @@ static int at76_do_probe(struct usb_device *udev, u8 *fw_data, int fw_size,
 		goto error;
 	}
 
-	if (op_mode != OPMODE_NORMAL_NIC_WITH_FLASH &&
-	    op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {
+	if (op_mode != OPMODE_NORMAL_NIC_WITH_FLASH
+	    && op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {
 
 		at76_dbg(DBG_DEVSTART, "need to download firmware");
 
-		/* disassem. the firmware */
-		if ((ret =
-		     at76_get_fw_info(fw_data, fw_size, &dev->board_type,
-					  &version, &id_str, &dev->intfw,
-					  &dev->intfw_size, &dev->extfw,
-					  &dev->extfw_size))) {
+		/* parse the firmware */
+		ret = at76_get_fw_info(fw->data, fw->size,
+				       &dev->board_type, &version, &id_str,
+				       &dev->intfw, &dev->intfw_size,
+				       &dev->extfw, &dev->extfw_size);
+		if (ret)
 			goto error;
-		}
 
-		at76_dbg(DBG_DEVSTART, "firmware board %u version %u.%u.%u#%u "
-		         "(int %x:%tx, ext %x:%tx)",
-		         dev->board_type, version >> 24, (version >> 16) & 0xff,
-		         (version >> 8) & 0xff, version & 0xff,
-		         dev->intfw_size, dev->intfw - fw_data,
-		         dev->extfw_size, dev->extfw - fw_data);
+		at76_dbg(DBG_DEVSTART,
+			 "firmware board %u version %u.%u.%u#%u "
+			 "(int %x:%tx, ext %x:%tx)", dev->board_type,
+			 version >> 24, (version >> 16) & 0xff,
+			 (version >> 8) & 0xff, version & 0xff, dev->intfw_size,
+			 dev->intfw - fw->data, dev->extfw_size,
+			 dev->extfw - fw->data);
 		if (*id_str)
-			at76_dbg(DBG_DEVSTART, "firmware id %s",id_str);
+			at76_dbg(DBG_DEVSTART, "firmware id %s", id_str);
 
 		if (dev->board_type != board_type) {
-			err("inconsistent board types %u != %u",
-			    board_type, dev->board_type);
+			err("inconsistent board types %u != %u", board_type,
+			    dev->board_type);
 			at76_delete_device(dev);
 			goto error;
 		}
 
 		/* download internal firmware part */
 		at76_dbg(DBG_DEVSTART, "downloading internal firmware");
-		         dev->istate = INTFW_DOWNLOAD;
-		         schedule_work(&dev->work_internal_fw);
+		dev->istate = INTFW_DOWNLOAD;
+		schedule_work(&dev->work_internal_fw);
 
 	} else {
-		/* internal firmware already inside the device */
-		/* get firmware version to test if external firmware is loaded */
-		/* This works only for newer firmware, e.g. the Intersil 0.90.x
-		   says "control timeout on ep0in" and subsequent at76_get_op_mode() fail
-		   too :-( */
+		/* Internal firmware already inside the device.  Get firmware
+		 * version to test if external firmware is loaded.
+		 * This works only for newer firmware, e.g. the Intersil 0.90.x
+		 * says "control timeout on ep0in" and subsequent
+		 * at76_get_op_mode() fail too :-( */
 		int force_fw_dwl = 0;
 
-		/* disassem. the firmware */
-		if ((ret =
-		     at76_get_fw_info(fw_data, fw_size, &dev->board_type,
-					  &version, &id_str, &dev->intfw,
-					  &dev->intfw_size, &dev->extfw,
-					  &dev->extfw_size))) {
+		/* parse the firmware */
+		ret = at76_get_fw_info(fw->data, fw->size,
+				       &dev->board_type, &version, &id_str,
+				       &dev->intfw, &dev->intfw_size,
+				       &dev->extfw, &dev->extfw_size);
+		if (ret)
 			goto error;
-		}
 
-		/* if version >= 0.100.x.y or device with built-in flash we can query the device
-		 * for the fw version */
+		/* if version >= 0.100.x.y or device with built-in flash we can
+		 * query the device for the fw version */
 		if (version >= ((0 << 24) | (100 << 16))
 		    || (op_mode == OPMODE_NORMAL_NIC_WITH_FLASH)) {
-			ret =
-			    at76_get_mib(udev, MIB_FW_VERSION, &dev->fw_version,
-					 sizeof(dev->fw_version));
+			ret = at76_get_mib(udev, MIB_FW_VERSION,
+					   &dev->fw_version,
+					   sizeof(dev->fw_version));
 		} else {
 			/* force fw download only if the device has no flash inside */
 			force_fw_dwl = 1;
@@ -6191,19 +6204,22 @@ static int at76_do_probe(struct usb_device *udev, u8 *fw_data, int fw_size,
 			&& (dev->fw_version.patch == 0)
 			&& (dev->fw_version.build == 0))) {
 			if (force_fw_dwl)
-				at76_dbg(DBG_DEVSTART, "forced download of external firmware part");
+				at76_dbg(DBG_DEVSTART,
+					 "forced download of external firmware part");
 			else
-				at76_dbg(DBG_DEVSTART, "cannot get firmware (ret %d) or all zeros "
-				         "- download external firmware", ret);
+				at76_dbg(DBG_DEVSTART,
+					 "cannot get firmware (ret %d) or all zeros "
+					 "- download external firmware", ret);
 			at76_dbg(DBG_DEVSTART,
-			         "firmware board %u version %u.%u.%u#%u "
-			         "(int %x:%tx, ext %x:%tx)", dev->board_type,
-			         version >> 24, (version >> 16) & 0xff,
-			         (version >> 8) & 0xff, version & 0xff,
-			         dev->intfw_size, dev->intfw - fw_data,
-			         dev->extfw_size, dev->extfw - fw_data);
+				 "firmware board %u version %u.%u.%u#%u "
+				 "(int %x:%tx, ext %x:%tx)", dev->board_type,
+				 version >> 24, (version >> 16) & 0xff,
+				 (version >> 8) & 0xff, version & 0xff,
+				 dev->intfw_size, dev->intfw - fw->data,
+				 dev->extfw_size, dev->extfw - fw->data);
 			if (*id_str)
-				at76_dbg(DBG_DEVSTART, "firmware id %s",id_str);
+				at76_dbg(DBG_DEVSTART, "firmware id %s",
+					 id_str);
 
 			if (dev->board_type != board_type) {
 				err("inconsistent board types %u != %u",
@@ -6221,43 +6237,13 @@ static int at76_do_probe(struct usb_device *udev, u8 *fw_data, int fw_size,
 			}
 		}
 	}
-
 	return 0;
 
-error:
+      error:
 	usb_put_dev(udev);
 	return ret;
 }
 
-static int at76_probe(struct usb_interface *interface,
-		      const struct usb_device_id *id)
-{
-	int ret;
-
-	struct usb_device *udev;
-	int boardtype = (int)id->driver_info;
-	const char *const fw_name = firmwares[boardtype].fwname;
-	const struct firmware *fw = firmwares[boardtype].fw;
-	udev = interface_to_usbdev(interface);
-
-	if (fw == NULL) {
-		at76_dbg(DBG_FW, "downloading firmware %s", fw_name);
-		ret = request_firmware(&fw, fw_name, &udev->dev);
-		if (ret == 0) {
-			at76_dbg(DBG_FW, "got it.");
-		} else {
-			err("firmware %s not found.", fw_name);
-			err("You may need to download the firmware from "
-			    "https://developer.berlios.de/projects/at76c503a/");
-			return ret;
-		}
-	} else
-		at76_dbg(DBG_FW, "re-using previously loaded fw");
-
-	ret = at76_do_probe(udev, fw->data, fw->size, boardtype);
-	return ret;
-}
-
 static void at76_disconnect(struct usb_interface *interface)
 {
 	struct at76_priv *priv;




From proski at gnu.org  Wed May  2 02:00:57 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 01 May 2007 20:00:57 -0400
Subject: [at76c503a-develop] [PATCH 4/6] Never call net_device "dev",
	call it "netdev" for readability
In-Reply-To: <20070502000041.14011.47848.stgit@dv.roinet.com>
References: <20070502000041.14011.47848.stgit@dv.roinet.com>
Message-ID: <20070502000057.14011.47651.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   21 ++++++++++++---------
 1 files changed, 12 insertions(+), 9 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 45d52d8..4659060 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -462,37 +462,40 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 
 
 /* some abbrev. for wireless events */
-static inline void at76_iwevent_scan_complete(struct net_device *dev)
+static inline void at76_iwevent_scan_complete(struct net_device *netdev)
 {
 	union iwreq_data wrqu;
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
-	wireless_send_event(dev, SIOCGIWSCAN, &wrqu, NULL);
-	at76_dbg(DBG_WE_EVENTS, "%s: SIOCGIWSCAN sent", dev->name);
+	wireless_send_event(netdev, SIOCGIWSCAN, &wrqu, NULL);
+	at76_dbg(DBG_WE_EVENTS, "%s: SIOCGIWSCAN sent", netdev->name);
 }
 
 
-static inline void at76_iwevent_bss_connect(struct net_device *dev, u8 *bssid)
+static inline void at76_iwevent_bss_connect(struct net_device *netdev,
+					    u8 *bssid)
 {
 	union iwreq_data wrqu;
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
 	memcpy(wrqu.ap_addr.sa_data, bssid, ETH_ALEN);
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	wireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);
-	at76_dbg(DBG_WE_EVENTS, "%s: %s: SIOCGIWAP sent", dev->name, __FUNCTION__);
+	wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
+	at76_dbg(DBG_WE_EVENTS, "%s: %s: SIOCGIWAP sent", netdev->name,
+		 __FUNCTION__);
 }
 
 
-static inline void at76_iwevent_bss_disconnect(struct net_device *dev)
+static inline void at76_iwevent_bss_disconnect(struct net_device *netdev)
 {
 	union iwreq_data wrqu;
 	wrqu.data.length = 0;
 	wrqu.data.flags = 0;
 	memset(wrqu.ap_addr.sa_data, '\0', ETH_ALEN);
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	wireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);
-	at76_dbg(DBG_WE_EVENTS, "%s: %s: SIOCGIWAP sent", dev->name, __FUNCTION__);
+	wireless_send_event(netdev, SIOCGIWAP, &wrqu, NULL);
+	at76_dbg(DBG_WE_EVENTS, "%s: %s: SIOCGIWAP sent", netdev->name,
+		 __FUNCTION__);
 }
 
 




From proski at gnu.org  Wed May  2 02:00:52 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 01 May 2007 20:00:52 -0400
Subject: [at76c503a-develop] [PATCH 3/6] Reorder the functions to avoid most
	forward declarations
In-Reply-To: <20070502000041.14011.47848.stgit@dv.roinet.com>
References: <20070502000041.14011.47848.stgit@dv.roinet.com>
Message-ID: <20070502000051.14011.40262.stgit@dv.roinet.com>

Always use two newlines between functions.  Re-format some function
declatrations.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c | 5317 +++++++++++++++++++++++++++++++-----------------------------
 1 files changed, 2724 insertions(+), 2593 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 59d9129..45d52d8 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -186,25 +186,6 @@ static int default_iw_mode = IW_MODE_INFRA;
 static int monitor_scan_min_time = 50;
 static int monitor_scan_max_time = 600;
 
-/* Function prototypes */
-static void at76_iwspy_update(struct at76_priv *dev, struct at76_rx_buffer *buf);
-static void at76_read_bulk_callback(struct urb *urb);
-static void at76_write_bulk_callback(struct urb *urb);
-static struct bss_info *at76_match_bss(struct at76_priv *dev,
-				       struct bss_info *curr);
-static int at76_auth_req(struct at76_priv *dev, struct bss_info *bss, int seq_nr,
-		         struct ieee80211_info_element *challenge);
-static int at76_disassoc_req(struct at76_priv *dev, struct bss_info *bss);
-static int at76_assoc_req(struct at76_priv *dev, struct bss_info *bss);
-static int at76_reassoc_req(struct at76_priv *dev, struct bss_info *curr,
-		            struct bss_info *new);
-static void at76_dump_bss_table(struct at76_priv *dev);
-static int at76_submit_rx_urb(struct at76_priv *dev);
-static int at76_startup_device(struct at76_priv *dev);
-static int at76_set_iroaming(struct at76_priv *dev, int onoff);
-static void at76_set_monitor_mode(struct at76_priv *dev);
-static int at76_init_new_device(struct at76_priv *dev);
-
 /* the supported rates of this hardware, bit7 marks a basic rate */
 static const u8 hw_rates[] = { 0x82, 0x84, 0x0b, 0x16 };
 /* The frequency of each channel in MHz */
@@ -255,6 +236,7 @@ struct dfu_ctx {
 	void *buf;
 };
 
+
 static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
 				   int block)
 {
@@ -281,6 +263,7 @@ static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
 	return result;
 }
 
+
 static int at76_dfu_get_status(struct dfu_ctx *ctx, struct dfu_status *status)
 {
 	int result;
@@ -297,6 +280,7 @@ static int at76_dfu_get_status(struct dfu_ctx *ctx, struct dfu_status *status)
 	return result;
 }
 
+
 static u8 at76_dfu_get_state(struct usb_device *udev, u8 *state)
 {
 	int result;
@@ -312,6 +296,7 @@ static u8 at76_dfu_get_state(struct usb_device *udev, u8 *state)
 	return result;
 }
 
+
 static inline u32 at76_get_timeout(struct dfu_status *s)
 {
 	u32 ret = (s->poll_timeout[2] << 16) | (s->poll_timeout[1] << 8) |
@@ -320,6 +305,7 @@ static inline u32 at76_get_timeout(struct dfu_status *s)
 	return ret;
 }
 
+
 static struct dfu_ctx *at76_dfu_alloc_ctx(struct usb_device *udev)
 {
 	struct dfu_ctx *ctx;
@@ -332,6 +318,7 @@ static struct dfu_ctx *at76_dfu_alloc_ctx(struct usb_device *udev)
 	return ctx;
 }
 
+
 /* if manifest_sync_timeout > 0 use this timeout (in msec) instead of the
    one reported by the device in state MANIFEST_SYNC */
 static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
@@ -473,6 +460,7 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 		return 0;
 }
 
+
 /* some abbrev. for wireless events */
 static inline void at76_iwevent_scan_complete(struct net_device *dev)
 {
@@ -483,6 +471,7 @@ static inline void at76_iwevent_scan_complete(struct net_device *dev)
 	at76_dbg(DBG_WE_EVENTS, "%s: SIOCGIWSCAN sent", dev->name);
 }
 
+
 static inline void at76_iwevent_bss_connect(struct net_device *dev, u8 *bssid)
 {
 	union iwreq_data wrqu;
@@ -494,6 +483,7 @@ static inline void at76_iwevent_bss_connect(struct net_device *dev, u8 *bssid)
 	at76_dbg(DBG_WE_EVENTS, "%s: %s: SIOCGIWAP sent", dev->name, __FUNCTION__);
 }
 
+
 static inline void at76_iwevent_bss_disconnect(struct net_device *dev)
 {
 	union iwreq_data wrqu;
@@ -529,6 +519,7 @@ static char *hex2str(char *obuf, void *buf, int len, char delim)
 	return ret;
 }
 
+
 /* check if the given ssid is cloaked */
 static inline int at76_is_cloaked_ssid(u8 *ssid, int length)
 {
@@ -539,6 +530,7 @@ static inline int at76_is_cloaked_ssid(u8 *ssid, int length)
 	    (length > 0 && !memcmp(ssid, zeros, length));
 }
 
+
 static inline void at76_free_bss_list(struct at76_priv *dev)
 {
 	struct list_head *next, *ptr;
@@ -556,6 +548,7 @@ static inline void at76_free_bss_list(struct at76_priv *dev)
 	spin_unlock_irqrestore(&dev->bss_list_spinlock, flags);
 }
 
+
 static inline char *mac2str(u8 *mac)
 {
 	static char str[6 * 3];
@@ -565,22 +558,18 @@ static inline char *mac2str(u8 *mac)
 	return str;
 }
 
+
 /* led trigger */
+static int tx_activity;
 static void at76_ledtrig_tx_timerfunc(unsigned long data);
-DEFINE_LED_TRIGGER(ledtrig_tx);
 static DEFINE_TIMER(ledtrig_tx_timer, at76_ledtrig_tx_timerfunc, 0, 0);
-static int tx_activity;
-static int tx_lastactivity;
+DEFINE_LED_TRIGGER(ledtrig_tx);
 
-static void at76_ledtrig_tx_activity(void)
-{
-	tx_activity++;
-	if (!timer_pending(&ledtrig_tx_timer))
-		mod_timer(&ledtrig_tx_timer, jiffies + msecs_to_jiffies(250));
-}
 
 static void at76_ledtrig_tx_timerfunc(unsigned long data)
 {
+	static int tx_lastactivity;
+
 	if (tx_lastactivity != tx_activity) {
 		tx_lastactivity = tx_activity;
 		led_trigger_event(ledtrig_tx, LED_FULL);
@@ -591,6 +580,14 @@ static void at76_ledtrig_tx_timerfunc(unsigned long data)
 }
 
 
+static void at76_ledtrig_tx_activity(void)
+{
+	tx_activity++;
+	if (!timer_pending(&ledtrig_tx_timer))
+		mod_timer(&ledtrig_tx_timer, jiffies + msecs_to_jiffies(250));
+}
+
+
 static int at76_remap(struct usb_device *udev)
 {
 	int ret;
@@ -616,15 +613,17 @@ static int at76_get_op_mode(struct usb_device *udev)
 	return op_mode;
 }
 
+
 /* this loads a block of the second part of the firmware */
-static inline int at76_load_ext_fw_block(struct usb_device *udev,
-				         int i, void *buf, int bsize)
+static inline int at76_load_ext_fw_block(struct usb_device *udev, int i,
+					 void *buf, int bsize)
 {
 	return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			       0x0e, DEVICE_VENDOR_REQUEST_OUT,
 			       0x0802, i, buf, bsize, USB_CTRL_GET_TIMEOUT);
 }
 
+
 static inline int at76_get_hw_cfg_rfmd(struct usb_device *udev,
 				       union at76_hwcfg *buf, int buf_size)
 {
@@ -634,6 +633,7 @@ static inline int at76_get_hw_cfg_rfmd(struct usb_device *udev,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
 }
 
+
 /* Intersil boards use a different "value" for GetHWConfig requests */
 static inline int get_hw_cfg_intersil(struct usb_device *udev,
 				      union at76_hwcfg *buf, int buf_size)
@@ -644,6 +644,7 @@ static inline int get_hw_cfg_intersil(struct usb_device *udev,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
 }
 
+
 /* Get the hardware configuration for the adapter and place the appropriate
  * data in the appropriate fields of 'dev' (the GetHWConfig request and
  * interpretation of the result depends on the type of board we're dealing
@@ -700,6 +701,7 @@ static int at76_get_hw_config(struct at76_priv *dev)
 	return ret;
 }
 
+
 static struct reg_domain const *at76_get_reg_domain(u16 code)
 {
 	static struct reg_domain const fd_tab[] = {
@@ -726,6 +728,7 @@ static struct reg_domain const *at76_get_reg_domain(u16 code)
 	return (i >= tab_len) ? &unknown : &fd_tab[i];
 }
 
+
 static inline int at76_get_mib(struct usb_device *udev, u16 mib, void *buf,
 			       int buf_size)
 {
@@ -735,6 +738,7 @@ static inline int at76_get_mib(struct usb_device *udev, u16 mib, void *buf,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
 }
 
+
 /* Return positive number for status, negative for an error */
 static inline int at76_get_cmd_status(struct usb_device *udev, u8 cmd)
 {
@@ -750,6 +754,7 @@ static inline int at76_get_cmd_status(struct usb_device *udev, u8 cmd)
 	return stat_buf[5];
 }
 
+
 #define EXT_FW_BLOCK_SIZE 1024
 static int at76_download_external_fw(struct usb_device *udev, u8 *buf, int size)
 {
@@ -795,8 +800,9 @@ static int at76_download_external_fw(struct usb_device *udev, u8 *buf, int size)
 	return ret;
 }
 
-static int at76_set_card_command(struct usb_device *udev, int cmd,
-			         void *buf, int buf_size)
+
+static int at76_set_card_command(struct usb_device *udev, int cmd, void *buf,
+				 int buf_size)
 {
 	int ret;
 	struct at76_command *cmd_buf = kmalloc(sizeof(struct at76_command) +
@@ -821,8 +827,8 @@ static int at76_set_card_command(struct usb_device *udev, int cmd,
 	return -ENOMEM;
 }
 
-#define MAKE_CMD_STATUS_CASE(c)	case (c): return #c
 
+#define MAKE_CMD_STATUS_CASE(c)	case (c): return #c
 static const char *at76_get_cmd_status_string(u8 cmd_status)
 {
 	switch (cmd_status) {
@@ -840,6 +846,7 @@ static const char *at76_get_cmd_status_string(u8 cmd_status)
 	return "UNKNOWN";
 }
 
+
 /* TODO: should timeout */
 static int at76_wait_completion(struct at76_priv *dev, int cmd)
 {
@@ -869,6 +876,7 @@ static int at76_wait_completion(struct at76_priv *dev, int cmd)
 	return status;
 }
 
+
 static int at76_set_mib(struct at76_priv *dev, struct set_mib_buffer *buf)
 {
 	struct usb_device *udev = dev->udev;
@@ -901,6 +909,7 @@ static int at76_set_mib(struct at76_priv *dev, struct set_mib_buffer *buf)
 	return ret;
 }
 
+
 /* return < 0 on error, == 0 if no command sent, == 1 if cmd sent */
 static int at76_set_radio(struct at76_priv *dev, int on_off)
 {
@@ -918,6 +927,7 @@ static int at76_set_radio(struct at76_priv *dev, int on_off)
 	return ret;
 }
 
+
 /**
  * set_pm_mode - set current power save mode
  * (AT76_PM_OFF/AT76_PM_ON/AT76_PM_SMART)
@@ -940,6 +950,7 @@ static int at76_set_pm_mode(struct at76_priv *dev)
 	return ret;
 }
 
+
 /* sets the assoc id for power save mode */
 static int at76_set_associd(struct at76_priv *dev, u16 id)
 {
@@ -960,6 +971,7 @@ static int at76_set_associd(struct at76_priv *dev, u16 id)
 	return ret;
 }
 
+
 /* sets the listen interval for power save mode.
    really needed, as we have a similar parameter in the assocreq ??? */
 static int at76_set_listen_interval(struct at76_priv *dev, u16 interval)
@@ -982,6 +994,7 @@ static int at76_set_listen_interval(struct at76_priv *dev, u16 interval)
 	return ret;
 }
 
+
 static int at76_set_preamble(struct at76_priv *dev, u8 type)
 {
 	int ret = 0;
@@ -998,6 +1011,7 @@ static int at76_set_preamble(struct at76_priv *dev, u8 type)
 	return ret;
 }
 
+
 static int at76_set_frag(struct at76_priv *dev, u16 size)
 {
 	int ret = 0;
@@ -1014,6 +1028,7 @@ static int at76_set_frag(struct at76_priv *dev, u16 size)
 	return ret;
 }
 
+
 static int at76_set_rts(struct at76_priv *dev, u16 size)
 {
 	int ret = 0;
@@ -1030,6 +1045,7 @@ static int at76_set_rts(struct at76_priv *dev, u16 size)
 	return ret;
 }
 
+
 static int at76_set_autorate_fallback(struct at76_priv *dev, int onoff)
 {
 	int ret = 0;
@@ -1046,6 +1062,7 @@ static int at76_set_autorate_fallback(struct at76_priv *dev, int onoff)
 	return ret;
 }
 
+
 static int at76_add_mac_address(struct at76_priv *dev, void *addr)
 {
 	int ret = 0;
@@ -1063,6 +1080,7 @@ static int at76_add_mac_address(struct at76_priv *dev, void *addr)
 	return ret;
 }
 
+
 #if 0
 /* implemented to get promisc. mode working, but does not help.
    May still be useful for multicast eventually. */
@@ -1099,6 +1117,7 @@ static int set_group_address(struct at76_priv *dev, u8 *addr, int n)
 }
 #endif
 
+
 static int at76_dump_mib_mac_addr(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1132,6 +1151,7 @@ static int at76_dump_mib_mac_addr(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_dump_mib_mac_wep(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1177,6 +1197,7 @@ static int at76_dump_mib_mac_wep(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_dump_mib_mac_mgmt(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1232,6 +1253,7 @@ static int at76_dump_mib_mac_mgmt(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_dump_mib_mac(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1279,6 +1301,7 @@ static int at76_dump_mib_mac(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_dump_mib_phy(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1318,6 +1341,7 @@ static int at76_dump_mib_phy(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_dump_mib_local(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1347,6 +1371,7 @@ static int at76_dump_mib_local(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_get_mib_mdomain(struct at76_priv *dev, struct mib_mdomain *val)
 {
 	int ret = 0;
@@ -1373,6 +1398,7 @@ static int at76_get_mib_mdomain(struct at76_priv *dev, struct mib_mdomain *val)
 	return ret;
 }
 
+
 static void at76_dump_mib_mdomain(struct at76_priv *dev)
 {
 	char obuf1[2*14+1], obuf2[2*14+1]; /* to hexdump tx_powerlevel,
@@ -1393,8 +1419,8 @@ static void at76_dump_mib_mdomain(struct at76_priv *dev)
 		         (sizeof(obuf2) - 1) / 2, '\0'));
 }
 
-static
-int at76_get_current_bssid(struct at76_priv *dev)
+
+static int at76_get_current_bssid(struct at76_priv *dev)
 {
 	int ret = 0;
 	struct mib_mac_mgmt *mac_mgmt =
@@ -1419,6 +1445,7 @@ int at76_get_current_bssid(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_get_current_channel(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1440,6 +1467,7 @@ static int at76_get_current_channel(struct at76_priv *dev)
 	return ret;
 }
 
+
 /**
  * start_scan - start a scan
  *
@@ -1502,6 +1530,7 @@ static int at76_start_scan(struct at76_priv *dev, int use_essid, int ir_step)
 	return at76_set_card_command(dev->udev, CMD_SCAN, &scan, sizeof(scan));
 }
 
+
 static int at76_start_ibss(struct at76_priv *dev)
 {
 	struct at76_start_bss bss;
@@ -1517,6 +1546,7 @@ static int at76_start_ibss(struct at76_priv *dev)
 				     sizeof(struct at76_start_bss));
 }
 
+
 /* idx points into dev->bss */
 static int at76_join_bss(struct at76_priv *dev, struct bss_info *ptr)
 {
@@ -1539,6 +1569,428 @@ static int at76_join_bss(struct at76_priv *dev, struct bss_info *ptr)
 				     sizeof(struct at76_join));
 }
 
+
+/* calc. the padding from txbuf->wlength (which excludes the USB TX header)
+   guess this is needed to compensate a flaw in the AT76C503A USB part ... */
+static inline int at76_calc_padding(int wlen)
+{
+	/* add the USB TX header */
+	wlen += AT76_TX_HDRLEN;
+
+	wlen = wlen % 64;
+
+	if (wlen < 50)
+		return 50 - wlen;
+
+	if (wlen >= 61)
+		return 64 + 50 - wlen;
+
+	return 0;
+}
+
+
+/* we are doing a lot of things here in an interrupt. Need
+   a bh handler (Watching TV with a TV card is probably
+   a good test: if you see flickers, we are doing too much.
+   Currently I do see flickers... even with our tasklet :-( )
+   Maybe because the bttv driver and usb-uhci use the same interrupt
+*/
+/* Or maybe because our BH handler is preempting bttv's BH handler.. BHs don't
+ * solve everything.. (alex) */
+static void at76_read_bulk_callback(struct urb *urb)
+{
+	struct at76_priv *priv = urb->context;
+
+	priv->rx_urb = urb;
+	tasklet_schedule(&priv->tasklet);
+	return;
+}
+
+
+static void at76_write_bulk_callback(struct urb *urb)
+{
+	struct at76_priv *dev = urb->context;
+	struct net_device_stats *stats = &dev->stats;
+	unsigned long flags;
+	struct at76_tx_buffer *mgmt_buf;
+	int ret;
+
+	if (urb->status != 0) {
+		if ((urb->status != -ENOENT) && (urb->status != -ECONNRESET)) {
+			at76_dbg(DBG_URB,
+			         "%s - nonzero write bulk status received: %d",
+			         __FUNCTION__, urb->status);
+		} else
+			return; /* urb has been unlinked */
+		stats->tx_errors++;
+	} else
+		stats->tx_packets++;
+
+	spin_lock_irqsave(&dev->mgmt_spinlock, flags);
+	mgmt_buf = dev->next_mgmt_bulk;
+	dev->next_mgmt_bulk = NULL;
+	spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
+
+	if (mgmt_buf) {
+		/* we don't copy the padding bytes, but add them
+		   to the length */
+		memcpy(dev->bulk_out_buffer, mgmt_buf,
+		       le16_to_cpu(mgmt_buf->wlength) +
+		       offsetof(struct at76_tx_buffer, packet));
+		usb_fill_bulk_urb(dev->write_urb, dev->udev,
+				  usb_sndbulkpipe(dev->udev,
+						  dev->bulk_out_endpointAddr),
+				  dev->bulk_out_buffer,
+				  le16_to_cpu(mgmt_buf->wlength) +
+				  mgmt_buf->padding + AT76_TX_HDRLEN,
+				  at76_write_bulk_callback,
+				  dev);
+		ret = usb_submit_urb(dev->write_urb, GFP_ATOMIC);
+		if (ret) {
+			err("%s: %s error in tx submit urb: %d",
+			    dev->netdev->name, __FUNCTION__, ret);
+		}
+		kfree(mgmt_buf);
+	} else
+		netif_wake_queue(dev->netdev);
+}
+
+
+/* send a management frame on bulk-out.
+   txbuf->wlength must be set (in LE format !) */
+static int at76_send_mgmt_bulk(struct at76_priv *dev,
+			       struct at76_tx_buffer *txbuf)
+{
+	unsigned long flags;
+	int ret = 0;
+	int urb_status;
+	void *oldbuf = NULL;
+
+	netif_carrier_off(dev->netdev);	/* disable running netdev watchdog */
+	netif_stop_queue(dev->netdev);	/* stop tx data packets */
+
+	spin_lock_irqsave(&dev->mgmt_spinlock, flags);
+
+	if ((urb_status = dev->write_urb->status) == -EINPROGRESS) {
+		oldbuf = dev->next_mgmt_bulk;	/* to kfree below */
+		dev->next_mgmt_bulk = txbuf;
+		txbuf = NULL;
+	}
+	spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
+
+	if (oldbuf) {
+		/* a data/mgmt tx is already pending in the URB -
+		   if this is no error in some situations we must
+		   implement a queue or silently modify the old msg */
+		err("%s: %s removed pending mgmt buffer %s",
+		    dev->netdev->name, __FUNCTION__,
+		    hex2str(dev->obuf, dev->next_mgmt_bulk,
+			    min((int)(sizeof(dev->obuf)) / 3, 64), ' '));
+		kfree(dev->next_mgmt_bulk);
+	}
+
+	if (txbuf) {
+
+		txbuf->tx_rate = 0;
+		txbuf->padding = at76_calc_padding(le16_to_cpu(txbuf->wlength));
+
+		if (dev->next_mgmt_bulk) {
+			err("%s: %s URB status %d, but mgmt is pending",
+			    dev->netdev->name, __FUNCTION__, urb_status);
+		}
+
+		at76_dbg(DBG_TX_MGMT, "%s: tx mgmt: wlen %d tx_rate %d pad %d %s",
+		         dev->netdev->name, le16_to_cpu(txbuf->wlength),
+		         txbuf->tx_rate, txbuf->padding,
+		         hex2str(dev->obuf, txbuf->packet,
+			    min((sizeof(dev->obuf) - 1) / 2,
+				(size_t) le16_to_cpu(txbuf->wlength)), '\0'));
+
+		/* txbuf was not consumed above -> send mgmt msg immediately */
+		memcpy(dev->bulk_out_buffer, txbuf,
+		       le16_to_cpu(txbuf->wlength) + AT76_TX_HDRLEN);
+		usb_fill_bulk_urb(dev->write_urb, dev->udev,
+				  usb_sndbulkpipe(dev->udev,
+						  dev->bulk_out_endpointAddr),
+				  dev->bulk_out_buffer,
+				  le16_to_cpu(txbuf->wlength) +
+				  txbuf->padding +
+				  AT76_TX_HDRLEN,
+				  at76_write_bulk_callback,
+				  dev);
+		ret = usb_submit_urb(dev->write_urb, GFP_ATOMIC);
+		if (ret) {
+			err("%s: %s error in tx submit urb: %d",
+			    dev->netdev->name, __FUNCTION__, ret);
+		}
+		kfree(txbuf);
+	}
+	/* if (txbuf) */
+	return ret;
+}
+
+
+/* Go to the next information element */
+static inline void next_ie(struct ieee80211_info_element **ie)
+{
+	*ie = (struct ieee80211_info_element *)(&(*ie)->data[(*ie)->len]);
+}
+
+
+/* challenge is the challenge string (in TLV format)
+   we got with seq_nr 2 for shared secret authentication only and
+   send in seq_nr 3 WEP encrypted to prove we have the correct WEP key;
+   otherwise it is NULL */
+static int at76_auth_req(struct at76_priv *dev, struct bss_info *bss,
+			 int seq_nr, struct ieee80211_info_element *challenge)
+{
+	struct at76_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee80211_auth *req;
+	int buf_len = (seq_nr != 3 ? AUTH_FRAME_SIZE :
+		       AUTH_FRAME_SIZE + 1 + 1 + challenge->len);
+
+	at76_assert(bss != NULL);
+	at76_assert(seq_nr != 3 || challenge != NULL);
+	tx_buffer = kmalloc(buf_len + MAX_PADDING_SIZE, GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	req = (struct ieee80211_auth *)(&tx_buffer->packet);
+	mgmt = &req->header;
+
+	/* make wireless header */
+	/* first auth msg is not encrypted, only the second (seq_nr == 3) */
+	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH |
+		(seq_nr == 3 ? IEEE80211_FCTL_PROTECTED : 0));
+
+	mgmt->duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
+	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
+	memcpy(mgmt->addr3, bss->bssid, ETH_ALEN);
+	mgmt->seq_ctl = cpu_to_le16(0);
+
+	req->algorithm = cpu_to_le16(dev->auth_mode);
+	req->transaction = cpu_to_le16(seq_nr);
+	req->status = cpu_to_le16(0);
+
+	if (seq_nr == 3)
+		memcpy(req->info_element, challenge, 1 + 1 + challenge->len);
+
+	/* init. at76_priv tx header */
+	tx_buffer->wlength = cpu_to_le16(buf_len - AT76_TX_HDRLEN);
+	at76_dbg(DBG_TX_MGMT, "%s: AuthReq bssid %s alg %d seq_nr %d",
+	         dev->netdev->name, mac2str(mgmt->addr3),
+	         le16_to_cpu(req->algorithm), le16_to_cpu(req->transaction));
+	if (seq_nr == 3) {
+		at76_dbg(DBG_TX_MGMT, "%s: AuthReq challenge: %s ...",
+		         dev->netdev->name,
+		         hex2str(dev->obuf, req->info_element,
+		             min((int)sizeof(dev->obuf) / 3, 18), ' '));
+	}
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return at76_send_mgmt_bulk(dev, tx_buffer);
+}
+
+
+static int at76_assoc_req(struct at76_priv *dev, struct bss_info *bss)
+{
+	struct at76_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee80211_assoc_request *req;
+	struct ieee80211_info_element *tlv;
+
+	at76_assert(bss != NULL);
+
+	tx_buffer = kmalloc(ASSOCREQ_MAX_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	req = (struct ieee80211_assoc_request *)(&tx_buffer->packet);
+	mgmt = &req->header;
+	tlv = req->info_element;
+
+	/* make wireless header */
+	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_ASSOC_REQ);
+
+	mgmt->duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
+	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
+	memcpy(mgmt->addr3, bss->bssid, ETH_ALEN);
+	mgmt->seq_ctl = cpu_to_le16(0);
+
+	/* we must set the Privacy bit in the capabilities to assure an
+	   Agere-based AP with optional WEP transmits encrypted frames
+	   to us.  AP only set the Privacy bit in their capabilities
+	   if WEP is mandatory in the BSS! */
+	req->capability = cpu_to_le16(bss->capa |
+				      (dev->wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
+				      (dev->preamble_type == PREAMBLE_TYPE_SHORT ?
+				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+
+	req->listen_interval = cpu_to_le16(2 * bss->beacon_interval);
+
+	/* write TLV data elements */
+
+	tlv->id = MFIE_TYPE_SSID;
+	tlv->len = bss->ssid_len;
+	memcpy(tlv->data, bss->ssid, bss->ssid_len);
+	next_ie(&tlv);
+
+	tlv->id = MFIE_TYPE_RATES;
+	tlv->len = sizeof(hw_rates);
+	memcpy(tlv->data, hw_rates, sizeof(hw_rates));
+	next_ie(&tlv);		/* tlv points behind the supp_rates field */
+
+	/* init. at76_priv tx header */
+	tx_buffer->wlength = cpu_to_le16((u8 *) tlv - (u8 *) mgmt);
+
+	{
+		/* output buffer for ssid and rates */
+		char orates[4 * 2 + 1];
+		int len;
+
+		tlv = req->info_element;
+		len = min_t(int, IW_ESSID_MAX_SIZE, tlv->len);
+		memcpy(dev->obuf, tlv->data, len);
+		dev->obuf[len] = '\0';
+		next_ie(&tlv); /* points to IE of rates now */
+		at76_dbg(DBG_TX_MGMT, "%s: AssocReq bssid %s capa x%04x ssid %s rates %s",
+		         dev->netdev->name, mac2str(mgmt->addr3),
+		         le16_to_cpu(req->capability), dev->obuf,
+		         hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
+			    '\0'));
+	}
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return at76_send_mgmt_bulk(dev, tx_buffer);
+}
+
+
+/* we are currently associated to curr_bss and
+   want to reassoc to new_bss */
+static int at76_reassoc_req(struct at76_priv *dev, struct bss_info *curr_bss,
+		            struct bss_info *new_bss)
+{
+	struct at76_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee80211_reassoc_request *req;
+	struct ieee80211_info_element *tlv;
+
+	at76_assert(curr_bss != NULL);
+	at76_assert(new_bss != NULL);
+	if (curr_bss == NULL || new_bss == NULL)
+		return -EFAULT;
+
+	tx_buffer = kmalloc(REASSOCREQ_MAX_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	req = (struct ieee80211_reassoc_request *)(&tx_buffer->packet);
+	mgmt = &req->header;
+	tlv = req->info_element;
+
+	/* make wireless header */
+	/* jal: encrypt this packet if wep_enabled is TRUE ??? */
+	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_REASSOC_REQ);
+	mgmt->duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt->addr1, new_bss->bssid, ETH_ALEN);
+	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
+	memcpy(mgmt->addr3, new_bss->bssid, ETH_ALEN);
+	mgmt->seq_ctl = cpu_to_le16(0);
+
+	/* we must set the Privacy bit in the capabilities to assure an
+	   Agere-based AP with optional WEP transmits encrypted frames
+	   to us.  AP only set the Privacy bit in their capabilities
+	   if WEP is mandatory in the BSS! */
+	req->capability = cpu_to_le16(new_bss->capa |
+				      (dev->wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
+				      (dev->preamble_type == PREAMBLE_TYPE_SHORT ?
+				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+
+	req->listen_interval = cpu_to_le16(2 * new_bss->beacon_interval);
+
+	memcpy(req->current_ap, curr_bss->bssid, ETH_ALEN);
+
+	/* write TLV data elements */
+	tlv->id = MFIE_TYPE_SSID;
+	tlv->len = new_bss->ssid_len;
+	memcpy(tlv->data, new_bss->ssid, new_bss->ssid_len);
+	next_ie(&tlv);
+
+	tlv->id = MFIE_TYPE_RATES;
+	tlv->len = sizeof(hw_rates);
+	memcpy(tlv->data, hw_rates, sizeof(hw_rates));
+	/* tlv points behind the supp_rates field */
+	next_ie(&tlv);
+
+	/* init. at76_priv tx header */
+	tx_buffer->wlength = cpu_to_le16((u8 *)tlv-(u8 *)mgmt);
+
+	{
+		/* output buffer for rates and bssid */
+		char orates[4*2+1];
+		char ocurr[6*3+1];
+		tlv = req->info_element;
+		memcpy(dev->obuf, tlv->data, min(sizeof(dev->obuf),(size_t)tlv->len));
+		dev->obuf[IW_ESSID_MAX_SIZE] = '\0';
+		next_ie(&tlv); /* points to IE of rates now */
+		at76_dbg(DBG_TX_MGMT, "%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s",
+		         dev->netdev->name,
+		         hex2str(ocurr, req->current_ap, ETH_ALEN, ':'),
+		         mac2str(mgmt->addr3), le16_to_cpu(req->capability), dev->obuf,
+		         hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
+			    '\0'));
+	}
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return at76_send_mgmt_bulk(dev, tx_buffer);
+}
+
+
+static int at76_disassoc_req(struct at76_priv *dev, struct bss_info *bss)
+{
+	struct at76_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee80211_disassoc *req;
+
+	at76_assert(bss != NULL);
+	if (bss == NULL)
+		return -EFAULT;
+
+	tx_buffer = kmalloc(DISASSOC_FRAME_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	req = (struct ieee80211_disassoc *)(&tx_buffer->packet);
+	mgmt = &req->header;
+
+	/* make wireless header */
+	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_AUTH);
+	mgmt->duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
+	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
+	memcpy(mgmt->addr3, bss->bssid, ETH_ALEN);
+	mgmt->seq_ctl = cpu_to_le16(0);
+
+	req->reason = 0;
+
+	/* init. at76_priv tx header */
+	tx_buffer->wlength = cpu_to_le16(DISASSOC_FRAME_SIZE - AT76_TX_HDRLEN);
+
+	at76_dbg(DBG_TX_MGMT, "%s: DisAssocReq bssid %s",
+	         dev->netdev->name, mac2str(mgmt->addr3));
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return at76_send_mgmt_bulk(dev, tx_buffer);
+}
+
+
 /* the firmware download timeout (after remap) */
 static void at76_fw_dl_timeout(unsigned long par)
 {
@@ -1546,6 +1998,7 @@ static void at76_fw_dl_timeout(unsigned long par)
 	schedule_work(&dev->work_reset_device);
 }
 
+
 /* the restart timer timed out */
 static void at76_restart_timeout(unsigned long par)
 {
@@ -1553,6 +2006,7 @@ static void at76_restart_timeout(unsigned long par)
 	schedule_work(&dev->work_restart);
 }
 
+
 /* we got to check the bss_list for old entries */
 static void at76_bss_list_timeout(unsigned long par)
 {
@@ -1580,9 +2034,41 @@ static void at76_bss_list_timeout(unsigned long par)
 	spin_unlock_irqrestore(&dev->bss_list_spinlock, flags);
 	/* restart the timer */
 	mod_timer(&dev->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
+}
+
+
+static void at76_dump_bss_table(struct at76_priv *dev)
+{
+	struct bss_info *ptr;
+	unsigned long flags;
+	struct list_head *lptr;
+	char obuf_s[3*32];
+
+	spin_lock_irqsave(&dev->bss_list_spinlock, flags);
 
+	pr_debug("%s BSS table (curr=%p, new=%p):", dev->netdev->name,
+	         dev->curr_bss, dev->new_bss);
+
+	list_for_each(lptr, &dev->bss_list) {
+		ptr = list_entry(lptr, struct bss_info, list);
+		pr_debug("0x%p: bssid %s channel %d ssid %s (%s)"
+		         " capa x%04x rates %s rssi %d link %d noise %d",
+		         ptr, mac2str(ptr->bssid),
+		         ptr->channel,
+		         ptr->ssid,
+		         hex2str(dev->obuf, ptr->ssid,
+			       min((sizeof(dev->obuf) - 1) / 2,
+				   (size_t) ptr->ssid_len), '\0'),
+		         ptr->capa,
+		         hex2str(obuf_s, ptr->rates,
+			       min(sizeof(obuf_s) / 3,
+				   (size_t) ptr->rates_len), ' '),
+		         ptr->rssi, ptr->link_qual, ptr->noise_level);
+	}
+	spin_unlock_irqrestore(&dev->bss_list_spinlock, flags);
 }
 
+
 /* we got a timeout for a infrastructure mgmt packet */
 static void at76_mgmt_timeout(unsigned long par)
 {
@@ -1590,6 +2076,7 @@ static void at76_mgmt_timeout(unsigned long par)
 	schedule_work(&dev->work_mgmt_timeout);
 }
 
+
 /*
  * at76_work_mgmt_timeout_scan - expiry of management timer in istate SCANNING
  */
@@ -1689,6 +2176,7 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *dev)
 	}
 }
 
+
 /* the deferred procedure called from at76_devent() */
 static void at76_handle_mgmt_timeout(struct at76_priv *dev)
 {
@@ -1790,402 +2278,1988 @@ static void at76_handle_mgmt_timeout(struct at76_priv *dev)
 	}
 }
 
-/* calc. the padding from txbuf->wlength (which excludes the USB TX header)
-   guess this is needed to compensate a flaw in the AT76C503A USB part ... */
-static inline int at76_calc_padding(int wlen)
+
+/* Called after successful association */
+static void at76_work_assoc_done(struct work_struct *work)
 {
-	/* add the USB TX header */
-	wlen += AT76_TX_HDRLEN;
+	struct at76_priv *dev = container_of(work, struct at76_priv,
+					     work_assoc_done);
 
-	wlen = wlen % 64;
+	down(&dev->sem);
 
-	if (wlen < 50)
-		return 50 - wlen;
+	at76_assert(dev->istate == ASSOCIATING || dev->istate == REASSOCIATING);
+	if (dev->iw_mode == IW_MODE_INFRA) {
+		at76_assert(dev->curr_bss != NULL);
+		if (dev->curr_bss != NULL && dev->pm_mode != AT76_PM_OFF) {
+			/* calculate the listen interval in units of
+			   beacon intervals of the curr_bss */
+			u32 pm_period_beacon = (dev->pm_period >> 10) /
+						dev->curr_bss->beacon_interval;
 
-	if (wlen >= 61)
-		return 64 + 50 - wlen;
+			pm_period_beacon = max(pm_period_beacon, 2u);
+			pm_period_beacon = min(pm_period_beacon, 0xffffu);
+
+			at76_dbg(DBG_PM, "%s: pm_mode %d assoc id x%x listen int %d",
+			         dev->netdev->name, dev->pm_mode,
+			         dev->curr_bss->assoc_id, pm_period_beacon);
+
+			at76_set_associd(dev, dev->curr_bss->assoc_id);
+			at76_set_listen_interval(dev, (u16)pm_period_beacon);
+#ifdef DEBUG
+			at76_dump_mib_mac(dev);
+			at76_dump_mib_mac_mgmt(dev);
+#endif
+		}
+	}
+	at76_set_pm_mode(dev);
+
+	netif_carrier_on(dev->netdev);
+	netif_wake_queue(dev->netdev);
+	dev->istate = CONNECTED;
+	at76_iwevent_bss_connect(dev->netdev, dev->curr_bss->bssid);
+	at76_dbg(DBG_PROGRESS, "%s: connected to BSSID %s",
+	         dev->netdev->name, mac2str(dev->curr_bss->bssid));
+
+	up(&dev->sem);
+}
+
+
+static void at76_delete_device(struct at76_priv *dev)
+{
+	int i;
+
+	if (!dev)
+		return;
+
+	/* signal to _stop() that the device is gone */
+	dev->device_unplugged = 1;
+
+	at76_dbg(DBG_PROC_ENTRY, "%s: ENTER",__FUNCTION__);
+
+	if (dev->netdev_registered) {
+		unregister_netdev(dev->netdev);
+	}
+
+	usb_put_dev(dev->udev);
+
+	/* assuming we used keventd, it must quiesce too */
+	flush_scheduled_work();
+
+	if (dev->bulk_out_buffer != NULL)
+		kfree(dev->bulk_out_buffer);
+
+	kfree(dev->ctrl_buffer);
+
+	if (dev->write_urb != NULL) {
+		usb_kill_urb(dev->write_urb);
+		usb_free_urb(dev->write_urb);
+	}
+	if (dev->read_urb != NULL) {
+		usb_kill_urb(dev->read_urb);
+		usb_free_urb(dev->read_urb);
+	}
+	if (dev->ctrl_buffer != NULL) {
+		usb_kill_urb(dev->ctrl_urb);
+		usb_free_urb(dev->ctrl_urb);
+	}
+
+	at76_dbg(DBG_PROC_ENTRY, "%s: unlinked urbs", __FUNCTION__);
+
+	if (dev->rx_skb != NULL)
+		kfree_skb(dev->rx_skb);
+
+	at76_free_bss_list(dev);
+	del_timer_sync(&dev->bss_list_timer);
+
+	if (dev->istate == CONNECTED) {
+		at76_iwevent_bss_disconnect(dev->netdev);
+	}
+
+	for (i = 0; i < NR_RX_DATA_BUF; i++)
+		if (dev->rx_data[i].skb != NULL) {
+			dev_kfree_skb(dev->rx_data[i].skb);
+			dev->rx_data[i].skb = NULL;
+		}
+	at76_dbg(DBG_PROC_ENTRY, "%s: before freeing dev/netdev", __FUNCTION__);
+	free_netdev(dev->netdev); /* dev is in netdev */
+
+	at76_dbg(DBG_PROC_ENTRY, "%s: EXIT", __FUNCTION__);
+}
+
+
+static int at76_alloc_urbs(struct at76_priv *dev)
+{
+	struct usb_interface *interface = dev->interface;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_device *udev = dev->udev;
+	int i, buffer_size;
+	struct usb_host_interface *iface_desc;
+
+	at76_dbg(DBG_PROC_ENTRY, "%s: ENTER", __FUNCTION__);
+
+	at76_dbg(DBG_URB, "%s: NumEndpoints %d ", __FUNCTION__,
+	    interface->altsetting[0].desc.bNumEndpoints);
+
+	iface_desc = interface->cur_altsetting;
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
+		endpoint = &iface_desc->endpoint[i].desc;
+
+		at76_dbg(DBG_URB, "%s: %d. endpoint: addr x%x attr x%x",
+		    __FUNCTION__,
+		    i, endpoint->bEndpointAddress, endpoint->bmAttributes);
+
+		if ((endpoint->bEndpointAddress & 0x80) &&
+		    ((endpoint->bmAttributes & 3) == 0x02)) {
+			/* we found a bulk in endpoint */
+
+			dev->read_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!dev->read_urb) {
+				err("No free urbs available");
+				return -ENOMEM;
+			}
+			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
+		}
+
+		if (((endpoint->bEndpointAddress & 0x80) == 0x00) &&
+		    ((endpoint->bmAttributes & 3) == 0x02)) {
+			/* we found a bulk out endpoint */
+			dev->write_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!dev->write_urb) {
+				err("no free urbs available");
+				return -ENOMEM;
+			}
+			buffer_size = sizeof(struct at76_tx_buffer) +
+			    MAX_PADDING_SIZE;
+			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
+			dev->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);
+			if (!dev->bulk_out_buffer) {
+				err("couldn't allocate bulk_out_buffer");
+				return -ENOMEM;
+			}
+			usb_fill_bulk_urb(dev->write_urb, udev,
+				          usb_sndbulkpipe(udev,
+						      endpoint->bEndpointAddress),
+				          dev->bulk_out_buffer, buffer_size,
+				          at76_write_bulk_callback, dev);
+		}
+	}
+
+	dev->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dev->ctrl_urb) {
+		err("no free urbs available");
+		return -ENOMEM;
+	}
+	dev->ctrl_buffer = kmalloc(1024, GFP_KERNEL);
+	if (!dev->ctrl_buffer) {
+		err("couldn't allocate ctrl_buffer");
+		return -ENOMEM;
+	}
+
+	at76_dbg(DBG_PROC_ENTRY, "%s: EXIT", __FUNCTION__);
 
 	return 0;
 }
 
-/* send a management frame on bulk-out.
-   txbuf->wlength must be set (in LE format !) */
-static int at76_send_mgmt_bulk(struct at76_priv *dev,
-			  struct at76_tx_buffer *txbuf)
+
+/* we only store the new mac address in netdev struct,
+   it gets set when the netdev is opened. */
+static int at76_set_mac_address(struct net_device *netdev, void *addr)
 {
+	struct sockaddr *mac = addr;
+	memcpy(netdev->dev_addr, mac->sa_data, ETH_ALEN);
+	return 1;
+}
+
+
+static struct net_device_stats *at76_get_stats(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	return &dev->stats;
+}
+
+
+static struct iw_statistics *at76_get_wireless_stats(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	at76_dbg(DBG_IOCTL, "RETURN qual %d level %d noise %d updated %d",
+	         dev->wstats.qual.qual, dev->wstats.qual.level,
+	         dev->wstats.qual.noise, dev->wstats.qual.updated);
+
+	return &dev->wstats;
+}
+
+
+static void at76_set_multicast(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int promisc;
+
+	promisc = ((netdev->flags & IFF_PROMISC) != 0);
+	if (promisc != dev->promisc) {
+		/* grmbl. This gets called in interrupt. */
+		dev->promisc = promisc;
+		schedule_work(&dev->work_set_promisc);
+	}
+}
+
+
+/*******************************************************************************
+ * at76_priv implementations of iw_handler functions:
+ */
+static int at76_iw_handler_commit(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  void *null, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
 	unsigned long flags;
+	at76_dbg(DBG_IOCTL, "%s %s: restarting the device", netdev->name,
+	         __FUNCTION__);
+
+	/* TODO: stop any pending tx bulk urb */
+	if (dev->istate != INIT) {
+		dev->istate = INIT;
+		/* stop pending management stuff */
+		del_timer_sync(&dev->mgmt_timer);
+
+		spin_lock_irqsave(&dev->mgmt_spinlock, flags);
+		if (dev->next_mgmt_bulk) {
+			kfree(dev->next_mgmt_bulk);
+			dev->next_mgmt_bulk = NULL;
+		}
+		spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
+
+		netif_carrier_off(dev->netdev);
+		netif_stop_queue(dev->netdev);
+	}
+
+	/* do the restart after two seconds to catch
+	 * following ioctl's (from more params of iwconfig)
+	 * in _one_ restart */
+	mod_timer(&dev->restart_timer, jiffies + 2 * HZ);
+
+	return 0;
+}
+
+
+static int at76_iw_handler_get_name(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    char *name, char *extra)
+{
+	strcpy(name, "IEEE 802.11b");
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWNAME - name %s", netdev->name, name);
+	return 0;
+}
+
+
+static int at76_iw_handler_set_freq(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_freq *freq, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int chan = -1;
+	int ret = -EIWCOMMIT;
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - freq.m %d freq.e %d", netdev->name,
+	    freq->m, freq->e);
+
+	if ((freq->e == 0) && (freq->m <= 1000)) {
+		/* Setting by channel number */
+		chan = freq->m;
+	} else {
+		/* Setting by frequency - search the table */
+		int mult = 1;
+		int i;
+
+		for (i = 0; i < (6 - freq->e); i++) {
+			mult *= 10;
+		}
+
+		for (i = 0; i < NUM_CHANNELS; i++) {
+			if (freq->m == (channel_frequency[i] * mult))
+				chan = i + 1;
+		}
+	}
+
+	if (chan < 1 || !dev->domain) {
+		/* non-positive channels are invalid
+		 * we need a domain info to set the channel
+		 * either that or an invalid frequency was
+		 * provided by the user */
+		ret = -EINVAL;
+	} else if (!dev->international_roaming) {
+		if (!(dev->domain->channel_map & (1 << (chan - 1)))) {
+			info("%s: channel %d not allowed for domain %s "
+			     "(and international_roaming is OFF)",
+			     dev->netdev->name, chan, dev->domain->name);
+			ret = -EINVAL;
+		}
+	}
+
+	if (ret == -EIWCOMMIT) {
+		dev->channel = chan;
+		at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - ch %d", netdev->name, chan);
+	}
+
+	return ret;
+}
+
+
+static int at76_iw_handler_get_freq(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_freq *freq, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	freq->m = dev->channel;
+	freq->e = 0;
+
+	if (dev->channel) {
+		at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - freq %ld x 10e%d",
+		         netdev->name, channel_frequency[dev->channel - 1], 6);
+	}
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - ch %d", netdev->name, dev->channel);
+
+	return 0;
+}
+
+
+static int at76_iw_handler_set_mode(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    __u32 *mode, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWMODE - %d", netdev->name, *mode);
+
+	if ((*mode != IW_MODE_ADHOC) && (*mode != IW_MODE_INFRA) &&
+	    (*mode != IW_MODE_MONITOR)) {
+		ret = -EINVAL;
+	} else {
+		dev->iw_mode = *mode;
+		if( dev->iw_mode != IW_MODE_INFRA)
+			dev->pm_mode = AT76_PM_OFF;
+	}
+	return ret;
+}
+
+
+static int at76_iw_handler_get_mode(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    __u32 * mode, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	*mode = dev->iw_mode;
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWMODE - %d", netdev->name, *mode);
+
+	return 0;
+}
+
+
+static int at76_iw_handler_get_range(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_point *data, char *extra)
+{
+	/* inspired by atmel.c */
+	struct at76_priv *dev = netdev_priv(netdev);
+	struct iw_range *range = (struct iw_range *)extra;
+	int i;
+
+	data->length = sizeof(struct iw_range);
+	memset(range, 0, sizeof(struct iw_range));
+
+	/* TODO: range->throughput = xxxxxx; */
+
+	range->min_nwid = 0x0000;
+	range->max_nwid = 0x0000;
+
+	/* this driver doesn't maintain sensitivity information */
+	range->sensitivity = 0;
+
+	range->max_qual.qual = 100;
+	range->max_qual.level = 100;
+	range->max_qual.noise = 0;
+	range->max_qual.updated = IW_QUAL_NOISE_INVALID;
+
+	range->avg_qual.qual = 50;
+	range->avg_qual.level = 50;
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = IW_QUAL_NOISE_INVALID;
+
+	range->bitrate[0] = 1000000;
+	range->bitrate[1] = 2000000;
+	range->bitrate[2] = 5500000;
+	range->bitrate[3] = 11000000;
+	range->num_bitrates = 4;
+
+	range->min_rts = 0;
+	range->max_rts = MAX_RTS_THRESHOLD;
+
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+
+	range->pmp_flags = IW_POWER_PERIOD;
+	range->pmt_flags = IW_POWER_ON;
+	range->pm_capa = IW_POWER_PERIOD | IW_POWER_ALL_R;
+
+	range->encoding_size[0] = WEP_SMALL_KEY_LEN;
+	range->encoding_size[1] = WEP_LARGE_KEY_LEN;
+	range->num_encoding_sizes = 2;
+	range->max_encoding_tokens = WEP_KEYS;
+
+	/* both WL-240U and Linksys WUSB11 v2.6 specify 15 dBm as output power
+	   - take this for all (ignore antenna gains) */
+	range->txpower[0] = 15;
+	range->num_txpower = 1;
+	range->txpower_capa = IW_TXPOW_DBM;
+
+	range->we_version_source = WIRELESS_EXT;
+	range->we_version_compiled = WIRELESS_EXT;
+
+	/* same as the values used in atmel.c */
+	range->retry_capa = IW_RETRY_LIMIT;
+	range->retry_flags = IW_RETRY_LIMIT;
+	range->r_time_flags = 0;
+	range->min_retry = 1;
+	range->max_retry = 255;
+
+
+	range->num_channels = NUM_CHANNELS;
+	range->num_frequency = 0;
+
+	for (i = 0; i < NUM_CHANNELS; i++) {
+		/* test if channel map bit is raised */
+		if (dev->domain->channel_map & (0x1 << i)) {
+			range->num_frequency += 1;
+
+			range->freq[i].i = i + 1;
+			range->freq[i].m = channel_frequency[i] * 100000;
+			range->freq[i].e = 1;	/* channel frequency*100000 * 10^1 */
+		}
+	}
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRANGE", netdev->name);
+
+	return 0;
+}
+
+
+static int at76_iw_handler_set_spy(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
 	int ret = 0;
-	int urb_status;
-	void *oldbuf = NULL;
 
-	netif_carrier_off(dev->netdev);	/* disable running netdev watchdog */
-	netif_stop_queue(dev->netdev);	/* stop tx data packets */
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWSPY - number of addresses %d",
+	         netdev->name, data->length);
 
-	spin_lock_irqsave(&dev->mgmt_spinlock, flags);
+	spin_lock_bh(&(dev->spy_spinlock));
+	ret = iw_handler_set_spy(dev->netdev, info, (union iwreq_data *)data,
+				 extra);
+	spin_unlock_bh(&(dev->spy_spinlock));
 
-	if ((urb_status = dev->write_urb->status) == -EINPROGRESS) {
-		oldbuf = dev->next_mgmt_bulk;	/* to kfree below */
-		dev->next_mgmt_bulk = txbuf;
-		txbuf = NULL;
+	return ret;
+}
+
+
+static int at76_iw_handler_get_spy(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_point *data, char *extra)
+{
+
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = 0;
+
+	spin_lock_bh(&(dev->spy_spinlock));
+	ret = iw_handler_get_spy(dev->netdev, info,
+				 (union iwreq_data *)data, extra);
+	spin_unlock_bh(&(dev->spy_spinlock));
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWSPY - number of addresses %d",
+	         netdev->name, data->length);
+
+	return ret;
+}
+
+
+static int at76_iw_handler_set_thrspy(struct net_device *netdev,
+				      struct iw_request_info *info,
+				      struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret;
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWTHRSPY - number of addresses %d)",
+	         netdev->name, data->length);
+
+	spin_lock_bh(&(dev->spy_spinlock));
+	ret = iw_handler_set_thrspy(netdev, info, (union iwreq_data *)data,
+				    extra);
+	spin_unlock_bh(&(dev->spy_spinlock));
+
+	return ret;
+}
+
+
+static int at76_iw_handler_get_thrspy(struct net_device *netdev,
+				      struct iw_request_info *info,
+				      struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret;
+
+	spin_lock_bh(&(dev->spy_spinlock));
+	ret = iw_handler_get_thrspy(netdev, info, (union iwreq_data *)data,
+				    extra);
+	spin_unlock_bh(&(dev->spy_spinlock));
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWTHRSPY - number of addresses %d)",
+	         netdev->name, data->length);
+
+	return ret;
+}
+
+
+static int at76_iw_handler_set_wap(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct sockaddr *ap_addr, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWAP - wap/bssid %s", netdev->name,
+	         mac2str(ap_addr->sa_data));
+
+	/* if the incoming address == ff:ff:ff:ff:ff:ff, the user has
+	   chosen any or auto AP preference */
+	if (is_broadcast_ether_addr(ap_addr->sa_data)
+	    || is_zero_ether_addr(ap_addr->sa_data)) {
+		dev->wanted_bssid_valid = 0;
+	} else {
+		/* user wants to set a preferred AP address */
+		dev->wanted_bssid_valid = 1;
+		memcpy(dev->wanted_bssid, ap_addr->sa_data, ETH_ALEN);
 	}
-	spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
 
-	if (oldbuf) {
-		/* a data/mgmt tx is already pending in the URB -
-		   if this is no error in some situations we must
-		   implement a queue or silently modify the old msg */
-		err("%s: %s removed pending mgmt buffer %s",
-		    dev->netdev->name, __FUNCTION__,
-		    hex2str(dev->obuf, dev->next_mgmt_bulk,
-			    min((int)(sizeof(dev->obuf)) / 3, 64), ' '));
+	return -EIWCOMMIT;
+}
+
+
+static int at76_iw_handler_get_wap(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct sockaddr *ap_addr, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	ap_addr->sa_family = ARPHRD_ETHER;
+	memcpy(ap_addr->sa_data, dev->bssid, ETH_ALEN);
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWAP - wap/bssid %s", netdev->name,
+	         mac2str(ap_addr->sa_data));
+
+	return 0;
+}
+
+
+static int at76_iw_handler_set_scan(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    union iwreq_data *wrqu, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	unsigned long flags;
+	int ret = 0;
+	struct iw_scan_req *req = NULL;
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWSCAN", netdev->name);
+
+	if (!netif_running(netdev))
+		return -ENETDOWN;
+
+	/* jal: we don't allow "iwlist ethX scan" while we are
+	   in monitor mode */
+	if (dev->iw_mode == IW_MODE_MONITOR)
+		return -EBUSY;
+
+	/* Discard old scan results */
+	if ((jiffies - dev->last_scan) > (20 * HZ))
+		dev->scan_state = SCAN_IDLE;
+	dev->last_scan = jiffies;
+
+	/* Initiate a scan command */
+	if (dev->scan_state == SCAN_IN_PROGRESS)
+		return -EBUSY;
+
+	dev->scan_state = SCAN_IN_PROGRESS;
+
+	/* stop pending management stuff */
+	del_timer_sync(&(dev->mgmt_timer));
+
+	spin_lock_irqsave(&(dev->mgmt_spinlock), flags);
+	if (dev->next_mgmt_bulk) {
 		kfree(dev->next_mgmt_bulk);
+		dev->next_mgmt_bulk = NULL;
 	}
+	spin_unlock_irqrestore(&(dev->mgmt_spinlock), flags);
 
-	if (txbuf) {
+	if (netif_running(dev->netdev)) {
+		/* pause network activity */
+		netif_carrier_off(dev->netdev);
+		netif_stop_queue(dev->netdev);
+	}
+	/* Try to do passive or active scan if WE asks as. */
+	if (wrqu->data.length
+	    && wrqu->data.length == sizeof(struct iw_scan_req)) {
+		req = (struct iw_scan_req *)extra;
 
-		txbuf->tx_rate = 0;
-		txbuf->padding = at76_calc_padding(le16_to_cpu(txbuf->wlength));
+		if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
+			dev->scan_mode = SCAN_TYPE_PASSIVE;
+		else if (req->scan_type == IW_SCAN_TYPE_ACTIVE)
+			dev->scan_mode = SCAN_TYPE_ACTIVE;
 
-		if (dev->next_mgmt_bulk) {
-			err("%s: %s URB status %d, but mgmt is pending",
-			    dev->netdev->name, __FUNCTION__, urb_status);
+		/* Sanity check values? */
+		if (req->min_channel_time > 0) {
+			if (dev->istate == MONITORING)
+				dev->monitor_scan_min_time =
+				    req->min_channel_time;
+			else
+				dev->scan_min_time = req->min_channel_time;
+		}
+		if (req->max_channel_time > 0) {
+			if (dev->istate == MONITORING)
+				dev->monitor_scan_max_time =
+				    req->max_channel_time;
+			else
+				dev->scan_max_time = req->max_channel_time;
 		}
+	}
 
-		at76_dbg(DBG_TX_MGMT, "%s: tx mgmt: wlen %d tx_rate %d pad %d %s",
-		         dev->netdev->name, le16_to_cpu(txbuf->wlength),
-		         txbuf->tx_rate, txbuf->padding,
-		         hex2str(dev->obuf, txbuf->packet,
-			    min((sizeof(dev->obuf) - 1) / 2,
-				(size_t) le16_to_cpu(txbuf->wlength)), '\0'));
+	/* change to scanning state */
+	dev->istate = SCANNING;
+	schedule_work(&dev->work_scan);
 
-		/* txbuf was not consumed above -> send mgmt msg immediately */
-		memcpy(dev->bulk_out_buffer, txbuf,
-		       le16_to_cpu(txbuf->wlength) + AT76_TX_HDRLEN);
-		usb_fill_bulk_urb(dev->write_urb, dev->udev,
-				  usb_sndbulkpipe(dev->udev,
-						  dev->bulk_out_endpointAddr),
-				  dev->bulk_out_buffer,
-				  le16_to_cpu(txbuf->wlength) +
-				  txbuf->padding +
-				  AT76_TX_HDRLEN,
-				  at76_write_bulk_callback,
-				  dev);
-		ret = usb_submit_urb(dev->write_urb, GFP_ATOMIC);
-		if (ret) {
-			err("%s: %s error in tx submit urb: %d",
-			    dev->netdev->name, __FUNCTION__, ret);
+	return ret;
+}
+
+
+static int at76_iw_handler_get_scan(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	unsigned long flags;
+	struct list_head *lptr, *nptr;
+	struct bss_info *curr_bss;
+	struct iw_event *iwe = kmalloc(sizeof(struct iw_event), GFP_KERNEL);
+	char *curr_val, *curr_pos = extra;
+	int i;
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWSCAN", netdev->name);
+
+	if (!iwe)
+		return -ENOMEM;
+
+	if (dev->scan_state != SCAN_COMPLETED)
+		/* scan not yet finished */
+		return -EAGAIN;
+
+	spin_lock_irqsave(&(dev->bss_list_spinlock), flags);
+
+	list_for_each_safe(lptr, nptr, &(dev->bss_list)) {
+		curr_bss = list_entry(lptr, struct bss_info, list);
+
+		iwe->cmd = SIOCGIWAP;
+		iwe->u.ap_addr.sa_family = ARPHRD_ETHER;
+		memcpy(iwe->u.ap_addr.sa_data, curr_bss->bssid, 6);
+		curr_pos = iwe_stream_add_event(curr_pos,
+						extra + IW_SCAN_MAX_DATA, iwe,
+						IW_EV_ADDR_LEN);
+
+		iwe->u.data.length = curr_bss->ssid_len;
+		iwe->cmd = SIOCGIWESSID;
+		iwe->u.data.flags = 1;
+
+		curr_pos = iwe_stream_add_point(curr_pos,
+			extra + IW_SCAN_MAX_DATA, iwe, curr_bss->ssid);
+
+		iwe->cmd = SIOCGIWMODE;
+		iwe->u.mode = (curr_bss->capa & WLAN_CAPABILITY_IBSS) ?
+		    IW_MODE_ADHOC :
+		    (curr_bss->capa & WLAN_CAPABILITY_ESS) ?
+		    IW_MODE_MASTER : IW_MODE_AUTO;
+		/* IW_MODE_AUTO = 0 which I thought is
+		 * the most logical value to return in this case */
+		curr_pos = iwe_stream_add_event(curr_pos,
+						extra + IW_SCAN_MAX_DATA, iwe,
+						IW_EV_UINT_LEN);
+
+		iwe->cmd = SIOCGIWFREQ;
+		iwe->u.freq.m = curr_bss->channel;
+		iwe->u.freq.e = 0;
+		curr_pos = iwe_stream_add_event(curr_pos,
+						extra + IW_SCAN_MAX_DATA, iwe,
+						IW_EV_FREQ_LEN);
+
+		iwe->cmd = SIOCGIWENCODE;
+		if (curr_bss->capa & WLAN_CAPABILITY_PRIVACY) {
+			iwe->u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+		} else {
+			iwe->u.data.flags = IW_ENCODE_DISABLED;
 		}
-		kfree(txbuf);
+		iwe->u.data.length = 0;
+		curr_pos = iwe_stream_add_point(curr_pos,
+						extra + IW_SCAN_MAX_DATA, iwe,
+						NULL);
+
+		/* Add quality statistics */
+		iwe->cmd = IWEVQUAL;
+		iwe->u.qual.noise = 0;
+		iwe->u.qual.updated =
+		    IW_QUAL_NOISE_INVALID | IW_QUAL_LEVEL_UPDATED;
+		iwe->u.qual.level = (curr_bss->rssi * 100 / 42);
+		if (iwe->u.qual.level > 100)
+			iwe->u.qual.level = 100;
+		if ((dev->board_type == BOARDTYPE_503_INTERSIL_3861) ||
+		    (dev->board_type == BOARDTYPE_503_INTERSIL_3863)) {
+			iwe->u.qual.qual = curr_bss->link_qual;
+		} else {
+			iwe->u.qual.qual = 0;
+			iwe->u.qual.updated |= IW_QUAL_QUAL_INVALID;
+		}
+		/* Add new value to event */
+		curr_pos = iwe_stream_add_event(curr_pos,
+						extra + IW_SCAN_MAX_DATA, iwe,
+						IW_EV_QUAL_LEN);
+
+		/* Rate : stuffing multiple values in a single event require a bit
+		 * more of magic - Jean II */
+		curr_val = curr_pos + IW_EV_LCP_LEN;
+
+		iwe->cmd = SIOCGIWRATE;
+		/* Those two flags are ignored... */
+		iwe->u.bitrate.fixed = iwe->u.bitrate.disabled = 0;
+		/* Max 8 values */
+		for (i = 0; i < curr_bss->rates_len; i++) {
+			/* Bit rate given in 500 kb/s units (+ 0x80) */
+			iwe->u.bitrate.value =
+			    ((curr_bss->rates[i] & 0x7f) * 500000);
+			/* Add new value to event */
+			curr_val = iwe_stream_add_value(curr_pos, curr_val,
+							extra +
+							IW_SCAN_MAX_DATA, iwe,
+							IW_EV_PARAM_LEN);
+		}
+
+		/* Check if we added any event */
+		if ((curr_val - curr_pos) > IW_EV_LCP_LEN)
+			curr_pos = curr_val;
+
+		/* more information may be sent back using IWECUSTOM */
+
 	}
-	/* if (txbuf) */
+
+	spin_unlock_irqrestore(&(dev->bss_list_spinlock), flags);
+
+	data->length = (curr_pos - extra);
+	data->flags = 0;
+
+	kfree(iwe);
+	return 0;
+}
+
+
+static int at76_iw_handler_set_essid(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWESSID - %s", netdev->name, extra);
+
+	if (data->flags) {
+		memcpy(dev->essid, extra, data->length);
+		dev->essid_size = data->length;
+	} else {
+		/* Use any SSID */
+		dev->essid_size = 0;
+	}
+
+	return -EIWCOMMIT;
+}
+
+
+static int at76_iw_handler_get_essid(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	if (dev->essid_size) {
+		/* not the ANY ssid in dev->essid */
+		data->flags = 1;
+		data->length = dev->essid_size;
+		memcpy(extra, dev->essid, data->length);
+		extra[data->length] = '\0';
+		data->length += 1;
+	} else {
+		/* the ANY ssid was specified */
+		if (dev->istate == CONNECTED && dev->curr_bss != NULL) {
+			/* report the SSID we have found */
+			data->flags = 1;
+			data->length = dev->curr_bss->ssid_len;
+			memcpy(extra, dev->curr_bss->ssid, data->length);
+			extra[dev->curr_bss->ssid_len] = '\0';
+			data->length += 1;
+		} else {
+			/* report ANY back */
+			data->flags = 0;
+			data->length = 0;
+		}
+	}
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWESSID - %s", netdev->name, extra);
+
+	return 0;
+}
+
+
+static int at76_iw_handler_set_rate(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_param *bitrate, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRATE - %d", netdev->name, bitrate->value);
+
+	switch (bitrate->value) {
+	case -1:
+		dev->txrate = TX_RATE_AUTO;
+		break;		/* auto rate */
+	case 1000000:
+		dev->txrate = TX_RATE_1MBIT;
+		break;
+	case 2000000:
+		dev->txrate = TX_RATE_2MBIT;
+		break;
+	case 5500000:
+		dev->txrate = TX_RATE_5_5MBIT;
+		break;
+	case 11000000:
+		dev->txrate = TX_RATE_11MBIT;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
 	return ret;
+}
+
+
+static int at76_iw_handler_get_rate(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_param *bitrate, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = 0;
+
+	switch (dev->txrate) {
+		/* return max rate if RATE_AUTO */
+	case TX_RATE_AUTO:
+		bitrate->value = 11000000;
+		break;
+	case TX_RATE_1MBIT:
+		bitrate->value = 1000000;
+		break;
+	case TX_RATE_2MBIT:
+		bitrate->value = 2000000;
+		break;
+	case TX_RATE_5_5MBIT:
+		bitrate->value = 5500000;
+		break;
+	case TX_RATE_11MBIT:
+		bitrate->value = 11000000;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	bitrate->fixed = (dev->txrate != TX_RATE_AUTO);
+	bitrate->disabled = 0;
 
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRATE - %d", netdev->name,
+	         bitrate->value);
+
+	return ret;
 }
 
-/* Go to the next information element */
-static inline void next_ie(struct ieee80211_info_element **ie)
+
+static int at76_iw_handler_set_rts(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_param *rts, char *extra)
 {
-	*ie = (struct ieee80211_info_element *)(&(*ie)->data[(*ie)->len]);
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = -EIWCOMMIT;
+	int rthr = rts->value;
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRTS - value %d disabled %s",
+		 netdev->name, rts->value, (rts->disabled) ? "true" : "false");
+
+	if (rts->disabled)
+		rthr = MAX_RTS_THRESHOLD;
+
+	if ((rthr < 0) || (rthr > MAX_RTS_THRESHOLD)) {
+		ret = -EINVAL;
+	} else {
+		dev->rts_threshold = rthr;
+	}
+
+	return ret;
 }
 
-static int at76_disassoc_req(struct at76_priv *dev, struct bss_info *bss)
+
+static int at76_iw_handler_get_rts(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_param *rts, char *extra)
 {
-	struct at76_tx_buffer *tx_buffer;
-	struct ieee80211_hdr_3addr *mgmt;
-	struct ieee80211_disassoc *req;
+	struct at76_priv *dev = netdev_priv(netdev);
 
-	at76_assert(bss != NULL);
-	if (bss == NULL)
-		return -EFAULT;
+	rts->value = dev->rts_threshold;
+	rts->disabled = (rts->value >= MAX_RTS_THRESHOLD);
+	rts->fixed = 1;
 
-	tx_buffer = kmalloc(DISASSOC_FRAME_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
-	if (!tx_buffer)
-		return -ENOMEM;
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRTS - value %d disabled %s",
+	         netdev->name, rts->value, (rts->disabled) ? "true" : "false");
 
-	req = (struct ieee80211_disassoc *)(&tx_buffer->packet);
-	mgmt = &req->header;
+	return 0;
+}
 
-	/* make wireless header */
-	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_AUTH);
-	mgmt->duration_id = cpu_to_le16(0x8000);
-	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
-	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
-	memcpy(mgmt->addr3, bss->bssid, ETH_ALEN);
-	mgmt->seq_ctl = cpu_to_le16(0);
 
-	req->reason = 0;
+static int at76_iw_handler_set_frag(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_param *frag, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = -EIWCOMMIT;
+	int fthr = frag->value;
 
-	/* init. at76_priv tx header */
-	tx_buffer->wlength = cpu_to_le16(DISASSOC_FRAME_SIZE - AT76_TX_HDRLEN);
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWFRAG - value %d, disabled %s",
+	         netdev->name, frag->value, (frag->disabled) ? "true" : "false");
 
-	at76_dbg(DBG_TX_MGMT, "%s: DisAssocReq bssid %s",
-	         dev->netdev->name, mac2str(mgmt->addr3));
+	if (frag->disabled)
+		fthr = MAX_FRAG_THRESHOLD;
 
-	/* either send immediately (if no data tx is pending
-	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	if ((fthr < MIN_FRAG_THRESHOLD) || (fthr > MAX_FRAG_THRESHOLD)) {
+		ret = -EINVAL;
+	} else {
+		dev->frag_threshold = fthr & ~0x1; /* get an even value */
+	}
 
+	return ret;
 }
 
-/* challenge is the challenge string (in TLV format)
-   we got with seq_nr 2 for shared secret authentication only and
-   send in seq_nr 3 WEP encrypted to prove we have the correct WEP key;
-   otherwise it is NULL */
-static int at76_auth_req(struct at76_priv *dev, struct bss_info *bss, int seq_nr,
-		    struct ieee80211_info_element *challenge)
+
+static int at76_iw_handler_get_frag(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_param *frag, char *extra)
 {
-	struct at76_tx_buffer *tx_buffer;
-	struct ieee80211_hdr_3addr *mgmt;
-	struct ieee80211_auth *req;
-	int buf_len = (seq_nr != 3 ? AUTH_FRAME_SIZE :
-		       AUTH_FRAME_SIZE + 1 + 1 + challenge->len);
+	struct at76_priv *dev = netdev_priv(netdev);
 
-	at76_assert(bss != NULL);
-	at76_assert(seq_nr != 3 || challenge != NULL);
-	tx_buffer = kmalloc(buf_len + MAX_PADDING_SIZE, GFP_ATOMIC);
-	if (!tx_buffer)
-		return -ENOMEM;
+	frag->value = dev->frag_threshold;
+	frag->disabled = (frag->value >= MAX_FRAG_THRESHOLD);
+	frag->fixed = 1;
 
-	req = (struct ieee80211_auth *)(&tx_buffer->packet);
-	mgmt = &req->header;
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFRAG - value %d, disabled %s",
+	         netdev->name, frag->value, (frag->disabled) ? "true" : "false");
 
-	/* make wireless header */
-	/* first auth msg is not encrypted, only the second (seq_nr == 3) */
-	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH |
-		(seq_nr == 3 ? IEEE80211_FCTL_PROTECTED : 0));
+	return 0;
+}
 
-	mgmt->duration_id = cpu_to_le16(0x8000);
-	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
-	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
-	memcpy(mgmt->addr3, bss->bssid, ETH_ALEN);
-	mgmt->seq_ctl = cpu_to_le16(0);
 
-	req->algorithm = cpu_to_le16(dev->auth_mode);
-	req->transaction = cpu_to_le16(seq_nr);
-	req->status = cpu_to_le16(0);
+static int at76_iw_handler_get_txpow(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_param *power, char *extra)
+{
+	power->value = 15;
+	power->fixed = 1;	/* No power control */
+	power->disabled = 0;
+	power->flags = IW_TXPOW_DBM;
 
-	if (seq_nr == 3)
-		memcpy(req->info_element, challenge, 1 + 1 + challenge->len);
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWTXPOW - txpow %d dBm", netdev->name,
+	         power->value);
 
-	/* init. at76_priv tx header */
-	tx_buffer->wlength = cpu_to_le16(buf_len - AT76_TX_HDRLEN);
-	at76_dbg(DBG_TX_MGMT, "%s: AuthReq bssid %s alg %d seq_nr %d",
-	         dev->netdev->name, mac2str(mgmt->addr3),
-	         le16_to_cpu(req->algorithm), le16_to_cpu(req->transaction));
-	if (seq_nr == 3) {
-		at76_dbg(DBG_TX_MGMT, "%s: AuthReq challenge: %s ...",
-		         dev->netdev->name,
-		         hex2str(dev->obuf, req->info_element,
-		             min((int)sizeof(dev->obuf) / 3, 18), ' '));
+	return 0;
+}
+
+
+/* jal: short retry is handled by the firmware (at least 0.90.x),
+   while long retry is not (?) */
+static int at76_iw_handler_set_retry(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_param *retry, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRETRY disabled %d  flags x%x val %d",
+	         netdev->name, retry->disabled, retry->flags, retry->value);
+
+	if (!retry->disabled && (retry->flags & IW_RETRY_LIMIT)) {
+		if ((retry->flags & IW_RETRY_MIN) ||
+		    !(retry->flags & IW_RETRY_MAX)) {
+			dev->short_retry_limit = retry->value;
+		} else
+			ret = -EINVAL;
+	} else {
+		ret = -EINVAL;
 	}
 
-	/* either send immediately (if no data tx is pending
-	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	return ret;
+}
+
+
+/* adapted (ripped) from atmel.c */
+static int at76_iw_handler_get_retry(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_param *retry, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRETRY", netdev->name);
+
+	retry->disabled = 0;      /* Can't be disabled */
+
 
+	retry->flags = IW_RETRY_LIMIT;
+	retry->value = dev->short_retry_limit;
+
+	return 0;
 }
 
-static int at76_assoc_req(struct at76_priv *dev, struct bss_info *bss)
+
+static int at76_iw_handler_set_encode(struct net_device *netdev,
+				      struct iw_request_info *info,
+				      struct iw_point *encoding,
+				      char *extra)
 {
-	struct at76_tx_buffer *tx_buffer;
-	struct ieee80211_hdr_3addr *mgmt;
-	struct ieee80211_assoc_request *req;
-	struct ieee80211_info_element *tlv;
+	struct at76_priv *dev = netdev_priv(netdev);
+	int index = (encoding->flags & IW_ENCODE_INDEX) - 1;
+	int len = encoding->length;
 
-	at76_assert(bss != NULL);
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - enc.flags %08x "
+	         "pointer %p len %d", netdev->name, encoding->flags,
+	         encoding->pointer, encoding->length);
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - old wepstate: enabled %s key_id %d "
+	         "auth_mode %s",
+	         netdev->name, (dev->wep_enabled) ? "true" : "false",
+	         dev->wep_key_id,
+	         (dev->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
 
-	tx_buffer = kmalloc(ASSOCREQ_MAX_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
-	if (!tx_buffer)
-		return -ENOMEM;
+	/* take the old default key if index is invalid */
+	if ((index < 0) || (index >= WEP_KEYS))
+		index = dev->wep_key_id;
 
-	req = (struct ieee80211_assoc_request *)(&tx_buffer->packet);
-	mgmt = &req->header;
-	tlv = req->info_element;
+	if (len > 0) {
+		if (len > WEP_LARGE_KEY_LEN)
+			len = WEP_LARGE_KEY_LEN;
 
-	/* make wireless header */
-	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_ASSOC_REQ);
+		memset(dev->wep_keys[index], 0, WEP_KEY_LEN);
+		memcpy(dev->wep_keys[index], extra, len);
+		dev->wep_keys_len[index] = (len <= WEP_SMALL_KEY_LEN) ?
+		    WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN;
+		dev->wep_enabled = 1;
+	}
 
-	mgmt->duration_id = cpu_to_le16(0x8000);
-	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
-	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
-	memcpy(mgmt->addr3, bss->bssid, ETH_ALEN);
-	mgmt->seq_ctl = cpu_to_le16(0);
+	dev->wep_key_id = index;
+	dev->wep_enabled = ((encoding->flags & IW_ENCODE_DISABLED) == 0);
 
-	/* we must set the Privacy bit in the capabilities to assure an
-	   Agere-based AP with optional WEP transmits encrypted frames
-	   to us.  AP only set the Privacy bit in their capabilities
-	   if WEP is mandatory in the BSS! */
-	req->capability = cpu_to_le16(bss->capa |
-				      (dev->wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
-				      (dev->preamble_type == PREAMBLE_TYPE_SHORT ?
-				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+	if (encoding->flags & IW_ENCODE_RESTRICTED)
+		dev->auth_mode = WLAN_AUTH_SHARED_KEY;
+	if (encoding->flags & IW_ENCODE_OPEN)
+		dev->auth_mode = WLAN_AUTH_OPEN;
 
-	req->listen_interval = cpu_to_le16(2 * bss->beacon_interval);
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - new wepstate: enabled %s key_id %d "
+	         "key_len %d auth_mode %s",
+	         netdev->name, (dev->wep_enabled) ? "true" : "false",
+	         dev->wep_key_id + 1, dev->wep_keys_len[dev->wep_key_id],
+	         (dev->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
 
-	/* write TLV data elements */
+	return -EIWCOMMIT;
+}
 
-	tlv->id = MFIE_TYPE_SSID;
-	tlv->len = bss->ssid_len;
-	memcpy(tlv->data, bss->ssid, bss->ssid_len);
-	next_ie(&tlv);
 
-	tlv->id = MFIE_TYPE_RATES;
-	tlv->len = sizeof(hw_rates);
-	memcpy(tlv->data, hw_rates, sizeof(hw_rates));
-	next_ie(&tlv);		/* tlv points behind the supp_rates field */
+static int at76_iw_handler_get_encode(struct net_device *netdev,
+				      struct iw_request_info *info,
+				      struct iw_point *encoding,
+				      char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int index = (encoding->flags & IW_ENCODE_INDEX) - 1;
 
-	/* init. at76_priv tx header */
-	tx_buffer->wlength = cpu_to_le16((u8 *) tlv - (u8 *) mgmt);
+	if ((index < 0) || (index >= WEP_KEYS))
+		index = dev->wep_key_id;
 
-	{
-		/* output buffer for ssid and rates */
-		char orates[4 * 2 + 1];
-		int len;
+	encoding->flags =
+	    (dev->auth_mode == WLAN_AUTH_SHARED_KEY) ?
+	    IW_ENCODE_RESTRICTED : IW_ENCODE_OPEN;
 
-		tlv = req->info_element;
-		len = min_t(int, IW_ESSID_MAX_SIZE, tlv->len);
-		memcpy(dev->obuf, tlv->data, len);
-		dev->obuf[len] = '\0';
-		next_ie(&tlv); /* points to IE of rates now */
-		at76_dbg(DBG_TX_MGMT, "%s: AssocReq bssid %s capa x%04x ssid %s rates %s",
-		         dev->netdev->name, mac2str(mgmt->addr3),
-		         le16_to_cpu(req->capability), dev->obuf,
-		         hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
-			    '\0'));
+	if (!dev->wep_enabled)
+		encoding->flags |= IW_ENCODE_DISABLED;
+
+	if (encoding->pointer) {
+		encoding->length = dev->wep_keys_len[index];
+
+		memcpy(extra, dev->wep_keys[index], dev->wep_keys_len[index]);
+
+		encoding->flags |= (index + 1);
 	}
 
-	/* either send immediately (if no data tx is pending
-	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWENCODE - enc.flags %08x "
+		"pointer %p len %d", netdev->name, encoding->flags,
+		encoding->pointer, encoding->length);
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWENCODE - wepstate: enabled %s key_id %d "
+		"key_len %d auth_mode %s",
+		netdev->name, (dev->wep_enabled) ? "true" : "false",
+		dev->wep_key_id + 1, dev->wep_keys_len[dev->wep_key_id],
+		(dev->auth_mode == WLAN_AUTH_SHARED_KEY) ?
+			"restricted" : "open");
 
+	return 0;
 }
 
-/* we are currently associated to curr_bss and
-   want to reassoc to new_bss */
-static int at76_reassoc_req(struct at76_priv *dev, struct bss_info *curr_bss,
-		            struct bss_info *new_bss)
+
+static int at76_iw_handler_set_power(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_param *prq, char *extra)
 {
-	struct at76_tx_buffer *tx_buffer;
-	struct ieee80211_hdr_3addr *mgmt;
-	struct ieee80211_reassoc_request *req;
-	struct ieee80211_info_element *tlv;
+	int err = -EIWCOMMIT;
+	struct at76_priv *dev = netdev_priv(netdev);
 
-	at76_assert(curr_bss != NULL);
-	at76_assert(new_bss != NULL);
-	if (curr_bss == NULL || new_bss == NULL)
-		return -EFAULT;
+	at76_dbg(DBG_IOCTL, "%s: SIOCSIWPOWER - disabled %s flags x%x value x%x",
+		 netdev->name, (prq->disabled) ? "true" : "false",
+		 prq->flags, prq->value);
 
-	tx_buffer = kmalloc(REASSOCREQ_MAX_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
-	if (!tx_buffer)
-		return -ENOMEM;
+	if (prq->disabled) {
+		dev->pm_mode = AT76_PM_OFF;
+	} else {
+		switch (prq->flags & IW_POWER_MODE) {
+                case IW_POWER_ALL_R:
+		case IW_POWER_ON:
+                        break;
+		default:
+			err = -EINVAL;
+			goto out;
+		}
+		if (prq->flags & IW_POWER_PERIOD) {
+			dev->pm_period = prq->value;
+		}
+		if (prq->flags & IW_POWER_TIMEOUT) {
+			err = -EINVAL;
+			goto out;
+		}
+		dev->pm_mode = AT76_PM_ON;
+	}
+out:
+	return err;
+}
 
-	req = (struct ieee80211_reassoc_request *)(&tx_buffer->packet);
-	mgmt = &req->header;
-	tlv = req->info_element;
 
-	/* make wireless header */
-	/* jal: encrypt this packet if wep_enabled is TRUE ??? */
-	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_REASSOC_REQ);
-	mgmt->duration_id = cpu_to_le16(0x8000);
-	memcpy(mgmt->addr1, new_bss->bssid, ETH_ALEN);
-	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
-	memcpy(mgmt->addr3, new_bss->bssid, ETH_ALEN);
-	mgmt->seq_ctl = cpu_to_le16(0);
+static int at76_iw_handler_get_power(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_param *power, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
 
-	/* we must set the Privacy bit in the capabilities to assure an
-	   Agere-based AP with optional WEP transmits encrypted frames
-	   to us.  AP only set the Privacy bit in their capabilities
-	   if WEP is mandatory in the BSS! */
-	req->capability = cpu_to_le16(new_bss->capa |
-				      (dev->wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
-				      (dev->preamble_type == PREAMBLE_TYPE_SHORT ?
-				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+	if ((power->disabled = (dev->pm_mode == AT76_PM_OFF)))
+		return 0;
+	else {
+		power->flags = IW_POWER_PERIOD;
+		power->value = dev->pm_period;
+	}
+	power->flags |= IW_POWER_ALL_R;
 
-	req->listen_interval = cpu_to_le16(2 * new_bss->beacon_interval);
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWPOWER - disabled %s flags x%x value x%x",
+		 netdev->name, (power->disabled) ? "true" : "false",
+		 power->flags, power->value);
 
-	memcpy(req->current_ap, curr_bss->bssid, ETH_ALEN);
+	return 0;
+}
 
-	/* write TLV data elements */
-	tlv->id = MFIE_TYPE_SSID;
-	tlv->len = new_bss->ssid_len;
-	memcpy(tlv->data, new_bss->ssid, new_bss->ssid_len);
-	next_ie(&tlv);
 
-	tlv->id = MFIE_TYPE_RATES;
-	tlv->len = sizeof(hw_rates);
-	memcpy(tlv->data, hw_rates, sizeof(hw_rates));
-	/* tlv points behind the supp_rates field */
-	next_ie(&tlv);
+/*******************************************************************************
+ * Private IOCTLS
+ */
+static int at76_iw_set_short_preamble(struct net_device *netdev,
+				      struct iw_request_info *info, char *name,
+				      char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
 
-	/* init. at76_priv tx header */
-	tx_buffer->wlength = cpu_to_le16((u8 *)tlv-(u8 *)mgmt);
+	at76_dbg(DBG_IOCTL, "%s: AT76_SET_SHORT_PREAMBLE, %d",
+	         netdev->name, val);
+
+	if (val < 0 || val > 2) {
+		/* allow value of 2 - in the win98 driver it stands
+		   for "auto preamble" ...? */
+		ret = -EINVAL;
+	} else {
+		dev->preamble_type = val;
+	}
+
+	return ret;
+}
+
+
+static int at76_iw_set_debug(struct net_device *netdev,
+			     struct iw_request_info *info,
+			     struct iw_point *data, char *extra)
+{
+	char *ptr;
+	u32 val;
+
+	if (data->length > 0) {
+		val = simple_strtol(extra, &ptr, 0);
+
+		if (ptr == extra) {
+			val = DBG_DEFAULTS;
+		}
+
+		dbg("%s: AT76_SET_DEBUG input %d: %s -> x%x",
+		       netdev->name, data->length, extra, val);
+	} else {
+		val = DBG_DEFAULTS;
+	}
+
+	dbg("%s: AT76_SET_DEBUG, old 0x%x  new 0x%x",
+	       netdev->name, at76_debug, val);
+
+	/* jal: some more output to pin down lockups */
+	dbg("%s: netif running %d queue_stopped %d carrier_ok %d",
+	       netdev->name,
+	       netif_running(netdev),
+	       netif_queue_stopped(netdev), netif_carrier_ok(netdev));
+
+	at76_debug = val;
+
+	return 0;
+}
+
+
+static int at76_iw_set_powersave_mode(struct net_device *netdev,
+				      struct iw_request_info *info, char *name,
+				      char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, "%s: AT76_SET_POWERSAVE_MODE, %d (%s)",
+	         netdev->name, val,
+	         val == AT76_PM_OFF ? "active" : val == AT76_PM_ON ? "save" :
+	         val == AT76_PM_SMART ? "smart save" : "<invalid>");
+	if (val < AT76_PM_OFF || val > AT76_PM_SMART) {
+		ret = -EINVAL;
+	} else {
+		dev->pm_mode = val;
+	}
+
+	return ret;
+}
+
+
+static int at76_iw_set_scan_times(struct net_device *netdev,
+				  struct iw_request_info *info, char *name,
+				  char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int mint = *((int *)name);
+	int maxt = *((int *)name + 1);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, "%s: AT76_SET_SCAN_TIMES - min %d max %d",
+	         netdev->name, mint, maxt);
+	if (mint <= 0 || maxt <= 0 || mint > maxt) {
+		ret = -EINVAL;
+	} else {
+		if (dev->istate == MONITORING) {
+			dev->monitor_scan_min_time = mint;
+			dev->monitor_scan_max_time = maxt;
+			ret = 0;
+		} else {
+			dev->scan_min_time = mint;
+			dev->scan_max_time = maxt;
+		}
+	}
+
+	return ret;
+}
+
+
+static int at76_iw_set_scan_mode(struct net_device *netdev,
+				 struct iw_request_info *info, char *name,
+				 char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, "%s: AT76_SET_SCAN_MODE - mode %s",
+		 netdev->name, (val = SCAN_TYPE_ACTIVE) ? "active" :
+		 (val = SCAN_TYPE_PASSIVE) ? "passive" : "<invalid>");
+
+	if (val != SCAN_TYPE_ACTIVE && val != SCAN_TYPE_PASSIVE) {
+		ret = -EINVAL;
+	} else {
+		dev->scan_mode = val;
+	}
+
+	return ret;
+}
+
+
+static int at76_set_iroaming(struct at76_priv *dev, int onoff)
+{
+	int ret = 0;
+
+	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev->mib_buf.type = MIB_MAC_MGMT;
+	dev->mib_buf.size = 1;
+	dev->mib_buf.index = IROAMING_OFFSET;
+	dev->mib_buf.data[0] = (dev->international_roaming ? 1 : 0);
+	ret = at76_set_mib(dev, &dev->mib_buf);
+	if (ret < 0) {
+		err("%s: set_mib (intl_roaming_enable) failed: %d", dev->netdev->name, ret);
+	}
+
+	return ret;
+}
+
+
+static int at76_iw_set_intl_roaming(struct net_device *netdev,
+				    struct iw_request_info *info, char *name,
+				    char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, "%s: AT76_SET_INTL_ROAMING - mode %s",
+	         netdev->name, (val == IR_OFF) ? "off" :
+	         (val == IR_ON) ? "on" : "<invalid>");
+
+	if (val != IR_OFF && val != IR_ON) {
+		ret = -EINVAL;
+	} else {
+		if (dev->international_roaming != val) {
+			dev->international_roaming = val;
+			at76_set_iroaming(dev, val);
+		}
+	}
+
+	return ret;
+}
+
+
+/*******************************************************************************
+ * structure that advertises the iw handlers of this driver
+ */
+static const iw_handler	at76_handlers[] =
+{
+        [SIOCSIWCOMMIT-SIOCIWFIRST] = (iw_handler) at76_iw_handler_commit,
+        [SIOCGIWNAME  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_name,
+        [SIOCSIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_freq,
+        [SIOCGIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_freq,
+        [SIOCSIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_mode,
+        [SIOCGIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_mode,
+        [SIOCGIWRANGE -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_range,
+        [SIOCSIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_spy,
+        [SIOCGIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_spy,
+        [SIOCSIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_thrspy,
+        [SIOCGIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_thrspy,
+        [SIOCSIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_wap,
+        [SIOCGIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_wap,
+        [SIOCSIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_scan,
+        [SIOCGIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_scan,
+        [SIOCSIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_essid,
+        [SIOCGIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_essid,
+        [SIOCSIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rate,
+        [SIOCGIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rate,
+        [SIOCSIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rts,
+        [SIOCGIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rts,
+        [SIOCSIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_frag,
+        [SIOCGIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_frag,
+        [SIOCGIWTXPOW -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_txpow,
+        [SIOCSIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_retry,
+        [SIOCGIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_retry,
+        [SIOCSIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_encode,
+        [SIOCGIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_encode,
+        [SIOCSIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_power,
+        [SIOCGIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_power,
+};
+
+#define AT76_SET_PRIV(h, f) [h - SIOCIWFIRSTPRIV] = (iw_handler) f
+
+/*structure that advertises the private iw handlers of this driver */
+static const iw_handler at76_priv_handlers[] = {
+	AT76_SET_PRIV(AT76_SET_SHORT_PREAMBLE, at76_iw_set_short_preamble),
+	AT76_SET_PRIV(AT76_SET_DEBUG, at76_iw_set_debug),
+	AT76_SET_PRIV(AT76_SET_POWERSAVE_MODE, at76_iw_set_powersave_mode),
+	AT76_SET_PRIV(AT76_SET_SCAN_TIMES, at76_iw_set_scan_times),
+	AT76_SET_PRIV(AT76_SET_SCAN_MODE, at76_iw_set_scan_mode),
+	AT76_SET_PRIV(AT76_SET_INTL_ROAMING, at76_iw_set_intl_roaming),
+};
+
+
+/*******************************************************************************
+ * structure that describes the private ioctls/iw handlers of this driver
+ */
+static const struct iw_priv_args at76_priv_args[] = {
+	{AT76_SET_SHORT_PREAMBLE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	 "short_preamble"},	/* 0 - long, 1 -short */
+
+	{AT76_SET_DEBUG,
+	 /* we must pass the new debug mask as a string,
+	  * 'cause iwpriv cannot parse hex numbers
+	  * starting with 0x :-(  */
+	 IW_PRIV_TYPE_CHAR | 10, 0,
+	 "set_debug"},		/* set debug value */
+
+	{AT76_SET_POWERSAVE_MODE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	 "powersave_mode"},	/* 1 -  active, 2 - power save,
+				   3 - smart power save */
+	{AT76_SET_SCAN_TIMES,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0,
+	 "scan_times"},		/* min_channel_time,
+				   max_channel_time */
+	{AT76_SET_SCAN_MODE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	 "scan_mode"},		/* 0 - active, 1 - passive scan */
+
+	{AT76_SET_INTL_ROAMING,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	 "intl_roaming"},
+};
+
+
+static const struct iw_handler_def at76_handler_def =
+{
+	.num_standard	= ARRAY_SIZE(at76_handlers),
+	.num_private	= ARRAY_SIZE(at76_priv_handlers),
+	.num_private_args = ARRAY_SIZE(at76_priv_args),
+	.standard	= at76_handlers,
+	.private	= at76_priv_handlers,
+	.private_args	= at76_priv_args,
+ 	.get_wireless_stats = at76_get_wireless_stats,
+};
+
+
+/* A short overview on Ethernet-II, 802.2, 802.3 and SNAP
+   (taken from http://www.geocities.com/billalexander/ethernet.html):
+
+Ethernet Frame Formats:
+
+Ethernet (a.k.a. Ethernet II)
+
+        +---------+---------+---------+----------
+        |   Dst   |   Src   |  Type   |  Data...
+        +---------+---------+---------+----------
+
+         <-- 6 --> <-- 6 --> <-- 2 --> <-46-1500->
+
+         Type 0x80 0x00 = TCP/IP
+         Type 0x06 0x00 = XNS
+         Type 0x81 0x37 = Novell NetWare
+
+
+802.3
+
+        +---------+---------+---------+----------
+        |   Dst   |   Src   | Length  | Data...
+        +---------+---------+---------+----------
+
+         <-- 6 --> <-- 6 --> <-- 2 --> <-46-1500->
+
+802.2 (802.3 with 802.2 header)
+
+        +---------+---------+---------+-------+-------+-------+----------
+        |   Dst   |   Src   | Length  | DSAP  | SSAP  |Control| Data...
+        +---------+---------+---------+-------+-------+-------+----------
+
+                                       <- 1 -> <- 1 -> <- 1 -> <-43-1497->
+
+SNAP (802.3 with 802.2 and SNAP headers)
+
+        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
+        |   Dst   |   Src   | Length  | 0xAA  | 0xAA  | 0x03  |  Org Code |   Type  | Data...
+        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
+
+                                                               <--  3  --> <-- 2 --> <-38-1492->
+
+*/
+static const u8 snapsig[] = { 0xaa, 0xaa, 0x03 };
+
+/* RFC 1042 encapsulates Ethernet frames in 802.2 SNAP (0xaa, 0xaa, 0x03) with
+ * a SNAP OID of 0 (0x00, 0x00, 0x00) */
+static const u8 rfc1042sig[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+
+
+static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	struct net_device_stats *stats = &dev->stats;
+	int ret = 0;
+	int wlen;
+	int submit_len;
+	struct at76_tx_buffer *tx_buffer = dev->bulk_out_buffer;
+	struct ieee80211_hdr_3addr *i802_11_hdr =
+	    (struct ieee80211_hdr_3addr *)&(tx_buffer->packet);
+	u8 *payload = tx_buffer->packet + sizeof(struct ieee80211_hdr_3addr);
+
+	if (netif_queue_stopped(netdev)) {
+		err("%s: %s called while netdev is stopped", netdev->name,
+		    __FUNCTION__);
+		/* skip this packet */
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	if (dev->write_urb->status == -EINPROGRESS) {
+		err("%s: %s called while dev->write_urb is pending for tx",
+		    netdev->name, __FUNCTION__);
+		/* skip this packet */
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	if (skb->len < 2 * ETH_ALEN) {
+		err("%s: %s: skb too short (%d)", dev->netdev->name,
+		    __FUNCTION__, skb->len);
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	at76_ledtrig_tx_activity(); /* tell the ledtrigger we send a packet */
+
+	/* we can get rid of memcpy, if we set netdev->hard_header_len
+	   to 8 + sizeof(struct ieee80211_hdr_3addr), because then we have
+	   enough space
+	   at76_dbg(DBG_TX, "skb->data - skb->head = %d", skb->data - skb->head); */
+
+	if (ntohs(*(__be16 *) (skb->data + 2 * ETH_ALEN)) <= 1518) {
+		/* this is a 802.3 packet */
+		if (skb->data[2 * ETH_ALEN + 2] == rfc1042sig[0] &&
+		    skb->data[2 * ETH_ALEN + 2 + 1] == rfc1042sig[1]) {
+			/* higher layer delivered SNAP header - keep it */
+			memcpy(payload, skb->data + 2*ETH_ALEN+2, skb->len - 2*ETH_ALEN -2);
+			wlen = sizeof(struct ieee80211_hdr_3addr) + skb->len - 2*ETH_ALEN -2;
+		} else {
+			err("%s: %s: no support for non-SNAP 802.2 packets "
+			    "(DSAP x%02x SSAP x%02x cntrl x%02x)",
+			    dev->netdev->name, __FUNCTION__,
+			    skb->data[2 * ETH_ALEN + 2],
+			    skb->data[2 * ETH_ALEN + 2 + 1],
+			    skb->data[2 * ETH_ALEN + 2 + 2]);
+			dev_kfree_skb(skb);
+			return 0;
+		}
+	} else {
+		/* add RFC 1042 header in front */
+		memcpy(payload, rfc1042sig, sizeof(rfc1042sig));
+		memcpy(payload + sizeof(rfc1042sig),
+		       skb->data + 2*ETH_ALEN, skb->len - 2*ETH_ALEN);
+		wlen = sizeof(struct ieee80211_hdr_3addr) + sizeof(rfc1042sig) +
+			skb->len - 2*ETH_ALEN;
+	}
+
+	/* make wireless header */
+	i802_11_hdr->frame_ctl =
+	    cpu_to_le16(IEEE80211_FTYPE_DATA |
+			(dev->wep_enabled ? IEEE80211_FCTL_PROTECTED : 0) |
+			(dev->iw_mode ==
+			 IW_MODE_INFRA ? IEEE80211_FCTL_TODS : 0));
+
+	if (dev->iw_mode == IW_MODE_ADHOC) {
+		memcpy(i802_11_hdr->addr1, skb->data, ETH_ALEN);	/* destination */
+		memcpy(i802_11_hdr->addr2, skb->data + ETH_ALEN, ETH_ALEN);	/* source */
+		memcpy(i802_11_hdr->addr3, dev->bssid, ETH_ALEN);
+	} else if (dev->iw_mode == IW_MODE_INFRA) {
+		memcpy(i802_11_hdr->addr1, dev->bssid, ETH_ALEN);
+		memcpy(i802_11_hdr->addr2, skb->data + ETH_ALEN, ETH_ALEN);	/* source */
+		memcpy(i802_11_hdr->addr3, skb->data, ETH_ALEN);	/* destination */
+	}
+
+	i802_11_hdr->duration_id = cpu_to_le16(0);
+	i802_11_hdr->seq_ctl = cpu_to_le16(0);
+
+	/* setup 'Atmel' header */
+	tx_buffer->wlength = cpu_to_le16(wlen);
+	tx_buffer->tx_rate = dev->txrate;
+	/* for broadcast destination addresses, the firmware 0.100.x
+	   seems to choose the highest rate set with CMD_STARTUP in
+	   basic_rate_set replacing this value */
+
+	memset(tx_buffer->reserved, 0, 4);
+
+	tx_buffer->padding = at76_calc_padding(wlen);
+	submit_len = wlen + AT76_TX_HDRLEN + tx_buffer->padding;
 
 	{
-		/* output buffer for rates and bssid */
-		char orates[4*2+1];
-		char ocurr[6*3+1];
-		tlv = req->info_element;
-		memcpy(dev->obuf, tlv->data, min(sizeof(dev->obuf),(size_t)tlv->len));
-		dev->obuf[IW_ESSID_MAX_SIZE] = '\0';
-		next_ie(&tlv); /* points to IE of rates now */
-		at76_dbg(DBG_TX_MGMT, "%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s",
+		at76_dbg(DBG_TX_DATA_CONTENT, "%s skb->data %s", dev->netdev->name,
+		         hex2str(dev->obuf, skb->data,
+			    min((int)(sizeof(dev->obuf) - 1) / 2, 32), '\0'));
+		at76_dbg(DBG_TX_DATA, "%s tx  wlen x%x pad x%x rate %d hdr %s",
 		         dev->netdev->name,
-		         hex2str(ocurr, req->current_ap, ETH_ALEN, ':'),
-		         mac2str(mgmt->addr3), le16_to_cpu(req->capability), dev->obuf,
-		         hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
-			    '\0'));
+		         le16_to_cpu(tx_buffer->wlength),
+		         tx_buffer->padding, tx_buffer->tx_rate,
+		         hex2str(dev->obuf, i802_11_hdr,
+			    min((sizeof(dev->obuf) - 1) / 2,
+				sizeof(struct ieee80211_hdr_3addr)), '\0'));
+		at76_dbg(DBG_TX_DATA_CONTENT, "%s payload %s", dev->netdev->name,
+		         hex2str(dev->obuf, payload,
+			    min((int)(sizeof(dev->obuf) - 1) / 2, 48), '\0'));
 	}
 
-	/* either send immediately (if no data tx is pending
-	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	/* send stuff */
+	netif_stop_queue(netdev);
+	netdev->trans_start = jiffies;
+
+	usb_fill_bulk_urb(dev->write_urb, dev->udev,
+		         usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),
+		         tx_buffer, submit_len,
+		         at76_write_bulk_callback, dev);
+	ret = usb_submit_urb(dev->write_urb, GFP_ATOMIC);
+	if (ret) {
+		stats->tx_errors++;
+		err("%s: error in tx submit urb: %d", netdev->name, ret);
+		if (ret == -EINVAL)
+			err("-EINVAL: urb %p urb->hcpriv %p urb->complete %p",
+			    dev->write_urb,
+			    dev->write_urb ? dev->write_urb->hcpriv : (void *)-1,
+			    dev->write_urb ? dev->write_urb->complete : (void *)-1);
+		goto err;
+	}
+
+	stats->tx_bytes += skb->len;
+
+	dev_kfree_skb(skb);
+	return 0;
 
+ err:
+	return ret;
 }
 
-/* Called after successful association */
-static void at76_work_assoc_done(struct work_struct *work)
+
+static void at76_tx_timeout(struct net_device *netdev)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
-					     work_assoc_done);
+	struct at76_priv *dev = netdev_priv(netdev);
 
-	down(&dev->sem);
+	if (!dev)
+		return;
+	warn("%s: tx timeout.", netdev->name);
 
-	at76_assert(dev->istate == ASSOCIATING || dev->istate == REASSOCIATING);
-	if (dev->iw_mode == IW_MODE_INFRA) {
-		at76_assert(dev->curr_bss != NULL);
-		if (dev->curr_bss != NULL && dev->pm_mode != AT76_PM_OFF) {
-			/* calculate the listen interval in units of
-			   beacon intervals of the curr_bss */
-			u32 pm_period_beacon = (dev->pm_period >> 10) /
-						dev->curr_bss->beacon_interval;
+	usb_unlink_urb(dev->write_urb);
+	dev->stats.tx_errors++;
+}
 
-			pm_period_beacon = max(pm_period_beacon, 2u);
-			pm_period_beacon = min(pm_period_beacon, 0xffffu);
 
-			at76_dbg(DBG_PM, "%s: pm_mode %d assoc id x%x listen int %d",
-			         dev->netdev->name, dev->pm_mode,
-			         dev->curr_bss->assoc_id, pm_period_beacon);
+static int at76_submit_rx_urb(struct at76_priv *dev)
+{
+	int ret, size;
+	struct sk_buff *skb = dev->rx_skb;
 
-			at76_set_associd(dev, dev->curr_bss->assoc_id);
-			at76_set_listen_interval(dev, (u16)pm_period_beacon);
+	if (dev->read_urb == NULL) {
+		err("%s: dev->read_urb is NULL", __FUNCTION__);
+		return -EFAULT;
+	}
+
+	if (skb == NULL) {
+		skb = dev_alloc_skb(sizeof(struct at76_rx_buffer));
+		if (skb == NULL) {
+			err("%s: unable to allocate rx skbuff.", dev->netdev->name);
+			ret = -ENOMEM;
+			goto exit;
+		}
+		dev->rx_skb = skb;
+	} else {
+		skb_push(skb, skb_headroom(skb));
+		skb_trim(skb, 0);
+	}
+
+	size = skb_tailroom(skb);
+	usb_fill_bulk_urb(dev->read_urb, dev->udev,
+		         usb_rcvbulkpipe(dev->udev, dev->bulk_in_endpointAddr),
+		         skb_put(skb, size), size,
+		         at76_read_bulk_callback, dev);
+	ret = usb_submit_urb(dev->read_urb, GFP_ATOMIC);
+	if (ret < 0) {
+		if (ret == -ENODEV)
+			at76_dbg(DBG_DEVSTART, "usb_submit_urb returned -ENODEV");
+		else
+			err("%s: rx, usb_submit_urb failed: %d", dev->netdev->name, ret);
+	}
+
+exit:
+	if (ret < 0) {
+		if (ret != -ENODEV) {
+			/* If we can't submit the URB, the adapter becomes completely
+			 * useless, so try again later */
+			if (--dev->nr_submit_rx_tries > 0)
+				schedule_work(&dev->work_submit_rx);
+			else {
+				err("%s: giving up to submit rx urb after %d failures -"
+			    	    " please unload the driver and/or power cycle the device",
+			    	    dev->netdev->name, NR_SUBMIT_RX_TRIES);
+			}
+		}
+	} else
+		/* reset counter to initial value */
+		dev->nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;
+	return ret;
+}
+
+
+static int at76_open(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = 0;
+
+	at76_dbg(DBG_PROC_ENTRY, "at76_open entry");
+
+	if (down_interruptible(&dev->sem))
+		return -EINTR;
+
+	/* if netdev->dev_addr != dev->mac_addr we must
+	   set the mac address in the device ! */
+	if (compare_ether_addr(netdev->dev_addr, dev->mac_addr)) {
+		if (at76_add_mac_address(dev, netdev->dev_addr) >= 0)
+			at76_dbg(DBG_PROGRESS, "%s: set new MAC addr %s",
+			         netdev->name, mac2str(netdev->dev_addr));
+	}
 #ifdef DEBUG
-			at76_dump_mib_mac(dev);
-			at76_dump_mib_mac_mgmt(dev);
+	at76_dump_mib_mac_addr(dev);
 #endif
-		}
+
+	dev->scan_state = SCAN_IDLE;
+	dev->last_scan = jiffies;
+	dev->nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;	/* init counter */
+
+	if ((ret = at76_submit_rx_urb(dev)) < 0) {
+		err("%s: open: submit_rx_urb failed: %d", netdev->name, ret);
+		goto err;
 	}
-	at76_set_pm_mode(dev);
 
-	netif_carrier_on(dev->netdev);
-	netif_wake_queue(dev->netdev);
-	dev->istate = CONNECTED;
-	at76_iwevent_bss_connect(dev->netdev, dev->curr_bss->bssid);
-	at76_dbg(DBG_PROGRESS, "%s: connected to BSSID %s",
-	         dev->netdev->name, mac2str(dev->curr_bss->bssid));
+	dev->open_count++;
+
+	schedule_work(&dev->work_restart);
+
+	at76_dbg(DBG_PROC_ENTRY, "at76_open end");
+ err:
+	up(&dev->sem);
+	return ret < 0 ? ret : 0;
+}
+
+
+static int at76_stop(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	unsigned long flags;
+
+	at76_dbg(DBG_DEVSTART, "%s: ENTER", __FUNCTION__);
+
+	if (down_interruptible(&dev->sem))
+		return -EINTR;
+
+	netif_stop_queue(netdev);
+
+	dev->istate = INIT;
+
+	if (!(dev->device_unplugged)) {
+		/* we are called by "ifconfig ethX down", not because the
+		   device isn't avail. anymore */
+		at76_set_radio(dev, 0);
+
+		/* we unlink the read urb, because the _open()
+		   submits it again. _delete_device() takes care of the
+		   read_urb otherwise. */
+		usb_kill_urb(dev->read_urb);
+	}
+
+	del_timer_sync(&dev->mgmt_timer);
+
+	spin_lock_irqsave(&dev->mgmt_spinlock, flags);
+	if (dev->next_mgmt_bulk) {
+		kfree(dev->next_mgmt_bulk);
+		dev->next_mgmt_bulk = NULL;
+	}
+	spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
+
+	/* free the bss_list */
+	at76_free_bss_list(dev);
+
+	at76_assert(dev->open_count > 0);
+	dev->open_count--;
 
 	up(&dev->sem);
+	at76_dbg(DBG_DEVSTART, "%s: EXIT", __FUNCTION__);
+
+	return 0;
+}
+
+
+static void at76_ethtool_get_drvinfo(struct net_device *netdev,
+					 struct ethtool_drvinfo *info)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	strncpy(info->driver, DRIVER_NAME, sizeof(info->driver) - 1);
+
+	strncpy(info->version, DRIVER_VERSION, sizeof(info->version));
+	info->version[sizeof(info->version) - 1] = '\0';
+
+	snprintf(info->bus_info, sizeof(info->bus_info) - 1, "usb%d:%d",
+		 dev->udev->bus->busnum, dev->udev->devnum);
+
+	snprintf(info->fw_version, sizeof(info->fw_version) - 1,
+		 "%d.%d.%d-%d",
+		 dev->fw_version.major, dev->fw_version.minor,
+		 dev->fw_version.patch, dev->fw_version.build);
+}
+
+
+static u32 at76_ethtool_get_link(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	return dev->istate == CONNECTED;
 }
 
+
+static struct ethtool_ops at76_ethtool_ops = {
+	.get_drvinfo = at76_ethtool_get_drvinfo,
+	.get_link = at76_ethtool_get_link,
+};
+
+
+/**
+ * at76_init_new_device - continue device initialization after firmware download
+ *
+ * FIXME: We may have to move the register_netdev into at76_alloc_new_device,
+ * because hotplug may try to configure the netdev _before_ (or parallel to)
+ * the download of firmware
+ */
+static int at76_init_new_device(struct at76_priv *dev)
+{
+	struct net_device *netdev = dev->netdev;
+	int ret;
+
+	/* set up the endpoint information */
+	/* check out the endpoints */
+
+	dev->interface = dev->udev->actconfig->interface[0];
+
+	at76_dbg(DBG_DEVSTART, "USB interface: %d endpoints",
+	         dev->interface->cur_altsetting->desc.bNumEndpoints);
+
+	if ((ret = at76_alloc_urbs(dev)) < 0)
+		goto error;
+
+	/* get firmware version */
+	ret = at76_get_mib(dev->udev, MIB_FW_VERSION, &dev->fw_version,
+			   sizeof(dev->fw_version));
+	if ((ret < 0) || ((dev->fw_version.major == 0) &&
+			  (dev->fw_version.minor == 0) &&
+			  (dev->fw_version.patch == 0) &&
+			  (dev->fw_version.build == 0))) {
+		err("getting firmware failed with %d, or version is 0", ret);
+		err("this probably means that the ext. fw was not loaded correctly");
+		if(ret >= 0)
+			ret = -ENODEV;
+		goto error;
+	}
+
+	/* fw 0.84 doesn't send FCS with rx data */
+	if (dev->fw_version.major == 0 && dev->fw_version.minor <= 84)
+		dev->rx_data_fcs_len = 0;
+	else
+		dev->rx_data_fcs_len = 4;
+
+	info("firmware version %d.%d.%d #%d (fcs_len %d)",
+	     dev->fw_version.major, dev->fw_version.minor,
+	     dev->fw_version.patch, dev->fw_version.build,
+	     dev->rx_data_fcs_len);
+
+	/* MAC address */
+	ret = at76_get_hw_config(dev);
+	if (ret < 0) {
+		err("could not get MAC address");
+		goto error;
+	}
+
+	dev->domain = at76_get_reg_domain(dev->regulatory_domain);
+	/* init. netdev->dev_addr */
+	memcpy(netdev->dev_addr, dev->mac_addr, ETH_ALEN);
+	info("device's MAC %s, regulatory domain %s (id %d)",
+	     mac2str(dev->mac_addr), dev->domain->name, dev->regulatory_domain);
+
+	/* initializing */
+	dev->international_roaming = international_roaming;
+	dev->channel = DEF_CHANNEL;
+	dev->iw_mode = default_iw_mode;
+	memset(dev->essid, 0, IW_ESSID_MAX_SIZE);
+	dev->rts_threshold = DEF_RTS_THRESHOLD;
+	dev->frag_threshold = DEF_FRAG_THRESHOLD;
+	dev->short_retry_limit = DEF_SHORT_RETRY_LIMIT;
+	dev->txrate = TX_RATE_AUTO;
+	dev->preamble_type = preamble_type;
+	dev->beacon_period = 100;
+	dev->beacons_last_qual = jiffies_to_msecs(jiffies);
+	dev->auth_mode = auth_mode ? WLAN_AUTH_SHARED_KEY : WLAN_AUTH_OPEN;
+	dev->scan_min_time = scan_min_time;
+	dev->scan_max_time = scan_max_time;
+	dev->scan_mode = scan_mode;
+	dev->monitor_scan_min_time = monitor_scan_min_time;
+	dev->monitor_scan_max_time = monitor_scan_max_time;
+
+	netdev->flags &= ~IFF_MULTICAST; /* not yet or never */
+	netdev->open = at76_open;
+	netdev->stop = at76_stop;
+	netdev->get_stats = at76_get_stats;
+	netdev->ethtool_ops = &at76_ethtool_ops;
+
+	/* Add pointers to enable iwspy support. */
+	dev->wireless_data.spy_data = &dev->spy_data;
+	netdev->wireless_data = &dev->wireless_data;
+
+	netdev->hard_start_xmit = at76_tx;
+	netdev->tx_timeout = at76_tx_timeout;
+	netdev->watchdog_timeo = 2 * HZ;
+	netdev->wireless_handlers = &at76_handler_def;
+	netdev->set_multicast_list = at76_set_multicast;
+	netdev->set_mac_address = at76_set_mac_address;
+
+	ret = register_netdev(dev->netdev);
+	if (ret) {
+		err("unable to register netdevice %s (status %d)!",
+		    dev->netdev->name, ret);
+		goto error;
+	}
+	info("registered %s", dev->netdev->name);
+	dev->netdev_registered = 1;
+
+	/* we let this timer run the whole time this driver instance lives */
+	mod_timer(&dev->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
+
+	return 0;
+ error:
+	at76_delete_device(dev);
+	return ret;
+}
+
+
 /* Download external firmware */
 static void at76_work_external_fw(struct work_struct *work)
 {
@@ -2226,6 +4300,7 @@ static void at76_work_external_fw(struct work_struct *work)
 	up(&dev->sem);
 }
 
+
 /* Download internal firmware */
 static void at76_work_internal_fw(struct work_struct *work)
 {
@@ -2262,6 +4337,133 @@ static void at76_work_internal_fw(struct work_struct *work)
 	up(&dev->sem);
 }
 
+
+static int at76_essid_matched(struct at76_priv *dev, struct bss_info *ptr)
+{
+	/* common criteria for both modi */
+
+	int ret = (dev->essid_size == 0 /* ANY ssid */  ||
+		      (dev->essid_size == ptr->ssid_len &&
+		       !memcmp(dev->essid, ptr->ssid, ptr->ssid_len)));
+	if (!ret)
+		at76_dbg(DBG_BSS_MATCH, "%s bss table entry %p: essid didn't match",
+		         dev->netdev->name, ptr);
+	return ret;
+}
+
+
+static inline int at76_mode_matched(struct at76_priv *dev, struct bss_info *ptr)
+{
+	int ret;
+
+	if (dev->iw_mode == IW_MODE_ADHOC)
+		ret = ptr->capa & WLAN_CAPABILITY_IBSS;
+	else
+		ret = ptr->capa & WLAN_CAPABILITY_ESS;
+	if (!ret)
+		at76_dbg(DBG_BSS_MATCH, "%s bss table entry %p: mode didn't match",
+		         dev->netdev->name, ptr);
+	return ret;
+}
+
+
+static int at76_rates_matched(struct at76_priv *dev, struct bss_info *ptr)
+{
+	int i;
+	u8 *rate;
+
+	for (i = 0, rate = ptr->rates; i < ptr->rates_len; i++, rate++)
+		if (*rate & 0x80) {
+			/* this is a basic rate we have to support
+			   (see IEEE802.11, ch. 7.3.2.2) */
+			if (*rate != (0x80 | hw_rates[0])
+			    && *rate != (0x80 | hw_rates[1])
+			    && *rate != (0x80 | hw_rates[2])
+			    && *rate != (0x80 | hw_rates[3])) {
+				at76_dbg(DBG_BSS_MATCH,
+				         "%s: bss table entry %p: basic rate %02x not supported",
+				         dev->netdev->name, ptr, *rate);
+				return 0;
+			}
+		}
+	/* if we use short preamble, the bss must support it */
+	if (dev->preamble_type == PREAMBLE_TYPE_SHORT &&
+	    !(ptr->capa & WLAN_CAPABILITY_SHORT_PREAMBLE)) {
+		at76_dbg(DBG_BSS_MATCH, "%s: %p does not support short preamble",
+		         dev->netdev->name, ptr);
+		return 0;
+	} else
+		return 1;
+}
+
+
+static inline int at76_wep_matched(struct at76_priv *dev, struct bss_info *ptr)
+{
+	if (!dev->wep_enabled && ptr->capa & WLAN_CAPABILITY_PRIVACY) {
+		/* we have disabled WEP, but the BSS signals privacy */
+		at76_dbg(DBG_BSS_MATCH, "%s: bss table entry %p: requires encryption",
+		         dev->netdev->name, ptr);
+		return 0;
+	}
+	/* otherwise if the BSS does not signal privacy it may well
+	   accept encrypted packets from us ... */
+	return 1;
+}
+
+
+static inline int at76_bssid_matched(struct at76_priv *dev,
+				     struct bss_info *ptr)
+{
+	if (!dev->wanted_bssid_valid ||
+	    !compare_ether_addr(ptr->bssid, dev->wanted_bssid)) {
+		return 1;
+	} else {
+		at76_dbg(DBG_BSS_MATCH, "%s: requested bssid - %s does not match",
+			 dev->netdev->name, mac2str(dev->wanted_bssid));
+		at76_dbg(DBG_BSS_MATCH, "      AP bssid - %s of bss table entry %p",
+			 mac2str(ptr->bssid), ptr);
+		return 0;
+	}
+}
+
+
+/**
+ * at76_match_bss - try to find a matching bss in dev->bss
+ *
+ * last - last bss tried
+ *
+ * last == NULL signals a new round starting with dev->bss_list.next
+ * this function must be called inside an acquired dev->bss_list_spinlock
+ * otherwise the timeout on bss may remove the newly chosen entry
+ */
+static struct bss_info *at76_match_bss(struct at76_priv *dev,
+				       struct bss_info *last)
+{
+	struct bss_info *ptr = NULL;
+	struct list_head *curr;
+
+	curr = last != NULL ? last->list.next : dev->bss_list.next;
+	while (curr != &dev->bss_list) {
+		ptr = list_entry(curr, struct bss_info, list);
+		if (at76_essid_matched(dev, ptr) &&
+		    at76_mode_matched(dev, ptr) &&
+		    at76_wep_matched(dev, ptr) &&
+		    at76_rates_matched(dev, ptr) &&
+		    at76_bssid_matched(dev, ptr))
+			break;
+		curr = curr->next;
+	}
+
+	if (curr == &dev->bss_list)
+		ptr = NULL;
+	/* otherwise ptr points to the struct bss_info we have chosen */
+
+	at76_dbg(DBG_BSS_TABLE, "%s %s: returned %p", dev->netdev->name,
+	         __FUNCTION__, ptr);
+	return ptr;
+}
+
+
 /* Try joining a BSS */
 static void at76_work_join(struct work_struct *work)
 {
@@ -2345,6 +4547,7 @@ static void at76_work_join(struct work_struct *work)
 	up(&dev->sem);
 }
 
+
 static void at76_work_mgmt_timeout(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2355,6 +4558,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 	up(&dev->sem);
 }
 
+
 static void at76_work_new_bss(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2390,6 +4594,7 @@ static void at76_work_new_bss(struct work_struct *work)
 	up(&dev->sem);
 }
 
+
 static void at76_work_reset_device(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2401,6 +4606,150 @@ static void at76_work_reset_device(struct work_struct *work)
 	up(&dev->sem);
 }
 
+
+static int at76_startup_device(struct at76_priv *dev)
+{
+	struct at76_card_config *ccfg = &dev->card_config;
+	int ret;
+
+	if (at76_debug & DBG_PARAMS) {
+		char ossid[IW_ESSID_MAX_SIZE + 1];
+
+		/* make dev->essid printable */
+		at76_assert(dev->essid_size <= IW_ESSID_MAX_SIZE);
+		memcpy(ossid, dev->essid, dev->essid_size);
+		ossid[dev->essid_size] = '\0';
+
+		dbg("%s param: ssid %s (%s) mode %s ch %d wep %s key %d keylen %d",
+		       dev->netdev->name, ossid,
+		       hex2str(dev->obuf, dev->essid,
+			       min((int)(sizeof(dev->obuf)-1)/2,
+				   IW_ESSID_MAX_SIZE), '\0'),
+		       dev->iw_mode == IW_MODE_ADHOC ? "adhoc" : "infra",
+		       dev->channel,
+		       dev->wep_enabled ? "enabled" : "disabled",
+		       dev->wep_key_id, dev->wep_keys_len[dev->wep_key_id]);
+		dbg("%s param: preamble %s rts %d retry %d frag %d "
+		       "txrate %s auth_mode %d",
+		       dev->netdev->name,
+		       dev->preamble_type == PREAMBLE_TYPE_SHORT ? "short" : "long",
+		       dev->rts_threshold, dev->short_retry_limit,
+		       dev->frag_threshold,
+		       dev->txrate == TX_RATE_1MBIT ? "1MBit" :
+		       dev->txrate == TX_RATE_2MBIT ? "2MBit" :
+		       dev->txrate == TX_RATE_5_5MBIT ? "5.5MBit" :
+		       dev->txrate == TX_RATE_11MBIT ? "11MBit" :
+		       dev->txrate == TX_RATE_AUTO ? "auto" : "<invalid>",
+		       dev->auth_mode);
+		dbg("%s param: pm_mode %d pm_period %d auth_mode %s "
+		       "scan_times %d %d scan_mode %s international_roaming %d",
+		       dev->netdev->name,
+		       dev->pm_mode, dev->pm_period,
+		       dev->auth_mode == WLAN_AUTH_OPEN ?
+		       "open" : "shared_secret",
+		       dev->scan_min_time, dev->scan_max_time,
+		       dev->scan_mode == SCAN_TYPE_ACTIVE ? "active" : "passive",
+		       dev->international_roaming);
+	}
+
+	memset(ccfg, 0, sizeof(struct at76_card_config));
+	ccfg->promiscuous_mode = 0;
+	ccfg->short_retry_limit = dev->short_retry_limit;
+
+	if (dev->wep_enabled) {
+		if (dev->wep_keys_len[dev->wep_key_id] > WEP_SMALL_KEY_LEN)
+			ccfg->encryption_type = 2;
+		else
+			ccfg->encryption_type = 1;
+
+		/* jal: always exclude unencrypted if WEP is active */
+		ccfg->exclude_unencrypted = 1;
+	} else {
+		ccfg->exclude_unencrypted = 0;
+		ccfg->encryption_type = 0;
+	}
+
+	ccfg->rts_threshold = cpu_to_le16(dev->rts_threshold);
+	ccfg->fragmentation_threshold = cpu_to_le16(dev->frag_threshold);
+
+	memcpy(ccfg->basic_rate_set, hw_rates, 4);
+	/* jal: really needed, we do a set_mib for autorate later ??? */
+	ccfg->auto_rate_fallback = (dev->txrate == TX_RATE_AUTO ? 1 : 0);
+	ccfg->channel = dev->channel;
+	ccfg->privacy_invoked = dev->wep_enabled;
+	memcpy(ccfg->current_ssid, dev->essid, IW_ESSID_MAX_SIZE);
+	ccfg->ssid_len = dev->essid_size;
+
+	ccfg->wep_default_key_id = dev->wep_key_id;
+	memcpy(ccfg->wep_default_key_value, dev->wep_keys, 4 * WEP_KEY_LEN);
+
+	ccfg->short_preamble = dev->preamble_type;
+	ccfg->beacon_period = cpu_to_le16(dev->beacon_period);
+
+	ret = at76_set_card_command(dev->udev, CMD_STARTUP, &dev->card_config,
+			            sizeof(struct at76_card_config));
+	if (ret < 0) {
+		err("%s: at76_set_card_command failed: %d", dev->netdev->name, ret);
+		return ret;
+	}
+
+	at76_wait_completion(dev, CMD_STARTUP);
+
+	/* remove BSSID from previous run */
+	memset(dev->bssid, 0, ETH_ALEN);
+
+	if (at76_set_radio(dev, 1) == 1)
+		at76_wait_completion(dev, CMD_RADIO);
+
+	if ((ret = at76_set_preamble(dev, dev->preamble_type)) < 0)
+		return ret;
+
+	if ((ret = at76_set_frag(dev, dev->frag_threshold)) < 0)
+		return ret;
+
+	if ((ret = at76_set_rts(dev, dev->rts_threshold)) < 0)
+		return ret;
+
+	if ((ret = at76_set_autorate_fallback(dev, dev->txrate == TX_RATE_AUTO ? 1 : 0)) < 0)
+		return ret;
+
+	if ((ret = at76_set_pm_mode(dev)) < 0)
+		return ret;
+
+	if ((ret = at76_set_iroaming(dev, dev->international_roaming)) < 0)
+		return ret;
+
+	if (at76_debug & DBG_MIB) {
+		at76_dump_mib_mac(dev);
+		at76_dump_mib_mac_addr(dev);
+		at76_dump_mib_mac_mgmt(dev);
+		at76_dump_mib_mac_wep(dev);
+		at76_dump_mib_mdomain(dev);
+		at76_dump_mib_phy(dev);
+		at76_dump_mib_local(dev);
+	}
+
+	return 0;
+}
+
+
+/**
+ * set_monitor_mode - sets dev->netdev->type
+ */
+static void at76_set_monitor_mode(struct at76_priv *dev)
+{
+	if (dev->iw_mode == IW_MODE_MONITOR) {
+		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE ON",
+			 dev->netdev->name);
+		dev->netdev->type = ARPHRD_IEEE80211_RADIOTAP;
+	} else {
+		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE OFF",
+		         dev->netdev->name);
+		dev->netdev->type = ARPHRD_ETHER;
+	}
+}
+
+
 static void at76_work_restart(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2429,6 +4778,7 @@ static void at76_work_restart(struct work_struct *work)
 	up(&dev->sem);
 }
 
+
 static void at76_work_scan(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2456,6 +4806,7 @@ static void at76_work_scan(struct work_struct *work)
 	up(&dev->sem);
 }
 
+
 static void at76_work_set_promisc(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2478,6 +4829,7 @@ static void at76_work_set_promisc(struct work_struct *work)
 	up(&dev->sem);
 }
 
+
 static void at76_work_start_ibss(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2526,6 +4878,7 @@ static void at76_work_start_ibss(struct work_struct *work)
 	up(&dev->sem);
 }
 
+
 static void at76_work_submit_rx(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2536,159 +4889,10 @@ static void at76_work_submit_rx(struct work_struct *work)
 	up(&dev->sem);
 }
 
-static int at76_essid_matched(struct at76_priv *dev, struct bss_info *ptr)
-{
-	/* common criteria for both modi */
-
-	int ret = (dev->essid_size == 0 /* ANY ssid */  ||
-		      (dev->essid_size == ptr->ssid_len &&
-		       !memcmp(dev->essid, ptr->ssid, ptr->ssid_len)));
-	if (!ret)
-		at76_dbg(DBG_BSS_MATCH, "%s bss table entry %p: essid didn't match",
-		         dev->netdev->name, ptr);
-	return ret;
-}
-
-static inline int at76_mode_matched(struct at76_priv *dev, struct bss_info *ptr)
-{
-	int ret;
-
-	if (dev->iw_mode == IW_MODE_ADHOC)
-		ret = ptr->capa & WLAN_CAPABILITY_IBSS;
-	else
-		ret = ptr->capa & WLAN_CAPABILITY_ESS;
-	if (!ret)
-		at76_dbg(DBG_BSS_MATCH, "%s bss table entry %p: mode didn't match",
-		         dev->netdev->name, ptr);
-	return ret;
-}
-
-static int at76_rates_matched(struct at76_priv *dev, struct bss_info *ptr)
-{
-	int i;
-	u8 *rate;
-
-	for (i = 0, rate = ptr->rates; i < ptr->rates_len; i++, rate++)
-		if (*rate & 0x80) {
-			/* this is a basic rate we have to support
-			   (see IEEE802.11, ch. 7.3.2.2) */
-			if (*rate != (0x80 | hw_rates[0])
-			    && *rate != (0x80 | hw_rates[1])
-			    && *rate != (0x80 | hw_rates[2])
-			    && *rate != (0x80 | hw_rates[3])) {
-				at76_dbg(DBG_BSS_MATCH,
-				         "%s: bss table entry %p: basic rate %02x not supported",
-				         dev->netdev->name, ptr, *rate);
-				return 0;
-			}
-		}
-	/* if we use short preamble, the bss must support it */
-	if (dev->preamble_type == PREAMBLE_TYPE_SHORT &&
-	    !(ptr->capa & WLAN_CAPABILITY_SHORT_PREAMBLE)) {
-		at76_dbg(DBG_BSS_MATCH, "%s: %p does not support short preamble",
-		         dev->netdev->name, ptr);
-		return 0;
-	} else
-		return 1;
-}
-
-static inline int at76_wep_matched(struct at76_priv *dev, struct bss_info *ptr)
-{
-	if (!dev->wep_enabled && ptr->capa & WLAN_CAPABILITY_PRIVACY) {
-		/* we have disabled WEP, but the BSS signals privacy */
-		at76_dbg(DBG_BSS_MATCH, "%s: bss table entry %p: requires encryption",
-		         dev->netdev->name, ptr);
-		return 0;
-	}
-	/* otherwise if the BSS does not signal privacy it may well
-	   accept encrypted packets from us ... */
-	return 1;
-}
-
-static inline int at76_bssid_matched(struct at76_priv *dev, struct bss_info *ptr)
-{
-	if (!dev->wanted_bssid_valid ||
-	    !compare_ether_addr(ptr->bssid, dev->wanted_bssid)) {
-		return 1;
-	} else {
-		at76_dbg(DBG_BSS_MATCH, "%s: requested bssid - %s does not match",
-			 dev->netdev->name, mac2str(dev->wanted_bssid));
-		at76_dbg(DBG_BSS_MATCH, "      AP bssid - %s of bss table entry %p",
-			 mac2str(ptr->bssid), ptr);
-		return 0;
-	}
-}
-
-static void at76_dump_bss_table(struct at76_priv *dev)
-{
-	struct bss_info *ptr;
-	unsigned long flags;
-	struct list_head *lptr;
-	char obuf_s[3*32];
-
-	spin_lock_irqsave(&dev->bss_list_spinlock, flags);
-
-	pr_debug("%s BSS table (curr=%p, new=%p):", dev->netdev->name,
-	         dev->curr_bss, dev->new_bss);
-
-	list_for_each(lptr, &dev->bss_list) {
-		ptr = list_entry(lptr, struct bss_info, list);
-		pr_debug("0x%p: bssid %s channel %d ssid %s (%s)"
-		         " capa x%04x rates %s rssi %d link %d noise %d",
-		         ptr, mac2str(ptr->bssid),
-		         ptr->channel,
-		         ptr->ssid,
-		         hex2str(dev->obuf, ptr->ssid,
-			       min((sizeof(dev->obuf) - 1) / 2,
-				   (size_t) ptr->ssid_len), '\0'),
-		         ptr->capa,
-		         hex2str(obuf_s, ptr->rates,
-			       min(sizeof(obuf_s) / 3,
-				   (size_t) ptr->rates_len), ' '),
-		         ptr->rssi, ptr->link_qual, ptr->noise_level);
-	}
-	spin_unlock_irqrestore(&dev->bss_list_spinlock, flags);
-}
-
-/**
- * at76_match_bss - try to find a matching bss in dev->bss
- *
- * last - last bss tried
- *
- * last == NULL signals a new round starting with dev->bss_list.next
- * this function must be called inside an acquired dev->bss_list_spinlock
- * otherwise the timeout on bss may remove the newly chosen entry
- */
-static struct bss_info *at76_match_bss(struct at76_priv *dev,
-					  struct bss_info *last)
-{
-	struct bss_info *ptr = NULL;
-	struct list_head *curr;
-
-	curr = last != NULL ? last->list.next : dev->bss_list.next;
-	while (curr != &dev->bss_list) {
-		ptr = list_entry(curr, struct bss_info, list);
-		if (at76_essid_matched(dev, ptr) &&
-		    at76_mode_matched(dev, ptr) &&
-		    at76_wep_matched(dev, ptr) &&
-		    at76_rates_matched(dev, ptr) &&
-		    at76_bssid_matched(dev, ptr))
-			break;
-		curr = curr->next;
-	}
-
-	if (curr == &dev->bss_list)
-		ptr = NULL;
-	/* otherwise ptr points to the struct bss_info we have chosen */
-
-	at76_dbg(DBG_BSS_TABLE, "%s %s: returned %p", dev->netdev->name,
-	         __FUNCTION__, ptr);
-	return ptr;
-}
-
 
 /* we got an association response */
-static void at76_rx_mgmt_assoc(struct at76_priv *dev, struct at76_rx_buffer *buf)
+static void at76_rx_mgmt_assoc(struct at76_priv *dev,
+			       struct at76_rx_buffer *buf)
 {
 	struct ieee80211_assoc_response *resp =
 	    (struct ieee80211_assoc_response *)buf->packet;
@@ -2728,7 +4932,7 @@ static void at76_rx_mgmt_assoc(struct at76_priv *dev, struct at76_rx_buffer *buf
 
 
 static void at76_rx_mgmt_reassoc(struct at76_priv *dev,
-			    struct at76_rx_buffer *buf)
+				 struct at76_rx_buffer *buf)
 {
 	struct ieee80211_assoc_response *resp =
 	    (struct ieee80211_assoc_response *)buf->packet;
@@ -2782,7 +4986,7 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *dev,
 
 
 static void at76_rx_mgmt_disassoc(struct at76_priv *dev,
-			     struct at76_rx_buffer *buf)
+				  struct at76_rx_buffer *buf)
 {
 	struct ieee80211_disassoc *resp =
 	    (struct ieee80211_disassoc *)buf->packet;
@@ -2901,7 +5105,8 @@ static void at76_rx_mgmt_auth(struct at76_priv *dev, struct at76_rx_buffer *buf)
 }
 
 
-static void at76_rx_mgmt_deauth(struct at76_priv *dev, struct at76_rx_buffer *buf)
+static void at76_rx_mgmt_deauth(struct at76_priv *dev,
+				struct at76_rx_buffer *buf)
 {
 	struct ieee80211_disassoc *resp =
 	    (struct ieee80211_disassoc *)buf->packet;
@@ -2943,7 +5148,8 @@ static void at76_rx_mgmt_deauth(struct at76_priv *dev, struct at76_rx_buffer *bu
 }
 
 
-static void at76_rx_mgmt_beacon(struct at76_priv *dev, struct at76_rx_buffer *buf)
+static void at76_rx_mgmt_beacon(struct at76_priv *dev,
+				struct at76_rx_buffer *buf)
 {
 	/* beacon content */
 	struct ieee80211_beacon *bdata = (struct ieee80211_beacon *)buf->packet;
@@ -3125,7 +5331,7 @@ rx_mgmt_beacon_end:
 
 /* calc the link level from a given rx_buffer */
 static void at76_calc_level(struct at76_priv *dev, struct at76_rx_buffer *buf,
-		       struct iw_quality *qual)
+			    struct iw_quality *qual)
 {
 	int max_rssi = 42;	/* just a guess for now, might be different for other chips */
 
@@ -3137,7 +5343,8 @@ static void at76_calc_level(struct at76_priv *dev, struct at76_rx_buffer *buf,
 
 
 /* calc the link quality from a given rx_buffer */
-static void at76_calc_qual(struct at76_priv *dev, struct at76_rx_buffer *buf, struct iw_quality* qual)
+static void at76_calc_qual(struct at76_priv *dev, struct at76_rx_buffer *buf,
+			   struct iw_quality* qual)
 {
 	if ((dev->board_type == BOARDTYPE_503_INTERSIL_3861) ||
 	    (dev->board_type == BOARDTYPE_503_INTERSIL_3863)) {
@@ -3160,15 +5367,18 @@ static void at76_calc_qual(struct at76_priv *dev, struct at76_rx_buffer *buf, st
 	qual->updated |= IW_QUAL_QUAL_UPDATED;
 }
 
+
 /* calc the noise quality from a given rx_buffer */
 static void at76_calc_noise(struct at76_priv *dev, struct at76_rx_buffer *buf,
-		       struct iw_quality *qual)
+			    struct iw_quality *qual)
 {
 	qual->noise = 0;
 	qual->updated |= IW_QUAL_NOISE_INVALID;
 }
 
-static void at76_update_wstats(struct at76_priv *dev, struct at76_rx_buffer *buf)
+
+static void at76_update_wstats(struct at76_priv *dev,
+			       struct at76_rx_buffer *buf)
 {
 	struct iw_quality *qual = &dev->wstats.qual;
 
@@ -3185,6 +5395,7 @@ static void at76_update_wstats(struct at76_priv *dev, struct at76_rx_buffer *buf
 	}
 }
 
+
 static void at76_rx_mgmt(struct at76_priv *dev, struct at76_rx_buffer *buf)
 {
 	struct ieee80211_hdr_3addr *mgmt =
@@ -3244,6 +5455,7 @@ static void at76_rx_mgmt(struct at76_priv *dev, struct at76_rx_buffer *buf)
 	return;
 }
 
+
 static void at76_dbg_dumpbuf(const char *tag, const u8 *buf, int size)
 {
 	int i;
@@ -3262,53 +5474,6 @@ static void at76_dbg_dumpbuf(const char *tag, const u8 *buf, int size)
 	pr_debug("\n");
 }
 
-/* A short overview on Ethernet-II, 802.2, 802.3 and SNAP
-   (taken from http://www.geocities.com/billalexander/ethernet.html):
-
-Ethernet Frame Formats:
-
-Ethernet (a.k.a. Ethernet II)
-
-        +---------+---------+---------+----------
-        |   Dst   |   Src   |  Type   |  Data...
-        +---------+---------+---------+----------
-
-         <-- 6 --> <-- 6 --> <-- 2 --> <-46-1500->
-
-         Type 0x80 0x00 = TCP/IP
-         Type 0x06 0x00 = XNS
-         Type 0x81 0x37 = Novell NetWare
-
-
-802.3
-
-        +---------+---------+---------+----------
-        |   Dst   |   Src   | Length  | Data...
-        +---------+---------+---------+----------
-
-         <-- 6 --> <-- 6 --> <-- 2 --> <-46-1500->
-
-802.2 (802.3 with 802.2 header)
-
-        +---------+---------+---------+-------+-------+-------+----------
-        |   Dst   |   Src   | Length  | DSAP  | SSAP  |Control| Data...
-        +---------+---------+---------+-------+-------+-------+----------
-
-                                       <- 1 -> <- 1 -> <- 1 -> <-43-1497->
-
-SNAP (802.3 with 802.2 and SNAP headers)
-
-        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
-        |   Dst   |   Src   | Length  | 0xAA  | 0xAA  | 0x03  |  Org Code |   Type  | Data...
-        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
-
-                                                               <--  3  --> <-- 2 --> <-38-1492->
-
-*/
-static const u8 snapsig[] = { 0xaa, 0xaa, 0x03 };
-/* RFC 1042 encapsulates Ethernet frames in 802.2 SNAP (0xaa, 0xaa, 0x03) with
- * a SNAP OID of 0 (0x00, 0x00, 0x00) */
-static const u8 rfc1042sig[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
 
 /* Convert the 802.11 header on a packet into an ethernet-style header
  * (basically, pretend we're an ethernet card receiving ethernet packets)
@@ -3401,9 +5566,9 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 	    ntohs(skb->protocol), skb->len,
 	    hex2str(dev->obuf, skb->data,
 		    min((int)sizeof(dev->obuf)/3,64), ' '));
-
 }
 
+
 /* Adjust the skb to trim the hardware header and CRC, and set up skb->mac,
  * skb->protocol, etc.
  */
@@ -3460,6 +5625,7 @@ static void at76_ieee80211_fixup(struct sk_buff *skb, int iw_mode)
 	}
 }
 
+
 /* check for fragmented data in dev->rx_skb. If the packet was no fragment
    or it was the last of a fragment set a skb containing the whole packet
    is returned for further processing. Otherwise we get NULL and are
@@ -3725,77 +5891,6 @@ static void at76_rx_data(struct at76_priv *dev)
 	return;
 }
 
-static int at76_submit_rx_urb(struct at76_priv *dev)
-{
-	int ret, size;
-	struct sk_buff *skb = dev->rx_skb;
-
-	if (dev->read_urb == NULL) {
-		err("%s: dev->read_urb is NULL", __FUNCTION__);
-		return -EFAULT;
-	}
-
-	if (skb == NULL) {
-		skb = dev_alloc_skb(sizeof(struct at76_rx_buffer));
-		if (skb == NULL) {
-			err("%s: unable to allocate rx skbuff.", dev->netdev->name);
-			ret = -ENOMEM;
-			goto exit;
-		}
-		dev->rx_skb = skb;
-	} else {
-		skb_push(skb, skb_headroom(skb));
-		skb_trim(skb, 0);
-	}
-
-	size = skb_tailroom(skb);
-	usb_fill_bulk_urb(dev->read_urb, dev->udev,
-		         usb_rcvbulkpipe(dev->udev, dev->bulk_in_endpointAddr),
-		         skb_put(skb, size), size,
-		         at76_read_bulk_callback, dev);
-	ret = usb_submit_urb(dev->read_urb, GFP_ATOMIC);
-	if (ret < 0) {
-		if (ret == -ENODEV)
-			at76_dbg(DBG_DEVSTART, "usb_submit_urb returned -ENODEV");
-		else
-			err("%s: rx, usb_submit_urb failed: %d", dev->netdev->name, ret);
-	}
-
-exit:
-	if (ret < 0) {
-		if (ret != -ENODEV) {
-			/* If we can't submit the URB, the adapter becomes completely
-			 * useless, so try again later */
-			if (--dev->nr_submit_rx_tries > 0)
-				schedule_work(&dev->work_submit_rx);
-			else {
-				err("%s: giving up to submit rx urb after %d failures -"
-			    	    " please unload the driver and/or power cycle the device",
-			    	    dev->netdev->name, NR_SUBMIT_RX_TRIES);
-			}
-		}
-	} else
-		/* reset counter to initial value */
-		dev->nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;
-	return ret;
-}
-
-/* we are doing a lot of things here in an interrupt. Need
-   a bh handler (Watching TV with a TV card is probably
-   a good test: if you see flickers, we are doing too much.
-   Currently I do see flickers... even with our tasklet :-( )
-   Maybe because the bttv driver and usb-uhci use the same interrupt
-*/
-/* Or maybe because our BH handler is preempting bttv's BH handler.. BHs don't
- * solve everything.. (alex) */
-static void at76_read_bulk_callback(struct urb *urb)
-{
-	struct at76_priv *priv = urb->context;
-
-	priv->rx_urb = urb;
-	tasklet_schedule(&priv->tasklet);
-	return;
-}
 
 static void at76_rx_monitor_mode(struct at76_priv *dev)
 {
@@ -3860,6 +5955,30 @@ static void at76_rx_monitor_mode(struct at76_priv *dev)
 }
 
 
+/**
+ * at76_iwspy_update - check if we spy on the sender address of buf and update stats
+ */
+static void at76_iwspy_update(struct at76_priv *dev, struct at76_rx_buffer *buf)
+{
+	struct ieee80211_hdr_3addr *hdr =
+	    (struct ieee80211_hdr_3addr *)buf->packet;
+	struct iw_quality qual;
+
+	/* We can only set the level here */
+	qual.updated = IW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;
+	qual.level = 0;
+	qual.noise = 0;
+	at76_calc_level(dev, buf, &qual);
+
+	spin_lock_bh(&(dev->spy_spinlock));
+
+	if (dev->spy_data.spy_number > 0) {
+		wireless_spy_update(dev->netdev, hdr->addr2, &qual);
+	}
+	spin_unlock_bh(&(dev->spy_spinlock));
+}
+
+
 static void at76_rx_tasklet(unsigned long param)
 {
 	struct at76_priv *dev = (struct at76_priv *)param;
@@ -3953,1884 +6072,6 @@ static void at76_rx_tasklet(unsigned long param)
 	return;
 }
 
-static void at76_write_bulk_callback(struct urb *urb)
-{
-	struct at76_priv *dev = urb->context;
-	struct net_device_stats *stats = &dev->stats;
-	unsigned long flags;
-	struct at76_tx_buffer *mgmt_buf;
-	int ret;
-
-	if (urb->status != 0) {
-		if ((urb->status != -ENOENT) && (urb->status != -ECONNRESET)) {
-			at76_dbg(DBG_URB,
-			         "%s - nonzero write bulk status received: %d",
-			         __FUNCTION__, urb->status);
-		} else
-			return; /* urb has been unlinked */
-		stats->tx_errors++;
-	} else
-		stats->tx_packets++;
-
-	spin_lock_irqsave(&dev->mgmt_spinlock, flags);
-	mgmt_buf = dev->next_mgmt_bulk;
-	dev->next_mgmt_bulk = NULL;
-	spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
-
-	if (mgmt_buf) {
-		/* we don't copy the padding bytes, but add them
-		   to the length */
-		memcpy(dev->bulk_out_buffer, mgmt_buf,
-		       le16_to_cpu(mgmt_buf->wlength) +
-		       offsetof(struct at76_tx_buffer, packet));
-		usb_fill_bulk_urb(dev->write_urb, dev->udev,
-				  usb_sndbulkpipe(dev->udev,
-						  dev->bulk_out_endpointAddr),
-				  dev->bulk_out_buffer,
-				  le16_to_cpu(mgmt_buf->wlength) +
-				  mgmt_buf->padding + AT76_TX_HDRLEN,
-				  at76_write_bulk_callback,
-				  dev);
-		ret = usb_submit_urb(dev->write_urb, GFP_ATOMIC);
-		if (ret) {
-			err("%s: %s error in tx submit urb: %d",
-			    dev->netdev->name, __FUNCTION__, ret);
-		}
-		kfree(mgmt_buf);
-	} else
-		netif_wake_queue(dev->netdev);
-
-}
-
-static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	struct net_device_stats *stats = &dev->stats;
-	int ret = 0;
-	int wlen;
-	int submit_len;
-	struct at76_tx_buffer *tx_buffer = dev->bulk_out_buffer;
-	struct ieee80211_hdr_3addr *i802_11_hdr =
-	    (struct ieee80211_hdr_3addr *)&(tx_buffer->packet);
-	u8 *payload = tx_buffer->packet + sizeof(struct ieee80211_hdr_3addr);
-
-	if (netif_queue_stopped(netdev)) {
-		err("%s: %s called while netdev is stopped", netdev->name,
-		    __FUNCTION__);
-		/* skip this packet */
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	if (dev->write_urb->status == -EINPROGRESS) {
-		err("%s: %s called while dev->write_urb is pending for tx",
-		    netdev->name, __FUNCTION__);
-		/* skip this packet */
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	if (skb->len < 2 * ETH_ALEN) {
-		err("%s: %s: skb too short (%d)", dev->netdev->name,
-		    __FUNCTION__, skb->len);
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	at76_ledtrig_tx_activity(); /* tell the ledtrigger we send a packet */
-
-	/* we can get rid of memcpy, if we set netdev->hard_header_len
-	   to 8 + sizeof(struct ieee80211_hdr_3addr), because then we have
-	   enough space
-	   at76_dbg(DBG_TX, "skb->data - skb->head = %d", skb->data - skb->head); */
-
-	if (ntohs(*(__be16 *) (skb->data + 2 * ETH_ALEN)) <= 1518) {
-		/* this is a 802.3 packet */
-		if (skb->data[2 * ETH_ALEN + 2] == rfc1042sig[0] &&
-		    skb->data[2 * ETH_ALEN + 2 + 1] == rfc1042sig[1]) {
-			/* higher layer delivered SNAP header - keep it */
-			memcpy(payload, skb->data + 2*ETH_ALEN+2, skb->len - 2*ETH_ALEN -2);
-			wlen = sizeof(struct ieee80211_hdr_3addr) + skb->len - 2*ETH_ALEN -2;
-		} else {
-			err("%s: %s: no support for non-SNAP 802.2 packets "
-			    "(DSAP x%02x SSAP x%02x cntrl x%02x)",
-			    dev->netdev->name, __FUNCTION__,
-			    skb->data[2 * ETH_ALEN + 2],
-			    skb->data[2 * ETH_ALEN + 2 + 1],
-			    skb->data[2 * ETH_ALEN + 2 + 2]);
-			dev_kfree_skb(skb);
-			return 0;
-		}
-	} else {
-		/* add RFC 1042 header in front */
-		memcpy(payload, rfc1042sig, sizeof(rfc1042sig));
-		memcpy(payload + sizeof(rfc1042sig),
-		       skb->data + 2*ETH_ALEN, skb->len - 2*ETH_ALEN);
-		wlen = sizeof(struct ieee80211_hdr_3addr) + sizeof(rfc1042sig) +
-			skb->len - 2*ETH_ALEN;
-	}
-
-	/* make wireless header */
-	i802_11_hdr->frame_ctl =
-	    cpu_to_le16(IEEE80211_FTYPE_DATA |
-			(dev->wep_enabled ? IEEE80211_FCTL_PROTECTED : 0) |
-			(dev->iw_mode ==
-			 IW_MODE_INFRA ? IEEE80211_FCTL_TODS : 0));
-
-	if (dev->iw_mode == IW_MODE_ADHOC) {
-		memcpy(i802_11_hdr->addr1, skb->data, ETH_ALEN);	/* destination */
-		memcpy(i802_11_hdr->addr2, skb->data + ETH_ALEN, ETH_ALEN);	/* source */
-		memcpy(i802_11_hdr->addr3, dev->bssid, ETH_ALEN);
-	} else if (dev->iw_mode == IW_MODE_INFRA) {
-		memcpy(i802_11_hdr->addr1, dev->bssid, ETH_ALEN);
-		memcpy(i802_11_hdr->addr2, skb->data + ETH_ALEN, ETH_ALEN);	/* source */
-		memcpy(i802_11_hdr->addr3, skb->data, ETH_ALEN);	/* destination */
-	}
-
-	i802_11_hdr->duration_id = cpu_to_le16(0);
-	i802_11_hdr->seq_ctl = cpu_to_le16(0);
-
-	/* setup 'Atmel' header */
-	tx_buffer->wlength = cpu_to_le16(wlen);
-	tx_buffer->tx_rate = dev->txrate;
-	/* for broadcast destination addresses, the firmware 0.100.x
-	   seems to choose the highest rate set with CMD_STARTUP in
-	   basic_rate_set replacing this value */
-
-	memset(tx_buffer->reserved, 0, 4);
-
-	tx_buffer->padding = at76_calc_padding(wlen);
-	submit_len = wlen + AT76_TX_HDRLEN + tx_buffer->padding;
-
-	{
-		at76_dbg(DBG_TX_DATA_CONTENT, "%s skb->data %s", dev->netdev->name,
-		         hex2str(dev->obuf, skb->data,
-			    min((int)(sizeof(dev->obuf) - 1) / 2, 32), '\0'));
-		at76_dbg(DBG_TX_DATA, "%s tx  wlen x%x pad x%x rate %d hdr %s",
-		         dev->netdev->name,
-		         le16_to_cpu(tx_buffer->wlength),
-		         tx_buffer->padding, tx_buffer->tx_rate,
-		         hex2str(dev->obuf, i802_11_hdr,
-			    min((sizeof(dev->obuf) - 1) / 2,
-				sizeof(struct ieee80211_hdr_3addr)), '\0'));
-		at76_dbg(DBG_TX_DATA_CONTENT, "%s payload %s", dev->netdev->name,
-		         hex2str(dev->obuf, payload,
-			    min((int)(sizeof(dev->obuf) - 1) / 2, 48), '\0'));
-	}
-
-	/* send stuff */
-	netif_stop_queue(netdev);
-	netdev->trans_start = jiffies;
-
-	usb_fill_bulk_urb(dev->write_urb, dev->udev,
-		         usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),
-		         tx_buffer, submit_len,
-		         at76_write_bulk_callback, dev);
-	ret = usb_submit_urb(dev->write_urb, GFP_ATOMIC);
-	if (ret) {
-		stats->tx_errors++;
-		err("%s: error in tx submit urb: %d", netdev->name, ret);
-		if (ret == -EINVAL)
-			err("-EINVAL: urb %p urb->hcpriv %p urb->complete %p",
-			    dev->write_urb,
-			    dev->write_urb ? dev->write_urb->hcpriv : (void *)-1,
-			    dev->write_urb ? dev->write_urb->complete : (void *)-1);
-		goto err;
-	}
-
-	stats->tx_bytes += skb->len;
-
-	dev_kfree_skb(skb);
-	return 0;
-
- err:
-	return ret;
-}
-
-static void at76_tx_timeout(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	if (!dev)
-		return;
-	warn("%s: tx timeout.", netdev->name);
-
-	usb_unlink_urb(dev->write_urb);
-	dev->stats.tx_errors++;
-}
-
-static int at76_startup_device(struct at76_priv *dev)
-{
-	struct at76_card_config *ccfg = &dev->card_config;
-	int ret;
-
-	if (at76_debug & DBG_PARAMS) {
-		char ossid[IW_ESSID_MAX_SIZE + 1];
-
-		/* make dev->essid printable */
-		at76_assert(dev->essid_size <= IW_ESSID_MAX_SIZE);
-		memcpy(ossid, dev->essid, dev->essid_size);
-		ossid[dev->essid_size] = '\0';
-
-		dbg("%s param: ssid %s (%s) mode %s ch %d wep %s key %d keylen %d",
-		       dev->netdev->name, ossid,
-		       hex2str(dev->obuf, dev->essid,
-			       min((int)(sizeof(dev->obuf)-1)/2,
-				   IW_ESSID_MAX_SIZE), '\0'),
-		       dev->iw_mode == IW_MODE_ADHOC ? "adhoc" : "infra",
-		       dev->channel,
-		       dev->wep_enabled ? "enabled" : "disabled",
-		       dev->wep_key_id, dev->wep_keys_len[dev->wep_key_id]);
-		dbg("%s param: preamble %s rts %d retry %d frag %d "
-		       "txrate %s auth_mode %d",
-		       dev->netdev->name,
-		       dev->preamble_type == PREAMBLE_TYPE_SHORT ? "short" : "long",
-		       dev->rts_threshold, dev->short_retry_limit,
-		       dev->frag_threshold,
-		       dev->txrate == TX_RATE_1MBIT ? "1MBit" :
-		       dev->txrate == TX_RATE_2MBIT ? "2MBit" :
-		       dev->txrate == TX_RATE_5_5MBIT ? "5.5MBit" :
-		       dev->txrate == TX_RATE_11MBIT ? "11MBit" :
-		       dev->txrate == TX_RATE_AUTO ? "auto" : "<invalid>",
-		       dev->auth_mode);
-		dbg("%s param: pm_mode %d pm_period %d auth_mode %s "
-		       "scan_times %d %d scan_mode %s international_roaming %d",
-		       dev->netdev->name,
-		       dev->pm_mode, dev->pm_period,
-		       dev->auth_mode == WLAN_AUTH_OPEN ?
-		       "open" : "shared_secret",
-		       dev->scan_min_time, dev->scan_max_time,
-		       dev->scan_mode == SCAN_TYPE_ACTIVE ? "active" : "passive",
-		       dev->international_roaming);
-	}
-
-	memset(ccfg, 0, sizeof(struct at76_card_config));
-	ccfg->promiscuous_mode = 0;
-	ccfg->short_retry_limit = dev->short_retry_limit;
-
-	if (dev->wep_enabled) {
-		if (dev->wep_keys_len[dev->wep_key_id] > WEP_SMALL_KEY_LEN)
-			ccfg->encryption_type = 2;
-		else
-			ccfg->encryption_type = 1;
-
-		/* jal: always exclude unencrypted if WEP is active */
-		ccfg->exclude_unencrypted = 1;
-	} else {
-		ccfg->exclude_unencrypted = 0;
-		ccfg->encryption_type = 0;
-	}
-
-	ccfg->rts_threshold = cpu_to_le16(dev->rts_threshold);
-	ccfg->fragmentation_threshold = cpu_to_le16(dev->frag_threshold);
-
-	memcpy(ccfg->basic_rate_set, hw_rates, 4);
-	/* jal: really needed, we do a set_mib for autorate later ??? */
-	ccfg->auto_rate_fallback = (dev->txrate == TX_RATE_AUTO ? 1 : 0);
-	ccfg->channel = dev->channel;
-	ccfg->privacy_invoked = dev->wep_enabled;
-	memcpy(ccfg->current_ssid, dev->essid, IW_ESSID_MAX_SIZE);
-	ccfg->ssid_len = dev->essid_size;
-
-	ccfg->wep_default_key_id = dev->wep_key_id;
-	memcpy(ccfg->wep_default_key_value, dev->wep_keys, 4 * WEP_KEY_LEN);
-
-	ccfg->short_preamble = dev->preamble_type;
-	ccfg->beacon_period = cpu_to_le16(dev->beacon_period);
-
-	ret = at76_set_card_command(dev->udev, CMD_STARTUP, &dev->card_config,
-			            sizeof(struct at76_card_config));
-	if (ret < 0) {
-		err("%s: at76_set_card_command failed: %d", dev->netdev->name, ret);
-		return ret;
-	}
-
-	at76_wait_completion(dev, CMD_STARTUP);
-
-	/* remove BSSID from previous run */
-	memset(dev->bssid, 0, ETH_ALEN);
-
-	if (at76_set_radio(dev, 1) == 1)
-		at76_wait_completion(dev, CMD_RADIO);
-
-	if ((ret = at76_set_preamble(dev, dev->preamble_type)) < 0)
-		return ret;
-
-	if ((ret = at76_set_frag(dev, dev->frag_threshold)) < 0)
-		return ret;
-
-	if ((ret = at76_set_rts(dev, dev->rts_threshold)) < 0)
-		return ret;
-
-	if ((ret = at76_set_autorate_fallback(dev, dev->txrate == TX_RATE_AUTO ? 1 : 0)) < 0)
-		return ret;
-
-	if ((ret = at76_set_pm_mode(dev)) < 0)
-		return ret;
-
-	if ((ret = at76_set_iroaming(dev, dev->international_roaming)) < 0)
-		return ret;
-
-	if (at76_debug & DBG_MIB) {
-		at76_dump_mib_mac(dev);
-		at76_dump_mib_mac_addr(dev);
-		at76_dump_mib_mac_mgmt(dev);
-		at76_dump_mib_mac_wep(dev);
-		at76_dump_mib_mdomain(dev);
-		at76_dump_mib_phy(dev);
-		at76_dump_mib_local(dev);
-	}
-
-	return 0;
-}
-
-static int at76_open(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = 0;
-
-	at76_dbg(DBG_PROC_ENTRY, "at76_open entry");
-
-	if (down_interruptible(&dev->sem))
-		return -EINTR;
-
-	/* if netdev->dev_addr != dev->mac_addr we must
-	   set the mac address in the device ! */
-	if (compare_ether_addr(netdev->dev_addr, dev->mac_addr)) {
-		if (at76_add_mac_address(dev, netdev->dev_addr) >= 0)
-			at76_dbg(DBG_PROGRESS, "%s: set new MAC addr %s",
-			         netdev->name, mac2str(netdev->dev_addr));
-	}
-#ifdef DEBUG
-	at76_dump_mib_mac_addr(dev);
-#endif
-
-	dev->scan_state = SCAN_IDLE;
-	dev->last_scan = jiffies;
-	dev->nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;	/* init counter */
-
-	if ((ret = at76_submit_rx_urb(dev)) < 0) {
-		err("%s: open: submit_rx_urb failed: %d", netdev->name, ret);
-		goto err;
-	}
-
-	dev->open_count++;
-
-	schedule_work(&dev->work_restart);
-
-	at76_dbg(DBG_PROC_ENTRY, "at76_open end");
- err:
-	up(&dev->sem);
-	return ret < 0 ? ret : 0;
-}
-
-static int at76_stop(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	unsigned long flags;
-
-	at76_dbg(DBG_DEVSTART, "%s: ENTER", __FUNCTION__);
-
-	if (down_interruptible(&dev->sem))
-		return -EINTR;
-
-	netif_stop_queue(netdev);
-
-	dev->istate = INIT;
-
-	if (!(dev->device_unplugged)) {
-		/* we are called by "ifconfig ethX down", not because the
-		   device isn't avail. anymore */
-		at76_set_radio(dev, 0);
-
-		/* we unlink the read urb, because the _open()
-		   submits it again. _delete_device() takes care of the
-		   read_urb otherwise. */
-		usb_kill_urb(dev->read_urb);
-	}
-
-	del_timer_sync(&dev->mgmt_timer);
-
-	spin_lock_irqsave(&dev->mgmt_spinlock, flags);
-	if (dev->next_mgmt_bulk) {
-		kfree(dev->next_mgmt_bulk);
-		dev->next_mgmt_bulk = NULL;
-	}
-	spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
-
-	/* free the bss_list */
-	at76_free_bss_list(dev);
-
-	at76_assert(dev->open_count > 0);
-	dev->open_count--;
-
-	up(&dev->sem);
-	at76_dbg(DBG_DEVSTART, "%s: EXIT", __FUNCTION__);
-
-	return 0;
-}
-
-static struct net_device_stats *at76_get_stats(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	return &dev->stats;
-}
-
-static struct iw_statistics *at76_get_wireless_stats(struct net_device
-							 *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	at76_dbg(DBG_IOCTL, "RETURN qual %d level %d noise %d updated %d",
-	         dev->wstats.qual.qual, dev->wstats.qual.level,
-	         dev->wstats.qual.noise, dev->wstats.qual.updated);
-
-	return &dev->wstats;
-}
-
-static void at76_set_multicast(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int promisc;
-
-	promisc = ((netdev->flags & IFF_PROMISC) != 0);
-	if (promisc != dev->promisc) {
-		/* grmbl. This gets called in interrupt. */
-		dev->promisc = promisc;
-		schedule_work(&dev->work_set_promisc);
-	}
-}
-
-/* we only store the new mac address in netdev struct,
-   it gets set when the netdev is opened. */
-static int at76_set_mac_address(struct net_device *netdev, void *addr)
-{
-	struct sockaddr *mac = addr;
-	memcpy(netdev->dev_addr, mac->sa_data, ETH_ALEN);
-	return 1;
-}
-
-/**
- * at76_iwspy_update - check if we spy on the sender address of buf and update stats
- */
-static void at76_iwspy_update(struct at76_priv *dev, struct at76_rx_buffer *buf)
-{
-	struct ieee80211_hdr_3addr *hdr =
-	    (struct ieee80211_hdr_3addr *)buf->packet;
-	struct iw_quality qual;
-
-	/* We can only set the level here */
-	qual.updated = IW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;
-	qual.level = 0;
-	qual.noise = 0;
-	at76_calc_level(dev, buf, &qual);
-
-	spin_lock_bh(&(dev->spy_spinlock));
-
-	if (dev->spy_data.spy_number > 0) {
-		wireless_spy_update(dev->netdev, hdr->addr2, &qual);
-	}
-	spin_unlock_bh(&(dev->spy_spinlock));
-}
-
-
-/*******************************************************************************
- * structure that describes the private ioctls/iw handlers of this driver
- */
-static const struct iw_priv_args at76_priv_args[] = {
-	{AT76_SET_SHORT_PREAMBLE,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 "short_preamble"},	/* 0 - long, 1 -short */
-
-	{AT76_SET_DEBUG,
-	 /* we must pass the new debug mask as a string,
-	  * 'cause iwpriv cannot parse hex numbers
-	  * starting with 0x :-(  */
-	 IW_PRIV_TYPE_CHAR | 10, 0,
-	 "set_debug"},		/* set debug value */
-
-	{AT76_SET_POWERSAVE_MODE,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 "powersave_mode"},	/* 1 -  active, 2 - power save,
-				   3 - smart power save */
-	{AT76_SET_SCAN_TIMES,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0,
-	 "scan_times"},		/* min_channel_time,
-				   max_channel_time */
-	{AT76_SET_SCAN_MODE,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 "scan_mode"},		/* 0 - active, 1 - passive scan */
-
-	{AT76_SET_INTL_ROAMING,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 "intl_roaming"},
-};
-
-/*******************************************************************************
- * at76_priv implementations of iw_handler functions:
- */
-static int at76_iw_handler_commit(struct net_device *netdev,
-				      struct iw_request_info *info,
-				      void *null, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	unsigned long flags;
-	at76_dbg(DBG_IOCTL, "%s %s: restarting the device", netdev->name,
-	         __FUNCTION__);
-
-	/* TODO: stop any pending tx bulk urb */
-	if (dev->istate != INIT) {
-		dev->istate = INIT;
-		/* stop pending management stuff */
-		del_timer_sync(&dev->mgmt_timer);
-
-		spin_lock_irqsave(&dev->mgmt_spinlock, flags);
-		if (dev->next_mgmt_bulk) {
-			kfree(dev->next_mgmt_bulk);
-			dev->next_mgmt_bulk = NULL;
-		}
-		spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
-
-		netif_carrier_off(dev->netdev);
-		netif_stop_queue(dev->netdev);
-	}
-
-	/* do the restart after two seconds to catch
-	 * following ioctl's (from more params of iwconfig)
-	 * in _one_ restart */
-	mod_timer(&dev->restart_timer, jiffies + 2 * HZ);
-
-	return 0;
-}
-
-static int at76_iw_handler_get_name(struct net_device *netdev,
-					struct iw_request_info *info,
-					char *name, char *extra)
-{
-	strcpy(name, "IEEE 802.11b");
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWNAME - name %s", netdev->name, name);
-	return 0;
-}
-
-static int at76_iw_handler_set_freq(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_freq *freq, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int chan = -1;
-	int ret = -EIWCOMMIT;
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - freq.m %d freq.e %d", netdev->name,
-	    freq->m, freq->e);
-
-	if ((freq->e == 0) && (freq->m <= 1000)) {
-		/* Setting by channel number */
-		chan = freq->m;
-	} else {
-		/* Setting by frequency - search the table */
-		int mult = 1;
-		int i;
-
-		for (i = 0; i < (6 - freq->e); i++) {
-			mult *= 10;
-		}
-
-		for (i = 0; i < NUM_CHANNELS; i++) {
-			if (freq->m == (channel_frequency[i] * mult))
-				chan = i + 1;
-		}
-	}
-
-	if (chan < 1 || !dev->domain) {
-		/* non-positive channels are invalid
-		 * we need a domain info to set the channel
-		 * either that or an invalid frequency was
-		 * provided by the user */
-		ret = -EINVAL;
-	} else if (!dev->international_roaming) {
-		if (!(dev->domain->channel_map & (1 << (chan - 1)))) {
-			info("%s: channel %d not allowed for domain %s "
-			     "(and international_roaming is OFF)",
-			     dev->netdev->name, chan, dev->domain->name);
-			ret = -EINVAL;
-		}
-	}
-
-	if (ret == -EIWCOMMIT) {
-		dev->channel = chan;
-		at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - ch %d", netdev->name, chan);
-	}
-
-	return ret;
-}
-
-static int at76_iw_handler_get_freq(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_freq *freq, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	freq->m = dev->channel;
-	freq->e = 0;
-
-	if (dev->channel) {
-		at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - freq %ld x 10e%d",
-		         netdev->name, channel_frequency[dev->channel - 1], 6);
-	}
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - ch %d", netdev->name, dev->channel);
-
-	return 0;
-}
-
-static int at76_iw_handler_set_mode(struct net_device *netdev,
-					struct iw_request_info *info,
-					__u32 * mode, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWMODE - %d", netdev->name, *mode);
-
-	if ((*mode != IW_MODE_ADHOC) && (*mode != IW_MODE_INFRA) &&
-	    (*mode != IW_MODE_MONITOR)) {
-		ret = -EINVAL;
-	} else {
-		dev->iw_mode = *mode;
-		if( dev->iw_mode != IW_MODE_INFRA)
-			dev->pm_mode = AT76_PM_OFF;
-	}
-	return ret;
-}
-
-static int at76_iw_handler_get_mode(struct net_device *netdev,
-					struct iw_request_info *info,
-					__u32 * mode, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	*mode = dev->iw_mode;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWMODE - %d", netdev->name, *mode);
-
-	return 0;
-}
-
-static int at76_iw_handler_get_range(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_point *data, char *extra)
-{
-	/* inspired by atmel.c */
-	struct at76_priv *dev = netdev_priv(netdev);
-	struct iw_range *range = (struct iw_range *)extra;
-	int i;
-
-	data->length = sizeof(struct iw_range);
-	memset(range, 0, sizeof(struct iw_range));
-
-	/* TODO: range->throughput = xxxxxx; */
-
-	range->min_nwid = 0x0000;
-	range->max_nwid = 0x0000;
-
-	/* this driver doesn't maintain sensitivity information */
-	range->sensitivity = 0;
-
-	range->max_qual.qual = 100;
-	range->max_qual.level = 100;
-	range->max_qual.noise = 0;
-	range->max_qual.updated = IW_QUAL_NOISE_INVALID;
-
-	range->avg_qual.qual = 50;
-	range->avg_qual.level = 50;
-	range->avg_qual.noise = 0;
-	range->avg_qual.updated = IW_QUAL_NOISE_INVALID;
-
-	range->bitrate[0] = 1000000;
-	range->bitrate[1] = 2000000;
-	range->bitrate[2] = 5500000;
-	range->bitrate[3] = 11000000;
-	range->num_bitrates = 4;
-
-	range->min_rts = 0;
-	range->max_rts = MAX_RTS_THRESHOLD;
-
-	range->min_frag = MIN_FRAG_THRESHOLD;
-	range->max_frag = MAX_FRAG_THRESHOLD;
-
-	range->pmp_flags = IW_POWER_PERIOD;
-	range->pmt_flags = IW_POWER_ON;
-	range->pm_capa = IW_POWER_PERIOD | IW_POWER_ALL_R;
-
-	range->encoding_size[0] = WEP_SMALL_KEY_LEN;
-	range->encoding_size[1] = WEP_LARGE_KEY_LEN;
-	range->num_encoding_sizes = 2;
-	range->max_encoding_tokens = WEP_KEYS;
-
-	/* both WL-240U and Linksys WUSB11 v2.6 specify 15 dBm as output power
-	   - take this for all (ignore antenna gains) */
-	range->txpower[0] = 15;
-	range->num_txpower = 1;
-	range->txpower_capa = IW_TXPOW_DBM;
-
-	range->we_version_source = WIRELESS_EXT;
-	range->we_version_compiled = WIRELESS_EXT;
-
-	/* same as the values used in atmel.c */
-	range->retry_capa = IW_RETRY_LIMIT;
-	range->retry_flags = IW_RETRY_LIMIT;
-	range->r_time_flags = 0;
-	range->min_retry = 1;
-	range->max_retry = 255;
-
-
-	range->num_channels = NUM_CHANNELS;
-	range->num_frequency = 0;
-
-	for (i = 0; i < NUM_CHANNELS; i++) {
-		/* test if channel map bit is raised */
-		if (dev->domain->channel_map & (0x1 << i)) {
-			range->num_frequency += 1;
-
-			range->freq[i].i = i + 1;
-			range->freq[i].m = channel_frequency[i] * 100000;
-			range->freq[i].e = 1;	/* channel frequency*100000 * 10^1 */
-		}
-	}
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRANGE", netdev->name);
-
-	return 0;
-}
-
-static int at76_iw_handler_set_spy(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = 0;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWSPY - number of addresses %d",
-	         netdev->name, data->length);
-
-	spin_lock_bh(&(dev->spy_spinlock));
-	ret = iw_handler_set_spy(dev->netdev, info, (union iwreq_data *)data,
-				 extra);
-	spin_unlock_bh(&(dev->spy_spinlock));
-
-	return ret;
-}
-
-static int at76_iw_handler_get_spy(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct iw_point *data, char *extra)
-{
-
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = 0;
-
-	spin_lock_bh(&(dev->spy_spinlock));
-	ret = iw_handler_get_spy(dev->netdev, info,
-				 (union iwreq_data *)data, extra);
-	spin_unlock_bh(&(dev->spy_spinlock));
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWSPY - number of addresses %d",
-	         netdev->name, data->length);
-
-	return ret;
-}
-
-static int at76_iw_handler_set_thrspy(struct net_device *netdev,
-					  struct iw_request_info *info,
-					  struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWTHRSPY - number of addresses %d)",
-	         netdev->name, data->length);
-
-	spin_lock_bh(&(dev->spy_spinlock));
-	ret = iw_handler_set_thrspy(netdev, info, (union iwreq_data *)data,
-				    extra);
-	spin_unlock_bh(&(dev->spy_spinlock));
-
-	return ret;
-}
-
-static int at76_iw_handler_get_thrspy(struct net_device *netdev,
-					  struct iw_request_info *info,
-					  struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret;
-
-	spin_lock_bh(&(dev->spy_spinlock));
-	ret = iw_handler_get_thrspy(netdev, info, (union iwreq_data *)data,
-				    extra);
-	spin_unlock_bh(&(dev->spy_spinlock));
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWTHRSPY - number of addresses %d)",
-	         netdev->name, data->length);
-
-	return ret;
-}
-
-static int at76_iw_handler_set_wap(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct sockaddr *ap_addr, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWAP - wap/bssid %s", netdev->name,
-	         mac2str(ap_addr->sa_data));
-
-	/* if the incoming address == ff:ff:ff:ff:ff:ff, the user has
-	   chosen any or auto AP preference */
-	if (is_broadcast_ether_addr(ap_addr->sa_data)
-	    || is_zero_ether_addr(ap_addr->sa_data)) {
-		dev->wanted_bssid_valid = 0;
-	} else {
-		/* user wants to set a preferred AP address */
-		dev->wanted_bssid_valid = 1;
-		memcpy(dev->wanted_bssid, ap_addr->sa_data, ETH_ALEN);
-	}
-
-	return -EIWCOMMIT;
-}
-
-static int at76_iw_handler_get_wap(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct sockaddr *ap_addr, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	ap_addr->sa_family = ARPHRD_ETHER;
-	memcpy(ap_addr->sa_data, dev->bssid, ETH_ALEN);
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWAP - wap/bssid %s", netdev->name,
-	         mac2str(ap_addr->sa_data));
-
-	return 0;
-}
-
-static int at76_iw_handler_set_scan(struct net_device *netdev,
-					struct iw_request_info *info,
-					union iwreq_data *wrqu, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	unsigned long flags;
-	int ret = 0;
-	struct iw_scan_req *req = NULL;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWSCAN", netdev->name);
-
-	if (!netif_running(netdev))
-		return -ENETDOWN;
-
-	/* jal: we don't allow "iwlist ethX scan" while we are
-	   in monitor mode */
-	if (dev->iw_mode == IW_MODE_MONITOR)
-		return -EBUSY;
-
-	/* Discard old scan results */
-	if ((jiffies - dev->last_scan) > (20 * HZ))
-		dev->scan_state = SCAN_IDLE;
-	dev->last_scan = jiffies;
-
-	/* Initiate a scan command */
-	if (dev->scan_state == SCAN_IN_PROGRESS)
-		return -EBUSY;
-
-	dev->scan_state = SCAN_IN_PROGRESS;
-
-	/* stop pending management stuff */
-	del_timer_sync(&(dev->mgmt_timer));
-
-	spin_lock_irqsave(&(dev->mgmt_spinlock), flags);
-	if (dev->next_mgmt_bulk) {
-		kfree(dev->next_mgmt_bulk);
-		dev->next_mgmt_bulk = NULL;
-	}
-	spin_unlock_irqrestore(&(dev->mgmt_spinlock), flags);
-
-	if (netif_running(dev->netdev)) {
-		/* pause network activity */
-		netif_carrier_off(dev->netdev);
-		netif_stop_queue(dev->netdev);
-	}
-	/* Try to do passive or active scan if WE asks as. */
-	if (wrqu->data.length
-	    && wrqu->data.length == sizeof(struct iw_scan_req)) {
-		req = (struct iw_scan_req *)extra;
-
-		if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
-			dev->scan_mode = SCAN_TYPE_PASSIVE;
-		else if (req->scan_type == IW_SCAN_TYPE_ACTIVE)
-			dev->scan_mode = SCAN_TYPE_ACTIVE;
-
-		/* Sanity check values? */
-		if (req->min_channel_time > 0) {
-			if (dev->istate == MONITORING)
-				dev->monitor_scan_min_time =
-				    req->min_channel_time;
-			else
-				dev->scan_min_time = req->min_channel_time;
-		}
-		if (req->max_channel_time > 0) {
-			if (dev->istate == MONITORING)
-				dev->monitor_scan_max_time =
-				    req->max_channel_time;
-			else
-				dev->scan_max_time = req->max_channel_time;
-		}
-	}
-
-	/* change to scanning state */
-	dev->istate = SCANNING;
-	schedule_work(&dev->work_scan);
-
-	return ret;
-}
-
-static int at76_iw_handler_get_scan(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	unsigned long flags;
-	struct list_head *lptr, *nptr;
-	struct bss_info *curr_bss;
-	struct iw_event *iwe = kmalloc(sizeof(struct iw_event), GFP_KERNEL);
-	char *curr_val, *curr_pos = extra;
-	int i;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWSCAN", netdev->name);
-
-	if (!iwe)
-		return -ENOMEM;
-
-	if (dev->scan_state != SCAN_COMPLETED)
-		/* scan not yet finished */
-		return -EAGAIN;
-
-	spin_lock_irqsave(&(dev->bss_list_spinlock), flags);
-
-	list_for_each_safe(lptr, nptr, &(dev->bss_list)) {
-		curr_bss = list_entry(lptr, struct bss_info, list);
-
-		iwe->cmd = SIOCGIWAP;
-		iwe->u.ap_addr.sa_family = ARPHRD_ETHER;
-		memcpy(iwe->u.ap_addr.sa_data, curr_bss->bssid, 6);
-		curr_pos = iwe_stream_add_event(curr_pos,
-						extra + IW_SCAN_MAX_DATA, iwe,
-						IW_EV_ADDR_LEN);
-
-		iwe->u.data.length = curr_bss->ssid_len;
-		iwe->cmd = SIOCGIWESSID;
-		iwe->u.data.flags = 1;
-
-		curr_pos = iwe_stream_add_point(curr_pos,
-			extra + IW_SCAN_MAX_DATA, iwe, curr_bss->ssid);
-
-		iwe->cmd = SIOCGIWMODE;
-		iwe->u.mode = (curr_bss->capa & WLAN_CAPABILITY_IBSS) ?
-		    IW_MODE_ADHOC :
-		    (curr_bss->capa & WLAN_CAPABILITY_ESS) ?
-		    IW_MODE_MASTER : IW_MODE_AUTO;
-		/* IW_MODE_AUTO = 0 which I thought is
-		 * the most logical value to return in this case */
-		curr_pos = iwe_stream_add_event(curr_pos,
-						extra + IW_SCAN_MAX_DATA, iwe,
-						IW_EV_UINT_LEN);
-
-		iwe->cmd = SIOCGIWFREQ;
-		iwe->u.freq.m = curr_bss->channel;
-		iwe->u.freq.e = 0;
-		curr_pos = iwe_stream_add_event(curr_pos,
-						extra + IW_SCAN_MAX_DATA, iwe,
-						IW_EV_FREQ_LEN);
-
-		iwe->cmd = SIOCGIWENCODE;
-		if (curr_bss->capa & WLAN_CAPABILITY_PRIVACY) {
-			iwe->u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
-		} else {
-			iwe->u.data.flags = IW_ENCODE_DISABLED;
-		}
-		iwe->u.data.length = 0;
-		curr_pos = iwe_stream_add_point(curr_pos,
-						extra + IW_SCAN_MAX_DATA, iwe,
-						NULL);
-
-		/* Add quality statistics */
-		iwe->cmd = IWEVQUAL;
-		iwe->u.qual.noise = 0;
-		iwe->u.qual.updated =
-		    IW_QUAL_NOISE_INVALID | IW_QUAL_LEVEL_UPDATED;
-		iwe->u.qual.level = (curr_bss->rssi * 100 / 42);
-		if (iwe->u.qual.level > 100)
-			iwe->u.qual.level = 100;
-		if ((dev->board_type == BOARDTYPE_503_INTERSIL_3861) ||
-		    (dev->board_type == BOARDTYPE_503_INTERSIL_3863)) {
-			iwe->u.qual.qual = curr_bss->link_qual;
-		} else {
-			iwe->u.qual.qual = 0;
-			iwe->u.qual.updated |= IW_QUAL_QUAL_INVALID;
-		}
-		/* Add new value to event */
-		curr_pos = iwe_stream_add_event(curr_pos,
-						extra + IW_SCAN_MAX_DATA, iwe,
-						IW_EV_QUAL_LEN);
-
-		/* Rate : stuffing multiple values in a single event require a bit
-		 * more of magic - Jean II */
-		curr_val = curr_pos + IW_EV_LCP_LEN;
-
-		iwe->cmd = SIOCGIWRATE;
-		/* Those two flags are ignored... */
-		iwe->u.bitrate.fixed = iwe->u.bitrate.disabled = 0;
-		/* Max 8 values */
-		for (i = 0; i < curr_bss->rates_len; i++) {
-			/* Bit rate given in 500 kb/s units (+ 0x80) */
-			iwe->u.bitrate.value =
-			    ((curr_bss->rates[i] & 0x7f) * 500000);
-			/* Add new value to event */
-			curr_val = iwe_stream_add_value(curr_pos, curr_val,
-							extra +
-							IW_SCAN_MAX_DATA, iwe,
-							IW_EV_PARAM_LEN);
-		}
-
-		/* Check if we added any event */
-		if ((curr_val - curr_pos) > IW_EV_LCP_LEN)
-			curr_pos = curr_val;
-
-		/* more information may be sent back using IWECUSTOM */
-
-	}
-
-	spin_unlock_irqrestore(&(dev->bss_list_spinlock), flags);
-
-	data->length = (curr_pos - extra);
-	data->flags = 0;
-
-	kfree(iwe);
-	return 0;
-}
-
-static int at76_iw_handler_set_essid(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWESSID - %s", netdev->name, extra);
-
-	if (data->flags) {
-		memcpy(dev->essid, extra, data->length);
-		dev->essid_size = data->length;
-	} else {
-		/* Use any SSID */
-		dev->essid_size = 0;
-	}
-
-	return -EIWCOMMIT;
-}
-
-static int at76_iw_handler_get_essid(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	if (dev->essid_size) {
-		/* not the ANY ssid in dev->essid */
-		data->flags = 1;
-		data->length = dev->essid_size;
-		memcpy(extra, dev->essid, data->length);
-		extra[data->length] = '\0';
-		data->length += 1;
-	} else {
-		/* the ANY ssid was specified */
-		if (dev->istate == CONNECTED && dev->curr_bss != NULL) {
-			/* report the SSID we have found */
-			data->flags = 1;
-			data->length = dev->curr_bss->ssid_len;
-			memcpy(extra, dev->curr_bss->ssid, data->length);
-			extra[dev->curr_bss->ssid_len] = '\0';
-			data->length += 1;
-		} else {
-			/* report ANY back */
-			data->flags = 0;
-			data->length = 0;
-		}
-	}
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWESSID - %s", netdev->name, extra);
-
-	return 0;
-}
-
-static int at76_iw_handler_set_rate(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_param *bitrate, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRATE - %d", netdev->name, bitrate->value);
-
-	switch (bitrate->value) {
-	case -1:
-		dev->txrate = TX_RATE_AUTO;
-		break;		/* auto rate */
-	case 1000000:
-		dev->txrate = TX_RATE_1MBIT;
-		break;
-	case 2000000:
-		dev->txrate = TX_RATE_2MBIT;
-		break;
-	case 5500000:
-		dev->txrate = TX_RATE_5_5MBIT;
-		break;
-	case 11000000:
-		dev->txrate = TX_RATE_11MBIT;
-		break;
-	default:
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static int at76_iw_handler_get_rate(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_param *bitrate, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = 0;
-
-	switch (dev->txrate) {
-		/* return max rate if RATE_AUTO */
-	case TX_RATE_AUTO:
-		bitrate->value = 11000000;
-		break;
-	case TX_RATE_1MBIT:
-		bitrate->value = 1000000;
-		break;
-	case TX_RATE_2MBIT:
-		bitrate->value = 2000000;
-		break;
-	case TX_RATE_5_5MBIT:
-		bitrate->value = 5500000;
-		break;
-	case TX_RATE_11MBIT:
-		bitrate->value = 11000000;
-		break;
-	default:
-		ret = -EINVAL;
-	}
-
-	bitrate->fixed = (dev->txrate != TX_RATE_AUTO);
-	bitrate->disabled = 0;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRATE - %d", netdev->name,
-	         bitrate->value);
-
-	return ret;
-}
-
-static int at76_iw_handler_set_rts(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct iw_param *rts, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = -EIWCOMMIT;
-	int rthr = rts->value;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRTS - value %d disabled %s",
-		 netdev->name, rts->value, (rts->disabled) ? "true" : "false");
-
-	if (rts->disabled)
-		rthr = MAX_RTS_THRESHOLD;
-
-	if ((rthr < 0) || (rthr > MAX_RTS_THRESHOLD)) {
-		ret = -EINVAL;
-	} else {
-		dev->rts_threshold = rthr;
-	}
-
-	return ret;
-}
-
-static int at76_iw_handler_get_rts(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct iw_param *rts, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	rts->value = dev->rts_threshold;
-	rts->disabled = (rts->value >= MAX_RTS_THRESHOLD);
-	rts->fixed = 1;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRTS - value %d disabled %s",
-	         netdev->name, rts->value, (rts->disabled) ? "true" : "false");
-
-	return 0;
-}
-
-static int at76_iw_handler_set_frag(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_param *frag, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = -EIWCOMMIT;
-	int fthr = frag->value;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWFRAG - value %d, disabled %s",
-	         netdev->name, frag->value, (frag->disabled) ? "true" : "false");
-
-	if (frag->disabled)
-		fthr = MAX_FRAG_THRESHOLD;
-
-	if ((fthr < MIN_FRAG_THRESHOLD) || (fthr > MAX_FRAG_THRESHOLD)) {
-		ret = -EINVAL;
-	} else {
-		dev->frag_threshold = fthr & ~0x1; /* get an even value */
-	}
-
-	return ret;
-}
-
-static int at76_iw_handler_get_frag(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_param *frag, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	frag->value = dev->frag_threshold;
-	frag->disabled = (frag->value >= MAX_FRAG_THRESHOLD);
-	frag->fixed = 1;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFRAG - value %d, disabled %s",
-	         netdev->name, frag->value, (frag->disabled) ? "true" : "false");
-
-	return 0;
-}
-
-static int at76_iw_handler_get_txpow(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_param *power, char *extra)
-{
-	power->value = 15;
-	power->fixed = 1;	/* No power control */
-	power->disabled = 0;
-	power->flags = IW_TXPOW_DBM;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWTXPOW - txpow %d dBm", netdev->name,
-	         power->value);
-
-	return 0;
-}
-
-/* jal: short retry is handled by the firmware (at least 0.90.x),
-   while long retry is not (?) */
-static int at76_iw_handler_set_retry(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_param *retry, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRETRY disabled %d  flags x%x val %d",
-	         netdev->name, retry->disabled, retry->flags, retry->value);
-
-	if (!retry->disabled && (retry->flags & IW_RETRY_LIMIT)) {
-		if ((retry->flags & IW_RETRY_MIN) ||
-		    !(retry->flags & IW_RETRY_MAX)) {
-			dev->short_retry_limit = retry->value;
-		} else
-			ret = -EINVAL;
-	} else {
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-/* adapted (ripped) from atmel.c */
-static int at76_iw_handler_get_retry(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_param *retry, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRETRY", netdev->name);
-
-	retry->disabled = 0;      /* Can't be disabled */
-
-
-	retry->flags = IW_RETRY_LIMIT;
-	retry->value = dev->short_retry_limit;
-
-	return 0;
-}
-
-static int at76_iw_handler_set_encode(struct net_device *netdev,
-					  struct iw_request_info *info,
-					  struct iw_point *encoding,
-					  char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int index = (encoding->flags & IW_ENCODE_INDEX) - 1;
-	int len = encoding->length;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - enc.flags %08x "
-	         "pointer %p len %d", netdev->name, encoding->flags,
-	         encoding->pointer, encoding->length);
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - old wepstate: enabled %s key_id %d "
-	         "auth_mode %s",
-	         netdev->name, (dev->wep_enabled) ? "true" : "false",
-	         dev->wep_key_id,
-	         (dev->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
-
-	/* take the old default key if index is invalid */
-	if ((index < 0) || (index >= WEP_KEYS))
-		index = dev->wep_key_id;
-
-	if (len > 0) {
-		if (len > WEP_LARGE_KEY_LEN)
-			len = WEP_LARGE_KEY_LEN;
-
-		memset(dev->wep_keys[index], 0, WEP_KEY_LEN);
-		memcpy(dev->wep_keys[index], extra, len);
-		dev->wep_keys_len[index] = (len <= WEP_SMALL_KEY_LEN) ?
-		    WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN;
-		dev->wep_enabled = 1;
-	}
-
-	dev->wep_key_id = index;
-	dev->wep_enabled = ((encoding->flags & IW_ENCODE_DISABLED) == 0);
-
-	if (encoding->flags & IW_ENCODE_RESTRICTED)
-		dev->auth_mode = WLAN_AUTH_SHARED_KEY;
-	if (encoding->flags & IW_ENCODE_OPEN)
-		dev->auth_mode = WLAN_AUTH_OPEN;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - new wepstate: enabled %s key_id %d "
-	         "key_len %d auth_mode %s",
-	         netdev->name, (dev->wep_enabled) ? "true" : "false",
-	         dev->wep_key_id + 1, dev->wep_keys_len[dev->wep_key_id],
-	         (dev->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
-
-	return -EIWCOMMIT;
-}
-
-static int at76_iw_handler_get_encode(struct net_device *netdev,
-					  struct iw_request_info *info,
-					  struct iw_point *encoding,
-					  char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int index = (encoding->flags & IW_ENCODE_INDEX) - 1;
-
-	if ((index < 0) || (index >= WEP_KEYS))
-		index = dev->wep_key_id;
-
-	encoding->flags =
-	    (dev->auth_mode == WLAN_AUTH_SHARED_KEY) ?
-	    IW_ENCODE_RESTRICTED : IW_ENCODE_OPEN;
-
-	if (!dev->wep_enabled)
-		encoding->flags |= IW_ENCODE_DISABLED;
-
-	if (encoding->pointer) {
-		encoding->length = dev->wep_keys_len[index];
-
-		memcpy(extra, dev->wep_keys[index], dev->wep_keys_len[index]);
-
-		encoding->flags |= (index + 1);
-	}
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWENCODE - enc.flags %08x "
-		"pointer %p len %d", netdev->name, encoding->flags,
-		encoding->pointer, encoding->length);
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWENCODE - wepstate: enabled %s key_id %d "
-		"key_len %d auth_mode %s",
-		netdev->name, (dev->wep_enabled) ? "true" : "false",
-		dev->wep_key_id + 1, dev->wep_keys_len[dev->wep_key_id],
-		(dev->auth_mode == WLAN_AUTH_SHARED_KEY) ?
-			"restricted" : "open");
-
-	return 0;
-}
-
-static int at76_iw_handler_set_power(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_param *prq, char *extra)
-{
-	int err = -EIWCOMMIT;
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCSIWPOWER - disabled %s flags x%x value x%x",
-		 netdev->name, (prq->disabled) ? "true" : "false",
-		 prq->flags, prq->value);
-
-	if (prq->disabled) {
-		dev->pm_mode = AT76_PM_OFF;
-	} else {
-		switch (prq->flags & IW_POWER_MODE) {
-                case IW_POWER_ALL_R:
-		case IW_POWER_ON:
-                        break;
-		default:
-			err = -EINVAL;
-			goto out;
-		}
-		if (prq->flags & IW_POWER_PERIOD) {
-			dev->pm_period = prq->value;
-		}
-		if (prq->flags & IW_POWER_TIMEOUT) {
-			err = -EINVAL;
-			goto out;
-		}
-		dev->pm_mode = AT76_PM_ON;
-	}
-out:
-	return err;
-}
-
-static int at76_iw_handler_get_power(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_param *power, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	if ((power->disabled = (dev->pm_mode == AT76_PM_OFF)))
-		return 0;
-	else {
-		power->flags = IW_POWER_PERIOD;
-		power->value = dev->pm_period;
-	}
-	power->flags |= IW_POWER_ALL_R;
-
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWPOWER - disabled %s flags x%x value x%x",
-		 netdev->name, (power->disabled) ? "true" : "false",
-		 power->flags, power->value);
-
-	return 0;
-}
-
-
-/*******************************************************************************
- * Private IOCTLS
- */
-static int at76_iw_set_short_preamble(struct net_device *netdev,
-				      struct iw_request_info *info, char *name,
-				      char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int val = *((int *)name);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, "%s: AT76_SET_SHORT_PREAMBLE, %d",
-	         netdev->name, val);
-
-	if (val < 0 || val > 2) {
-		/* allow value of 2 - in the win98 driver it stands
-		   for "auto preamble" ...? */
-		ret = -EINVAL;
-	} else {
-		dev->preamble_type = val;
-	}
-
-	return ret;
-}
-
-static int at76_iw_set_debug(struct net_device *netdev,
-			     struct iw_request_info *info,
-			     struct iw_point *data, char *extra)
-{
-	char *ptr;
-	u32 val;
-
-	if (data->length > 0) {
-		val = simple_strtol(extra, &ptr, 0);
-
-		if (ptr == extra) {
-			val = DBG_DEFAULTS;
-		}
-
-		dbg("%s: AT76_SET_DEBUG input %d: %s -> x%x",
-		       netdev->name, data->length, extra, val);
-	} else {
-		val = DBG_DEFAULTS;
-	}
-
-	dbg("%s: AT76_SET_DEBUG, old 0x%x  new 0x%x",
-	       netdev->name, at76_debug, val);
-
-	/* jal: some more output to pin down lockups */
-	dbg("%s: netif running %d queue_stopped %d carrier_ok %d",
-	       netdev->name,
-	       netif_running(netdev),
-	       netif_queue_stopped(netdev), netif_carrier_ok(netdev));
-
-	at76_debug = val;
-
-	return 0;
-}
-
-static int at76_iw_set_powersave_mode(struct net_device *netdev,
-				      struct iw_request_info *info, char *name,
-				      char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int val = *((int *)name);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, "%s: AT76_SET_POWERSAVE_MODE, %d (%s)",
-	         netdev->name, val,
-	         val == AT76_PM_OFF ? "active" : val == AT76_PM_ON ? "save" :
-	         val == AT76_PM_SMART ? "smart save" : "<invalid>");
-	if (val < AT76_PM_OFF || val > AT76_PM_SMART) {
-		ret = -EINVAL;
-	} else {
-		dev->pm_mode = val;
-	}
-
-	return ret;
-}
-
-static int at76_iw_set_scan_times(struct net_device *netdev,
-				  struct iw_request_info *info, char *name,
-				  char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int mint = *((int *)name);
-	int maxt = *((int *)name + 1);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, "%s: AT76_SET_SCAN_TIMES - min %d max %d",
-	         netdev->name, mint, maxt);
-	if (mint <= 0 || maxt <= 0 || mint > maxt) {
-		ret = -EINVAL;
-	} else {
-		if (dev->istate == MONITORING) {
-			dev->monitor_scan_min_time = mint;
-			dev->monitor_scan_max_time = maxt;
-			ret = 0;
-		} else {
-			dev->scan_min_time = mint;
-			dev->scan_max_time = maxt;
-		}
-	}
-
-	return ret;
-}
-
-static int at76_iw_set_scan_mode(struct net_device *netdev,
-				 struct iw_request_info *info, char *name,
-				 char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int val = *((int *)name);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, "%s: AT76_SET_SCAN_MODE - mode %s",
-		 netdev->name, (val = SCAN_TYPE_ACTIVE) ? "active" :
-		 (val = SCAN_TYPE_PASSIVE) ? "passive" : "<invalid>");
-
-	if (val != SCAN_TYPE_ACTIVE && val != SCAN_TYPE_PASSIVE) {
-		ret = -EINVAL;
-	} else {
-		dev->scan_mode = val;
-	}
-
-	return ret;
-}
-
-static int at76_set_iroaming(struct at76_priv *dev, int onoff)
-{
-	int ret = 0;
-
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC_MGMT;
-	dev->mib_buf.size = 1;
-	dev->mib_buf.index = IROAMING_OFFSET;
-	dev->mib_buf.data[0] = (dev->international_roaming ? 1 : 0);
-	ret = at76_set_mib(dev, &dev->mib_buf);
-	if (ret < 0) {
-		err("%s: set_mib (intl_roaming_enable) failed: %d", dev->netdev->name, ret);
-	}
-
-	return ret;
-}
-
-static int at76_iw_set_intl_roaming(struct net_device *netdev,
-				    struct iw_request_info *info, char *name,
-				    char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int val = *((int *)name);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, "%s: AT76_SET_INTL_ROAMING - mode %s",
-	         netdev->name, (val == IR_OFF) ? "off" :
-	         (val == IR_ON) ? "on" : "<invalid>");
-
-	if (val != IR_OFF && val != IR_ON) {
-		ret = -EINVAL;
-	} else {
-		if (dev->international_roaming != val) {
-			dev->international_roaming = val;
-			at76_set_iroaming(dev, val);
-		}
-	}
-
-	return ret;
-}
-
-/**
- * set_monitor_mode - sets dev->netdev->type
- */
-static void at76_set_monitor_mode(struct at76_priv *dev)
-{
-	if (dev->iw_mode == IW_MODE_MONITOR) {
-		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE ON",
-			 dev->netdev->name);
-		dev->netdev->type = ARPHRD_IEEE80211_RADIOTAP;
-	} else {
-		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE OFF",
-		         dev->netdev->name);
-		dev->netdev->type = ARPHRD_ETHER;
-	}
-}
-
-
-/*******************************************************************************
- * structure that advertises the iw handlers of this driver
- */
-static const iw_handler	at76_handlers[] =
-{
-        [SIOCSIWCOMMIT-SIOCIWFIRST] = (iw_handler) at76_iw_handler_commit,
-        [SIOCGIWNAME  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_name,
-        [SIOCSIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_freq,
-        [SIOCGIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_freq,
-        [SIOCSIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_mode,
-        [SIOCGIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_mode,
-        [SIOCGIWRANGE -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_range,
-        [SIOCSIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_spy,
-        [SIOCGIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_spy,
-        [SIOCSIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_thrspy,
-        [SIOCGIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_thrspy,
-        [SIOCSIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_wap,
-        [SIOCGIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_wap,
-        [SIOCSIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_scan,
-        [SIOCGIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_scan,
-        [SIOCSIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_essid,
-        [SIOCGIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_essid,
-        [SIOCSIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rate,
-        [SIOCGIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rate,
-        [SIOCSIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rts,
-        [SIOCGIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rts,
-        [SIOCSIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_frag,
-        [SIOCGIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_frag,
-        [SIOCGIWTXPOW -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_txpow,
-        [SIOCSIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_retry,
-        [SIOCGIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_retry,
-        [SIOCSIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_encode,
-        [SIOCGIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_encode,
-        [SIOCSIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_power,
-        [SIOCGIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_power,
-};
-
-#define AT76_SET_PRIV(h, f) [h - SIOCIWFIRSTPRIV] = (iw_handler) f
-
-/*structure that advertises the private iw handlers of this driver */
-static const iw_handler at76_priv_handlers[] = {
-	AT76_SET_PRIV(AT76_SET_SHORT_PREAMBLE, at76_iw_set_short_preamble),
-	AT76_SET_PRIV(AT76_SET_DEBUG, at76_iw_set_debug),
-	AT76_SET_PRIV(AT76_SET_POWERSAVE_MODE, at76_iw_set_powersave_mode),
-	AT76_SET_PRIV(AT76_SET_SCAN_TIMES, at76_iw_set_scan_times),
-	AT76_SET_PRIV(AT76_SET_SCAN_MODE, at76_iw_set_scan_mode),
-	AT76_SET_PRIV(AT76_SET_INTL_ROAMING, at76_iw_set_intl_roaming),
-};
-
-static const struct iw_handler_def at76_handler_def =
-{
-	.num_standard	= ARRAY_SIZE(at76_handlers),
-	.num_private	= ARRAY_SIZE(at76_priv_handlers),
-	.num_private_args = ARRAY_SIZE(at76_priv_args),
-	.standard	= at76_handlers,
-	.private	= at76_priv_handlers,
-	.private_args	= at76_priv_args,
- 	.get_wireless_stats = at76_get_wireless_stats,
-};
-
-
-static void at76_ethtool_get_drvinfo(struct net_device *netdev,
-					 struct ethtool_drvinfo *info)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	strncpy(info->driver, DRIVER_NAME, sizeof(info->driver) - 1);
-
-	strncpy(info->version, DRIVER_VERSION, sizeof(info->version));
-	info->version[sizeof(info->version) - 1] = '\0';
-
-	snprintf(info->bus_info, sizeof(info->bus_info) - 1, "usb%d:%d",
-		 dev->udev->bus->busnum, dev->udev->devnum);
-
-	snprintf(info->fw_version, sizeof(info->fw_version) - 1,
-		 "%d.%d.%d-%d",
-		 dev->fw_version.major, dev->fw_version.minor,
-		 dev->fw_version.patch, dev->fw_version.build);
-}
-
-static u32 at76_ethtool_get_link(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	return dev->istate == CONNECTED;
-}
-
-static struct ethtool_ops at76_ethtool_ops = {
-	.get_drvinfo = at76_ethtool_get_drvinfo,
-	.get_link = at76_ethtool_get_link,
-};
-
-static void at76_delete_device(struct at76_priv *dev)
-{
-	int i;
-
-	if (!dev)
-		return;
-
-	/* signal to _stop() that the device is gone */
-	dev->device_unplugged = 1;
-
-	at76_dbg(DBG_PROC_ENTRY, "%s: ENTER",__FUNCTION__);
-
-	if (dev->netdev_registered) {
-		unregister_netdev(dev->netdev);
-	}
-
-	usb_put_dev(dev->udev);
-
-	/* assuming we used keventd, it must quiesce too */
-	flush_scheduled_work();
-
-	if (dev->bulk_out_buffer != NULL)
-		kfree(dev->bulk_out_buffer);
-
-	kfree(dev->ctrl_buffer);
-
-	if (dev->write_urb != NULL) {
-		usb_kill_urb(dev->write_urb);
-		usb_free_urb(dev->write_urb);
-	}
-	if (dev->read_urb != NULL) {
-		usb_kill_urb(dev->read_urb);
-		usb_free_urb(dev->read_urb);
-	}
-	if (dev->ctrl_buffer != NULL) {
-		usb_kill_urb(dev->ctrl_urb);
-		usb_free_urb(dev->ctrl_urb);
-	}
-
-	at76_dbg(DBG_PROC_ENTRY, "%s: unlinked urbs", __FUNCTION__);
-
-	if (dev->rx_skb != NULL)
-		kfree_skb(dev->rx_skb);
-
-	at76_free_bss_list(dev);
-	del_timer_sync(&dev->bss_list_timer);
-
-	if (dev->istate == CONNECTED) {
-		at76_iwevent_bss_disconnect(dev->netdev);
-	}
-
-	for (i = 0; i < NR_RX_DATA_BUF; i++)
-		if (dev->rx_data[i].skb != NULL) {
-			dev_kfree_skb(dev->rx_data[i].skb);
-			dev->rx_data[i].skb = NULL;
-		}
-	at76_dbg(DBG_PROC_ENTRY, "%s: before freeing dev/netdev", __FUNCTION__);
-	free_netdev(dev->netdev); /* dev is in netdev */
-
-	at76_dbg(DBG_PROC_ENTRY, "%s: EXIT", __FUNCTION__);
-}
-
-static int at76_alloc_urbs(struct at76_priv *dev)
-{
-	struct usb_interface *interface = dev->interface;
-	struct usb_endpoint_descriptor *endpoint;
-	struct usb_device *udev = dev->udev;
-	int i, buffer_size;
-	struct usb_host_interface *iface_desc;
-
-	at76_dbg(DBG_PROC_ENTRY, "%s: ENTER", __FUNCTION__);
-
-	at76_dbg(DBG_URB, "%s: NumEndpoints %d ", __FUNCTION__,
-	    interface->altsetting[0].desc.bNumEndpoints);
-
-	iface_desc = interface->cur_altsetting;
-	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
-		endpoint = &iface_desc->endpoint[i].desc;
-
-		at76_dbg(DBG_URB, "%s: %d. endpoint: addr x%x attr x%x",
-		    __FUNCTION__,
-		    i, endpoint->bEndpointAddress, endpoint->bmAttributes);
-
-		if ((endpoint->bEndpointAddress & 0x80) &&
-		    ((endpoint->bmAttributes & 3) == 0x02)) {
-			/* we found a bulk in endpoint */
-
-			dev->read_urb = usb_alloc_urb(0, GFP_KERNEL);
-			if (!dev->read_urb) {
-				err("No free urbs available");
-				return -ENOMEM;
-			}
-			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
-		}
-
-		if (((endpoint->bEndpointAddress & 0x80) == 0x00) &&
-		    ((endpoint->bmAttributes & 3) == 0x02)) {
-			/* we found a bulk out endpoint */
-			dev->write_urb = usb_alloc_urb(0, GFP_KERNEL);
-			if (!dev->write_urb) {
-				err("no free urbs available");
-				return -ENOMEM;
-			}
-			buffer_size = sizeof(struct at76_tx_buffer) +
-			    MAX_PADDING_SIZE;
-			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
-			dev->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);
-			if (!dev->bulk_out_buffer) {
-				err("couldn't allocate bulk_out_buffer");
-				return -ENOMEM;
-			}
-			usb_fill_bulk_urb(dev->write_urb, udev,
-				          usb_sndbulkpipe(udev,
-						      endpoint->bEndpointAddress),
-				          dev->bulk_out_buffer, buffer_size,
-				          at76_write_bulk_callback, dev);
-		}
-	}
-
-	dev->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!dev->ctrl_urb) {
-		err("no free urbs available");
-		return -ENOMEM;
-	}
-	dev->ctrl_buffer = kmalloc(1024, GFP_KERNEL);
-	if (!dev->ctrl_buffer) {
-		err("couldn't allocate ctrl_buffer");
-		return -ENOMEM;
-	}
-
-	at76_dbg(DBG_PROC_ENTRY, "%s: EXIT", __FUNCTION__);
-
-	return 0;
-}
 
 static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 					       int board_type)
@@ -5912,122 +6153,6 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 }
 
 
-/**
- * at76_init_new_device - continue device initialization after firmware download
- *
- * FIXME: We may have to move the register_netdev into at76_alloc_new_device,
- * because hotplug may try to configure the netdev _before_ (or parallel to)
- * the download of firmware
- */
-static int at76_init_new_device(struct at76_priv *dev)
-{
-	struct net_device *netdev = dev->netdev;
-	int ret;
-
-	/* set up the endpoint information */
-	/* check out the endpoints */
-
-	dev->interface = dev->udev->actconfig->interface[0];
-
-	at76_dbg(DBG_DEVSTART, "USB interface: %d endpoints",
-	         dev->interface->cur_altsetting->desc.bNumEndpoints);
-
-	if ((ret = at76_alloc_urbs(dev)) < 0)
-		goto error;
-
-	/* get firmware version */
-	ret = at76_get_mib(dev->udev, MIB_FW_VERSION, &dev->fw_version,
-			   sizeof(dev->fw_version));
-	if ((ret < 0) || ((dev->fw_version.major == 0) &&
-			  (dev->fw_version.minor == 0) &&
-			  (dev->fw_version.patch == 0) &&
-			  (dev->fw_version.build == 0))) {
-		err("getting firmware failed with %d, or version is 0", ret);
-		err("this probably means that the ext. fw was not loaded correctly");
-		if(ret >= 0)
-			ret = -ENODEV;
-		goto error;
-	}
-
-	/* fw 0.84 doesn't send FCS with rx data */
-	if (dev->fw_version.major == 0 && dev->fw_version.minor <= 84)
-		dev->rx_data_fcs_len = 0;
-	else
-		dev->rx_data_fcs_len = 4;
-
-	info("firmware version %d.%d.%d #%d (fcs_len %d)",
-	     dev->fw_version.major, dev->fw_version.minor,
-	     dev->fw_version.patch, dev->fw_version.build,
-	     dev->rx_data_fcs_len);
-
-	/* MAC address */
-	ret = at76_get_hw_config(dev);
-	if (ret < 0) {
-		err("could not get MAC address");
-		goto error;
-	}
-
-	dev->domain = at76_get_reg_domain(dev->regulatory_domain);
-	/* init. netdev->dev_addr */
-	memcpy(netdev->dev_addr, dev->mac_addr, ETH_ALEN);
-	info("device's MAC %s, regulatory domain %s (id %d)",
-	     mac2str(dev->mac_addr), dev->domain->name, dev->regulatory_domain);
-
-	/* initializing */
-	dev->international_roaming = international_roaming;
-	dev->channel = DEF_CHANNEL;
-	dev->iw_mode = default_iw_mode;
-	memset(dev->essid, 0, IW_ESSID_MAX_SIZE);
-	dev->rts_threshold = DEF_RTS_THRESHOLD;
-	dev->frag_threshold = DEF_FRAG_THRESHOLD;
-	dev->short_retry_limit = DEF_SHORT_RETRY_LIMIT;
-	dev->txrate = TX_RATE_AUTO;
-	dev->preamble_type = preamble_type;
-	dev->beacon_period = 100;
-	dev->beacons_last_qual = jiffies_to_msecs(jiffies);
-	dev->auth_mode = auth_mode ? WLAN_AUTH_SHARED_KEY : WLAN_AUTH_OPEN;
-	dev->scan_min_time = scan_min_time;
-	dev->scan_max_time = scan_max_time;
-	dev->scan_mode = scan_mode;
-	dev->monitor_scan_min_time = monitor_scan_min_time;
-	dev->monitor_scan_max_time = monitor_scan_max_time;
-
-	netdev->flags &= ~IFF_MULTICAST; /* not yet or never */
-	netdev->open = at76_open;
-	netdev->stop = at76_stop;
-	netdev->get_stats = at76_get_stats;
-	netdev->ethtool_ops = &at76_ethtool_ops;
-
-	/* Add pointers to enable iwspy support. */
-	dev->wireless_data.spy_data = &dev->spy_data;
-	netdev->wireless_data = &dev->wireless_data;
-
-	netdev->hard_start_xmit = at76_tx;
-	netdev->tx_timeout = at76_tx_timeout;
-	netdev->watchdog_timeo = 2 * HZ;
-	netdev->wireless_handlers = &at76_handler_def;
-	netdev->set_multicast_list = at76_set_multicast;
-	netdev->set_mac_address = at76_set_mac_address;
-
-	ret = register_netdev(dev->netdev);
-	if (ret) {
-		err("unable to register netdevice %s (status %d)!",
-		    dev->netdev->name, ret);
-		goto error;
-	}
-	info("registered %s", dev->netdev->name);
-	dev->netdev_registered = 1;
-
-	/* we let this timer run the whole time this driver instance lives */
-	mod_timer(&dev->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
-
-	return 0;
- error:
-	at76_delete_device(dev);
-	return ret;
-}
-
-
 /* Parse the firmware image */
 static int at76_parse_fw(struct at76_priv *dev, u8 *fw_data, int fw_size,
 			 int board_type)
@@ -6069,6 +6194,7 @@ static int at76_parse_fw(struct at76_priv *dev, u8 *fw_data, int fw_size,
 	return 0;
 }
 
+
 static int at76_probe(struct usb_interface *interface,
 		      const struct usb_device_id *id)
 {
@@ -6179,6 +6305,7 @@ static int at76_probe(struct usb_interface *interface,
 	return ret;
 }
 
+
 static void at76_disconnect(struct usb_interface *interface)
 {
 	struct at76_priv *priv;
@@ -6191,6 +6318,7 @@ static void at76_disconnect(struct usb_interface *interface)
 	info(DRIVER_NAME " disconnected");
 }
 
+
 /* structure for registering this driver with the USB subsystem */
 static struct usb_driver at76_driver = {
 	.name = DRIVER_NAME,
@@ -6199,6 +6327,7 @@ static struct usb_driver at76_driver = {
 	.id_table = dev_table,
 };
 
+
 static int __init at76_mod_init(void)
 {
 	int result;
@@ -6215,6 +6344,7 @@ static int __init at76_mod_init(void)
 	return result;
 }
 
+
 static void __exit at76_mod_exit(void)
 {
 	int i;
@@ -6228,6 +6358,7 @@ static void __exit at76_mod_exit(void)
 	led_trigger_unregister_simple(ledtrig_tx);
 }
 
+
 module_param_named(debug, at76_debug, int, 0600);
 MODULE_PARM_DESC(debug, "Debugging level");
 module_param(rx_copybreak, int, 0400);




From proski at gnu.org  Wed May  2 02:01:07 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 01 May 2007 20:01:07 -0400
Subject: [at76c503a-develop] [PATCH 6/6] Replace semaphores with mutexes
In-Reply-To: <20070502000041.14011.47848.stgit@dv.roinet.com>
References: <20070502000041.14011.47848.stgit@dv.roinet.com>
Message-ID: <20070502000107.14011.31624.stgit@dv.roinet.com>

Semaphores are overkill for simple locking.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   60 ++++++++++++++++++++++++++++++------------------------------
 at76_usb.h |    2 +-
 2 files changed, 31 insertions(+), 31 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index b66536d..62172ff 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -2288,7 +2288,7 @@ static void at76_work_assoc_done(struct work_struct *work)
 	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_assoc_done);
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 
 	at76_assert(priv->istate == ASSOCIATING || priv->istate == REASSOCIATING);
 	if (priv->iw_mode == IW_MODE_INFRA) {
@@ -2323,7 +2323,7 @@ static void at76_work_assoc_done(struct work_struct *work)
 	at76_dbg(DBG_PROGRESS, "%s: connected to BSSID %s",
 	         priv->netdev->name, mac2str(priv->curr_bss->bssid));
 
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4033,7 +4033,7 @@ static int at76_open(struct net_device *netdev)
 
 	at76_dbg(DBG_PROC_ENTRY, "at76_open entry");
 
-	if (down_interruptible(&priv->sem))
+	if (mutex_lock_interruptible(&priv->mtx))
 		return -EINTR;
 
 	/* if netdev->dev_addr != priv->mac_addr we must
@@ -4062,7 +4062,7 @@ static int at76_open(struct net_device *netdev)
 
 	at76_dbg(DBG_PROC_ENTRY, "at76_open end");
  err:
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 	return ret < 0 ? ret : 0;
 }
 
@@ -4074,7 +4074,7 @@ static int at76_stop(struct net_device *netdev)
 
 	at76_dbg(DBG_DEVSTART, "%s: ENTER", __FUNCTION__);
 
-	if (down_interruptible(&priv->sem))
+	if (mutex_lock_interruptible(&priv->mtx))
 		return -EINTR;
 
 	netif_stop_queue(netdev);
@@ -4107,7 +4107,7 @@ static int at76_stop(struct net_device *netdev)
 	at76_assert(priv->open_count > 0);
 	priv->open_count--;
 
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 	at76_dbg(DBG_DEVSTART, "%s: EXIT", __FUNCTION__);
 
 	return 0;
@@ -4271,7 +4271,7 @@ static void at76_work_external_fw(struct work_struct *work)
 	int ret;
 	u8 op_mode;
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 
 	op_mode = at76_get_op_mode(priv->udev);
 	at76_dbg(DBG_DEVSTART, "opmode %d", op_mode);
@@ -4290,7 +4290,7 @@ static void at76_work_external_fw(struct work_struct *work)
 		}
 		if (priv->board_type == BOARDTYPE_505A_RFMD_2958) {
 			info("200 ms delay for board type 7");
-			/* can we do this with priv->sem down? */
+			/* can we do this with priv->mtx down? */
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(HZ / 5 + 1);
 		}
@@ -4300,7 +4300,7 @@ static void at76_work_external_fw(struct work_struct *work)
 		err("Downloading external firmware failed: %d", ret);
 
   end_external_fw:
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4311,7 +4311,7 @@ static void at76_work_internal_fw(struct work_struct *work)
 					     work_internal_fw);
 	int ret;
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 
 	ret = at76_usbdfu_download(priv->udev, priv->intfw,
 			           priv->intfw_size,
@@ -4337,7 +4337,7 @@ static void at76_work_internal_fw(struct work_struct *work)
 	mod_timer(&priv->fw_dl_timer, jiffies + 2 * HZ + 1);
 
   end_internal_fw:
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4475,7 +4475,7 @@ static void at76_work_join(struct work_struct *work)
 	int ret;
 	unsigned long flags;
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 
 	if (priv->istate == INIT)
 		goto end_join;
@@ -4547,7 +4547,7 @@ static void at76_work_join(struct work_struct *work)
 	schedule_work(&priv->work_scan);
 
   end_join:
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4556,9 +4556,9 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_mgmt_timeout);
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 	at76_handle_mgmt_timeout(priv);
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4570,7 +4570,7 @@ static void at76_work_new_bss(struct work_struct *work)
 	struct net_device *netdev = priv->netdev;
 	struct mib_mac_mgmt mac_mgmt;
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 
 	ret = at76_get_mib(priv->udev, MIB_MAC_MGMT, &mac_mgmt,
 		      sizeof(struct mib_mac_mgmt));
@@ -4594,7 +4594,7 @@ static void at76_work_new_bss(struct work_struct *work)
 		err("%s: set_mib (ibss change ok) failed: %d", netdev->name, ret);
 
   new_bss_clean:
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4603,10 +4603,10 @@ static void at76_work_reset_device(struct work_struct *work)
 	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_reset_device);
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 	usb_reset_device(priv->udev);
 	priv->istate = WAIT_FOR_DISCONNECT;
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4758,7 +4758,7 @@ static void at76_work_restart(struct work_struct *work)
 	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_restart);
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 
 	at76_startup_device(priv);
 	at76_set_monitor_mode(priv);
@@ -4778,7 +4778,7 @@ static void at76_work_restart(struct work_struct *work)
 			  jiffies + SCAN_POLL_INTERVAL);
 	}
 
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4788,7 +4788,7 @@ static void at76_work_scan(struct work_struct *work)
 					     work_scan);
 	int ret;
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 
 	at76_assert(priv->istate == SCANNING);
 	/* only clear the bss list when a scan is actively initiated,
@@ -4806,7 +4806,7 @@ static void at76_work_scan(struct work_struct *work)
 		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 	}
 
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4816,7 +4816,7 @@ static void at76_work_set_promisc(struct work_struct *work)
 					     work_set_promisc);
 	int ret = 0;
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 
 	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
 	priv->mib_buf.type = MIB_LOCAL;
@@ -4829,7 +4829,7 @@ static void at76_work_set_promisc(struct work_struct *work)
 		    priv->netdev->name, ret);
 	}
 
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4839,7 +4839,7 @@ static void at76_work_start_ibss(struct work_struct *work)
 					     work_start_ibss);
 	int ret;
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 
 	at76_assert(priv->istate == STARTIBSS);
 	ret = at76_start_ibss(priv);
@@ -4878,7 +4878,7 @@ static void at76_work_start_ibss(struct work_struct *work)
 	netif_start_queue(priv->netdev);
 
   end_startibss:
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -4887,9 +4887,9 @@ static void at76_work_submit_rx(struct work_struct *work)
 	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_submit_rx);
 
-	down(&priv->sem);
+	mutex_lock(&priv->mtx);
 	at76_submit_rx_urb(priv);
-	up(&priv->sem);
+	mutex_unlock(&priv->mtx);
 }
 
 
@@ -6097,7 +6097,7 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 	priv->udev = udev;
 	priv->netdev = netdev;
 
-	init_MUTEX(&priv->sem);
+	mutex_init(&priv->mtx);
 	INIT_WORK(&priv->work_assoc_done, at76_work_assoc_done);
 	INIT_WORK(&priv->work_external_fw, at76_work_external_fw);
 	INIT_WORK(&priv->work_internal_fw, at76_work_internal_fw);
diff --git a/at76_usb.h b/at76_usb.h
index f32bb61..34f1862 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -466,7 +466,7 @@ struct at76_priv {
 	__u8 bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
 
 	int open_count;		/* number of times this port has been opened */
-	struct semaphore sem;	/* locks this structure */
+	struct mutex mtx;	/* locks this structure */
 
 	/* work queues */
 	struct work_struct work_assoc_done;




From proski at gnu.org  Wed May  2 02:01:02 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 01 May 2007 20:01:02 -0400
Subject: [at76c503a-develop] [PATCH 5/6] Call private data (at76_priv)
	"priv", not "dev", the later is ambiguous
In-Reply-To: <20070502000041.14011.47848.stgit@dv.roinet.com>
References: <20070502000041.14011.47848.stgit@dv.roinet.com>
Message-ID: <20070502000102.14011.658.stgit@dv.roinet.com>

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c | 2586 ++++++++++++++++++++++++++++++------------------------------
 at76_usb.h |    6 
 2 files changed, 1296 insertions(+), 1296 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 4659060..b66536d 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -534,21 +534,21 @@ static inline int at76_is_cloaked_ssid(u8 *ssid, int length)
 }
 
 
-static inline void at76_free_bss_list(struct at76_priv *dev)
+static inline void at76_free_bss_list(struct at76_priv *priv)
 {
 	struct list_head *next, *ptr;
 	unsigned long flags;
 
-	spin_lock_irqsave(&dev->bss_list_spinlock, flags);
+	spin_lock_irqsave(&priv->bss_list_spinlock, flags);
 
-	dev->curr_bss = dev->new_bss = NULL;
+	priv->curr_bss = priv->new_bss = NULL;
 
-	list_for_each_safe(ptr, next, &dev->bss_list) {
+	list_for_each_safe(ptr, next, &priv->bss_list) {
 		list_del(ptr);
 		kfree(list_entry(ptr, struct bss_info, list));
 	}
 
-	spin_unlock_irqrestore(&dev->bss_list_spinlock, flags);
+	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
 
 
@@ -649,10 +649,10 @@ static inline int get_hw_cfg_intersil(struct usb_device *udev,
 
 
 /* Get the hardware configuration for the adapter and place the appropriate
- * data in the appropriate fields of 'dev' (the GetHWConfig request and
+ * data in the appropriate fields of 'priv' (the GetHWConfig request and
  * interpretation of the result depends on the type of board we're dealing
  * with) */
-static int at76_get_hw_config(struct at76_priv *dev)
+static int at76_get_hw_config(struct at76_priv *priv)
 {
 	int ret;
 	union at76_hwcfg *hwcfg = kmalloc(sizeof(*hwcfg), GFP_KERNEL);
@@ -660,39 +660,39 @@ static int at76_get_hw_config(struct at76_priv *dev)
 	if (!hwcfg)
 		return -ENOMEM;
 
-	switch (dev->board_type) {
+	switch (priv->board_type) {
 
 	case BOARDTYPE_503_INTERSIL_3861:
 	case BOARDTYPE_503_INTERSIL_3863:
-		ret = get_hw_cfg_intersil(dev->udev, hwcfg, sizeof(hwcfg->i));
+		ret = get_hw_cfg_intersil(priv->udev, hwcfg, sizeof(hwcfg->i));
 		if (ret < 0)
 			break;
-		memcpy(dev->mac_addr, hwcfg->i.mac_addr, ETH_ALEN);
-		dev->regulatory_domain = hwcfg->i.regulatory_domain;
+		memcpy(priv->mac_addr, hwcfg->i.mac_addr, ETH_ALEN);
+		priv->regulatory_domain = hwcfg->i.regulatory_domain;
 		break;
 
 	case BOARDTYPE_503_RFMD:
 	case BOARDTYPE_503_RFMD_ACC:
-		ret = at76_get_hw_cfg_rfmd(dev->udev, hwcfg, sizeof(hwcfg->r3));
+		ret = at76_get_hw_cfg_rfmd(priv->udev, hwcfg, sizeof(hwcfg->r3));
 		if (ret < 0)
 			break;
-		memcpy(dev->mac_addr, hwcfg->r3.mac_addr, ETH_ALEN);
-		dev->regulatory_domain = hwcfg->r3.regulatory_domain;
+		memcpy(priv->mac_addr, hwcfg->r3.mac_addr, ETH_ALEN);
+		priv->regulatory_domain = hwcfg->r3.regulatory_domain;
 		break;
 
 	case BOARDTYPE_505_RFMD:
 	case BOARDTYPE_505_RFMD_2958:
 	case BOARDTYPE_505A_RFMD_2958:
-		ret = at76_get_hw_cfg_rfmd(dev->udev, hwcfg, sizeof(hwcfg->r5));
+		ret = at76_get_hw_cfg_rfmd(priv->udev, hwcfg, sizeof(hwcfg->r5));
 		if (ret < 0)
 			break;
-		memcpy(dev->mac_addr, hwcfg->r5.mac_addr, ETH_ALEN);
-		dev->regulatory_domain = hwcfg->r5.regulatory_domain;
+		memcpy(priv->mac_addr, hwcfg->r5.mac_addr, ETH_ALEN);
+		priv->regulatory_domain = hwcfg->r5.regulatory_domain;
 		break;
 
 	default:
 		err("Bad board type set (%d).  Unable to get hardware config.",
-		    dev->board_type);
+		    priv->board_type);
 		ret = -EINVAL;
 	}
 
@@ -851,13 +851,13 @@ static const char *at76_get_cmd_status_string(u8 cmd_status)
 
 
 /* TODO: should timeout */
-static int at76_wait_completion(struct at76_priv *dev, int cmd)
+static int at76_wait_completion(struct at76_priv *priv, int cmd)
 {
-	struct net_device *netdev = dev->netdev;
+	struct net_device *netdev = priv->netdev;
 	int status = 0;
 
 	do {
-		status = at76_get_cmd_status(dev->udev, cmd);
+		status = at76_get_cmd_status(priv->udev, cmd);
 		if (status < 0) {
 			err("%s: at76_get_cmd_status failed: %d", netdev->name, status);
 			break;
@@ -865,7 +865,7 @@ static int at76_wait_completion(struct at76_priv *dev, int cmd)
 
 		at76_dbg(DBG_WAIT_COMPLETE,
 		         "%s: Waiting on cmd %d, status = %d (%s)",
-		         dev->netdev->name, cmd, status,
+		         priv->netdev->name, cmd, status,
 		         at76_get_cmd_status_string(status));
 
 		if (status == CMD_STATUS_IN_PROGRESS ||
@@ -880,9 +880,9 @@ static int at76_wait_completion(struct at76_priv *dev, int cmd)
 }
 
 
-static int at76_set_mib(struct at76_priv *dev, struct set_mib_buffer *buf)
+static int at76_set_mib(struct at76_priv *priv, struct set_mib_buffer *buf)
 {
-	struct usb_device *udev = dev->udev;
+	struct usb_device *udev = priv->udev;
 	int ret;
 	struct at76_command *cmd_buf = kmalloc(sizeof(struct at76_command) +
 					       buf->size + 4, GFP_KERNEL);
@@ -899,9 +899,9 @@ static int at76_set_mib(struct at76_priv *dev, struct set_mib_buffer *buf)
 				      sizeof(struct at76_command) +
 				      buf->size + 4, USB_CTRL_GET_TIMEOUT);
 		if (ret >= 0)
-			if ((ret = at76_wait_completion(dev, CMD_SET_MIB)) !=
+			if ((ret = at76_wait_completion(priv, CMD_SET_MIB)) !=
 			    CMD_STATUS_COMPLETE) {
-				info("%s: set_mib: at76_wait_completion failed with %d", dev->netdev->name, ret);
+				info("%s: set_mib: at76_wait_completion failed with %d", priv->netdev->name, ret);
 				ret = -EIO;
 			}
 		kfree(cmd_buf);
@@ -914,17 +914,17 @@ static int at76_set_mib(struct at76_priv *dev, struct set_mib_buffer *buf)
 
 
 /* return < 0 on error, == 0 if no command sent, == 1 if cmd sent */
-static int at76_set_radio(struct at76_priv *dev, int on_off)
+static int at76_set_radio(struct at76_priv *priv, int on_off)
 {
 	int ret;
 
-	if (dev->radio_on != on_off) {
-		ret = at76_set_card_command(dev->udev, CMD_RADIO, NULL, 0);
+	if (priv->radio_on != on_off) {
+		ret = at76_set_card_command(priv->udev, CMD_RADIO, NULL, 0);
 		if (ret < 0) {
-			err("%s: at76_set_card_command(CMD_RADIO) failed: %d", dev->netdev->name, ret);
+			err("%s: at76_set_card_command(CMD_RADIO) failed: %d", priv->netdev->name, ret);
 		} else
 			ret = 1;
-		dev->radio_on = on_off;
+		priv->radio_on = on_off;
 	} else
 		ret = 0;
 	return ret;
@@ -935,41 +935,41 @@ static int at76_set_radio(struct at76_priv *dev, int on_off)
  * set_pm_mode - set current power save mode
  * (AT76_PM_OFF/AT76_PM_ON/AT76_PM_SMART)
  */
-static int at76_set_pm_mode(struct at76_priv *dev)
+static int at76_set_pm_mode(struct at76_priv *priv)
 {
 	int ret = 0;
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC_MGMT;
-	dev->mib_buf.size = 1;
-	dev->mib_buf.index = POWER_MGMT_MODE_OFFSET;
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC_MGMT;
+	priv->mib_buf.size = 1;
+	priv->mib_buf.index = POWER_MGMT_MODE_OFFSET;
 
-	dev->mib_buf.data[0] = dev->pm_mode;
+	priv->mib_buf.data[0] = priv->pm_mode;
 
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (pm_mode) failed: %d", dev->netdev->name, ret);
+		err("%s: set_mib (pm_mode) failed: %d", priv->netdev->name, ret);
 	}
 	return ret;
 }
 
 
 /* sets the assoc id for power save mode */
-static int at76_set_associd(struct at76_priv *dev, u16 id)
+static int at76_set_associd(struct at76_priv *priv, u16 id)
 {
 	int ret = 0;
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC_MGMT;
-	dev->mib_buf.size = 2;
-	dev->mib_buf.index = STATION_ID_OFFSET;
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC_MGMT;
+	priv->mib_buf.size = 2;
+	priv->mib_buf.index = STATION_ID_OFFSET;
 
-	dev->mib_buf.data[0] = id & 0xff;
-	dev->mib_buf.data[1] = id >> 8;
+	priv->mib_buf.data[0] = id & 0xff;
+	priv->mib_buf.data[1] = id >> 8;
 
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (associd) failed: %d", dev->netdev->name, ret);
+		err("%s: set_mib (associd) failed: %d", priv->netdev->name, ret);
 	}
 	return ret;
 }
@@ -977,108 +977,108 @@ static int at76_set_associd(struct at76_priv *dev, u16 id)
 
 /* sets the listen interval for power save mode.
    really needed, as we have a similar parameter in the assocreq ??? */
-static int at76_set_listen_interval(struct at76_priv *dev, u16 interval)
+static int at76_set_listen_interval(struct at76_priv *priv, u16 interval)
 {
 	int ret = 0;
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC;
-	dev->mib_buf.size = 2;
-	dev->mib_buf.index = STATION_ID_OFFSET;
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC;
+	priv->mib_buf.size = 2;
+	priv->mib_buf.index = STATION_ID_OFFSET;
 
-	dev->mib_buf.data[0] = interval & 0xff;
-	dev->mib_buf.data[1] = interval >> 8;
+	priv->mib_buf.data[0] = interval & 0xff;
+	priv->mib_buf.data[1] = interval >> 8;
 
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
 		err("%s: set_mib (listen_interval) failed: %d",
-		    dev->netdev->name, ret);
+		    priv->netdev->name, ret);
 	}
 	return ret;
 }
 
 
-static int at76_set_preamble(struct at76_priv *dev, u8 type)
+static int at76_set_preamble(struct at76_priv *priv, u8 type)
 {
 	int ret = 0;
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_LOCAL;
-	dev->mib_buf.size = 1;
-	dev->mib_buf.index = PREAMBLE_TYPE_OFFSET;
-	dev->mib_buf.data[0] = type;
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_LOCAL;
+	priv->mib_buf.size = 1;
+	priv->mib_buf.index = PREAMBLE_TYPE_OFFSET;
+	priv->mib_buf.data[0] = type;
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (preamble) failed: %d", dev->netdev->name, ret);
+		err("%s: set_mib (preamble) failed: %d", priv->netdev->name, ret);
 	}
 	return ret;
 }
 
 
-static int at76_set_frag(struct at76_priv *dev, u16 size)
+static int at76_set_frag(struct at76_priv *priv, u16 size)
 {
 	int ret = 0;
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC;
-	dev->mib_buf.size = 2;
-	dev->mib_buf.index = FRAGMENTATION_OFFSET;
-	*(__le16 *) dev->mib_buf.data = cpu_to_le16(size);
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC;
+	priv->mib_buf.size = 2;
+	priv->mib_buf.index = FRAGMENTATION_OFFSET;
+	*(__le16 *) priv->mib_buf.data = cpu_to_le16(size);
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (frag threshold) failed: %d", dev->netdev->name, ret);
+		err("%s: set_mib (frag threshold) failed: %d", priv->netdev->name, ret);
 	}
 	return ret;
 }
 
 
-static int at76_set_rts(struct at76_priv *dev, u16 size)
+static int at76_set_rts(struct at76_priv *priv, u16 size)
 {
 	int ret = 0;
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC;
-	dev->mib_buf.size = 2;
-	dev->mib_buf.index = RTS_OFFSET;
-	*(__le16 *) dev->mib_buf.data = cpu_to_le16(size);
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC;
+	priv->mib_buf.size = 2;
+	priv->mib_buf.index = RTS_OFFSET;
+	*(__le16 *) priv->mib_buf.data = cpu_to_le16(size);
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (rts) failed: %d", dev->netdev->name, ret);
+		err("%s: set_mib (rts) failed: %d", priv->netdev->name, ret);
 	}
 	return ret;
 }
 
 
-static int at76_set_autorate_fallback(struct at76_priv *dev, int onoff)
+static int at76_set_autorate_fallback(struct at76_priv *priv, int onoff)
 {
 	int ret = 0;
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_LOCAL;
-	dev->mib_buf.size = 1;
-	dev->mib_buf.index = TX_AUTORATE_FALLBACK_OFFSET;
-	dev->mib_buf.data[0] = onoff;
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_LOCAL;
+	priv->mib_buf.size = 1;
+	priv->mib_buf.index = TX_AUTORATE_FALLBACK_OFFSET;
+	priv->mib_buf.data[0] = onoff;
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (autorate fallback) failed: %d", dev->netdev->name, ret);
+		err("%s: set_mib (autorate fallback) failed: %d", priv->netdev->name, ret);
 	}
 	return ret;
 }
 
 
-static int at76_add_mac_address(struct at76_priv *dev, void *addr)
+static int at76_add_mac_address(struct at76_priv *priv, void *addr)
 {
 	int ret = 0;
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC_ADD;
-	dev->mib_buf.size = ETH_ALEN;
-	dev->mib_buf.index = offsetof(struct mib_mac_addr, mac_addr);
-	memcpy(dev->mib_buf.data, addr, ETH_ALEN);
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC_ADD;
+	priv->mib_buf.size = ETH_ALEN;
+	priv->mib_buf.index = offsetof(struct mib_mac_addr, mac_addr);
+	memcpy(priv->mib_buf.data, addr, ETH_ALEN);
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
 		err("%s: set_mib (MAC_ADDR, mac_addr) failed: %d",
-		    dev->netdev->name, ret);
+		    priv->netdev->name, ret);
 	}
 	return ret;
 }
@@ -1087,33 +1087,33 @@ static int at76_add_mac_address(struct at76_priv *dev, void *addr)
 #if 0
 /* implemented to get promisc. mode working, but does not help.
    May still be useful for multicast eventually. */
-static int set_group_address(struct at76_priv *dev, u8 *addr, int n)
+static int set_group_address(struct at76_priv *priv, u8 *addr, int n)
 {
 	int ret = 0;
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC_ADD;
-	dev->mib_buf.size = ETH_ALEN;
-	dev->mib_buf.index =
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC_ADD;
+	priv->mib_buf.size = ETH_ALEN;
+	priv->mib_buf.index =
 	    offsetof(struct mib_mac_addr, group_addr) + n * ETH_ALEN;
-	memcpy(dev->mib_buf.data, addr, ETH_ALEN);
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	memcpy(priv->mib_buf.data, addr, ETH_ALEN);
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
 		err("%s: set_mib (MIB_MAC_ADD, group_addr) failed: %d",
-		    dev->netdev->name, ret);
+		    priv->netdev->name, ret);
 	}
 #if 1
 	/* I do not know anything about the group_addr_status field... (oku) */
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC_ADD;
-	dev->mib_buf.size = 1;
-	dev->mib_buf.index =
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC_ADD;
+	priv->mib_buf.size = 1;
+	priv->mib_buf.index =
 	    offsetof(struct mib_mac_addr, group_addr_status) + n;
-	dev->mib_buf.data[0] = 1;
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	priv->mib_buf.data[0] = 1;
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
 		err("%s: set_mib (MIB_MAC_ADD, group_addr_status) failed: %d",
-		    dev->netdev->name, ret);
+		    priv->netdev->name, ret);
 	}
 #endif
 	return ret;
@@ -1121,7 +1121,7 @@ static int set_group_address(struct at76_priv *dev, u8 *addr, int n)
 #endif
 
 
-static int at76_dump_mib_mac_addr(struct at76_priv *dev)
+static int at76_dump_mib_mac_addr(struct at76_priv *priv)
 {
 	int ret = 0;
 	struct mib_mac_addr *mac_addr =
@@ -1132,19 +1132,19 @@ static int at76_dump_mib_mac_addr(struct at76_priv *dev)
 		goto exit;
 	}
 
-	ret = at76_get_mib(dev->udev, MIB_MAC_ADD,
+	ret = at76_get_mib(priv->udev, MIB_MAC_ADD,
 			   mac_addr, sizeof(struct mib_mac_addr));
 	if (ret < 0) {
-		err("%s: at76_get_mib (MAC_ADDR) failed: %d", dev->netdev->name,
+		err("%s: at76_get_mib (MAC_ADDR) failed: %d", priv->netdev->name,
 		    ret);
 		goto err;
 	}
 
 	dbg("%s: MIB MAC_ADDR: mac_addr %s res 0x%x 0x%x group_addr %s status %d %d %d %d",
-	       dev->netdev->name, mac2str(mac_addr->mac_addr),
+	       priv->netdev->name, mac2str(mac_addr->mac_addr),
 		   mac_addr->res[0], mac_addr->res[1],
-	       hex2str(dev->obuf, mac_addr->group_addr,
-		       min((int)(sizeof(dev->obuf)-1)/2, 4*ETH_ALEN), '\0'),
+	       hex2str(priv->obuf, mac_addr->group_addr,
+		       min((int)(sizeof(priv->obuf)-1)/2, 4*ETH_ALEN), '\0'),
 	       mac_addr->group_addr_status[0], mac_addr->group_addr_status[1],
 	       mac_addr->group_addr_status[2], mac_addr->group_addr_status[3]);
 
@@ -1155,7 +1155,7 @@ static int at76_dump_mib_mac_addr(struct at76_priv *dev)
 }
 
 
-static int at76_dump_mib_mac_wep(struct at76_priv *dev)
+static int at76_dump_mib_mac_wep(struct at76_priv *priv)
 {
 	int ret = 0;
 	struct mib_mac_wep *mac_wep =
@@ -1165,28 +1165,28 @@ static int at76_dump_mib_mac_wep(struct at76_priv *dev)
 		ret = -ENOMEM;
 		goto exit;
 	}
-	ret = at76_get_mib(dev->udev, MIB_MAC_WEP, mac_wep,
+	ret = at76_get_mib(priv->udev, MIB_MAC_WEP, mac_wep,
 			   sizeof(struct mib_mac_wep));
 	if (ret < 0) {
-		err("%s: at76_get_mib (MAC_WEP) failed: %d", dev->netdev->name, ret);
+		err("%s: at76_get_mib (MAC_WEP) failed: %d", priv->netdev->name, ret);
 		goto err;
 	}
 
 	dbg("%s: MIB MAC_WEP: priv_invoked %u def_key_id %u key_len %u "
 	       "excl_unencr %u wep_icv_err %u wep_excluded %u encr_level %u key %d: %s",
-	       dev->netdev->name, mac_wep->privacy_invoked,
+	       priv->netdev->name, mac_wep->privacy_invoked,
 	       mac_wep->wep_default_key_id, mac_wep->wep_key_mapping_len,
 	       mac_wep->exclude_unencrypted,
 	       le32_to_cpu(mac_wep->wep_icv_error_count),
 	       le32_to_cpu(mac_wep->wep_excluded_count),
 	       mac_wep->encryption_level, mac_wep->wep_default_key_id,
-	       mac_wep->wep_default_key_id < 4 ? hex2str(dev->obuf,
+	       mac_wep->wep_default_key_id < 4 ? hex2str(priv->obuf,
 							 mac_wep->
 							 wep_default_keyvalue
 							 [mac_wep->
 							  wep_default_key_id],
 							 min((int)
-							     (sizeof(dev->obuf)
+							     (sizeof(priv->obuf)
 							      - 1) / 2,
 							     mac_wep->
 							     encryption_level ==
@@ -1201,7 +1201,7 @@ static int at76_dump_mib_mac_wep(struct at76_priv *dev)
 }
 
 
-static int at76_dump_mib_mac_mgmt(struct at76_priv *dev)
+static int at76_dump_mib_mac_mgmt(struct at76_priv *priv)
 {
 	int ret = 0;
 	struct mib_mac_mgmt *mac_mgmt =
@@ -1212,10 +1212,10 @@ static int at76_dump_mib_mac_mgmt(struct at76_priv *dev)
 		ret = -ENOMEM;
 		goto exit;
 	}
-	ret = at76_get_mib(dev->udev, MIB_MAC_MGMT, mac_mgmt,
+	ret = at76_get_mib(priv->udev, MIB_MAC_MGMT, mac_mgmt,
 			   sizeof(struct mib_mac_mgmt));
 	if (ret < 0) {
-		err("%s: at76_get_mib failed: %d", dev->netdev->name, ret);
+		err("%s: at76_get_mib failed: %d", priv->netdev->name, ret);
 		goto err;
 	}
 
@@ -1229,7 +1229,7 @@ static int at76_dump_mib_mac_mgmt(struct at76_priv *dev)
 	       "pm_mode %d ibss_change %d res %d "
 	       "multi_domain_capability_implemented %d "
 	       "international_roaming %d country_string %s",
-	       dev->netdev->name,
+	       priv->netdev->name,
 	       le16_to_cpu(mac_mgmt->beacon_period),
 	       le16_to_cpu(mac_mgmt->CFP_max_duration),
 	       le16_to_cpu(mac_mgmt->medium_occupancy_limit),
@@ -1240,8 +1240,8 @@ static int at76_dump_mib_mac_mgmt(struct at76_priv *dev)
 	       mac_mgmt->DTIM_period,
 	       mac_mgmt->CFP_period,
 	       mac2str(mac_mgmt->current_bssid),
-	       hex2str(dev->obuf, mac_mgmt->current_essid,
-		       min((int)(sizeof(dev->obuf) - 1) / 2,
+	       hex2str(priv->obuf, mac_mgmt->current_essid,
+		       min((int)(sizeof(priv->obuf) - 1) / 2,
 			   IW_ESSID_MAX_SIZE), '\0'),
 	       mac_mgmt->current_bss_type,
 	       mac_mgmt->power_mgmt_mode,
@@ -1257,7 +1257,7 @@ static int at76_dump_mib_mac_mgmt(struct at76_priv *dev)
 }
 
 
-static int at76_dump_mib_mac(struct at76_priv *dev)
+static int at76_dump_mib_mac(struct at76_priv *priv)
 {
 	int ret = 0;
 	struct mib_mac *mac = kmalloc(sizeof(struct mib_mac), GFP_KERNEL);
@@ -1267,9 +1267,9 @@ static int at76_dump_mib_mac(struct at76_priv *dev)
 		goto exit;
 	}
 
-	ret = at76_get_mib(dev->udev, MIB_MAC, mac, sizeof(struct mib_mac));
+	ret = at76_get_mib(priv->udev, MIB_MAC, mac, sizeof(struct mib_mac));
 	if (ret < 0) {
-		err("%s: at76_get_mib failed: %d", dev->netdev->name, ret);
+		err("%s: at76_get_mib failed: %d", priv->netdev->name, ret);
 		goto err;
 	}
 
@@ -1279,7 +1279,7 @@ static int at76_dump_mib_mac(struct at76_priv *dev)
 	       "scan_channel %d probe_delay %u min_channel_time %d "
 	       "max_channel_time %d listen_int %d desired_ssid %s "
 	       "desired_bssid %s desired_bsstype %d",
-	       dev->netdev->name,
+	       priv->netdev->name,
 	       le32_to_cpu(mac->max_tx_msdu_lifetime),
 	       le32_to_cpu(mac->max_rx_lifetime),
 	       le16_to_cpu(mac->frag_threshold),
@@ -1294,8 +1294,8 @@ static int at76_dump_mib_mac(struct at76_priv *dev)
 	       le16_to_cpu(mac->min_channel_time),
 	       le16_to_cpu(mac->max_channel_time),
 	       le16_to_cpu(mac->listen_interval),
-	       hex2str(dev->obuf, mac->desired_ssid,
-		       min((int)(sizeof(dev->obuf) - 1) / 2,
+	       hex2str(priv->obuf, mac->desired_ssid,
+		       min((int)(sizeof(priv->obuf) - 1) / 2,
 			   IW_ESSID_MAX_SIZE), '\0'),
 	       mac2str(mac->desired_bssid), mac->desired_bsstype);
       err:
@@ -1305,7 +1305,7 @@ static int at76_dump_mib_mac(struct at76_priv *dev)
 }
 
 
-static int at76_dump_mib_phy(struct at76_priv *dev)
+static int at76_dump_mib_phy(struct at76_priv *priv)
 {
 	int ret = 0;
 	struct mib_phy *phy = kmalloc(sizeof(struct mib_phy), GFP_KERNEL);
@@ -1315,9 +1315,9 @@ static int at76_dump_mib_phy(struct at76_priv *dev)
 		goto exit;
 	}
 
-	ret = at76_get_mib(dev->udev, MIB_PHY, phy, sizeof(struct mib_phy));
+	ret = at76_get_mib(priv->udev, MIB_PHY, phy, sizeof(struct mib_phy));
 	if (ret < 0) {
-		err("%s: at76_get_mib failed: %d", dev->netdev->name, ret);
+		err("%s: at76_get_mib failed: %d", priv->netdev->name, ret);
 		goto err;
 	}
 
@@ -1326,7 +1326,7 @@ static int at76_dump_mib_phy(struct at76_priv *dev)
 	       "cca_mode_supported %d operation_rate_set "
 	       "0x%x 0x%x 0x%x 0x%x channel_id %d current_cca_mode %d "
 	       "phy_type %d current_reg_domain %d",
-	       dev->netdev->name,
+	       priv->netdev->name,
 	       le32_to_cpu(phy->ed_threshold),
 	       le16_to_cpu(phy->slot_time),
 	       le16_to_cpu(phy->sifs_time),
@@ -1345,7 +1345,7 @@ static int at76_dump_mib_phy(struct at76_priv *dev)
 }
 
 
-static int at76_dump_mib_local(struct at76_priv *dev)
+static int at76_dump_mib_local(struct at76_priv *priv)
 {
 	int ret = 0;
 	struct mib_local *local = kmalloc(sizeof(struct mib_phy), GFP_KERNEL);
@@ -1355,16 +1355,16 @@ static int at76_dump_mib_local(struct at76_priv *dev)
 		goto exit;
 	}
 
-	ret = at76_get_mib(dev->udev, MIB_LOCAL, local,
+	ret = at76_get_mib(priv->udev, MIB_LOCAL, local,
 			   sizeof(struct mib_local));
 	if (ret < 0) {
-		err("%s: at76_get_mib failed: %d", dev->netdev->name, ret);
+		err("%s: at76_get_mib failed: %d", priv->netdev->name, ret);
 		goto err;
 	}
 
 	dbg("%s: MIB PHY: beacon_enable %d txautorate_fallback %d "
 	       "ssid_size %d promiscuous_mode %d preamble_type %d",
-	       dev->netdev->name,
+	       priv->netdev->name,
 	       local->beacon_enable,
 	       local->txautorate_fallback,
 	       local->ssid_size, local->promiscuous_mode, local->preamble_type);
@@ -1375,7 +1375,7 @@ static int at76_dump_mib_local(struct at76_priv *dev)
 }
 
 
-static int at76_get_mib_mdomain(struct at76_priv *dev, struct mib_mdomain *val)
+static int at76_get_mib_mdomain(struct at76_priv *priv, struct mib_mdomain *val)
 {
 	int ret = 0;
 	struct mib_mdomain *mdomain =
@@ -1386,10 +1386,10 @@ static int at76_get_mib_mdomain(struct at76_priv *dev, struct mib_mdomain *val)
 		goto exit;
 	}
 
-	ret = at76_get_mib(dev->udev, MIB_MDOMAIN, mdomain,
+	ret = at76_get_mib(priv->udev, MIB_MDOMAIN, mdomain,
 			   sizeof(struct mib_mdomain));
 	if (ret < 0) {
-		err("%s: at76_get_mib failed: %d", dev->netdev->name, ret);
+		err("%s: at76_get_mib failed: %d", priv->netdev->name, ret);
 		goto err;
 	}
 
@@ -1402,20 +1402,20 @@ static int at76_get_mib_mdomain(struct at76_priv *dev, struct mib_mdomain *val)
 }
 
 
-static void at76_dump_mib_mdomain(struct at76_priv *dev)
+static void at76_dump_mib_mdomain(struct at76_priv *priv)
 {
 	char obuf1[2*14+1], obuf2[2*14+1]; /* to hexdump tx_powerlevel,
 					      channel_list */
 	int ret;
 	struct mib_mdomain mdomain;
 
-	if ((ret=at76_get_mib_mdomain(dev, &mdomain)) < 0) {
+	if ((ret=at76_get_mib_mdomain(priv, &mdomain)) < 0) {
 		err("%s: at76_get_mib_mdomain returned %d", __FUNCTION__, ret);
 		return;
 	}
 
 	at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %s tx_powerlevel %s",
-	         dev->netdev->name,
+	         priv->netdev->name,
 	         hex2str(obuf1, mdomain.channel_list,
 		         (sizeof(obuf1) - 1) / 2, '\0'),
 	         hex2str(obuf2, mdomain.tx_powerlevel,
@@ -1423,7 +1423,7 @@ static void at76_dump_mib_mdomain(struct at76_priv *dev)
 }
 
 
-static int at76_get_current_bssid(struct at76_priv *dev)
+static int at76_get_current_bssid(struct at76_priv *priv)
 {
 	int ret = 0;
 	struct mib_mac_mgmt *mac_mgmt =
@@ -1434,14 +1434,14 @@ static int at76_get_current_bssid(struct at76_priv *dev)
 		goto exit;
 	}
 
-	ret = at76_get_mib(dev->udev, MIB_MAC_MGMT, mac_mgmt,
+	ret = at76_get_mib(priv->udev, MIB_MAC_MGMT, mac_mgmt,
 			   sizeof(struct mib_mac_mgmt));
 	if (ret < 0) {
-		err("%s: at76_get_mib failed: %d", dev->netdev->name, ret);
+		err("%s: at76_get_mib failed: %d", priv->netdev->name, ret);
 		goto err;
 	}
-	memcpy(dev->bssid, mac_mgmt->current_bssid, ETH_ALEN);
-	info("using BSSID %s", mac2str(dev->bssid));
+	memcpy(priv->bssid, mac_mgmt->current_bssid, ETH_ALEN);
+	info("using BSSID %s", mac2str(priv->bssid));
  err:
 	kfree(mac_mgmt);
  exit:
@@ -1449,7 +1449,7 @@ static int at76_get_current_bssid(struct at76_priv *dev)
 }
 
 
-static int at76_get_current_channel(struct at76_priv *dev)
+static int at76_get_current_channel(struct at76_priv *priv)
 {
 	int ret = 0;
 	struct mib_phy *phy = kmalloc(sizeof(struct mib_phy), GFP_KERNEL);
@@ -1458,12 +1458,12 @@ static int at76_get_current_channel(struct at76_priv *dev)
 		ret = -ENOMEM;
 		goto exit;
 	}
-	ret = at76_get_mib(dev->udev, MIB_PHY, phy, sizeof(struct mib_phy));
+	ret = at76_get_mib(priv->udev, MIB_PHY, phy, sizeof(struct mib_phy));
 	if (ret < 0) {
-		err("%s: at76_get_mib(MIB_PHY) failed: %d", dev->netdev->name, ret);
+		err("%s: at76_get_mib(MIB_PHY) failed: %d", priv->netdev->name, ret);
 		goto err;
 	}
-	dev->channel = phy->channel_id;
+	priv->channel = phy->channel_id;
  err:
 	kfree(phy);
  exit:
@@ -1477,7 +1477,7 @@ static int at76_get_current_channel(struct at76_priv *dev)
  * @use_essid - use the configured ESSID in non passive mode
  * @ir_step - international roaming step (0, 1)
  */
-static int at76_start_scan(struct at76_priv *dev, int use_essid, int ir_step)
+static int at76_start_scan(struct at76_priv *priv, int use_essid, int ir_step)
 {
 	struct at76_start_scan scan;
 
@@ -1485,73 +1485,73 @@ static int at76_start_scan(struct at76_priv *dev, int use_essid, int ir_step)
 	memset(scan.bssid, 0xff, ETH_ALEN);
 
 	if (use_essid) {
-		memcpy(scan.essid, dev->essid, IW_ESSID_MAX_SIZE);
-		scan.essid_size = dev->essid_size;
+		memcpy(scan.essid, priv->essid, IW_ESSID_MAX_SIZE);
+		scan.essid_size = priv->essid_size;
 	} else
 		scan.essid_size = 0;
 
 	/* jal: why should we start at a certain channel? we do scan the whole range
 	   allowed by reg domain. */
-	scan.channel = dev->channel;
+	scan.channel = priv->channel;
 
 	/* atmelwlandriver differs between scan type 0 and 1 (active/passive)
 	   For ad-hoc mode, it uses type 0 only. */
-	if ((dev->international_roaming == IR_ON && ir_step == 0) ||
-	    dev->iw_mode == IW_MODE_MONITOR)
+	if ((priv->international_roaming == IR_ON && ir_step == 0) ||
+	    priv->iw_mode == IW_MODE_MONITOR)
 		scan.scan_type = SCAN_TYPE_PASSIVE;
 	else
-		scan.scan_type = dev->scan_mode;
+		scan.scan_type = priv->scan_mode;
 
 	/* INFO: For probe_delay, not multiplying by 1024 as this will be
 	   slightly less than min_channel_time
 	   (per spec: probe delay < min. channel time) */
-	if (dev->istate == MONITORING) {
-		scan.min_channel_time = cpu_to_le16(dev->monitor_scan_min_time);
-		scan.max_channel_time = cpu_to_le16(dev->monitor_scan_max_time);
-		scan.probe_delay = cpu_to_le16(dev->monitor_scan_min_time * 1000);
+	if (priv->istate == MONITORING) {
+		scan.min_channel_time = cpu_to_le16(priv->monitor_scan_min_time);
+		scan.max_channel_time = cpu_to_le16(priv->monitor_scan_max_time);
+		scan.probe_delay = cpu_to_le16(priv->monitor_scan_min_time * 1000);
 	} else {
-		scan.min_channel_time = cpu_to_le16(dev->scan_min_time);
-		scan.max_channel_time = cpu_to_le16(dev->scan_max_time);
-		scan.probe_delay = cpu_to_le16(dev->scan_min_time * 1000);
+		scan.min_channel_time = cpu_to_le16(priv->scan_min_time);
+		scan.max_channel_time = cpu_to_le16(priv->scan_max_time);
+		scan.probe_delay = cpu_to_le16(priv->scan_min_time * 1000);
 	}
-	if (dev->international_roaming == IR_ON && ir_step == 1)
+	if (priv->international_roaming == IR_ON && ir_step == 1)
 		scan.international_scan = 0;
 	else
-		scan.international_scan = dev->international_roaming;
+		scan.international_scan = priv->international_roaming;
 
 	/* other values are set to 0 for type 0 */
 
 	at76_dbg(DBG_PROGRESS, "%s: start_scan (use_essid = %d, intl = %d, "
 	         "channel = %d, probe_delay = %d, scan_min_time = %d, "
 	         "scan_max_time = %d)",
-	         dev->netdev->name, use_essid,
+	         priv->netdev->name, use_essid,
 	         scan.international_scan, scan.channel,
 	         le16_to_cpu(scan.probe_delay),
 	         le16_to_cpu(scan.min_channel_time),
 	         le16_to_cpu(scan.max_channel_time));
 
-	return at76_set_card_command(dev->udev, CMD_SCAN, &scan, sizeof(scan));
+	return at76_set_card_command(priv->udev, CMD_SCAN, &scan, sizeof(scan));
 }
 
 
-static int at76_start_ibss(struct at76_priv *dev)
+static int at76_start_ibss(struct at76_priv *priv)
 {
 	struct at76_start_bss bss;
 
 	memset(&bss, 0, sizeof(struct at76_start_bss));
 	memset(bss.bssid, 0xff, ETH_ALEN);
-	memcpy(bss.essid, dev->essid, IW_ESSID_MAX_SIZE);
-	bss.essid_size = dev->essid_size;
+	memcpy(bss.essid, priv->essid, IW_ESSID_MAX_SIZE);
+	bss.essid_size = priv->essid_size;
 	bss.bss_type = ADHOC_MODE;
-	bss.channel = dev->channel;
+	bss.channel = priv->channel;
 
-	return at76_set_card_command(dev->udev, CMD_START_IBSS, &bss,
+	return at76_set_card_command(priv->udev, CMD_START_IBSS, &bss,
 				     sizeof(struct at76_start_bss));
 }
 
 
-/* idx points into dev->bss */
-static int at76_join_bss(struct at76_priv *dev, struct bss_info *ptr)
+/* idx points into priv->bss */
+static int at76_join_bss(struct at76_priv *priv, struct bss_info *ptr)
 {
 	struct at76_join join;
 
@@ -1561,14 +1561,14 @@ static int at76_join_bss(struct at76_priv *dev, struct bss_info *ptr)
 	memcpy(join.bssid, ptr->bssid, ETH_ALEN);
 	memcpy(join.essid, ptr->ssid, ptr->ssid_len);
 	join.essid_size = ptr->ssid_len;
-	join.bss_type = (dev->iw_mode == IW_MODE_ADHOC ? 1 : 2);
+	join.bss_type = (priv->iw_mode == IW_MODE_ADHOC ? 1 : 2);
 	join.channel = ptr->channel;
 	join.timeout = cpu_to_le16(2000);
 
 	at76_dbg(DBG_PROGRESS, "%s join addr %s ssid %s type %d ch %d timeout %d",
-	         dev->netdev->name, mac2str(join.bssid),
+	         priv->netdev->name, mac2str(join.bssid),
 	         join.essid, join.bss_type, join.channel, le16_to_cpu(join.timeout));
-	return at76_set_card_command(dev->udev, CMD_JOIN, &join,
+	return at76_set_card_command(priv->udev, CMD_JOIN, &join,
 				     sizeof(struct at76_join));
 }
 
@@ -1612,8 +1612,8 @@ static void at76_read_bulk_callback(struct urb *urb)
 
 static void at76_write_bulk_callback(struct urb *urb)
 {
-	struct at76_priv *dev = urb->context;
-	struct net_device_stats *stats = &dev->stats;
+	struct at76_priv *priv = urb->context;
+	struct net_device_stats *stats = &priv->stats;
 	unsigned long flags;
 	struct at76_tx_buffer *mgmt_buf;
 	int ret;
@@ -1629,39 +1629,39 @@ static void at76_write_bulk_callback(struct urb *urb)
 	} else
 		stats->tx_packets++;
 
-	spin_lock_irqsave(&dev->mgmt_spinlock, flags);
-	mgmt_buf = dev->next_mgmt_bulk;
-	dev->next_mgmt_bulk = NULL;
-	spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
+	spin_lock_irqsave(&priv->mgmt_spinlock, flags);
+	mgmt_buf = priv->next_mgmt_bulk;
+	priv->next_mgmt_bulk = NULL;
+	spin_unlock_irqrestore(&priv->mgmt_spinlock, flags);
 
 	if (mgmt_buf) {
 		/* we don't copy the padding bytes, but add them
 		   to the length */
-		memcpy(dev->bulk_out_buffer, mgmt_buf,
+		memcpy(priv->bulk_out_buffer, mgmt_buf,
 		       le16_to_cpu(mgmt_buf->wlength) +
 		       offsetof(struct at76_tx_buffer, packet));
-		usb_fill_bulk_urb(dev->write_urb, dev->udev,
-				  usb_sndbulkpipe(dev->udev,
-						  dev->bulk_out_endpointAddr),
-				  dev->bulk_out_buffer,
+		usb_fill_bulk_urb(priv->write_urb, priv->udev,
+				  usb_sndbulkpipe(priv->udev,
+						  priv->bulk_out_endpointAddr),
+				  priv->bulk_out_buffer,
 				  le16_to_cpu(mgmt_buf->wlength) +
 				  mgmt_buf->padding + AT76_TX_HDRLEN,
 				  at76_write_bulk_callback,
-				  dev);
-		ret = usb_submit_urb(dev->write_urb, GFP_ATOMIC);
+				  priv);
+		ret = usb_submit_urb(priv->write_urb, GFP_ATOMIC);
 		if (ret) {
 			err("%s: %s error in tx submit urb: %d",
-			    dev->netdev->name, __FUNCTION__, ret);
+			    priv->netdev->name, __FUNCTION__, ret);
 		}
 		kfree(mgmt_buf);
 	} else
-		netif_wake_queue(dev->netdev);
+		netif_wake_queue(priv->netdev);
 }
 
 
 /* send a management frame on bulk-out.
    txbuf->wlength must be set (in LE format !) */
-static int at76_send_mgmt_bulk(struct at76_priv *dev,
+static int at76_send_mgmt_bulk(struct at76_priv *priv,
 			       struct at76_tx_buffer *txbuf)
 {
 	unsigned long flags;
@@ -1669,27 +1669,27 @@ static int at76_send_mgmt_bulk(struct at76_priv *dev,
 	int urb_status;
 	void *oldbuf = NULL;
 
-	netif_carrier_off(dev->netdev);	/* disable running netdev watchdog */
-	netif_stop_queue(dev->netdev);	/* stop tx data packets */
+	netif_carrier_off(priv->netdev);	/* disable running netdev watchdog */
+	netif_stop_queue(priv->netdev);	/* stop tx data packets */
 
-	spin_lock_irqsave(&dev->mgmt_spinlock, flags);
+	spin_lock_irqsave(&priv->mgmt_spinlock, flags);
 
-	if ((urb_status = dev->write_urb->status) == -EINPROGRESS) {
-		oldbuf = dev->next_mgmt_bulk;	/* to kfree below */
-		dev->next_mgmt_bulk = txbuf;
+	if ((urb_status = priv->write_urb->status) == -EINPROGRESS) {
+		oldbuf = priv->next_mgmt_bulk;	/* to kfree below */
+		priv->next_mgmt_bulk = txbuf;
 		txbuf = NULL;
 	}
-	spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
+	spin_unlock_irqrestore(&priv->mgmt_spinlock, flags);
 
 	if (oldbuf) {
 		/* a data/mgmt tx is already pending in the URB -
 		   if this is no error in some situations we must
 		   implement a queue or silently modify the old msg */
 		err("%s: %s removed pending mgmt buffer %s",
-		    dev->netdev->name, __FUNCTION__,
-		    hex2str(dev->obuf, dev->next_mgmt_bulk,
-			    min((int)(sizeof(dev->obuf)) / 3, 64), ' '));
-		kfree(dev->next_mgmt_bulk);
+		    priv->netdev->name, __FUNCTION__,
+		    hex2str(priv->obuf, priv->next_mgmt_bulk,
+			    min((int)(sizeof(priv->obuf)) / 3, 64), ' '));
+		kfree(priv->next_mgmt_bulk);
 	}
 
 	if (txbuf) {
@@ -1697,34 +1697,34 @@ static int at76_send_mgmt_bulk(struct at76_priv *dev,
 		txbuf->tx_rate = 0;
 		txbuf->padding = at76_calc_padding(le16_to_cpu(txbuf->wlength));
 
-		if (dev->next_mgmt_bulk) {
+		if (priv->next_mgmt_bulk) {
 			err("%s: %s URB status %d, but mgmt is pending",
-			    dev->netdev->name, __FUNCTION__, urb_status);
+			    priv->netdev->name, __FUNCTION__, urb_status);
 		}
 
 		at76_dbg(DBG_TX_MGMT, "%s: tx mgmt: wlen %d tx_rate %d pad %d %s",
-		         dev->netdev->name, le16_to_cpu(txbuf->wlength),
+		         priv->netdev->name, le16_to_cpu(txbuf->wlength),
 		         txbuf->tx_rate, txbuf->padding,
-		         hex2str(dev->obuf, txbuf->packet,
-			    min((sizeof(dev->obuf) - 1) / 2,
+		         hex2str(priv->obuf, txbuf->packet,
+			    min((sizeof(priv->obuf) - 1) / 2,
 				(size_t) le16_to_cpu(txbuf->wlength)), '\0'));
 
 		/* txbuf was not consumed above -> send mgmt msg immediately */
-		memcpy(dev->bulk_out_buffer, txbuf,
+		memcpy(priv->bulk_out_buffer, txbuf,
 		       le16_to_cpu(txbuf->wlength) + AT76_TX_HDRLEN);
-		usb_fill_bulk_urb(dev->write_urb, dev->udev,
-				  usb_sndbulkpipe(dev->udev,
-						  dev->bulk_out_endpointAddr),
-				  dev->bulk_out_buffer,
+		usb_fill_bulk_urb(priv->write_urb, priv->udev,
+				  usb_sndbulkpipe(priv->udev,
+						  priv->bulk_out_endpointAddr),
+				  priv->bulk_out_buffer,
 				  le16_to_cpu(txbuf->wlength) +
 				  txbuf->padding +
 				  AT76_TX_HDRLEN,
 				  at76_write_bulk_callback,
-				  dev);
-		ret = usb_submit_urb(dev->write_urb, GFP_ATOMIC);
+				  priv);
+		ret = usb_submit_urb(priv->write_urb, GFP_ATOMIC);
 		if (ret) {
 			err("%s: %s error in tx submit urb: %d",
-			    dev->netdev->name, __FUNCTION__, ret);
+			    priv->netdev->name, __FUNCTION__, ret);
 		}
 		kfree(txbuf);
 	}
@@ -1744,7 +1744,7 @@ static inline void next_ie(struct ieee80211_info_element **ie)
    we got with seq_nr 2 for shared secret authentication only and
    send in seq_nr 3 WEP encrypted to prove we have the correct WEP key;
    otherwise it is NULL */
-static int at76_auth_req(struct at76_priv *dev, struct bss_info *bss,
+static int at76_auth_req(struct at76_priv *priv, struct bss_info *bss,
 			 int seq_nr, struct ieee80211_info_element *challenge)
 {
 	struct at76_tx_buffer *tx_buffer;
@@ -1769,11 +1769,11 @@ static int at76_auth_req(struct at76_priv *dev, struct bss_info *bss,
 
 	mgmt->duration_id = cpu_to_le16(0x8000);
 	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
-	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
+	memcpy(mgmt->addr2, priv->netdev->dev_addr, ETH_ALEN);
 	memcpy(mgmt->addr3, bss->bssid, ETH_ALEN);
 	mgmt->seq_ctl = cpu_to_le16(0);
 
-	req->algorithm = cpu_to_le16(dev->auth_mode);
+	req->algorithm = cpu_to_le16(priv->auth_mode);
 	req->transaction = cpu_to_le16(seq_nr);
 	req->status = cpu_to_le16(0);
 
@@ -1783,22 +1783,22 @@ static int at76_auth_req(struct at76_priv *dev, struct bss_info *bss,
 	/* init. at76_priv tx header */
 	tx_buffer->wlength = cpu_to_le16(buf_len - AT76_TX_HDRLEN);
 	at76_dbg(DBG_TX_MGMT, "%s: AuthReq bssid %s alg %d seq_nr %d",
-	         dev->netdev->name, mac2str(mgmt->addr3),
+	         priv->netdev->name, mac2str(mgmt->addr3),
 	         le16_to_cpu(req->algorithm), le16_to_cpu(req->transaction));
 	if (seq_nr == 3) {
 		at76_dbg(DBG_TX_MGMT, "%s: AuthReq challenge: %s ...",
-		         dev->netdev->name,
-		         hex2str(dev->obuf, req->info_element,
-		             min((int)sizeof(dev->obuf) / 3, 18), ' '));
+		         priv->netdev->name,
+		         hex2str(priv->obuf, req->info_element,
+		             min((int)sizeof(priv->obuf) / 3, 18), ' '));
 	}
 
 	/* either send immediately (if no data tx is pending
 	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
 
-static int at76_assoc_req(struct at76_priv *dev, struct bss_info *bss)
+static int at76_assoc_req(struct at76_priv *priv, struct bss_info *bss)
 {
 	struct at76_tx_buffer *tx_buffer;
 	struct ieee80211_hdr_3addr *mgmt;
@@ -1820,7 +1820,7 @@ static int at76_assoc_req(struct at76_priv *dev, struct bss_info *bss)
 
 	mgmt->duration_id = cpu_to_le16(0x8000);
 	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
-	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
+	memcpy(mgmt->addr2, priv->netdev->dev_addr, ETH_ALEN);
 	memcpy(mgmt->addr3, bss->bssid, ETH_ALEN);
 	mgmt->seq_ctl = cpu_to_le16(0);
 
@@ -1829,8 +1829,8 @@ static int at76_assoc_req(struct at76_priv *dev, struct bss_info *bss)
 	   to us.  AP only set the Privacy bit in their capabilities
 	   if WEP is mandatory in the BSS! */
 	req->capability = cpu_to_le16(bss->capa |
-				      (dev->wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
-				      (dev->preamble_type == PREAMBLE_TYPE_SHORT ?
+				      (priv->wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
+				      (priv->preamble_type == PREAMBLE_TYPE_SHORT ?
 				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
 
 	req->listen_interval = cpu_to_le16(2 * bss->beacon_interval);
@@ -1857,25 +1857,25 @@ static int at76_assoc_req(struct at76_priv *dev, struct bss_info *bss)
 
 		tlv = req->info_element;
 		len = min_t(int, IW_ESSID_MAX_SIZE, tlv->len);
-		memcpy(dev->obuf, tlv->data, len);
-		dev->obuf[len] = '\0';
+		memcpy(priv->obuf, tlv->data, len);
+		priv->obuf[len] = '\0';
 		next_ie(&tlv); /* points to IE of rates now */
 		at76_dbg(DBG_TX_MGMT, "%s: AssocReq bssid %s capa x%04x ssid %s rates %s",
-		         dev->netdev->name, mac2str(mgmt->addr3),
-		         le16_to_cpu(req->capability), dev->obuf,
+		         priv->netdev->name, mac2str(mgmt->addr3),
+		         le16_to_cpu(req->capability), priv->obuf,
 		         hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
 			    '\0'));
 	}
 
 	/* either send immediately (if no data tx is pending
 	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
 
 /* we are currently associated to curr_bss and
    want to reassoc to new_bss */
-static int at76_reassoc_req(struct at76_priv *dev, struct bss_info *curr_bss,
+static int at76_reassoc_req(struct at76_priv *priv, struct bss_info *curr_bss,
 		            struct bss_info *new_bss)
 {
 	struct at76_tx_buffer *tx_buffer;
@@ -1901,7 +1901,7 @@ static int at76_reassoc_req(struct at76_priv *dev, struct bss_info *curr_bss,
 	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_REASSOC_REQ);
 	mgmt->duration_id = cpu_to_le16(0x8000);
 	memcpy(mgmt->addr1, new_bss->bssid, ETH_ALEN);
-	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
+	memcpy(mgmt->addr2, priv->netdev->dev_addr, ETH_ALEN);
 	memcpy(mgmt->addr3, new_bss->bssid, ETH_ALEN);
 	mgmt->seq_ctl = cpu_to_le16(0);
 
@@ -1910,8 +1910,8 @@ static int at76_reassoc_req(struct at76_priv *dev, struct bss_info *curr_bss,
 	   to us.  AP only set the Privacy bit in their capabilities
 	   if WEP is mandatory in the BSS! */
 	req->capability = cpu_to_le16(new_bss->capa |
-				      (dev->wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
-				      (dev->preamble_type == PREAMBLE_TYPE_SHORT ?
+				      (priv->wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
+				      (priv->preamble_type == PREAMBLE_TYPE_SHORT ?
 				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
 
 	req->listen_interval = cpu_to_le16(2 * new_bss->beacon_interval);
@@ -1938,24 +1938,24 @@ static int at76_reassoc_req(struct at76_priv *dev, struct bss_info *curr_bss,
 		char orates[4*2+1];
 		char ocurr[6*3+1];
 		tlv = req->info_element;
-		memcpy(dev->obuf, tlv->data, min(sizeof(dev->obuf),(size_t)tlv->len));
-		dev->obuf[IW_ESSID_MAX_SIZE] = '\0';
+		memcpy(priv->obuf, tlv->data, min(sizeof(priv->obuf),(size_t)tlv->len));
+		priv->obuf[IW_ESSID_MAX_SIZE] = '\0';
 		next_ie(&tlv); /* points to IE of rates now */
 		at76_dbg(DBG_TX_MGMT, "%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s",
-		         dev->netdev->name,
+		         priv->netdev->name,
 		         hex2str(ocurr, req->current_ap, ETH_ALEN, ':'),
-		         mac2str(mgmt->addr3), le16_to_cpu(req->capability), dev->obuf,
+		         mac2str(mgmt->addr3), le16_to_cpu(req->capability), priv->obuf,
 		         hex2str(orates,tlv->data,min((sizeof(orates)-1)/2,(size_t)tlv->len),
 			    '\0'));
 	}
 
 	/* either send immediately (if no data tx is pending
 	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
 
-static int at76_disassoc_req(struct at76_priv *dev, struct bss_info *bss)
+static int at76_disassoc_req(struct at76_priv *priv, struct bss_info *bss)
 {
 	struct at76_tx_buffer *tx_buffer;
 	struct ieee80211_hdr_3addr *mgmt;
@@ -1976,7 +1976,7 @@ static int at76_disassoc_req(struct at76_priv *dev, struct bss_info *bss)
 	mgmt->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_AUTH);
 	mgmt->duration_id = cpu_to_le16(0x8000);
 	memcpy(mgmt->addr1, bss->bssid, ETH_ALEN);
-	memcpy(mgmt->addr2, dev->netdev->dev_addr, ETH_ALEN);
+	memcpy(mgmt->addr2, priv->netdev->dev_addr, ETH_ALEN);
 	memcpy(mgmt->addr3, bss->bssid, ETH_ALEN);
 	mgmt->seq_ctl = cpu_to_le16(0);
 
@@ -1986,81 +1986,81 @@ static int at76_disassoc_req(struct at76_priv *dev, struct bss_info *bss)
 	tx_buffer->wlength = cpu_to_le16(DISASSOC_FRAME_SIZE - AT76_TX_HDRLEN);
 
 	at76_dbg(DBG_TX_MGMT, "%s: DisAssocReq bssid %s",
-	         dev->netdev->name, mac2str(mgmt->addr3));
+	         priv->netdev->name, mac2str(mgmt->addr3));
 
 	/* either send immediately (if no data tx is pending
 	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	return at76_send_mgmt_bulk(priv, tx_buffer);
 }
 
 
 /* the firmware download timeout (after remap) */
 static void at76_fw_dl_timeout(unsigned long par)
 {
-	struct at76_priv *dev = (struct at76_priv *)par;
-	schedule_work(&dev->work_reset_device);
+	struct at76_priv *priv = (struct at76_priv *)par;
+	schedule_work(&priv->work_reset_device);
 }
 
 
 /* the restart timer timed out */
 static void at76_restart_timeout(unsigned long par)
 {
-	struct at76_priv *dev = (struct at76_priv *)par;
-	schedule_work(&dev->work_restart);
+	struct at76_priv *priv = (struct at76_priv *)par;
+	schedule_work(&priv->work_restart);
 }
 
 
 /* we got to check the bss_list for old entries */
 static void at76_bss_list_timeout(unsigned long par)
 {
-	struct at76_priv *dev = (struct at76_priv *)par;
+	struct at76_priv *priv = (struct at76_priv *)par;
 	unsigned long flags;
 	struct list_head *lptr, *nptr;
 	struct bss_info *ptr;
 
-	spin_lock_irqsave(&dev->bss_list_spinlock, flags);
+	spin_lock_irqsave(&priv->bss_list_spinlock, flags);
 
-	list_for_each_safe(lptr, nptr, &dev->bss_list) {
+	list_for_each_safe(lptr, nptr, &priv->bss_list) {
 
 		ptr = list_entry(lptr, struct bss_info, list);
 
-		if (ptr != dev->curr_bss && ptr != dev->new_bss &&
+		if (ptr != priv->curr_bss && ptr != priv->new_bss &&
 		    time_after(jiffies, ptr->last_rx + BSS_LIST_TIMEOUT)) {
 			at76_dbg(DBG_BSS_TABLE_RM,
 			         "%s: bss_list: removing old BSS %s ch %d",
-			         dev->netdev->name, mac2str(ptr->bssid),
+			         priv->netdev->name, mac2str(ptr->bssid),
 			         ptr->channel);
 			list_del(&ptr->list);
 			kfree(ptr);
 		}
 	}
-	spin_unlock_irqrestore(&dev->bss_list_spinlock, flags);
+	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 	/* restart the timer */
-	mod_timer(&dev->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
+	mod_timer(&priv->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
 }
 
 
-static void at76_dump_bss_table(struct at76_priv *dev)
+static void at76_dump_bss_table(struct at76_priv *priv)
 {
 	struct bss_info *ptr;
 	unsigned long flags;
 	struct list_head *lptr;
 	char obuf_s[3*32];
 
-	spin_lock_irqsave(&dev->bss_list_spinlock, flags);
+	spin_lock_irqsave(&priv->bss_list_spinlock, flags);
 
-	pr_debug("%s BSS table (curr=%p, new=%p):", dev->netdev->name,
-	         dev->curr_bss, dev->new_bss);
+	pr_debug("%s BSS table (curr=%p, new=%p):", priv->netdev->name,
+	         priv->curr_bss, priv->new_bss);
 
-	list_for_each(lptr, &dev->bss_list) {
+	list_for_each(lptr, &priv->bss_list) {
 		ptr = list_entry(lptr, struct bss_info, list);
 		pr_debug("0x%p: bssid %s channel %d ssid %s (%s)"
 		         " capa x%04x rates %s rssi %d link %d noise %d",
 		         ptr, mac2str(ptr->bssid),
 		         ptr->channel,
 		         ptr->ssid,
-		         hex2str(dev->obuf, ptr->ssid,
-			       min((sizeof(dev->obuf) - 1) / 2,
+		         hex2str(priv->obuf, ptr->ssid,
+			       min((sizeof(priv->obuf) - 1) / 2,
 				   (size_t) ptr->ssid_len), '\0'),
 		         ptr->capa,
 		         hex2str(obuf_s, ptr->rates,
@@ -2068,132 +2068,132 @@ static void at76_dump_bss_table(struct at76_priv *dev)
 				   (size_t) ptr->rates_len), ' '),
 		         ptr->rssi, ptr->link_qual, ptr->noise_level);
 	}
-	spin_unlock_irqrestore(&dev->bss_list_spinlock, flags);
+	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
 
 
 /* we got a timeout for a infrastructure mgmt packet */
 static void at76_mgmt_timeout(unsigned long par)
 {
-	struct at76_priv *dev = (struct at76_priv *)par;
-	schedule_work(&dev->work_mgmt_timeout);
+	struct at76_priv *priv = (struct at76_priv *)par;
+	schedule_work(&priv->work_mgmt_timeout);
 }
 
 
 /*
  * at76_work_mgmt_timeout_scan - expiry of management timer in istate SCANNING
  */
-static void at76_handle_mgmt_timeout_scan(struct at76_priv *dev)
+static void at76_handle_mgmt_timeout_scan(struct at76_priv *priv)
 {
 	int status, ret;
 	struct mib_mdomain mdomain;
 
-	if ((status = at76_get_cmd_status(dev->udev, CMD_SCAN)) < 0) {
+	if ((status = at76_get_cmd_status(priv->udev, CMD_SCAN)) < 0) {
 		err("%s: %s: at76_get_cmd_status failed with %d",
-		    dev->netdev->name, __FUNCTION__, status);
+		    priv->netdev->name, __FUNCTION__, status);
 		status = CMD_STATUS_IN_PROGRESS;
 		/* INFO: Hope it was a one off error - if not, scanning
 		   further down the line and stop this cycle */
 	}
 	at76_dbg(DBG_PROGRESS, "%s %s:%d got cmd_status %d (istate %d, "
 	         "scan_runs %d)",
-	         dev->netdev->name, __FUNCTION__, __LINE__, status,
-	         dev->istate, dev->scan_runs);
+	         priv->netdev->name, __FUNCTION__, __LINE__, status,
+	         priv->istate, priv->scan_runs);
 	if (status == CMD_STATUS_COMPLETE) {
-		if (dev->istate == SCANNING) {
+		if (priv->istate == SCANNING) {
 			if (at76_debug & DBG_BSS_TABLE)
-				at76_dump_bss_table(dev);
-			switch (dev->scan_runs) {
+				at76_dump_bss_table(priv);
+			switch (priv->scan_runs) {
 
 			case 1:
-				at76_assert(dev->international_roaming);
-				if ((ret=at76_get_mib_mdomain(dev, &mdomain)) < 0) {
+				at76_assert(priv->international_roaming);
+				if ((ret=at76_get_mib_mdomain(priv, &mdomain)) < 0) {
 					err("at76_get_mib_mdomain returned %d", ret);
 				} else {
 					char obuf1[2*14+1], obuf2[2*14+1];
 
 					at76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %s "
 					         "tx_powerlevel %s",
-					         dev->netdev->name,
+					         priv->netdev->name,
 					         hex2str(obuf1, mdomain.channel_list,
 				     		    (sizeof(obuf1)-1)/2,'\0'),
 				     	         hex2str(obuf2, mdomain.tx_powerlevel,
 						    (sizeof(obuf2)-1)/2,'\0'));
 				}
-				if ((ret = at76_start_scan(dev, 0, 1)) < 0) {
+				if ((ret = at76_start_scan(priv, 0, 1)) < 0) {
 					err("%s: %s: start_scan (ANY) failed with %d",
-					    dev->netdev->name, __FUNCTION__, ret);
+					    priv->netdev->name, __FUNCTION__, ret);
 				}
 				at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
 				         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-				mod_timer(&dev->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+				mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 				break;
 
 			case 2:
-				if ((ret = at76_start_scan(dev, 1, 1)) < 0) {
+				if ((ret = at76_start_scan(priv, 1, 1)) < 0) {
 					err("%s: %s: start_scan (SSID) failed with %d",
-					    dev->netdev->name, __FUNCTION__, ret);
+					    priv->netdev->name, __FUNCTION__, ret);
 				}
 				at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
 				         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-				mod_timer(&dev->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+				mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 				break;
 
 			case 3:
-				dev->scan_state = SCAN_COMPLETED;
+				priv->scan_state = SCAN_COMPLETED;
 				/* report the end of scan to user space */
-				at76_iwevent_scan_complete(dev->netdev);
-				dev->istate = JOINING;
+				at76_iwevent_scan_complete(priv->netdev);
+				priv->istate = JOINING;
 				/* call join_bss immediately after
 				   re-run of all other threads in at76_devent */
-				schedule_work(&dev->work_join);
+				schedule_work(&priv->work_join);
 				break;
 
 			default:
-				err("unexpected dev->scan_runs %d", dev->scan_runs);
+				err("unexpected priv->scan_runs %d", priv->scan_runs);
 			}
-			dev->scan_runs++;
+			priv->scan_runs++;
 		} else {
 
-			at76_assert(dev->istate == MONITORING);
+			at76_assert(priv->istate == MONITORING);
 			at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE: restart scan",
-			         dev->netdev->name);
-			at76_start_scan(dev, 0, 0);
+			         priv->netdev->name);
+			at76_start_scan(priv, 0, 0);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
 			         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-			mod_timer(&dev->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+			mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 		}
 
 	} else {
 		if ((status != CMD_STATUS_IN_PROGRESS) &&
 		    (status != CMD_STATUS_IDLE))
 			err("%s: %s: Bad scan status: %s",
-			    dev->netdev->name, __FUNCTION__,
+			    priv->netdev->name, __FUNCTION__,
 			    at76_get_cmd_status_string(status));
 
 		/* the first cmd status after scan start is always a IDLE ->
 		   start the timer to poll again until COMPLETED */
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
 		         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-		mod_timer(&dev->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 	}
 }
 
 
 /* the deferred procedure called from at76_devent() */
-static void at76_handle_mgmt_timeout(struct at76_priv *dev)
+static void at76_handle_mgmt_timeout(struct at76_priv *priv)
 {
-	if ((dev->istate != SCANNING && dev->istate != MONITORING) ||
+	if ((priv->istate != SCANNING && priv->istate != MONITORING) ||
 	    (at76_debug & DBG_MGMT_TIMER))
 		/* this is normal behavior in states MONITORING, SCANNING ... */
-		at76_dbg(DBG_PROGRESS, "%s: timeout, state %d", dev->netdev->name,
-		         dev->istate);
+		at76_dbg(DBG_PROGRESS, "%s: timeout, state %d", priv->netdev->name,
+		         priv->istate);
 
-	switch (dev->istate) {
+	switch (priv->istate) {
 
 	case MONITORING:
 	case SCANNING:
-		at76_handle_mgmt_timeout_scan(dev);
+		at76_handle_mgmt_timeout_scan(priv);
 		break;
 
 	case JOINING:
@@ -2203,73 +2203,73 @@ static void at76_handle_mgmt_timeout(struct at76_priv *dev)
 	case CONNECTED:	/* we haven't received the beacon of this BSS for
 				   BEACON_TIMEOUT seconds */
 		info("%s: lost beacon bssid %s",
-		     dev->netdev->name, mac2str(dev->curr_bss->bssid));
+		     priv->netdev->name, mac2str(priv->curr_bss->bssid));
 		/* jal: starting mgmt_timer in ad-hoc mode is questionable,
 		   but I'll leave it here to track down another lockup problem */
-		if (dev->iw_mode != IW_MODE_ADHOC) {
-			netif_carrier_off(dev->netdev);
-			netif_stop_queue(dev->netdev);
-			at76_iwevent_bss_disconnect(dev->netdev);
-			dev->istate = SCANNING;
-			schedule_work(&dev->work_scan);
+		if (priv->iw_mode != IW_MODE_ADHOC) {
+			netif_carrier_off(priv->netdev);
+			netif_stop_queue(priv->netdev);
+			at76_iwevent_bss_disconnect(priv->netdev);
+			priv->istate = SCANNING;
+			schedule_work(&priv->work_scan);
 		}
 		break;
 
 	case AUTHENTICATING:
-		if (dev->retries-- >= 0) {
-			at76_auth_req(dev, dev->curr_bss, 1, NULL);
+		if (priv->retries-- >= 0) {
+			at76_auth_req(priv, priv->curr_bss, 1, NULL);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
 			         __FUNCTION__, __LINE__);
-			mod_timer(&dev->mgmt_timer, jiffies + HZ);
+			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		} else {
 			/* try to get next matching BSS */
-			dev->istate = JOINING;
-			schedule_work(&dev->work_join);
+			priv->istate = JOINING;
+			schedule_work(&priv->work_join);
 		}
 		break;
 
 	case ASSOCIATING:
-		if (dev->retries-- >= 0) {
-			at76_assoc_req(dev, dev->curr_bss);
+		if (priv->retries-- >= 0) {
+			at76_assoc_req(priv, priv->curr_bss);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
 			         __FUNCTION__, __LINE__);
-			mod_timer(&dev->mgmt_timer, jiffies + HZ);
+			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		} else {
 			/* jal: TODO: we may be authenticated to several
 			   BSS and may try to associate to the next of them here
 			   in the future ... */
 
 			/* try to get next matching BSS */
-			dev->istate = JOINING;
-			schedule_work(&dev->work_join);
+			priv->istate = JOINING;
+			schedule_work(&priv->work_join);
 		}
 		break;
 
 	case REASSOCIATING:
-		if (dev->retries-- >= 0)
-			at76_reassoc_req(dev, dev->curr_bss, dev->new_bss);
+		if (priv->retries-- >= 0)
+			at76_reassoc_req(priv, priv->curr_bss, priv->new_bss);
 		else {
 			/* we disassociate from the curr_bss and
 			   scan again ... */
-			dev->istate = DISASSOCIATING;
-			dev->retries = DISASSOC_RETRIES;
-			at76_disassoc_req(dev, dev->curr_bss);
+			priv->istate = DISASSOCIATING;
+			priv->retries = DISASSOC_RETRIES;
+			at76_disassoc_req(priv, priv->curr_bss);
 		}
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
 		         __FUNCTION__, __LINE__);
-		mod_timer(&dev->mgmt_timer, jiffies + HZ);
+		mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		break;
 
 	case DISASSOCIATING:
-		if (dev->retries-- >= 0) {
-			at76_disassoc_req(dev, dev->curr_bss);
+		if (priv->retries-- >= 0) {
+			at76_disassoc_req(priv, priv->curr_bss);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
 		     	         __FUNCTION__, __LINE__);
-			mod_timer(&dev->mgmt_timer, jiffies + HZ);
+			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		} else {
 			/* we scan again ... */
-			dev->istate = SCANNING;
-			schedule_work(&dev->work_scan);
+			priv->istate = SCANNING;
+			schedule_work(&priv->work_scan);
 		}
 		break;
 
@@ -2285,116 +2285,116 @@ static void at76_handle_mgmt_timeout(struct at76_priv *dev)
 /* Called after successful association */
 static void at76_work_assoc_done(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_assoc_done);
 
-	down(&dev->sem);
+	down(&priv->sem);
 
-	at76_assert(dev->istate == ASSOCIATING || dev->istate == REASSOCIATING);
-	if (dev->iw_mode == IW_MODE_INFRA) {
-		at76_assert(dev->curr_bss != NULL);
-		if (dev->curr_bss != NULL && dev->pm_mode != AT76_PM_OFF) {
+	at76_assert(priv->istate == ASSOCIATING || priv->istate == REASSOCIATING);
+	if (priv->iw_mode == IW_MODE_INFRA) {
+		at76_assert(priv->curr_bss != NULL);
+		if (priv->curr_bss != NULL && priv->pm_mode != AT76_PM_OFF) {
 			/* calculate the listen interval in units of
 			   beacon intervals of the curr_bss */
-			u32 pm_period_beacon = (dev->pm_period >> 10) /
-						dev->curr_bss->beacon_interval;
+			u32 pm_period_beacon = (priv->pm_period >> 10) /
+						priv->curr_bss->beacon_interval;
 
 			pm_period_beacon = max(pm_period_beacon, 2u);
 			pm_period_beacon = min(pm_period_beacon, 0xffffu);
 
 			at76_dbg(DBG_PM, "%s: pm_mode %d assoc id x%x listen int %d",
-			         dev->netdev->name, dev->pm_mode,
-			         dev->curr_bss->assoc_id, pm_period_beacon);
+			         priv->netdev->name, priv->pm_mode,
+			         priv->curr_bss->assoc_id, pm_period_beacon);
 
-			at76_set_associd(dev, dev->curr_bss->assoc_id);
-			at76_set_listen_interval(dev, (u16)pm_period_beacon);
+			at76_set_associd(priv, priv->curr_bss->assoc_id);
+			at76_set_listen_interval(priv, (u16)pm_period_beacon);
 #ifdef DEBUG
-			at76_dump_mib_mac(dev);
-			at76_dump_mib_mac_mgmt(dev);
+			at76_dump_mib_mac(priv);
+			at76_dump_mib_mac_mgmt(priv);
 #endif
 		}
 	}
-	at76_set_pm_mode(dev);
+	at76_set_pm_mode(priv);
 
-	netif_carrier_on(dev->netdev);
-	netif_wake_queue(dev->netdev);
-	dev->istate = CONNECTED;
-	at76_iwevent_bss_connect(dev->netdev, dev->curr_bss->bssid);
+	netif_carrier_on(priv->netdev);
+	netif_wake_queue(priv->netdev);
+	priv->istate = CONNECTED;
+	at76_iwevent_bss_connect(priv->netdev, priv->curr_bss->bssid);
 	at76_dbg(DBG_PROGRESS, "%s: connected to BSSID %s",
-	         dev->netdev->name, mac2str(dev->curr_bss->bssid));
+	         priv->netdev->name, mac2str(priv->curr_bss->bssid));
 
-	up(&dev->sem);
+	up(&priv->sem);
 }
 
 
-static void at76_delete_device(struct at76_priv *dev)
+static void at76_delete_device(struct at76_priv *priv)
 {
 	int i;
 
-	if (!dev)
+	if (!priv)
 		return;
 
 	/* signal to _stop() that the device is gone */
-	dev->device_unplugged = 1;
+	priv->device_unplugged = 1;
 
 	at76_dbg(DBG_PROC_ENTRY, "%s: ENTER",__FUNCTION__);
 
-	if (dev->netdev_registered) {
-		unregister_netdev(dev->netdev);
+	if (priv->netdev_registered) {
+		unregister_netdev(priv->netdev);
 	}
 
-	usb_put_dev(dev->udev);
+	usb_put_dev(priv->udev);
 
 	/* assuming we used keventd, it must quiesce too */
 	flush_scheduled_work();
 
-	if (dev->bulk_out_buffer != NULL)
-		kfree(dev->bulk_out_buffer);
+	if (priv->bulk_out_buffer != NULL)
+		kfree(priv->bulk_out_buffer);
 
-	kfree(dev->ctrl_buffer);
+	kfree(priv->ctrl_buffer);
 
-	if (dev->write_urb != NULL) {
-		usb_kill_urb(dev->write_urb);
-		usb_free_urb(dev->write_urb);
+	if (priv->write_urb != NULL) {
+		usb_kill_urb(priv->write_urb);
+		usb_free_urb(priv->write_urb);
 	}
-	if (dev->read_urb != NULL) {
-		usb_kill_urb(dev->read_urb);
-		usb_free_urb(dev->read_urb);
+	if (priv->read_urb != NULL) {
+		usb_kill_urb(priv->read_urb);
+		usb_free_urb(priv->read_urb);
 	}
-	if (dev->ctrl_buffer != NULL) {
-		usb_kill_urb(dev->ctrl_urb);
-		usb_free_urb(dev->ctrl_urb);
+	if (priv->ctrl_buffer != NULL) {
+		usb_kill_urb(priv->ctrl_urb);
+		usb_free_urb(priv->ctrl_urb);
 	}
 
 	at76_dbg(DBG_PROC_ENTRY, "%s: unlinked urbs", __FUNCTION__);
 
-	if (dev->rx_skb != NULL)
-		kfree_skb(dev->rx_skb);
+	if (priv->rx_skb != NULL)
+		kfree_skb(priv->rx_skb);
 
-	at76_free_bss_list(dev);
-	del_timer_sync(&dev->bss_list_timer);
+	at76_free_bss_list(priv);
+	del_timer_sync(&priv->bss_list_timer);
 
-	if (dev->istate == CONNECTED) {
-		at76_iwevent_bss_disconnect(dev->netdev);
+	if (priv->istate == CONNECTED) {
+		at76_iwevent_bss_disconnect(priv->netdev);
 	}
 
 	for (i = 0; i < NR_RX_DATA_BUF; i++)
-		if (dev->rx_data[i].skb != NULL) {
-			dev_kfree_skb(dev->rx_data[i].skb);
-			dev->rx_data[i].skb = NULL;
+		if (priv->rx_data[i].skb != NULL) {
+			dev_kfree_skb(priv->rx_data[i].skb);
+			priv->rx_data[i].skb = NULL;
 		}
-	at76_dbg(DBG_PROC_ENTRY, "%s: before freeing dev/netdev", __FUNCTION__);
-	free_netdev(dev->netdev); /* dev is in netdev */
+	at76_dbg(DBG_PROC_ENTRY, "%s: before freeing priv/netdev", __FUNCTION__);
+	free_netdev(priv->netdev); /* priv is in netdev */
 
 	at76_dbg(DBG_PROC_ENTRY, "%s: EXIT", __FUNCTION__);
 }
 
 
-static int at76_alloc_urbs(struct at76_priv *dev)
+static int at76_alloc_urbs(struct at76_priv *priv)
 {
-	struct usb_interface *interface = dev->interface;
+	struct usb_interface *interface = priv->interface;
 	struct usb_endpoint_descriptor *endpoint;
-	struct usb_device *udev = dev->udev;
+	struct usb_device *udev = priv->udev;
 	int i, buffer_size;
 	struct usb_host_interface *iface_desc;
 
@@ -2415,45 +2415,45 @@ static int at76_alloc_urbs(struct at76_priv *dev)
 		    ((endpoint->bmAttributes & 3) == 0x02)) {
 			/* we found a bulk in endpoint */
 
-			dev->read_urb = usb_alloc_urb(0, GFP_KERNEL);
-			if (!dev->read_urb) {
+			priv->read_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!priv->read_urb) {
 				err("No free urbs available");
 				return -ENOMEM;
 			}
-			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
+			priv->bulk_in_endpointAddr = endpoint->bEndpointAddress;
 		}
 
 		if (((endpoint->bEndpointAddress & 0x80) == 0x00) &&
 		    ((endpoint->bmAttributes & 3) == 0x02)) {
 			/* we found a bulk out endpoint */
-			dev->write_urb = usb_alloc_urb(0, GFP_KERNEL);
-			if (!dev->write_urb) {
+			priv->write_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!priv->write_urb) {
 				err("no free urbs available");
 				return -ENOMEM;
 			}
 			buffer_size = sizeof(struct at76_tx_buffer) +
 			    MAX_PADDING_SIZE;
-			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
-			dev->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);
-			if (!dev->bulk_out_buffer) {
+			priv->bulk_out_endpointAddr = endpoint->bEndpointAddress;
+			priv->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);
+			if (!priv->bulk_out_buffer) {
 				err("couldn't allocate bulk_out_buffer");
 				return -ENOMEM;
 			}
-			usb_fill_bulk_urb(dev->write_urb, udev,
+			usb_fill_bulk_urb(priv->write_urb, udev,
 				          usb_sndbulkpipe(udev,
 						      endpoint->bEndpointAddress),
-				          dev->bulk_out_buffer, buffer_size,
-				          at76_write_bulk_callback, dev);
+				          priv->bulk_out_buffer, buffer_size,
+				          at76_write_bulk_callback, priv);
 		}
 	}
 
-	dev->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!dev->ctrl_urb) {
+	priv->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!priv->ctrl_urb) {
 		err("no free urbs available");
 		return -ENOMEM;
 	}
-	dev->ctrl_buffer = kmalloc(1024, GFP_KERNEL);
-	if (!dev->ctrl_buffer) {
+	priv->ctrl_buffer = kmalloc(1024, GFP_KERNEL);
+	if (!priv->ctrl_buffer) {
 		err("couldn't allocate ctrl_buffer");
 		return -ENOMEM;
 	}
@@ -2476,33 +2476,33 @@ static int at76_set_mac_address(struct net_device *netdev, void *addr)
 
 static struct net_device_stats *at76_get_stats(struct net_device *netdev)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
-	return &dev->stats;
+	struct at76_priv *priv = netdev_priv(netdev);
+	return &priv->stats;
 }
 
 
 static struct iw_statistics *at76_get_wireless_stats(struct net_device *netdev)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
 	at76_dbg(DBG_IOCTL, "RETURN qual %d level %d noise %d updated %d",
-	         dev->wstats.qual.qual, dev->wstats.qual.level,
-	         dev->wstats.qual.noise, dev->wstats.qual.updated);
+	         priv->wstats.qual.qual, priv->wstats.qual.level,
+	         priv->wstats.qual.noise, priv->wstats.qual.updated);
 
-	return &dev->wstats;
+	return &priv->wstats;
 }
 
 
 static void at76_set_multicast(struct net_device *netdev)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int promisc;
 
 	promisc = ((netdev->flags & IFF_PROMISC) != 0);
-	if (promisc != dev->promisc) {
+	if (promisc != priv->promisc) {
 		/* grmbl. This gets called in interrupt. */
-		dev->promisc = promisc;
-		schedule_work(&dev->work_set_promisc);
+		priv->promisc = promisc;
+		schedule_work(&priv->work_set_promisc);
 	}
 }
 
@@ -2514,32 +2514,32 @@ static int at76_iw_handler_commit(struct net_device *netdev,
 				  struct iw_request_info *info,
 				  void *null, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	unsigned long flags;
 	at76_dbg(DBG_IOCTL, "%s %s: restarting the device", netdev->name,
 	         __FUNCTION__);
 
 	/* TODO: stop any pending tx bulk urb */
-	if (dev->istate != INIT) {
-		dev->istate = INIT;
+	if (priv->istate != INIT) {
+		priv->istate = INIT;
 		/* stop pending management stuff */
-		del_timer_sync(&dev->mgmt_timer);
+		del_timer_sync(&priv->mgmt_timer);
 
-		spin_lock_irqsave(&dev->mgmt_spinlock, flags);
-		if (dev->next_mgmt_bulk) {
-			kfree(dev->next_mgmt_bulk);
-			dev->next_mgmt_bulk = NULL;
+		spin_lock_irqsave(&priv->mgmt_spinlock, flags);
+		if (priv->next_mgmt_bulk) {
+			kfree(priv->next_mgmt_bulk);
+			priv->next_mgmt_bulk = NULL;
 		}
-		spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
+		spin_unlock_irqrestore(&priv->mgmt_spinlock, flags);
 
-		netif_carrier_off(dev->netdev);
-		netif_stop_queue(dev->netdev);
+		netif_carrier_off(priv->netdev);
+		netif_stop_queue(priv->netdev);
 	}
 
 	/* do the restart after two seconds to catch
 	 * following ioctl's (from more params of iwconfig)
 	 * in _one_ restart */
-	mod_timer(&dev->restart_timer, jiffies + 2 * HZ);
+	mod_timer(&priv->restart_timer, jiffies + 2 * HZ);
 
 	return 0;
 }
@@ -2559,7 +2559,7 @@ static int at76_iw_handler_set_freq(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_freq *freq, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int chan = -1;
 	int ret = -EIWCOMMIT;
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - freq.m %d freq.e %d", netdev->name,
@@ -2583,23 +2583,23 @@ static int at76_iw_handler_set_freq(struct net_device *netdev,
 		}
 	}
 
-	if (chan < 1 || !dev->domain) {
+	if (chan < 1 || !priv->domain) {
 		/* non-positive channels are invalid
 		 * we need a domain info to set the channel
 		 * either that or an invalid frequency was
 		 * provided by the user */
 		ret = -EINVAL;
-	} else if (!dev->international_roaming) {
-		if (!(dev->domain->channel_map & (1 << (chan - 1)))) {
+	} else if (!priv->international_roaming) {
+		if (!(priv->domain->channel_map & (1 << (chan - 1)))) {
 			info("%s: channel %d not allowed for domain %s "
 			     "(and international_roaming is OFF)",
-			     dev->netdev->name, chan, dev->domain->name);
+			     priv->netdev->name, chan, priv->domain->name);
 			ret = -EINVAL;
 		}
 	}
 
 	if (ret == -EIWCOMMIT) {
-		dev->channel = chan;
+		priv->channel = chan;
 		at76_dbg(DBG_IOCTL, "%s: SIOCSIWFREQ - ch %d", netdev->name, chan);
 	}
 
@@ -2611,16 +2611,16 @@ static int at76_iw_handler_get_freq(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_freq *freq, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
-	freq->m = dev->channel;
+	freq->m = priv->channel;
 	freq->e = 0;
 
-	if (dev->channel) {
+	if (priv->channel) {
 		at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - freq %ld x 10e%d",
-		         netdev->name, channel_frequency[dev->channel - 1], 6);
+		         netdev->name, channel_frequency[priv->channel - 1], 6);
 	}
-	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - ch %d", netdev->name, dev->channel);
+	at76_dbg(DBG_IOCTL, "%s: SIOCGIWFREQ - ch %d", netdev->name, priv->channel);
 
 	return 0;
 }
@@ -2630,7 +2630,7 @@ static int at76_iw_handler_set_mode(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    __u32 *mode, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = -EIWCOMMIT;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWMODE - %d", netdev->name, *mode);
@@ -2639,9 +2639,9 @@ static int at76_iw_handler_set_mode(struct net_device *netdev,
 	    (*mode != IW_MODE_MONITOR)) {
 		ret = -EINVAL;
 	} else {
-		dev->iw_mode = *mode;
-		if( dev->iw_mode != IW_MODE_INFRA)
-			dev->pm_mode = AT76_PM_OFF;
+		priv->iw_mode = *mode;
+		if( priv->iw_mode != IW_MODE_INFRA)
+			priv->pm_mode = AT76_PM_OFF;
 	}
 	return ret;
 }
@@ -2651,9 +2651,9 @@ static int at76_iw_handler_get_mode(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    __u32 * mode, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
-	*mode = dev->iw_mode;
+	*mode = priv->iw_mode;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWMODE - %d", netdev->name, *mode);
 
@@ -2666,7 +2666,7 @@ static int at76_iw_handler_get_range(struct net_device *netdev,
 				     struct iw_point *data, char *extra)
 {
 	/* inspired by atmel.c */
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	struct iw_range *range = (struct iw_range *)extra;
 	int i;
 
@@ -2734,7 +2734,7 @@ static int at76_iw_handler_get_range(struct net_device *netdev,
 
 	for (i = 0; i < NUM_CHANNELS; i++) {
 		/* test if channel map bit is raised */
-		if (dev->domain->channel_map & (0x1 << i)) {
+		if (priv->domain->channel_map & (0x1 << i)) {
 			range->num_frequency += 1;
 
 			range->freq[i].i = i + 1;
@@ -2753,16 +2753,16 @@ static int at76_iw_handler_set_spy(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct iw_point *data, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = 0;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWSPY - number of addresses %d",
 	         netdev->name, data->length);
 
-	spin_lock_bh(&(dev->spy_spinlock));
-	ret = iw_handler_set_spy(dev->netdev, info, (union iwreq_data *)data,
+	spin_lock_bh(&(priv->spy_spinlock));
+	ret = iw_handler_set_spy(priv->netdev, info, (union iwreq_data *)data,
 				 extra);
-	spin_unlock_bh(&(dev->spy_spinlock));
+	spin_unlock_bh(&(priv->spy_spinlock));
 
 	return ret;
 }
@@ -2773,13 +2773,13 @@ static int at76_iw_handler_get_spy(struct net_device *netdev,
 				   struct iw_point *data, char *extra)
 {
 
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = 0;
 
-	spin_lock_bh(&(dev->spy_spinlock));
-	ret = iw_handler_get_spy(dev->netdev, info,
+	spin_lock_bh(&(priv->spy_spinlock));
+	ret = iw_handler_get_spy(priv->netdev, info,
 				 (union iwreq_data *)data, extra);
-	spin_unlock_bh(&(dev->spy_spinlock));
+	spin_unlock_bh(&(priv->spy_spinlock));
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWSPY - number of addresses %d",
 	         netdev->name, data->length);
@@ -2792,16 +2792,16 @@ static int at76_iw_handler_set_thrspy(struct net_device *netdev,
 				      struct iw_request_info *info,
 				      struct iw_point *data, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWTHRSPY - number of addresses %d)",
 	         netdev->name, data->length);
 
-	spin_lock_bh(&(dev->spy_spinlock));
+	spin_lock_bh(&(priv->spy_spinlock));
 	ret = iw_handler_set_thrspy(netdev, info, (union iwreq_data *)data,
 				    extra);
-	spin_unlock_bh(&(dev->spy_spinlock));
+	spin_unlock_bh(&(priv->spy_spinlock));
 
 	return ret;
 }
@@ -2811,13 +2811,13 @@ static int at76_iw_handler_get_thrspy(struct net_device *netdev,
 				      struct iw_request_info *info,
 				      struct iw_point *data, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret;
 
-	spin_lock_bh(&(dev->spy_spinlock));
+	spin_lock_bh(&(priv->spy_spinlock));
 	ret = iw_handler_get_thrspy(netdev, info, (union iwreq_data *)data,
 				    extra);
-	spin_unlock_bh(&(dev->spy_spinlock));
+	spin_unlock_bh(&(priv->spy_spinlock));
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWTHRSPY - number of addresses %d)",
 	         netdev->name, data->length);
@@ -2830,7 +2830,7 @@ static int at76_iw_handler_set_wap(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct sockaddr *ap_addr, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWAP - wap/bssid %s", netdev->name,
 	         mac2str(ap_addr->sa_data));
@@ -2839,11 +2839,11 @@ static int at76_iw_handler_set_wap(struct net_device *netdev,
 	   chosen any or auto AP preference */
 	if (is_broadcast_ether_addr(ap_addr->sa_data)
 	    || is_zero_ether_addr(ap_addr->sa_data)) {
-		dev->wanted_bssid_valid = 0;
+		priv->wanted_bssid_valid = 0;
 	} else {
 		/* user wants to set a preferred AP address */
-		dev->wanted_bssid_valid = 1;
-		memcpy(dev->wanted_bssid, ap_addr->sa_data, ETH_ALEN);
+		priv->wanted_bssid_valid = 1;
+		memcpy(priv->wanted_bssid, ap_addr->sa_data, ETH_ALEN);
 	}
 
 	return -EIWCOMMIT;
@@ -2854,10 +2854,10 @@ static int at76_iw_handler_get_wap(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct sockaddr *ap_addr, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
 	ap_addr->sa_family = ARPHRD_ETHER;
-	memcpy(ap_addr->sa_data, dev->bssid, ETH_ALEN);
+	memcpy(ap_addr->sa_data, priv->bssid, ETH_ALEN);
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWAP - wap/bssid %s", netdev->name,
 	         mac2str(ap_addr->sa_data));
@@ -2870,7 +2870,7 @@ static int at76_iw_handler_set_scan(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    union iwreq_data *wrqu, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	unsigned long flags;
 	int ret = 0;
 	struct iw_scan_req *req = NULL;
@@ -2882,34 +2882,34 @@ static int at76_iw_handler_set_scan(struct net_device *netdev,
 
 	/* jal: we don't allow "iwlist ethX scan" while we are
 	   in monitor mode */
-	if (dev->iw_mode == IW_MODE_MONITOR)
+	if (priv->iw_mode == IW_MODE_MONITOR)
 		return -EBUSY;
 
 	/* Discard old scan results */
-	if ((jiffies - dev->last_scan) > (20 * HZ))
-		dev->scan_state = SCAN_IDLE;
-	dev->last_scan = jiffies;
+	if ((jiffies - priv->last_scan) > (20 * HZ))
+		priv->scan_state = SCAN_IDLE;
+	priv->last_scan = jiffies;
 
 	/* Initiate a scan command */
-	if (dev->scan_state == SCAN_IN_PROGRESS)
+	if (priv->scan_state == SCAN_IN_PROGRESS)
 		return -EBUSY;
 
-	dev->scan_state = SCAN_IN_PROGRESS;
+	priv->scan_state = SCAN_IN_PROGRESS;
 
 	/* stop pending management stuff */
-	del_timer_sync(&(dev->mgmt_timer));
+	del_timer_sync(&(priv->mgmt_timer));
 
-	spin_lock_irqsave(&(dev->mgmt_spinlock), flags);
-	if (dev->next_mgmt_bulk) {
-		kfree(dev->next_mgmt_bulk);
-		dev->next_mgmt_bulk = NULL;
+	spin_lock_irqsave(&(priv->mgmt_spinlock), flags);
+	if (priv->next_mgmt_bulk) {
+		kfree(priv->next_mgmt_bulk);
+		priv->next_mgmt_bulk = NULL;
 	}
-	spin_unlock_irqrestore(&(dev->mgmt_spinlock), flags);
+	spin_unlock_irqrestore(&(priv->mgmt_spinlock), flags);
 
-	if (netif_running(dev->netdev)) {
+	if (netif_running(priv->netdev)) {
 		/* pause network activity */
-		netif_carrier_off(dev->netdev);
-		netif_stop_queue(dev->netdev);
+		netif_carrier_off(priv->netdev);
+		netif_stop_queue(priv->netdev);
 	}
 	/* Try to do passive or active scan if WE asks as. */
 	if (wrqu->data.length
@@ -2917,30 +2917,30 @@ static int at76_iw_handler_set_scan(struct net_device *netdev,
 		req = (struct iw_scan_req *)extra;
 
 		if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
-			dev->scan_mode = SCAN_TYPE_PASSIVE;
+			priv->scan_mode = SCAN_TYPE_PASSIVE;
 		else if (req->scan_type == IW_SCAN_TYPE_ACTIVE)
-			dev->scan_mode = SCAN_TYPE_ACTIVE;
+			priv->scan_mode = SCAN_TYPE_ACTIVE;
 
 		/* Sanity check values? */
 		if (req->min_channel_time > 0) {
-			if (dev->istate == MONITORING)
-				dev->monitor_scan_min_time =
+			if (priv->istate == MONITORING)
+				priv->monitor_scan_min_time =
 				    req->min_channel_time;
 			else
-				dev->scan_min_time = req->min_channel_time;
+				priv->scan_min_time = req->min_channel_time;
 		}
 		if (req->max_channel_time > 0) {
-			if (dev->istate == MONITORING)
-				dev->monitor_scan_max_time =
+			if (priv->istate == MONITORING)
+				priv->monitor_scan_max_time =
 				    req->max_channel_time;
 			else
-				dev->scan_max_time = req->max_channel_time;
+				priv->scan_max_time = req->max_channel_time;
 		}
 	}
 
 	/* change to scanning state */
-	dev->istate = SCANNING;
-	schedule_work(&dev->work_scan);
+	priv->istate = SCANNING;
+	schedule_work(&priv->work_scan);
 
 	return ret;
 }
@@ -2950,7 +2950,7 @@ static int at76_iw_handler_get_scan(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_point *data, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	unsigned long flags;
 	struct list_head *lptr, *nptr;
 	struct bss_info *curr_bss;
@@ -2963,13 +2963,13 @@ static int at76_iw_handler_get_scan(struct net_device *netdev,
 	if (!iwe)
 		return -ENOMEM;
 
-	if (dev->scan_state != SCAN_COMPLETED)
+	if (priv->scan_state != SCAN_COMPLETED)
 		/* scan not yet finished */
 		return -EAGAIN;
 
-	spin_lock_irqsave(&(dev->bss_list_spinlock), flags);
+	spin_lock_irqsave(&(priv->bss_list_spinlock), flags);
 
-	list_for_each_safe(lptr, nptr, &(dev->bss_list)) {
+	list_for_each_safe(lptr, nptr, &(priv->bss_list)) {
 		curr_bss = list_entry(lptr, struct bss_info, list);
 
 		iwe->cmd = SIOCGIWAP;
@@ -3023,8 +3023,8 @@ static int at76_iw_handler_get_scan(struct net_device *netdev,
 		iwe->u.qual.level = (curr_bss->rssi * 100 / 42);
 		if (iwe->u.qual.level > 100)
 			iwe->u.qual.level = 100;
-		if ((dev->board_type == BOARDTYPE_503_INTERSIL_3861) ||
-		    (dev->board_type == BOARDTYPE_503_INTERSIL_3863)) {
+		if ((priv->board_type == BOARDTYPE_503_INTERSIL_3861) ||
+		    (priv->board_type == BOARDTYPE_503_INTERSIL_3863)) {
 			iwe->u.qual.qual = curr_bss->link_qual;
 		} else {
 			iwe->u.qual.qual = 0;
@@ -3062,7 +3062,7 @@ static int at76_iw_handler_get_scan(struct net_device *netdev,
 
 	}
 
-	spin_unlock_irqrestore(&(dev->bss_list_spinlock), flags);
+	spin_unlock_irqrestore(&(priv->bss_list_spinlock), flags);
 
 	data->length = (curr_pos - extra);
 	data->flags = 0;
@@ -3076,16 +3076,16 @@ static int at76_iw_handler_set_essid(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_point *data, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWESSID - %s", netdev->name, extra);
 
 	if (data->flags) {
-		memcpy(dev->essid, extra, data->length);
-		dev->essid_size = data->length;
+		memcpy(priv->essid, extra, data->length);
+		priv->essid_size = data->length;
 	} else {
 		/* Use any SSID */
-		dev->essid_size = 0;
+		priv->essid_size = 0;
 	}
 
 	return -EIWCOMMIT;
@@ -3096,23 +3096,23 @@ static int at76_iw_handler_get_essid(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_point *data, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
-	if (dev->essid_size) {
-		/* not the ANY ssid in dev->essid */
+	if (priv->essid_size) {
+		/* not the ANY ssid in priv->essid */
 		data->flags = 1;
-		data->length = dev->essid_size;
-		memcpy(extra, dev->essid, data->length);
+		data->length = priv->essid_size;
+		memcpy(extra, priv->essid, data->length);
 		extra[data->length] = '\0';
 		data->length += 1;
 	} else {
 		/* the ANY ssid was specified */
-		if (dev->istate == CONNECTED && dev->curr_bss != NULL) {
+		if (priv->istate == CONNECTED && priv->curr_bss != NULL) {
 			/* report the SSID we have found */
 			data->flags = 1;
-			data->length = dev->curr_bss->ssid_len;
-			memcpy(extra, dev->curr_bss->ssid, data->length);
-			extra[dev->curr_bss->ssid_len] = '\0';
+			data->length = priv->curr_bss->ssid_len;
+			memcpy(extra, priv->curr_bss->ssid, data->length);
+			extra[priv->curr_bss->ssid_len] = '\0';
 			data->length += 1;
 		} else {
 			/* report ANY back */
@@ -3131,26 +3131,26 @@ static int at76_iw_handler_set_rate(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_param *bitrate, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = -EIWCOMMIT;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRATE - %d", netdev->name, bitrate->value);
 
 	switch (bitrate->value) {
 	case -1:
-		dev->txrate = TX_RATE_AUTO;
+		priv->txrate = TX_RATE_AUTO;
 		break;		/* auto rate */
 	case 1000000:
-		dev->txrate = TX_RATE_1MBIT;
+		priv->txrate = TX_RATE_1MBIT;
 		break;
 	case 2000000:
-		dev->txrate = TX_RATE_2MBIT;
+		priv->txrate = TX_RATE_2MBIT;
 		break;
 	case 5500000:
-		dev->txrate = TX_RATE_5_5MBIT;
+		priv->txrate = TX_RATE_5_5MBIT;
 		break;
 	case 11000000:
-		dev->txrate = TX_RATE_11MBIT;
+		priv->txrate = TX_RATE_11MBIT;
 		break;
 	default:
 		ret = -EINVAL;
@@ -3164,10 +3164,10 @@ static int at76_iw_handler_get_rate(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_param *bitrate, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = 0;
 
-	switch (dev->txrate) {
+	switch (priv->txrate) {
 		/* return max rate if RATE_AUTO */
 	case TX_RATE_AUTO:
 		bitrate->value = 11000000;
@@ -3188,7 +3188,7 @@ static int at76_iw_handler_get_rate(struct net_device *netdev,
 		ret = -EINVAL;
 	}
 
-	bitrate->fixed = (dev->txrate != TX_RATE_AUTO);
+	bitrate->fixed = (priv->txrate != TX_RATE_AUTO);
 	bitrate->disabled = 0;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRATE - %d", netdev->name,
@@ -3202,7 +3202,7 @@ static int at76_iw_handler_set_rts(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct iw_param *rts, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = -EIWCOMMIT;
 	int rthr = rts->value;
 
@@ -3215,7 +3215,7 @@ static int at76_iw_handler_set_rts(struct net_device *netdev,
 	if ((rthr < 0) || (rthr > MAX_RTS_THRESHOLD)) {
 		ret = -EINVAL;
 	} else {
-		dev->rts_threshold = rthr;
+		priv->rts_threshold = rthr;
 	}
 
 	return ret;
@@ -3226,9 +3226,9 @@ static int at76_iw_handler_get_rts(struct net_device *netdev,
 				   struct iw_request_info *info,
 				   struct iw_param *rts, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
-	rts->value = dev->rts_threshold;
+	rts->value = priv->rts_threshold;
 	rts->disabled = (rts->value >= MAX_RTS_THRESHOLD);
 	rts->fixed = 1;
 
@@ -3243,7 +3243,7 @@ static int at76_iw_handler_set_frag(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_param *frag, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = -EIWCOMMIT;
 	int fthr = frag->value;
 
@@ -3256,7 +3256,7 @@ static int at76_iw_handler_set_frag(struct net_device *netdev,
 	if ((fthr < MIN_FRAG_THRESHOLD) || (fthr > MAX_FRAG_THRESHOLD)) {
 		ret = -EINVAL;
 	} else {
-		dev->frag_threshold = fthr & ~0x1; /* get an even value */
+		priv->frag_threshold = fthr & ~0x1; /* get an even value */
 	}
 
 	return ret;
@@ -3267,9 +3267,9 @@ static int at76_iw_handler_get_frag(struct net_device *netdev,
 				    struct iw_request_info *info,
 				    struct iw_param *frag, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
-	frag->value = dev->frag_threshold;
+	frag->value = priv->frag_threshold;
 	frag->disabled = (frag->value >= MAX_FRAG_THRESHOLD);
 	frag->fixed = 1;
 
@@ -3302,7 +3302,7 @@ static int at76_iw_handler_set_retry(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_param *retry, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = -EIWCOMMIT;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWRETRY disabled %d  flags x%x val %d",
@@ -3311,7 +3311,7 @@ static int at76_iw_handler_set_retry(struct net_device *netdev,
 	if (!retry->disabled && (retry->flags & IW_RETRY_LIMIT)) {
 		if ((retry->flags & IW_RETRY_MIN) ||
 		    !(retry->flags & IW_RETRY_MAX)) {
-			dev->short_retry_limit = retry->value;
+			priv->short_retry_limit = retry->value;
 		} else
 			ret = -EINVAL;
 	} else {
@@ -3327,7 +3327,7 @@ static int at76_iw_handler_get_retry(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_param *retry, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWRETRY", netdev->name);
 
@@ -3335,7 +3335,7 @@ static int at76_iw_handler_get_retry(struct net_device *netdev,
 
 
 	retry->flags = IW_RETRY_LIMIT;
-	retry->value = dev->short_retry_limit;
+	retry->value = priv->short_retry_limit;
 
 	return 0;
 }
@@ -3346,7 +3346,7 @@ static int at76_iw_handler_set_encode(struct net_device *netdev,
 				      struct iw_point *encoding,
 				      char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int index = (encoding->flags & IW_ENCODE_INDEX) - 1;
 	int len = encoding->length;
 
@@ -3355,38 +3355,38 @@ static int at76_iw_handler_set_encode(struct net_device *netdev,
 	         encoding->pointer, encoding->length);
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - old wepstate: enabled %s key_id %d "
 	         "auth_mode %s",
-	         netdev->name, (dev->wep_enabled) ? "true" : "false",
-	         dev->wep_key_id,
-	         (dev->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
+	         netdev->name, (priv->wep_enabled) ? "true" : "false",
+	         priv->wep_key_id,
+	         (priv->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
 
 	/* take the old default key if index is invalid */
 	if ((index < 0) || (index >= WEP_KEYS))
-		index = dev->wep_key_id;
+		index = priv->wep_key_id;
 
 	if (len > 0) {
 		if (len > WEP_LARGE_KEY_LEN)
 			len = WEP_LARGE_KEY_LEN;
 
-		memset(dev->wep_keys[index], 0, WEP_KEY_LEN);
-		memcpy(dev->wep_keys[index], extra, len);
-		dev->wep_keys_len[index] = (len <= WEP_SMALL_KEY_LEN) ?
+		memset(priv->wep_keys[index], 0, WEP_KEY_LEN);
+		memcpy(priv->wep_keys[index], extra, len);
+		priv->wep_keys_len[index] = (len <= WEP_SMALL_KEY_LEN) ?
 		    WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN;
-		dev->wep_enabled = 1;
+		priv->wep_enabled = 1;
 	}
 
-	dev->wep_key_id = index;
-	dev->wep_enabled = ((encoding->flags & IW_ENCODE_DISABLED) == 0);
+	priv->wep_key_id = index;
+	priv->wep_enabled = ((encoding->flags & IW_ENCODE_DISABLED) == 0);
 
 	if (encoding->flags & IW_ENCODE_RESTRICTED)
-		dev->auth_mode = WLAN_AUTH_SHARED_KEY;
+		priv->auth_mode = WLAN_AUTH_SHARED_KEY;
 	if (encoding->flags & IW_ENCODE_OPEN)
-		dev->auth_mode = WLAN_AUTH_OPEN;
+		priv->auth_mode = WLAN_AUTH_OPEN;
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWENCODE - new wepstate: enabled %s key_id %d "
 	         "key_len %d auth_mode %s",
-	         netdev->name, (dev->wep_enabled) ? "true" : "false",
-	         dev->wep_key_id + 1, dev->wep_keys_len[dev->wep_key_id],
-	         (dev->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
+	         netdev->name, (priv->wep_enabled) ? "true" : "false",
+	         priv->wep_key_id + 1, priv->wep_keys_len[priv->wep_key_id],
+	         (priv->auth_mode == WLAN_AUTH_SHARED_KEY) ? "restricted" : "open");
 
 	return -EIWCOMMIT;
 }
@@ -3397,23 +3397,23 @@ static int at76_iw_handler_get_encode(struct net_device *netdev,
 				      struct iw_point *encoding,
 				      char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int index = (encoding->flags & IW_ENCODE_INDEX) - 1;
 
 	if ((index < 0) || (index >= WEP_KEYS))
-		index = dev->wep_key_id;
+		index = priv->wep_key_id;
 
 	encoding->flags =
-	    (dev->auth_mode == WLAN_AUTH_SHARED_KEY) ?
+	    (priv->auth_mode == WLAN_AUTH_SHARED_KEY) ?
 	    IW_ENCODE_RESTRICTED : IW_ENCODE_OPEN;
 
-	if (!dev->wep_enabled)
+	if (!priv->wep_enabled)
 		encoding->flags |= IW_ENCODE_DISABLED;
 
 	if (encoding->pointer) {
-		encoding->length = dev->wep_keys_len[index];
+		encoding->length = priv->wep_keys_len[index];
 
-		memcpy(extra, dev->wep_keys[index], dev->wep_keys_len[index]);
+		memcpy(extra, priv->wep_keys[index], priv->wep_keys_len[index]);
 
 		encoding->flags |= (index + 1);
 	}
@@ -3423,9 +3423,9 @@ static int at76_iw_handler_get_encode(struct net_device *netdev,
 		encoding->pointer, encoding->length);
 	at76_dbg(DBG_IOCTL, "%s: SIOCGIWENCODE - wepstate: enabled %s key_id %d "
 		"key_len %d auth_mode %s",
-		netdev->name, (dev->wep_enabled) ? "true" : "false",
-		dev->wep_key_id + 1, dev->wep_keys_len[dev->wep_key_id],
-		(dev->auth_mode == WLAN_AUTH_SHARED_KEY) ?
+		netdev->name, (priv->wep_enabled) ? "true" : "false",
+		priv->wep_key_id + 1, priv->wep_keys_len[priv->wep_key_id],
+		(priv->auth_mode == WLAN_AUTH_SHARED_KEY) ?
 			"restricted" : "open");
 
 	return 0;
@@ -3437,14 +3437,14 @@ static int at76_iw_handler_set_power(struct net_device *netdev,
 				     struct iw_param *prq, char *extra)
 {
 	int err = -EIWCOMMIT;
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
 	at76_dbg(DBG_IOCTL, "%s: SIOCSIWPOWER - disabled %s flags x%x value x%x",
 		 netdev->name, (prq->disabled) ? "true" : "false",
 		 prq->flags, prq->value);
 
 	if (prq->disabled) {
-		dev->pm_mode = AT76_PM_OFF;
+		priv->pm_mode = AT76_PM_OFF;
 	} else {
 		switch (prq->flags & IW_POWER_MODE) {
                 case IW_POWER_ALL_R:
@@ -3455,13 +3455,13 @@ static int at76_iw_handler_set_power(struct net_device *netdev,
 			goto out;
 		}
 		if (prq->flags & IW_POWER_PERIOD) {
-			dev->pm_period = prq->value;
+			priv->pm_period = prq->value;
 		}
 		if (prq->flags & IW_POWER_TIMEOUT) {
 			err = -EINVAL;
 			goto out;
 		}
-		dev->pm_mode = AT76_PM_ON;
+		priv->pm_mode = AT76_PM_ON;
 	}
 out:
 	return err;
@@ -3472,13 +3472,13 @@ static int at76_iw_handler_get_power(struct net_device *netdev,
 				     struct iw_request_info *info,
 				     struct iw_param *power, char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
-	if ((power->disabled = (dev->pm_mode == AT76_PM_OFF)))
+	if ((power->disabled = (priv->pm_mode == AT76_PM_OFF)))
 		return 0;
 	else {
 		power->flags = IW_POWER_PERIOD;
-		power->value = dev->pm_period;
+		power->value = priv->pm_period;
 	}
 	power->flags |= IW_POWER_ALL_R;
 
@@ -3497,7 +3497,7 @@ static int at76_iw_set_short_preamble(struct net_device *netdev,
 				      struct iw_request_info *info, char *name,
 				      char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int val = *((int *)name);
 	int ret = -EIWCOMMIT;
 
@@ -3509,7 +3509,7 @@ static int at76_iw_set_short_preamble(struct net_device *netdev,
 		   for "auto preamble" ...? */
 		ret = -EINVAL;
 	} else {
-		dev->preamble_type = val;
+		priv->preamble_type = val;
 	}
 
 	return ret;
@@ -3555,7 +3555,7 @@ static int at76_iw_set_powersave_mode(struct net_device *netdev,
 				      struct iw_request_info *info, char *name,
 				      char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int val = *((int *)name);
 	int ret = -EIWCOMMIT;
 
@@ -3566,7 +3566,7 @@ static int at76_iw_set_powersave_mode(struct net_device *netdev,
 	if (val < AT76_PM_OFF || val > AT76_PM_SMART) {
 		ret = -EINVAL;
 	} else {
-		dev->pm_mode = val;
+		priv->pm_mode = val;
 	}
 
 	return ret;
@@ -3577,7 +3577,7 @@ static int at76_iw_set_scan_times(struct net_device *netdev,
 				  struct iw_request_info *info, char *name,
 				  char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int mint = *((int *)name);
 	int maxt = *((int *)name + 1);
 	int ret = -EIWCOMMIT;
@@ -3587,13 +3587,13 @@ static int at76_iw_set_scan_times(struct net_device *netdev,
 	if (mint <= 0 || maxt <= 0 || mint > maxt) {
 		ret = -EINVAL;
 	} else {
-		if (dev->istate == MONITORING) {
-			dev->monitor_scan_min_time = mint;
-			dev->monitor_scan_max_time = maxt;
+		if (priv->istate == MONITORING) {
+			priv->monitor_scan_min_time = mint;
+			priv->monitor_scan_max_time = maxt;
 			ret = 0;
 		} else {
-			dev->scan_min_time = mint;
-			dev->scan_max_time = maxt;
+			priv->scan_min_time = mint;
+			priv->scan_max_time = maxt;
 		}
 	}
 
@@ -3605,7 +3605,7 @@ static int at76_iw_set_scan_mode(struct net_device *netdev,
 				 struct iw_request_info *info, char *name,
 				 char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int val = *((int *)name);
 	int ret = -EIWCOMMIT;
 
@@ -3616,25 +3616,25 @@ static int at76_iw_set_scan_mode(struct net_device *netdev,
 	if (val != SCAN_TYPE_ACTIVE && val != SCAN_TYPE_PASSIVE) {
 		ret = -EINVAL;
 	} else {
-		dev->scan_mode = val;
+		priv->scan_mode = val;
 	}
 
 	return ret;
 }
 
 
-static int at76_set_iroaming(struct at76_priv *dev, int onoff)
+static int at76_set_iroaming(struct at76_priv *priv, int onoff)
 {
 	int ret = 0;
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC_MGMT;
-	dev->mib_buf.size = 1;
-	dev->mib_buf.index = IROAMING_OFFSET;
-	dev->mib_buf.data[0] = (dev->international_roaming ? 1 : 0);
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC_MGMT;
+	priv->mib_buf.size = 1;
+	priv->mib_buf.index = IROAMING_OFFSET;
+	priv->mib_buf.data[0] = (priv->international_roaming ? 1 : 0);
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (intl_roaming_enable) failed: %d", dev->netdev->name, ret);
+		err("%s: set_mib (intl_roaming_enable) failed: %d", priv->netdev->name, ret);
 	}
 
 	return ret;
@@ -3645,7 +3645,7 @@ static int at76_iw_set_intl_roaming(struct net_device *netdev,
 				    struct iw_request_info *info, char *name,
 				    char *extra)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int val = *((int *)name);
 	int ret = -EIWCOMMIT;
 
@@ -3656,9 +3656,9 @@ static int at76_iw_set_intl_roaming(struct net_device *netdev,
 	if (val != IR_OFF && val != IR_ON) {
 		ret = -EINVAL;
 	} else {
-		if (dev->international_roaming != val) {
-			dev->international_roaming = val;
-			at76_set_iroaming(dev, val);
+		if (priv->international_roaming != val) {
+			priv->international_roaming = val;
+			at76_set_iroaming(priv, val);
 		}
 	}
 
@@ -3813,12 +3813,12 @@ static const u8 rfc1042sig[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
 
 static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
-	struct net_device_stats *stats = &dev->stats;
+	struct at76_priv *priv = netdev_priv(netdev);
+	struct net_device_stats *stats = &priv->stats;
 	int ret = 0;
 	int wlen;
 	int submit_len;
-	struct at76_tx_buffer *tx_buffer = dev->bulk_out_buffer;
+	struct at76_tx_buffer *tx_buffer = priv->bulk_out_buffer;
 	struct ieee80211_hdr_3addr *i802_11_hdr =
 	    (struct ieee80211_hdr_3addr *)&(tx_buffer->packet);
 	u8 *payload = tx_buffer->packet + sizeof(struct ieee80211_hdr_3addr);
@@ -3831,8 +3831,8 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 		return 0;
 	}
 
-	if (dev->write_urb->status == -EINPROGRESS) {
-		err("%s: %s called while dev->write_urb is pending for tx",
+	if (priv->write_urb->status == -EINPROGRESS) {
+		err("%s: %s called while priv->write_urb is pending for tx",
 		    netdev->name, __FUNCTION__);
 		/* skip this packet */
 		dev_kfree_skb(skb);
@@ -3840,7 +3840,7 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	}
 
 	if (skb->len < 2 * ETH_ALEN) {
-		err("%s: %s: skb too short (%d)", dev->netdev->name,
+		err("%s: %s: skb too short (%d)", priv->netdev->name,
 		    __FUNCTION__, skb->len);
 		dev_kfree_skb(skb);
 		return 0;
@@ -3863,7 +3863,7 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 		} else {
 			err("%s: %s: no support for non-SNAP 802.2 packets "
 			    "(DSAP x%02x SSAP x%02x cntrl x%02x)",
-			    dev->netdev->name, __FUNCTION__,
+			    priv->netdev->name, __FUNCTION__,
 			    skb->data[2 * ETH_ALEN + 2],
 			    skb->data[2 * ETH_ALEN + 2 + 1],
 			    skb->data[2 * ETH_ALEN + 2 + 2]);
@@ -3882,16 +3882,16 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	/* make wireless header */
 	i802_11_hdr->frame_ctl =
 	    cpu_to_le16(IEEE80211_FTYPE_DATA |
-			(dev->wep_enabled ? IEEE80211_FCTL_PROTECTED : 0) |
-			(dev->iw_mode ==
+			(priv->wep_enabled ? IEEE80211_FCTL_PROTECTED : 0) |
+			(priv->iw_mode ==
 			 IW_MODE_INFRA ? IEEE80211_FCTL_TODS : 0));
 
-	if (dev->iw_mode == IW_MODE_ADHOC) {
+	if (priv->iw_mode == IW_MODE_ADHOC) {
 		memcpy(i802_11_hdr->addr1, skb->data, ETH_ALEN);	/* destination */
 		memcpy(i802_11_hdr->addr2, skb->data + ETH_ALEN, ETH_ALEN);	/* source */
-		memcpy(i802_11_hdr->addr3, dev->bssid, ETH_ALEN);
-	} else if (dev->iw_mode == IW_MODE_INFRA) {
-		memcpy(i802_11_hdr->addr1, dev->bssid, ETH_ALEN);
+		memcpy(i802_11_hdr->addr3, priv->bssid, ETH_ALEN);
+	} else if (priv->iw_mode == IW_MODE_INFRA) {
+		memcpy(i802_11_hdr->addr1, priv->bssid, ETH_ALEN);
 		memcpy(i802_11_hdr->addr2, skb->data + ETH_ALEN, ETH_ALEN);	/* source */
 		memcpy(i802_11_hdr->addr3, skb->data, ETH_ALEN);	/* destination */
 	}
@@ -3901,7 +3901,7 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 
 	/* setup 'Atmel' header */
 	tx_buffer->wlength = cpu_to_le16(wlen);
-	tx_buffer->tx_rate = dev->txrate;
+	tx_buffer->tx_rate = priv->txrate;
 	/* for broadcast destination addresses, the firmware 0.100.x
 	   seems to choose the highest rate set with CMD_STARTUP in
 	   basic_rate_set replacing this value */
@@ -3912,38 +3912,38 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 	submit_len = wlen + AT76_TX_HDRLEN + tx_buffer->padding;
 
 	{
-		at76_dbg(DBG_TX_DATA_CONTENT, "%s skb->data %s", dev->netdev->name,
-		         hex2str(dev->obuf, skb->data,
-			    min((int)(sizeof(dev->obuf) - 1) / 2, 32), '\0'));
+		at76_dbg(DBG_TX_DATA_CONTENT, "%s skb->data %s", priv->netdev->name,
+		         hex2str(priv->obuf, skb->data,
+			    min((int)(sizeof(priv->obuf) - 1) / 2, 32), '\0'));
 		at76_dbg(DBG_TX_DATA, "%s tx  wlen x%x pad x%x rate %d hdr %s",
-		         dev->netdev->name,
+		         priv->netdev->name,
 		         le16_to_cpu(tx_buffer->wlength),
 		         tx_buffer->padding, tx_buffer->tx_rate,
-		         hex2str(dev->obuf, i802_11_hdr,
-			    min((sizeof(dev->obuf) - 1) / 2,
+		         hex2str(priv->obuf, i802_11_hdr,
+			    min((sizeof(priv->obuf) - 1) / 2,
 				sizeof(struct ieee80211_hdr_3addr)), '\0'));
-		at76_dbg(DBG_TX_DATA_CONTENT, "%s payload %s", dev->netdev->name,
-		         hex2str(dev->obuf, payload,
-			    min((int)(sizeof(dev->obuf) - 1) / 2, 48), '\0'));
+		at76_dbg(DBG_TX_DATA_CONTENT, "%s payload %s", priv->netdev->name,
+		         hex2str(priv->obuf, payload,
+			    min((int)(sizeof(priv->obuf) - 1) / 2, 48), '\0'));
 	}
 
 	/* send stuff */
 	netif_stop_queue(netdev);
 	netdev->trans_start = jiffies;
 
-	usb_fill_bulk_urb(dev->write_urb, dev->udev,
-		         usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),
+	usb_fill_bulk_urb(priv->write_urb, priv->udev,
+		         usb_sndbulkpipe(priv->udev, priv->bulk_out_endpointAddr),
 		         tx_buffer, submit_len,
-		         at76_write_bulk_callback, dev);
-	ret = usb_submit_urb(dev->write_urb, GFP_ATOMIC);
+		         at76_write_bulk_callback, priv);
+	ret = usb_submit_urb(priv->write_urb, GFP_ATOMIC);
 	if (ret) {
 		stats->tx_errors++;
 		err("%s: error in tx submit urb: %d", netdev->name, ret);
 		if (ret == -EINVAL)
 			err("-EINVAL: urb %p urb->hcpriv %p urb->complete %p",
-			    dev->write_urb,
-			    dev->write_urb ? dev->write_urb->hcpriv : (void *)-1,
-			    dev->write_urb ? dev->write_urb->complete : (void *)-1);
+			    priv->write_urb,
+			    priv->write_urb ? priv->write_urb->hcpriv : (void *)-1,
+			    priv->write_urb ? priv->write_urb->complete : (void *)-1);
 		goto err;
 	}
 
@@ -3959,51 +3959,51 @@ static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
 
 static void at76_tx_timeout(struct net_device *netdev)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
-	if (!dev)
+	if (!priv)
 		return;
 	warn("%s: tx timeout.", netdev->name);
 
-	usb_unlink_urb(dev->write_urb);
-	dev->stats.tx_errors++;
+	usb_unlink_urb(priv->write_urb);
+	priv->stats.tx_errors++;
 }
 
 
-static int at76_submit_rx_urb(struct at76_priv *dev)
+static int at76_submit_rx_urb(struct at76_priv *priv)
 {
 	int ret, size;
-	struct sk_buff *skb = dev->rx_skb;
+	struct sk_buff *skb = priv->rx_skb;
 
-	if (dev->read_urb == NULL) {
-		err("%s: dev->read_urb is NULL", __FUNCTION__);
+	if (priv->read_urb == NULL) {
+		err("%s: priv->read_urb is NULL", __FUNCTION__);
 		return -EFAULT;
 	}
 
 	if (skb == NULL) {
 		skb = dev_alloc_skb(sizeof(struct at76_rx_buffer));
 		if (skb == NULL) {
-			err("%s: unable to allocate rx skbuff.", dev->netdev->name);
+			err("%s: unable to allocate rx skbuff.", priv->netdev->name);
 			ret = -ENOMEM;
 			goto exit;
 		}
-		dev->rx_skb = skb;
+		priv->rx_skb = skb;
 	} else {
 		skb_push(skb, skb_headroom(skb));
 		skb_trim(skb, 0);
 	}
 
 	size = skb_tailroom(skb);
-	usb_fill_bulk_urb(dev->read_urb, dev->udev,
-		         usb_rcvbulkpipe(dev->udev, dev->bulk_in_endpointAddr),
+	usb_fill_bulk_urb(priv->read_urb, priv->udev,
+		         usb_rcvbulkpipe(priv->udev, priv->bulk_in_endpointAddr),
 		         skb_put(skb, size), size,
-		         at76_read_bulk_callback, dev);
-	ret = usb_submit_urb(dev->read_urb, GFP_ATOMIC);
+		         at76_read_bulk_callback, priv);
+	ret = usb_submit_urb(priv->read_urb, GFP_ATOMIC);
 	if (ret < 0) {
 		if (ret == -ENODEV)
 			at76_dbg(DBG_DEVSTART, "usb_submit_urb returned -ENODEV");
 		else
-			err("%s: rx, usb_submit_urb failed: %d", dev->netdev->name, ret);
+			err("%s: rx, usb_submit_urb failed: %d", priv->netdev->name, ret);
 	}
 
 exit:
@@ -4011,103 +4011,103 @@ exit:
 		if (ret != -ENODEV) {
 			/* If we can't submit the URB, the adapter becomes completely
 			 * useless, so try again later */
-			if (--dev->nr_submit_rx_tries > 0)
-				schedule_work(&dev->work_submit_rx);
+			if (--priv->nr_submit_rx_tries > 0)
+				schedule_work(&priv->work_submit_rx);
 			else {
 				err("%s: giving up to submit rx urb after %d failures -"
 			    	    " please unload the driver and/or power cycle the device",
-			    	    dev->netdev->name, NR_SUBMIT_RX_TRIES);
+			    	    priv->netdev->name, NR_SUBMIT_RX_TRIES);
 			}
 		}
 	} else
 		/* reset counter to initial value */
-		dev->nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;
+		priv->nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;
 	return ret;
 }
 
 
 static int at76_open(struct net_device *netdev)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	int ret = 0;
 
 	at76_dbg(DBG_PROC_ENTRY, "at76_open entry");
 
-	if (down_interruptible(&dev->sem))
+	if (down_interruptible(&priv->sem))
 		return -EINTR;
 
-	/* if netdev->dev_addr != dev->mac_addr we must
+	/* if netdev->dev_addr != priv->mac_addr we must
 	   set the mac address in the device ! */
-	if (compare_ether_addr(netdev->dev_addr, dev->mac_addr)) {
-		if (at76_add_mac_address(dev, netdev->dev_addr) >= 0)
+	if (compare_ether_addr(netdev->dev_addr, priv->mac_addr)) {
+		if (at76_add_mac_address(priv, netdev->dev_addr) >= 0)
 			at76_dbg(DBG_PROGRESS, "%s: set new MAC addr %s",
 			         netdev->name, mac2str(netdev->dev_addr));
 	}
 #ifdef DEBUG
-	at76_dump_mib_mac_addr(dev);
+	at76_dump_mib_mac_addr(priv);
 #endif
 
-	dev->scan_state = SCAN_IDLE;
-	dev->last_scan = jiffies;
-	dev->nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;	/* init counter */
+	priv->scan_state = SCAN_IDLE;
+	priv->last_scan = jiffies;
+	priv->nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;	/* init counter */
 
-	if ((ret = at76_submit_rx_urb(dev)) < 0) {
+	if ((ret = at76_submit_rx_urb(priv)) < 0) {
 		err("%s: open: submit_rx_urb failed: %d", netdev->name, ret);
 		goto err;
 	}
 
-	dev->open_count++;
+	priv->open_count++;
 
-	schedule_work(&dev->work_restart);
+	schedule_work(&priv->work_restart);
 
 	at76_dbg(DBG_PROC_ENTRY, "at76_open end");
  err:
-	up(&dev->sem);
+	up(&priv->sem);
 	return ret < 0 ? ret : 0;
 }
 
 
 static int at76_stop(struct net_device *netdev)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 	unsigned long flags;
 
 	at76_dbg(DBG_DEVSTART, "%s: ENTER", __FUNCTION__);
 
-	if (down_interruptible(&dev->sem))
+	if (down_interruptible(&priv->sem))
 		return -EINTR;
 
 	netif_stop_queue(netdev);
 
-	dev->istate = INIT;
+	priv->istate = INIT;
 
-	if (!(dev->device_unplugged)) {
+	if (!(priv->device_unplugged)) {
 		/* we are called by "ifconfig ethX down", not because the
 		   device isn't avail. anymore */
-		at76_set_radio(dev, 0);
+		at76_set_radio(priv, 0);
 
 		/* we unlink the read urb, because the _open()
 		   submits it again. _delete_device() takes care of the
 		   read_urb otherwise. */
-		usb_kill_urb(dev->read_urb);
+		usb_kill_urb(priv->read_urb);
 	}
 
-	del_timer_sync(&dev->mgmt_timer);
+	del_timer_sync(&priv->mgmt_timer);
 
-	spin_lock_irqsave(&dev->mgmt_spinlock, flags);
-	if (dev->next_mgmt_bulk) {
-		kfree(dev->next_mgmt_bulk);
-		dev->next_mgmt_bulk = NULL;
+	spin_lock_irqsave(&priv->mgmt_spinlock, flags);
+	if (priv->next_mgmt_bulk) {
+		kfree(priv->next_mgmt_bulk);
+		priv->next_mgmt_bulk = NULL;
 	}
-	spin_unlock_irqrestore(&dev->mgmt_spinlock, flags);
+	spin_unlock_irqrestore(&priv->mgmt_spinlock, flags);
 
 	/* free the bss_list */
-	at76_free_bss_list(dev);
+	at76_free_bss_list(priv);
 
-	at76_assert(dev->open_count > 0);
-	dev->open_count--;
+	at76_assert(priv->open_count > 0);
+	priv->open_count--;
 
-	up(&dev->sem);
+	up(&priv->sem);
 	at76_dbg(DBG_DEVSTART, "%s: EXIT", __FUNCTION__);
 
 	return 0;
@@ -4117,7 +4117,7 @@ static int at76_stop(struct net_device *netdev)
 static void at76_ethtool_get_drvinfo(struct net_device *netdev,
 					 struct ethtool_drvinfo *info)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
+	struct at76_priv *priv = netdev_priv(netdev);
 
 	strncpy(info->driver, DRIVER_NAME, sizeof(info->driver) - 1);
 
@@ -4125,19 +4125,19 @@ static void at76_ethtool_get_drvinfo(struct net_device *netdev,
 	info->version[sizeof(info->version) - 1] = '\0';
 
 	snprintf(info->bus_info, sizeof(info->bus_info) - 1, "usb%d:%d",
-		 dev->udev->bus->busnum, dev->udev->devnum);
+		 priv->udev->bus->busnum, priv->udev->devnum);
 
 	snprintf(info->fw_version, sizeof(info->fw_version) - 1,
 		 "%d.%d.%d-%d",
-		 dev->fw_version.major, dev->fw_version.minor,
-		 dev->fw_version.patch, dev->fw_version.build);
+		 priv->fw_version.major, priv->fw_version.minor,
+		 priv->fw_version.patch, priv->fw_version.build);
 }
 
 
 static u32 at76_ethtool_get_link(struct net_device *netdev)
 {
-	struct at76_priv *dev = netdev_priv(netdev);
-	return dev->istate == CONNECTED;
+	struct at76_priv *priv = netdev_priv(netdev);
+	return priv->istate == CONNECTED;
 }
 
 
@@ -4154,29 +4154,29 @@ static struct ethtool_ops at76_ethtool_ops = {
  * because hotplug may try to configure the netdev _before_ (or parallel to)
  * the download of firmware
  */
-static int at76_init_new_device(struct at76_priv *dev)
+static int at76_init_new_device(struct at76_priv *priv)
 {
-	struct net_device *netdev = dev->netdev;
+	struct net_device *netdev = priv->netdev;
 	int ret;
 
 	/* set up the endpoint information */
 	/* check out the endpoints */
 
-	dev->interface = dev->udev->actconfig->interface[0];
+	priv->interface = priv->udev->actconfig->interface[0];
 
 	at76_dbg(DBG_DEVSTART, "USB interface: %d endpoints",
-	         dev->interface->cur_altsetting->desc.bNumEndpoints);
+	         priv->interface->cur_altsetting->desc.bNumEndpoints);
 
-	if ((ret = at76_alloc_urbs(dev)) < 0)
+	if ((ret = at76_alloc_urbs(priv)) < 0)
 		goto error;
 
 	/* get firmware version */
-	ret = at76_get_mib(dev->udev, MIB_FW_VERSION, &dev->fw_version,
-			   sizeof(dev->fw_version));
-	if ((ret < 0) || ((dev->fw_version.major == 0) &&
-			  (dev->fw_version.minor == 0) &&
-			  (dev->fw_version.patch == 0) &&
-			  (dev->fw_version.build == 0))) {
+	ret = at76_get_mib(priv->udev, MIB_FW_VERSION, &priv->fw_version,
+			   sizeof(priv->fw_version));
+	if ((ret < 0) || ((priv->fw_version.major == 0) &&
+			  (priv->fw_version.minor == 0) &&
+			  (priv->fw_version.patch == 0) &&
+			  (priv->fw_version.build == 0))) {
 		err("getting firmware failed with %d, or version is 0", ret);
 		err("this probably means that the ext. fw was not loaded correctly");
 		if(ret >= 0)
@@ -4185,47 +4185,47 @@ static int at76_init_new_device(struct at76_priv *dev)
 	}
 
 	/* fw 0.84 doesn't send FCS with rx data */
-	if (dev->fw_version.major == 0 && dev->fw_version.minor <= 84)
-		dev->rx_data_fcs_len = 0;
+	if (priv->fw_version.major == 0 && priv->fw_version.minor <= 84)
+		priv->rx_data_fcs_len = 0;
 	else
-		dev->rx_data_fcs_len = 4;
+		priv->rx_data_fcs_len = 4;
 
 	info("firmware version %d.%d.%d #%d (fcs_len %d)",
-	     dev->fw_version.major, dev->fw_version.minor,
-	     dev->fw_version.patch, dev->fw_version.build,
-	     dev->rx_data_fcs_len);
+	     priv->fw_version.major, priv->fw_version.minor,
+	     priv->fw_version.patch, priv->fw_version.build,
+	     priv->rx_data_fcs_len);
 
 	/* MAC address */
-	ret = at76_get_hw_config(dev);
+	ret = at76_get_hw_config(priv);
 	if (ret < 0) {
 		err("could not get MAC address");
 		goto error;
 	}
 
-	dev->domain = at76_get_reg_domain(dev->regulatory_domain);
+	priv->domain = at76_get_reg_domain(priv->regulatory_domain);
 	/* init. netdev->dev_addr */
-	memcpy(netdev->dev_addr, dev->mac_addr, ETH_ALEN);
+	memcpy(netdev->dev_addr, priv->mac_addr, ETH_ALEN);
 	info("device's MAC %s, regulatory domain %s (id %d)",
-	     mac2str(dev->mac_addr), dev->domain->name, dev->regulatory_domain);
+	     mac2str(priv->mac_addr), priv->domain->name, priv->regulatory_domain);
 
 	/* initializing */
-	dev->international_roaming = international_roaming;
-	dev->channel = DEF_CHANNEL;
-	dev->iw_mode = default_iw_mode;
-	memset(dev->essid, 0, IW_ESSID_MAX_SIZE);
-	dev->rts_threshold = DEF_RTS_THRESHOLD;
-	dev->frag_threshold = DEF_FRAG_THRESHOLD;
-	dev->short_retry_limit = DEF_SHORT_RETRY_LIMIT;
-	dev->txrate = TX_RATE_AUTO;
-	dev->preamble_type = preamble_type;
-	dev->beacon_period = 100;
-	dev->beacons_last_qual = jiffies_to_msecs(jiffies);
-	dev->auth_mode = auth_mode ? WLAN_AUTH_SHARED_KEY : WLAN_AUTH_OPEN;
-	dev->scan_min_time = scan_min_time;
-	dev->scan_max_time = scan_max_time;
-	dev->scan_mode = scan_mode;
-	dev->monitor_scan_min_time = monitor_scan_min_time;
-	dev->monitor_scan_max_time = monitor_scan_max_time;
+	priv->international_roaming = international_roaming;
+	priv->channel = DEF_CHANNEL;
+	priv->iw_mode = default_iw_mode;
+	memset(priv->essid, 0, IW_ESSID_MAX_SIZE);
+	priv->rts_threshold = DEF_RTS_THRESHOLD;
+	priv->frag_threshold = DEF_FRAG_THRESHOLD;
+	priv->short_retry_limit = DEF_SHORT_RETRY_LIMIT;
+	priv->txrate = TX_RATE_AUTO;
+	priv->preamble_type = preamble_type;
+	priv->beacon_period = 100;
+	priv->beacons_last_qual = jiffies_to_msecs(jiffies);
+	priv->auth_mode = auth_mode ? WLAN_AUTH_SHARED_KEY : WLAN_AUTH_OPEN;
+	priv->scan_min_time = scan_min_time;
+	priv->scan_max_time = scan_max_time;
+	priv->scan_mode = scan_mode;
+	priv->monitor_scan_min_time = monitor_scan_min_time;
+	priv->monitor_scan_max_time = monitor_scan_max_time;
 
 	netdev->flags &= ~IFF_MULTICAST; /* not yet or never */
 	netdev->open = at76_open;
@@ -4234,8 +4234,8 @@ static int at76_init_new_device(struct at76_priv *dev)
 	netdev->ethtool_ops = &at76_ethtool_ops;
 
 	/* Add pointers to enable iwspy support. */
-	dev->wireless_data.spy_data = &dev->spy_data;
-	netdev->wireless_data = &dev->wireless_data;
+	priv->wireless_data.spy_data = &priv->spy_data;
+	netdev->wireless_data = &priv->wireless_data;
 
 	netdev->hard_start_xmit = at76_tx;
 	netdev->tx_timeout = at76_tx_timeout;
@@ -4244,21 +4244,21 @@ static int at76_init_new_device(struct at76_priv *dev)
 	netdev->set_multicast_list = at76_set_multicast;
 	netdev->set_mac_address = at76_set_mac_address;
 
-	ret = register_netdev(dev->netdev);
+	ret = register_netdev(priv->netdev);
 	if (ret) {
 		err("unable to register netdevice %s (status %d)!",
-		    dev->netdev->name, ret);
+		    priv->netdev->name, ret);
 		goto error;
 	}
-	info("registered %s", dev->netdev->name);
-	dev->netdev_registered = 1;
+	info("registered %s", priv->netdev->name);
+	priv->netdev_registered = 1;
 
 	/* we let this timer run the whole time this driver instance lives */
-	mod_timer(&dev->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
+	mod_timer(&priv->bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
 
 	return 0;
  error:
-	at76_delete_device(dev);
+	at76_delete_device(priv);
 	return ret;
 }
 
@@ -4266,14 +4266,14 @@ static int at76_init_new_device(struct at76_priv *dev)
 /* Download external firmware */
 static void at76_work_external_fw(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_external_fw);
 	int ret;
 	u8 op_mode;
 
-	down(&dev->sem);
+	down(&priv->sem);
 
-	op_mode = at76_get_op_mode(dev->udev);
+	op_mode = at76_get_op_mode(priv->udev);
 	at76_dbg(DBG_DEVSTART, "opmode %d", op_mode);
 
 	if (op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {
@@ -4281,41 +4281,41 @@ static void at76_work_external_fw(struct work_struct *work)
 		goto end_external_fw;
 	}
 
-	if (dev->extfw && dev->extfw_size) {
-		ret = at76_download_external_fw(dev->udev, dev->extfw,
-					        dev->extfw_size);
+	if (priv->extfw && priv->extfw_size) {
+		ret = at76_download_external_fw(priv->udev, priv->extfw,
+					        priv->extfw_size);
 		if (ret < 0) {
 			err("Downloading external firmware failed: %d", ret);
 			goto end_external_fw;
 		}
-		if (dev->board_type == BOARDTYPE_505A_RFMD_2958) {
+		if (priv->board_type == BOARDTYPE_505A_RFMD_2958) {
 			info("200 ms delay for board type 7");
-			/* can we do this with dev->sem down? */
+			/* can we do this with priv->sem down? */
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(HZ / 5 + 1);
 		}
 	}
-	dev->istate = INIT;
-	if ((ret = at76_init_new_device(dev)) < 0)
+	priv->istate = INIT;
+	if ((ret = at76_init_new_device(priv)) < 0)
 		err("Downloading external firmware failed: %d", ret);
 
   end_external_fw:
-	up(&dev->sem);
+	up(&priv->sem);
 }
 
 
 /* Download internal firmware */
 static void at76_work_internal_fw(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_internal_fw);
 	int ret;
 
-	down(&dev->sem);
+	down(&priv->sem);
 
-	ret = at76_usbdfu_download(dev->udev, dev->intfw,
-			           dev->intfw_size,
-			           dev->board_type ==
+	ret = at76_usbdfu_download(priv->udev, priv->intfw,
+			           priv->intfw_size,
+			           priv->board_type ==
 			           BOARDTYPE_505A_RFMD_2958 ? 2000 : 0);
 
 	if (ret < 0) {
@@ -4326,51 +4326,51 @@ static void at76_work_internal_fw(struct work_struct *work)
 	at76_dbg(DBG_DEVSTART, "sending REMAP");
 
 	/* no REMAP for 505A (see SF driver) */
-	if (dev->board_type != BOARDTYPE_505A_RFMD_2958)
-		if ((ret = at76_remap(dev->udev)) < 0) {
+	if (priv->board_type != BOARDTYPE_505A_RFMD_2958)
+		if ((ret = at76_remap(priv->udev)) < 0) {
 			err("sending REMAP failed with %d", ret);
 			goto end_internal_fw;
 		}
 
 	at76_dbg(DBG_DEVSTART, "sleeping for 2 seconds");
-	dev->istate = EXTFW_DOWNLOAD;
-	mod_timer(&dev->fw_dl_timer, jiffies + 2 * HZ + 1);
+	priv->istate = EXTFW_DOWNLOAD;
+	mod_timer(&priv->fw_dl_timer, jiffies + 2 * HZ + 1);
 
   end_internal_fw:
-	up(&dev->sem);
+	up(&priv->sem);
 }
 
 
-static int at76_essid_matched(struct at76_priv *dev, struct bss_info *ptr)
+static int at76_essid_matched(struct at76_priv *priv, struct bss_info *ptr)
 {
 	/* common criteria for both modi */
 
-	int ret = (dev->essid_size == 0 /* ANY ssid */  ||
-		      (dev->essid_size == ptr->ssid_len &&
-		       !memcmp(dev->essid, ptr->ssid, ptr->ssid_len)));
+	int ret = (priv->essid_size == 0 /* ANY ssid */  ||
+		      (priv->essid_size == ptr->ssid_len &&
+		       !memcmp(priv->essid, ptr->ssid, ptr->ssid_len)));
 	if (!ret)
 		at76_dbg(DBG_BSS_MATCH, "%s bss table entry %p: essid didn't match",
-		         dev->netdev->name, ptr);
+		         priv->netdev->name, ptr);
 	return ret;
 }
 
 
-static inline int at76_mode_matched(struct at76_priv *dev, struct bss_info *ptr)
+static inline int at76_mode_matched(struct at76_priv *priv, struct bss_info *ptr)
 {
 	int ret;
 
-	if (dev->iw_mode == IW_MODE_ADHOC)
+	if (priv->iw_mode == IW_MODE_ADHOC)
 		ret = ptr->capa & WLAN_CAPABILITY_IBSS;
 	else
 		ret = ptr->capa & WLAN_CAPABILITY_ESS;
 	if (!ret)
 		at76_dbg(DBG_BSS_MATCH, "%s bss table entry %p: mode didn't match",
-		         dev->netdev->name, ptr);
+		         priv->netdev->name, ptr);
 	return ret;
 }
 
 
-static int at76_rates_matched(struct at76_priv *dev, struct bss_info *ptr)
+static int at76_rates_matched(struct at76_priv *priv, struct bss_info *ptr)
 {
 	int i;
 	u8 *rate;
@@ -4385,27 +4385,27 @@ static int at76_rates_matched(struct at76_priv *dev, struct bss_info *ptr)
 			    && *rate != (0x80 | hw_rates[3])) {
 				at76_dbg(DBG_BSS_MATCH,
 				         "%s: bss table entry %p: basic rate %02x not supported",
-				         dev->netdev->name, ptr, *rate);
+				         priv->netdev->name, ptr, *rate);
 				return 0;
 			}
 		}
 	/* if we use short preamble, the bss must support it */
-	if (dev->preamble_type == PREAMBLE_TYPE_SHORT &&
+	if (priv->preamble_type == PREAMBLE_TYPE_SHORT &&
 	    !(ptr->capa & WLAN_CAPABILITY_SHORT_PREAMBLE)) {
 		at76_dbg(DBG_BSS_MATCH, "%s: %p does not support short preamble",
-		         dev->netdev->name, ptr);
+		         priv->netdev->name, ptr);
 		return 0;
 	} else
 		return 1;
 }
 
 
-static inline int at76_wep_matched(struct at76_priv *dev, struct bss_info *ptr)
+static inline int at76_wep_matched(struct at76_priv *priv, struct bss_info *ptr)
 {
-	if (!dev->wep_enabled && ptr->capa & WLAN_CAPABILITY_PRIVACY) {
+	if (!priv->wep_enabled && ptr->capa & WLAN_CAPABILITY_PRIVACY) {
 		/* we have disabled WEP, but the BSS signals privacy */
 		at76_dbg(DBG_BSS_MATCH, "%s: bss table entry %p: requires encryption",
-		         dev->netdev->name, ptr);
+		         priv->netdev->name, ptr);
 		return 0;
 	}
 	/* otherwise if the BSS does not signal privacy it may well
@@ -4414,15 +4414,15 @@ static inline int at76_wep_matched(struct at76_priv *dev, struct bss_info *ptr)
 }
 
 
-static inline int at76_bssid_matched(struct at76_priv *dev,
+static inline int at76_bssid_matched(struct at76_priv *priv,
 				     struct bss_info *ptr)
 {
-	if (!dev->wanted_bssid_valid ||
-	    !compare_ether_addr(ptr->bssid, dev->wanted_bssid)) {
+	if (!priv->wanted_bssid_valid ||
+	    !compare_ether_addr(ptr->bssid, priv->wanted_bssid)) {
 		return 1;
 	} else {
 		at76_dbg(DBG_BSS_MATCH, "%s: requested bssid - %s does not match",
-			 dev->netdev->name, mac2str(dev->wanted_bssid));
+			 priv->netdev->name, mac2str(priv->wanted_bssid));
 		at76_dbg(DBG_BSS_MATCH, "      AP bssid - %s of bss table entry %p",
 			 mac2str(ptr->bssid), ptr);
 		return 0;
@@ -4431,37 +4431,37 @@ static inline int at76_bssid_matched(struct at76_priv *dev,
 
 
 /**
- * at76_match_bss - try to find a matching bss in dev->bss
+ * at76_match_bss - try to find a matching bss in priv->bss
  *
  * last - last bss tried
  *
- * last == NULL signals a new round starting with dev->bss_list.next
- * this function must be called inside an acquired dev->bss_list_spinlock
+ * last == NULL signals a new round starting with priv->bss_list.next
+ * this function must be called inside an acquired priv->bss_list_spinlock
  * otherwise the timeout on bss may remove the newly chosen entry
  */
-static struct bss_info *at76_match_bss(struct at76_priv *dev,
+static struct bss_info *at76_match_bss(struct at76_priv *priv,
 				       struct bss_info *last)
 {
 	struct bss_info *ptr = NULL;
 	struct list_head *curr;
 
-	curr = last != NULL ? last->list.next : dev->bss_list.next;
-	while (curr != &dev->bss_list) {
+	curr = last != NULL ? last->list.next : priv->bss_list.next;
+	while (curr != &priv->bss_list) {
 		ptr = list_entry(curr, struct bss_info, list);
-		if (at76_essid_matched(dev, ptr) &&
-		    at76_mode_matched(dev, ptr) &&
-		    at76_wep_matched(dev, ptr) &&
-		    at76_rates_matched(dev, ptr) &&
-		    at76_bssid_matched(dev, ptr))
+		if (at76_essid_matched(priv, ptr) &&
+		    at76_mode_matched(priv, ptr) &&
+		    at76_wep_matched(priv, ptr) &&
+		    at76_rates_matched(priv, ptr) &&
+		    at76_bssid_matched(priv, ptr))
 			break;
 		curr = curr->next;
 	}
 
-	if (curr == &dev->bss_list)
+	if (curr == &priv->bss_list)
 		ptr = NULL;
 	/* otherwise ptr points to the struct bss_info we have chosen */
 
-	at76_dbg(DBG_BSS_TABLE, "%s %s: returned %p", dev->netdev->name,
+	at76_dbg(DBG_BSS_TABLE, "%s %s: returned %p", priv->netdev->name,
 	         __FUNCTION__, ptr);
 	return ptr;
 }
@@ -4470,109 +4470,109 @@ static struct bss_info *at76_match_bss(struct at76_priv *dev,
 /* Try joining a BSS */
 static void at76_work_join(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_join);
 	int ret;
 	unsigned long flags;
 
-	down(&dev->sem);
+	down(&priv->sem);
 
-	if (dev->istate == INIT)
+	if (priv->istate == INIT)
 		goto end_join;
 
-	at76_assert(dev->istate == JOINING);
-	/* dev->curr_bss == NULL signals a new round,
-	   starting with list_entry(dev->bss_list.next, ...) */
+	at76_assert(priv->istate == JOINING);
+	/* priv->curr_bss == NULL signals a new round,
+	   starting with list_entry(priv->bss_list.next, ...) */
 
-	/* secure the access to dev->curr_bss ! */
-	spin_lock_irqsave(&dev->bss_list_spinlock, flags);
-	dev->curr_bss = at76_match_bss(dev, dev->curr_bss);
-	spin_unlock_irqrestore(&dev->bss_list_spinlock, flags);
+	/* secure the access to priv->curr_bss ! */
+	spin_lock_irqsave(&priv->bss_list_spinlock, flags);
+	priv->curr_bss = at76_match_bss(priv, priv->curr_bss);
+	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 
-	if (dev->curr_bss != NULL) {
-		if ((ret = at76_join_bss(dev, dev->curr_bss)) < 0) {
+	if (priv->curr_bss != NULL) {
+		if ((ret = at76_join_bss(priv, priv->curr_bss)) < 0) {
 			err("%s: join_bss failed with %d",
-			    dev->netdev->name, ret);
+			    priv->netdev->name, ret);
 			goto end_join;
 		}
 
-		ret = at76_wait_completion(dev, CMD_JOIN);
+		ret = at76_wait_completion(priv, CMD_JOIN);
 		if (ret != CMD_STATUS_COMPLETE) {
 			if (ret != CMD_STATUS_TIME_OUT)
 				err("%s join_bss completed with %d",
-				    dev->netdev->name, ret);
+				    priv->netdev->name, ret);
 			else
 				info("%s join_bss ssid %s timed out",
-				     dev->netdev->name,
-				     mac2str(dev->curr_bss->bssid));
+				     priv->netdev->name,
+				     mac2str(priv->curr_bss->bssid));
 
 			/* retry next BSS immediately */
-			schedule_work(&dev->work_join);
+			schedule_work(&priv->work_join);
 			goto end_join;
 		}
 
 		/* here we have joined the (I)BSS */
-		if (dev->iw_mode == IW_MODE_ADHOC) {
-			struct bss_info *bptr = dev->curr_bss;
-			dev->istate = CONNECTED;
-			/* get ESSID, BSSID and channel for dev->curr_bss */
-			dev->essid_size = bptr->ssid_len;
-			memcpy(dev->essid, bptr->ssid, bptr->ssid_len);
-			memcpy(dev->bssid, bptr->bssid, ETH_ALEN);
-			dev->channel = bptr->channel;
-			at76_iwevent_bss_connect(dev->netdev, bptr->bssid);
-			netif_carrier_on(dev->netdev);
-			netif_start_queue(dev->netdev);
+		if (priv->iw_mode == IW_MODE_ADHOC) {
+			struct bss_info *bptr = priv->curr_bss;
+			priv->istate = CONNECTED;
+			/* get ESSID, BSSID and channel for priv->curr_bss */
+			priv->essid_size = bptr->ssid_len;
+			memcpy(priv->essid, bptr->ssid, bptr->ssid_len);
+			memcpy(priv->bssid, bptr->bssid, ETH_ALEN);
+			priv->channel = bptr->channel;
+			at76_iwevent_bss_connect(priv->netdev, bptr->bssid);
+			netif_carrier_on(priv->netdev);
+			netif_start_queue(priv->netdev);
 			/* just to be sure */
-			del_timer_sync(&dev->mgmt_timer);
+			del_timer_sync(&priv->mgmt_timer);
 		} else {
 			/* send auth req */
-			dev->istate = AUTHENTICATING;
-			at76_auth_req(dev, dev->curr_bss, 1, NULL);
+			priv->istate = AUTHENTICATING;
+			at76_auth_req(priv, priv->curr_bss, 1, NULL);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
 			         __FUNCTION__, __LINE__);
-			mod_timer(&dev->mgmt_timer, jiffies + HZ);
+			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 		}
 		goto end_join;
 	}
 
 	/* here we haven't found a matching (i)bss ... */
-	if (dev->iw_mode == IW_MODE_ADHOC) {
-		dev->istate = STARTIBSS;
-		schedule_work(&dev->work_start_ibss);
+	if (priv->iw_mode == IW_MODE_ADHOC) {
+		priv->istate = STARTIBSS;
+		schedule_work(&priv->work_start_ibss);
 		goto end_join;
 	}
 	/* haven't found a matching BSS in infra mode - try again */
-	dev->istate = SCANNING;
-	schedule_work(&dev->work_scan);
+	priv->istate = SCANNING;
+	schedule_work(&priv->work_scan);
 
   end_join:
-	up(&dev->sem);
+	up(&priv->sem);
 }
 
 
 static void at76_work_mgmt_timeout(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_mgmt_timeout);
 
-	down(&dev->sem);
-	at76_handle_mgmt_timeout(dev);
-	up(&dev->sem);
+	down(&priv->sem);
+	at76_handle_mgmt_timeout(priv);
+	up(&priv->sem);
 }
 
 
 static void at76_work_new_bss(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_new_bss);
 	int ret;
-	struct net_device *netdev = dev->netdev;
+	struct net_device *netdev = priv->netdev;
 	struct mib_mac_mgmt mac_mgmt;
 
-	down(&dev->sem);
+	down(&priv->sem);
 
-	ret = at76_get_mib(dev->udev, MIB_MAC_MGMT, &mac_mgmt,
+	ret = at76_get_mib(priv->udev, MIB_MAC_MGMT, &mac_mgmt,
 		      sizeof(struct mib_mac_mgmt));
 	if (ret < 0) {
 		err("%s: at76_get_mib failed: %d", netdev->name, ret);
@@ -4580,87 +4580,87 @@ static void at76_work_new_bss(struct work_struct *work)
 	}
 
 	at76_dbg(DBG_PROGRESS, "ibss_change = 0x%2x", mac_mgmt.ibss_change);
-	memcpy(dev->bssid, mac_mgmt.current_bssid, ETH_ALEN);
-	at76_dbg(DBG_PROGRESS, "using BSSID %s", mac2str(dev->bssid));
+	memcpy(priv->bssid, mac_mgmt.current_bssid, ETH_ALEN);
+	at76_dbg(DBG_PROGRESS, "using BSSID %s", mac2str(priv->bssid));
 
-	at76_iwevent_bss_connect(dev->netdev, dev->bssid);
+	at76_iwevent_bss_connect(priv->netdev, priv->bssid);
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC_MGMT;
-	dev->mib_buf.size = 1;
-	dev->mib_buf.index = IBSS_CHANGE_OK_OFFSET;
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC_MGMT;
+	priv->mib_buf.size = 1;
+	priv->mib_buf.index = IBSS_CHANGE_OK_OFFSET;
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0)
 		err("%s: set_mib (ibss change ok) failed: %d", netdev->name, ret);
 
   new_bss_clean:
-	up(&dev->sem);
+	up(&priv->sem);
 }
 
 
 static void at76_work_reset_device(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_reset_device);
 
-	down(&dev->sem);
-	usb_reset_device(dev->udev);
-	dev->istate = WAIT_FOR_DISCONNECT;
-	up(&dev->sem);
+	down(&priv->sem);
+	usb_reset_device(priv->udev);
+	priv->istate = WAIT_FOR_DISCONNECT;
+	up(&priv->sem);
 }
 
 
-static int at76_startup_device(struct at76_priv *dev)
+static int at76_startup_device(struct at76_priv *priv)
 {
-	struct at76_card_config *ccfg = &dev->card_config;
+	struct at76_card_config *ccfg = &priv->card_config;
 	int ret;
 
 	if (at76_debug & DBG_PARAMS) {
 		char ossid[IW_ESSID_MAX_SIZE + 1];
 
-		/* make dev->essid printable */
-		at76_assert(dev->essid_size <= IW_ESSID_MAX_SIZE);
-		memcpy(ossid, dev->essid, dev->essid_size);
-		ossid[dev->essid_size] = '\0';
+		/* make priv->essid printable */
+		at76_assert(priv->essid_size <= IW_ESSID_MAX_SIZE);
+		memcpy(ossid, priv->essid, priv->essid_size);
+		ossid[priv->essid_size] = '\0';
 
 		dbg("%s param: ssid %s (%s) mode %s ch %d wep %s key %d keylen %d",
-		       dev->netdev->name, ossid,
-		       hex2str(dev->obuf, dev->essid,
-			       min((int)(sizeof(dev->obuf)-1)/2,
+		       priv->netdev->name, ossid,
+		       hex2str(priv->obuf, priv->essid,
+			       min((int)(sizeof(priv->obuf)-1)/2,
 				   IW_ESSID_MAX_SIZE), '\0'),
-		       dev->iw_mode == IW_MODE_ADHOC ? "adhoc" : "infra",
-		       dev->channel,
-		       dev->wep_enabled ? "enabled" : "disabled",
-		       dev->wep_key_id, dev->wep_keys_len[dev->wep_key_id]);
+		       priv->iw_mode == IW_MODE_ADHOC ? "adhoc" : "infra",
+		       priv->channel,
+		       priv->wep_enabled ? "enabled" : "disabled",
+		       priv->wep_key_id, priv->wep_keys_len[priv->wep_key_id]);
 		dbg("%s param: preamble %s rts %d retry %d frag %d "
 		       "txrate %s auth_mode %d",
-		       dev->netdev->name,
-		       dev->preamble_type == PREAMBLE_TYPE_SHORT ? "short" : "long",
-		       dev->rts_threshold, dev->short_retry_limit,
-		       dev->frag_threshold,
-		       dev->txrate == TX_RATE_1MBIT ? "1MBit" :
-		       dev->txrate == TX_RATE_2MBIT ? "2MBit" :
-		       dev->txrate == TX_RATE_5_5MBIT ? "5.5MBit" :
-		       dev->txrate == TX_RATE_11MBIT ? "11MBit" :
-		       dev->txrate == TX_RATE_AUTO ? "auto" : "<invalid>",
-		       dev->auth_mode);
+		       priv->netdev->name,
+		       priv->preamble_type == PREAMBLE_TYPE_SHORT ? "short" : "long",
+		       priv->rts_threshold, priv->short_retry_limit,
+		       priv->frag_threshold,
+		       priv->txrate == TX_RATE_1MBIT ? "1MBit" :
+		       priv->txrate == TX_RATE_2MBIT ? "2MBit" :
+		       priv->txrate == TX_RATE_5_5MBIT ? "5.5MBit" :
+		       priv->txrate == TX_RATE_11MBIT ? "11MBit" :
+		       priv->txrate == TX_RATE_AUTO ? "auto" : "<invalid>",
+		       priv->auth_mode);
 		dbg("%s param: pm_mode %d pm_period %d auth_mode %s "
 		       "scan_times %d %d scan_mode %s international_roaming %d",
-		       dev->netdev->name,
-		       dev->pm_mode, dev->pm_period,
-		       dev->auth_mode == WLAN_AUTH_OPEN ?
+		       priv->netdev->name,
+		       priv->pm_mode, priv->pm_period,
+		       priv->auth_mode == WLAN_AUTH_OPEN ?
 		       "open" : "shared_secret",
-		       dev->scan_min_time, dev->scan_max_time,
-		       dev->scan_mode == SCAN_TYPE_ACTIVE ? "active" : "passive",
-		       dev->international_roaming);
+		       priv->scan_min_time, priv->scan_max_time,
+		       priv->scan_mode == SCAN_TYPE_ACTIVE ? "active" : "passive",
+		       priv->international_roaming);
 	}
 
 	memset(ccfg, 0, sizeof(struct at76_card_config));
 	ccfg->promiscuous_mode = 0;
-	ccfg->short_retry_limit = dev->short_retry_limit;
+	ccfg->short_retry_limit = priv->short_retry_limit;
 
-	if (dev->wep_enabled) {
-		if (dev->wep_keys_len[dev->wep_key_id] > WEP_SMALL_KEY_LEN)
+	if (priv->wep_enabled) {
+		if (priv->wep_keys_len[priv->wep_key_id] > WEP_SMALL_KEY_LEN)
 			ccfg->encryption_type = 2;
 		else
 			ccfg->encryption_type = 1;
@@ -4672,64 +4672,64 @@ static int at76_startup_device(struct at76_priv *dev)
 		ccfg->encryption_type = 0;
 	}
 
-	ccfg->rts_threshold = cpu_to_le16(dev->rts_threshold);
-	ccfg->fragmentation_threshold = cpu_to_le16(dev->frag_threshold);
+	ccfg->rts_threshold = cpu_to_le16(priv->rts_threshold);
+	ccfg->fragmentation_threshold = cpu_to_le16(priv->frag_threshold);
 
 	memcpy(ccfg->basic_rate_set, hw_rates, 4);
 	/* jal: really needed, we do a set_mib for autorate later ??? */
-	ccfg->auto_rate_fallback = (dev->txrate == TX_RATE_AUTO ? 1 : 0);
-	ccfg->channel = dev->channel;
-	ccfg->privacy_invoked = dev->wep_enabled;
-	memcpy(ccfg->current_ssid, dev->essid, IW_ESSID_MAX_SIZE);
-	ccfg->ssid_len = dev->essid_size;
+	ccfg->auto_rate_fallback = (priv->txrate == TX_RATE_AUTO ? 1 : 0);
+	ccfg->channel = priv->channel;
+	ccfg->privacy_invoked = priv->wep_enabled;
+	memcpy(ccfg->current_ssid, priv->essid, IW_ESSID_MAX_SIZE);
+	ccfg->ssid_len = priv->essid_size;
 
-	ccfg->wep_default_key_id = dev->wep_key_id;
-	memcpy(ccfg->wep_default_key_value, dev->wep_keys, 4 * WEP_KEY_LEN);
+	ccfg->wep_default_key_id = priv->wep_key_id;
+	memcpy(ccfg->wep_default_key_value, priv->wep_keys, 4 * WEP_KEY_LEN);
 
-	ccfg->short_preamble = dev->preamble_type;
-	ccfg->beacon_period = cpu_to_le16(dev->beacon_period);
+	ccfg->short_preamble = priv->preamble_type;
+	ccfg->beacon_period = cpu_to_le16(priv->beacon_period);
 
-	ret = at76_set_card_command(dev->udev, CMD_STARTUP, &dev->card_config,
+	ret = at76_set_card_command(priv->udev, CMD_STARTUP, &priv->card_config,
 			            sizeof(struct at76_card_config));
 	if (ret < 0) {
-		err("%s: at76_set_card_command failed: %d", dev->netdev->name, ret);
+		err("%s: at76_set_card_command failed: %d", priv->netdev->name, ret);
 		return ret;
 	}
 
-	at76_wait_completion(dev, CMD_STARTUP);
+	at76_wait_completion(priv, CMD_STARTUP);
 
 	/* remove BSSID from previous run */
-	memset(dev->bssid, 0, ETH_ALEN);
+	memset(priv->bssid, 0, ETH_ALEN);
 
-	if (at76_set_radio(dev, 1) == 1)
-		at76_wait_completion(dev, CMD_RADIO);
+	if (at76_set_radio(priv, 1) == 1)
+		at76_wait_completion(priv, CMD_RADIO);
 
-	if ((ret = at76_set_preamble(dev, dev->preamble_type)) < 0)
+	if ((ret = at76_set_preamble(priv, priv->preamble_type)) < 0)
 		return ret;
 
-	if ((ret = at76_set_frag(dev, dev->frag_threshold)) < 0)
+	if ((ret = at76_set_frag(priv, priv->frag_threshold)) < 0)
 		return ret;
 
-	if ((ret = at76_set_rts(dev, dev->rts_threshold)) < 0)
+	if ((ret = at76_set_rts(priv, priv->rts_threshold)) < 0)
 		return ret;
 
-	if ((ret = at76_set_autorate_fallback(dev, dev->txrate == TX_RATE_AUTO ? 1 : 0)) < 0)
+	if ((ret = at76_set_autorate_fallback(priv, priv->txrate == TX_RATE_AUTO ? 1 : 0)) < 0)
 		return ret;
 
-	if ((ret = at76_set_pm_mode(dev)) < 0)
+	if ((ret = at76_set_pm_mode(priv)) < 0)
 		return ret;
 
-	if ((ret = at76_set_iroaming(dev, dev->international_roaming)) < 0)
+	if ((ret = at76_set_iroaming(priv, priv->international_roaming)) < 0)
 		return ret;
 
 	if (at76_debug & DBG_MIB) {
-		at76_dump_mib_mac(dev);
-		at76_dump_mib_mac_addr(dev);
-		at76_dump_mib_mac_mgmt(dev);
-		at76_dump_mib_mac_wep(dev);
-		at76_dump_mib_mdomain(dev);
-		at76_dump_mib_phy(dev);
-		at76_dump_mib_local(dev);
+		at76_dump_mib_mac(priv);
+		at76_dump_mib_mac_addr(priv);
+		at76_dump_mib_mac_mgmt(priv);
+		at76_dump_mib_mac_wep(priv);
+		at76_dump_mib_mdomain(priv);
+		at76_dump_mib_phy(priv);
+		at76_dump_mib_local(priv);
 	}
 
 	return 0;
@@ -4737,164 +4737,164 @@ static int at76_startup_device(struct at76_priv *dev)
 
 
 /**
- * set_monitor_mode - sets dev->netdev->type
+ * set_monitor_mode - sets priv->netdev->type
  */
-static void at76_set_monitor_mode(struct at76_priv *dev)
+static void at76_set_monitor_mode(struct at76_priv *priv)
 {
-	if (dev->iw_mode == IW_MODE_MONITOR) {
+	if (priv->iw_mode == IW_MODE_MONITOR) {
 		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE ON",
-			 dev->netdev->name);
-		dev->netdev->type = ARPHRD_IEEE80211_RADIOTAP;
+			 priv->netdev->name);
+		priv->netdev->type = ARPHRD_IEEE80211_RADIOTAP;
 	} else {
 		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE OFF",
-		         dev->netdev->name);
-		dev->netdev->type = ARPHRD_ETHER;
+		         priv->netdev->name);
+		priv->netdev->type = ARPHRD_ETHER;
 	}
 }
 
 
 static void at76_work_restart(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_restart);
 
-	down(&dev->sem);
+	down(&priv->sem);
 
-	at76_startup_device(dev);
-	at76_set_monitor_mode(dev);
+	at76_startup_device(priv);
+	at76_set_monitor_mode(priv);
 
-	netif_carrier_off(dev->netdev);	/* disable running netdev watchdog */
-	netif_stop_queue(dev->netdev);	/* stop tx data packets */
-	if (dev->iw_mode != IW_MODE_MONITOR) {
-		dev->istate = SCANNING;
-		schedule_work(&dev->work_scan);
+	netif_carrier_off(priv->netdev);	/* disable running netdev watchdog */
+	netif_stop_queue(priv->netdev);	/* stop tx data packets */
+	if (priv->iw_mode != IW_MODE_MONITOR) {
+		priv->istate = SCANNING;
+		schedule_work(&priv->work_scan);
 	} else {
-		dev->istate = MONITORING;
-		at76_start_scan(dev, 0, 0);
+		priv->istate = MONITORING;
+		at76_start_scan(priv, 0, 0);
 		at76_dbg(DBG_MGMT_TIMER,
 		         "%s:%d: starting mgmt_timer for %d ticks",
 		         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-		mod_timer(&dev->mgmt_timer,
+		mod_timer(&priv->mgmt_timer,
 			  jiffies + SCAN_POLL_INTERVAL);
 	}
 
-	up(&dev->sem);
+	up(&priv->sem);
 }
 
 
 static void at76_work_scan(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_scan);
 	int ret;
 
-	down(&dev->sem);
+	down(&priv->sem);
 
-	at76_assert(dev->istate == SCANNING);
+	at76_assert(priv->istate == SCANNING);
 	/* only clear the bss list when a scan is actively initiated,
 	 * otherwise simply rely on at76_bss_list_timeout */
-	if (dev->scan_state == SCAN_IN_PROGRESS)
-		at76_free_bss_list(dev);
+	if (priv->scan_state == SCAN_IN_PROGRESS)
+		at76_free_bss_list(priv);
 
-	dev->scan_runs = 2;
-	if ((ret = at76_start_scan(dev, 0, 1)) < 0) {
+	priv->scan_runs = 2;
+	if ((ret = at76_start_scan(priv, 0, 1)) < 0) {
 		err("%s: %s: start_scan failed with %d",
-		    dev->netdev->name, __FUNCTION__, ret);
+		    priv->netdev->name, __FUNCTION__, ret);
 	} else {
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer for %d ticks",
 		         __FUNCTION__, __LINE__, SCAN_POLL_INTERVAL);
-		mod_timer(&dev->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
+		mod_timer(&priv->mgmt_timer, jiffies + SCAN_POLL_INTERVAL);
 	}
 
-	up(&dev->sem);
+	up(&priv->sem);
 }
 
 
 static void at76_work_set_promisc(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_set_promisc);
 	int ret = 0;
 
-	down(&dev->sem);
+	down(&priv->sem);
 
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_LOCAL;
-	dev->mib_buf.size = 1;
-	dev->mib_buf.index = offsetof(struct mib_local, promiscuous_mode);
-	dev->mib_buf.data[0] = dev->promisc ? 1 : 0;
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_LOCAL;
+	priv->mib_buf.size = 1;
+	priv->mib_buf.index = offsetof(struct mib_local, promiscuous_mode);
+	priv->mib_buf.data[0] = priv->promisc ? 1 : 0;
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
 		err("%s: set_mib (promiscuous_mode) failed: %d",
-		    dev->netdev->name, ret);
+		    priv->netdev->name, ret);
 	}
 
-	up(&dev->sem);
+	up(&priv->sem);
 }
 
 
 static void at76_work_start_ibss(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_start_ibss);
 	int ret;
 
-	down(&dev->sem);
+	down(&priv->sem);
 
-	at76_assert(dev->istate == STARTIBSS);
-	ret = at76_start_ibss(dev);
+	at76_assert(priv->istate == STARTIBSS);
+	ret = at76_start_ibss(priv);
 	if (ret < 0) {
-		err("%s: start_ibss failed: %d", dev->netdev->name, ret);
+		err("%s: start_ibss failed: %d", priv->netdev->name, ret);
 		goto end_startibss;
 	}
 
-	ret = at76_wait_completion(dev, CMD_START_IBSS);
+	ret = at76_wait_completion(priv, CMD_START_IBSS);
 	if (ret != CMD_STATUS_COMPLETE) {
 		err("%s start_ibss failed to complete,%d",
-		    dev->netdev->name, ret);
+		    priv->netdev->name, ret);
 		goto end_startibss;
 	}
 
-	ret = at76_get_current_bssid(dev);
+	ret = at76_get_current_bssid(priv);
 	if (ret < 0)
 		goto end_startibss;
 
-	ret = at76_get_current_channel(dev);
+	ret = at76_get_current_channel(priv);
 	if (ret < 0)
 		goto end_startibss;
 
 	/* not sure what this is good for ??? */
-	memset(&dev->mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev->mib_buf.type = MIB_MAC_MGMT;
-	dev->mib_buf.size = 1;
-	dev->mib_buf.index = IBSS_CHANGE_OK_OFFSET;
-	ret = at76_set_mib(dev, &dev->mib_buf);
+	memset(&priv->mib_buf, 0, sizeof(struct set_mib_buffer));
+	priv->mib_buf.type = MIB_MAC_MGMT;
+	priv->mib_buf.size = 1;
+	priv->mib_buf.index = IBSS_CHANGE_OK_OFFSET;
+	ret = at76_set_mib(priv, &priv->mib_buf);
 	if (ret < 0) {
-		err("%s: set_mib (ibss change ok) failed: %d", dev->netdev->name, ret);
+		err("%s: set_mib (ibss change ok) failed: %d", priv->netdev->name, ret);
 		goto end_startibss;
 	}
 
-	netif_carrier_on(dev->netdev);
-	netif_start_queue(dev->netdev);
+	netif_carrier_on(priv->netdev);
+	netif_start_queue(priv->netdev);
 
   end_startibss:
-	up(&dev->sem);
+	up(&priv->sem);
 }
 
 
 static void at76_work_submit_rx(struct work_struct *work)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
+	struct at76_priv *priv = container_of(work, struct at76_priv,
 					     work_submit_rx);
 
-	down(&dev->sem);
-	at76_submit_rx_urb(dev);
-	up(&dev->sem);
+	down(&priv->sem);
+	at76_submit_rx_urb(priv);
+	up(&priv->sem);
 }
 
 
 /* we got an association response */
-static void at76_rx_mgmt_assoc(struct at76_priv *dev,
+static void at76_rx_mgmt_assoc(struct at76_priv *priv,
 			       struct at76_rx_buffer *buf)
 {
 	struct ieee80211_assoc_response *resp =
@@ -4905,36 +4905,36 @@ static void at76_rx_mgmt_assoc(struct at76_priv *dev,
 	u16 capa = le16_to_cpu(resp->capability);
 	at76_dbg(DBG_RX_MGMT, "%s: rx AssocResp bssid %s capa x%04x status x%04x "
 	         "assoc_id x%04x rates %s",
-	    dev->netdev->name, mac2str(mgmt->addr3), capa, status, assoc_id,
-	    hex2str(dev->obuf, resp->info_element->data,
-		    min((size_t)resp->info_element->len, (sizeof(dev->obuf)-1)/2), '\0'));
-	if (dev->istate == ASSOCIATING) {
-		at76_assert(dev->curr_bss != NULL);
-		if (dev->curr_bss == NULL)
+	    priv->netdev->name, mac2str(mgmt->addr3), capa, status, assoc_id,
+	    hex2str(priv->obuf, resp->info_element->data,
+		    min((size_t)resp->info_element->len, (sizeof(priv->obuf)-1)/2), '\0'));
+	if (priv->istate == ASSOCIATING) {
+		at76_assert(priv->curr_bss != NULL);
+		if (priv->curr_bss == NULL)
 			return;
 
 		if (status == WLAN_STATUS_SUCCESS) {
-			struct bss_info *ptr = dev->curr_bss;
+			struct bss_info *ptr = priv->curr_bss;
 			ptr->assoc_id = assoc_id & 0x3fff;
 			/* update iwconfig params */
-			memcpy(dev->bssid, ptr->bssid, ETH_ALEN);
-			memcpy(dev->essid, ptr->ssid, ptr->ssid_len);
-			dev->essid_size = ptr->ssid_len;
-			dev->channel = ptr->channel;
-			schedule_work(&dev->work_assoc_done);
+			memcpy(priv->bssid, ptr->bssid, ETH_ALEN);
+			memcpy(priv->essid, ptr->ssid, ptr->ssid_len);
+			priv->essid_size = ptr->ssid_len;
+			priv->channel = ptr->channel;
+			schedule_work(&priv->work_assoc_done);
 		} else {
-			dev->istate = JOINING;
-			schedule_work(&dev->work_join);
+			priv->istate = JOINING;
+			schedule_work(&priv->work_join);
 		}
-		del_timer_sync(&dev->mgmt_timer);
+		del_timer_sync(&priv->mgmt_timer);
 	} else {
 		info("%s: AssocResp in state %d ignored",
-		     dev->netdev->name, dev->istate);
+		     priv->netdev->name, priv->istate);
 	}
 }
 
 
-static void at76_rx_mgmt_reassoc(struct at76_priv *dev,
+static void at76_rx_mgmt_reassoc(struct at76_priv *priv,
 				 struct at76_rx_buffer *buf)
 {
 	struct ieee80211_assoc_response *resp =
@@ -4947,48 +4947,48 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *dev,
 
 	at76_dbg(DBG_RX_MGMT, "%s: rx ReAssocResp bssid %s capa x%04x status x%04x "
 	         "assoc_id x%04x rates %s",
-	         dev->netdev->name, mac2str(mgmt->addr3), capa, status, assoc_id,
-	         hex2str(dev->obuf, resp->info_element->data,
+	         priv->netdev->name, mac2str(mgmt->addr3), capa, status, assoc_id,
+	         hex2str(priv->obuf, resp->info_element->data,
 		    min((size_t) resp->info_element->len,
-			(sizeof(dev->obuf) - 1) / 2), '\0'));
-	if (dev->istate == REASSOCIATING) {
-		at76_assert(dev->new_bss != NULL);
-		if (dev->new_bss == NULL)
+			(sizeof(priv->obuf) - 1) / 2), '\0'));
+	if (priv->istate == REASSOCIATING) {
+		at76_assert(priv->new_bss != NULL);
+		if (priv->new_bss == NULL)
 			return;
 
 		if (status == WLAN_STATUS_SUCCESS) {
-			struct bss_info *bptr = dev->new_bss;
+			struct bss_info *bptr = priv->new_bss;
 			bptr->assoc_id = assoc_id;
-			dev->istate = CONNECTED;
+			priv->istate = CONNECTED;
 
-			at76_iwevent_bss_connect(dev->netdev, bptr->bssid);
+			at76_iwevent_bss_connect(priv->netdev, bptr->bssid);
 
-			spin_lock_irqsave(&dev->bss_list_spinlock, flags);
-			dev->curr_bss = dev->new_bss;
-			dev->new_bss = NULL;
-			spin_unlock_irqrestore(&dev->bss_list_spinlock, flags);
+			spin_lock_irqsave(&priv->bss_list_spinlock, flags);
+			priv->curr_bss = priv->new_bss;
+			priv->new_bss = NULL;
+			spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 
-			/* get ESSID, BSSID and channel for dev->curr_bss */
-			dev->essid_size = bptr->ssid_len;
-			memcpy(dev->essid, bptr->ssid, bptr->ssid_len);
-			memcpy(dev->bssid, bptr->bssid, ETH_ALEN);
-			dev->channel = bptr->channel;
+			/* get ESSID, BSSID and channel for priv->curr_bss */
+			priv->essid_size = bptr->ssid_len;
+			memcpy(priv->essid, bptr->ssid, bptr->ssid_len);
+			memcpy(priv->bssid, bptr->bssid, ETH_ALEN);
+			priv->channel = bptr->channel;
 			at76_dbg(DBG_PROGRESS, "%s: reassociated to BSSID %s",
-			         dev->netdev->name, mac2str(dev->bssid));
-			schedule_work(&dev->work_assoc_done);
+			         priv->netdev->name, mac2str(priv->bssid));
+			schedule_work(&priv->work_assoc_done);
 		} else {
-			del_timer_sync(&dev->mgmt_timer);
-			dev->istate = JOINING;
-			schedule_work(&dev->work_join);
+			del_timer_sync(&priv->mgmt_timer);
+			priv->istate = JOINING;
+			schedule_work(&priv->work_join);
 		}
 	} else {
 		info("%s: ReAssocResp in state %d ignored",
-		     dev->netdev->name, dev->istate);
+		     priv->netdev->name, priv->istate);
 	}
 }
 
 
-static void at76_rx_mgmt_disassoc(struct at76_priv *dev,
+static void at76_rx_mgmt_disassoc(struct at76_priv *priv,
 				  struct at76_rx_buffer *buf)
 {
 	struct ieee80211_disassoc *resp =
@@ -4996,51 +4996,51 @@ static void at76_rx_mgmt_disassoc(struct at76_priv *dev,
 	struct ieee80211_hdr_3addr *mgmt = &resp->header;
 
 	at76_dbg(DBG_RX_MGMT, "%s: rx DisAssoc bssid %s reason x%04x destination %s",
-	         dev->netdev->name, mac2str(mgmt->addr3),
+	         priv->netdev->name, mac2str(mgmt->addr3),
 	         le16_to_cpu(resp->reason),
-	         hex2str(dev->obuf, mgmt->addr1,
-		    min((int)sizeof(dev->obuf) / 3, ETH_ALEN), ':'));
-	if (dev->istate == SCANNING || dev->istate == INIT)
+	         hex2str(priv->obuf, mgmt->addr1,
+		    min((int)sizeof(priv->obuf) / 3, ETH_ALEN), ':'));
+	if (priv->istate == SCANNING || priv->istate == INIT)
 		return;
 
-	at76_assert(dev->curr_bss != NULL);
-	if (dev->curr_bss == NULL)
+	at76_assert(priv->curr_bss != NULL);
+	if (priv->curr_bss == NULL)
 		return;
-	if (dev->istate == REASSOCIATING) {
-		at76_assert(dev->new_bss != NULL);
-		if (dev->new_bss == NULL)
+	if (priv->istate == REASSOCIATING) {
+		at76_assert(priv->new_bss != NULL);
+		if (priv->new_bss == NULL)
 			return;
 	}
-	if (!compare_ether_addr(mgmt->addr3, dev->curr_bss->bssid) &&
-	    (!compare_ether_addr(dev->netdev->dev_addr, mgmt->addr1) ||
+	if (!compare_ether_addr(mgmt->addr3, priv->curr_bss->bssid) &&
+	    (!compare_ether_addr(priv->netdev->dev_addr, mgmt->addr1) ||
 	     is_broadcast_ether_addr(mgmt->addr1))) {
 		/* this is a DisAssoc from the BSS we are connected or
 		   trying to connect to, directed to us or broadcasted */
 		/* jal: TODO: can the DisAssoc also come from the BSS
-		   we've sent a ReAssocReq to (i.e. from dev->new_bss) ? */
-		if (dev->istate == DISASSOCIATING ||
-		    dev->istate == ASSOCIATING ||
-		    dev->istate == REASSOCIATING ||
-		    dev->istate == CONNECTED || dev->istate == JOINING) {
-			if (dev->istate == CONNECTED) {
-				netif_carrier_off(dev->netdev);
-				netif_stop_queue(dev->netdev);
-				at76_iwevent_bss_disconnect(dev->netdev);
+		   we've sent a ReAssocReq to (i.e. from priv->new_bss) ? */
+		if (priv->istate == DISASSOCIATING ||
+		    priv->istate == ASSOCIATING ||
+		    priv->istate == REASSOCIATING ||
+		    priv->istate == CONNECTED || priv->istate == JOINING) {
+			if (priv->istate == CONNECTED) {
+				netif_carrier_off(priv->netdev);
+				netif_stop_queue(priv->netdev);
+				at76_iwevent_bss_disconnect(priv->netdev);
 			}
-			del_timer_sync(&dev->mgmt_timer);
-			dev->istate = JOINING;
-			schedule_work(&dev->work_join);
+			del_timer_sync(&priv->mgmt_timer);
+			priv->istate = JOINING;
+			schedule_work(&priv->work_join);
 		} else {
 			/* ignore DisAssoc in states AUTH, ASSOC */
 			info("%s: DisAssoc in state %d ignored",
-			     dev->netdev->name, dev->istate);
+			     priv->netdev->name, priv->istate);
 		}
 	}
 	/* ignore DisAssoc to other STA or from other BSSID */
 }
 
 
-static void at76_rx_mgmt_auth(struct at76_priv *dev, struct at76_rx_buffer *buf)
+static void at76_rx_mgmt_auth(struct at76_priv *priv, struct at76_rx_buffer *buf)
 {
 	struct ieee80211_auth *resp = (struct ieee80211_auth *)buf->packet;
 	struct ieee80211_hdr_3addr *mgmt = &resp->header;
@@ -5050,65 +5050,65 @@ static void at76_rx_mgmt_auth(struct at76_priv *dev, struct at76_rx_buffer *buf)
 
 	at76_dbg(DBG_RX_MGMT, "%s: rx AuthFrame bssid %s alg %d seq_nr %d status %d "
 	         "destination %s",
-	         dev->netdev->name, mac2str(mgmt->addr3),
+	         priv->netdev->name, mac2str(mgmt->addr3),
 	         alg, seq_nr, status,
-	         hex2str(dev->obuf, mgmt->addr1,
-		    min((int)sizeof(dev->obuf) / 3, ETH_ALEN), ':'));
+	         hex2str(priv->obuf, mgmt->addr1,
+		    min((int)sizeof(priv->obuf) / 3, ETH_ALEN), ':'));
 
 	if (alg == WLAN_AUTH_SHARED_KEY && seq_nr == 2) {
 		at76_dbg(DBG_RX_MGMT, "%s: AuthFrame challenge %s ...",
-		         dev->netdev->name,
-		         hex2str(dev->obuf, resp->info_element,
-			    min((int)sizeof(dev->obuf) / 3, 18), ' '));
+		         priv->netdev->name,
+		         hex2str(priv->obuf, resp->info_element,
+			    min((int)sizeof(priv->obuf) / 3, 18), ' '));
 	}
-	if (dev->istate != AUTHENTICATING) {
+	if (priv->istate != AUTHENTICATING) {
 		info("%s: ignored AuthFrame in state %d",
-		     dev->netdev->name, dev->istate);
+		     priv->netdev->name, priv->istate);
 		return;
 	}
-	if (dev->auth_mode != alg) {
+	if (priv->auth_mode != alg) {
 		info("%s: ignored AuthFrame for alg %d",
-		     dev->netdev->name, alg);
+		     priv->netdev->name, alg);
 		return;
 	}
 
-	at76_assert(dev->curr_bss != NULL);
-	if (dev->curr_bss == NULL)
+	at76_assert(priv->curr_bss != NULL);
+	if (priv->curr_bss == NULL)
 		return;
 
-	if (!compare_ether_addr(mgmt->addr3, dev->curr_bss->bssid) &&
-	    !compare_ether_addr(dev->netdev->dev_addr, mgmt->addr1)) {
+	if (!compare_ether_addr(mgmt->addr3, priv->curr_bss->bssid) &&
+	    !compare_ether_addr(priv->netdev->dev_addr, mgmt->addr1)) {
 		/* this is a AuthFrame from the BSS we are connected or
 		   trying to connect to, directed to us */
 		if (status != WLAN_STATUS_SUCCESS) {
-			del_timer_sync(&dev->mgmt_timer);
+			del_timer_sync(&priv->mgmt_timer);
 			/* try to join next bss */
-			dev->istate = JOINING;
-			schedule_work(&dev->work_join);
+			priv->istate = JOINING;
+			schedule_work(&priv->work_join);
 			return;
 		}
 
-		if (dev->auth_mode == WLAN_AUTH_OPEN || seq_nr == 4) {
-			dev->retries = ASSOC_RETRIES;
-			dev->istate = ASSOCIATING;
-			at76_assoc_req(dev, dev->curr_bss);
+		if (priv->auth_mode == WLAN_AUTH_OPEN || seq_nr == 4) {
+			priv->retries = ASSOC_RETRIES;
+			priv->istate = ASSOCIATING;
+			at76_assoc_req(priv, priv->curr_bss);
 			at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
 			         __FUNCTION__, __LINE__);
-			mod_timer(&dev->mgmt_timer, jiffies + HZ);
+			mod_timer(&priv->mgmt_timer, jiffies + HZ);
 			return;
 		}
 
 		at76_assert(seq_nr == 2);
-		at76_auth_req(dev, dev->curr_bss, seq_nr + 1, resp->info_element);
+		at76_auth_req(priv, priv->curr_bss, seq_nr + 1, resp->info_element);
 		at76_dbg(DBG_MGMT_TIMER, "%s:%d: starting mgmt_timer + HZ",
 		         __FUNCTION__, __LINE__);
-		mod_timer(&dev->mgmt_timer, jiffies + HZ);
+		mod_timer(&priv->mgmt_timer, jiffies + HZ);
 	}
 	/* else: ignore AuthFrames to other recipients */
 }
 
 
-static void at76_rx_mgmt_deauth(struct at76_priv *dev,
+static void at76_rx_mgmt_deauth(struct at76_priv *priv,
 				struct at76_rx_buffer *buf)
 {
 	struct ieee80211_disassoc *resp =
@@ -5117,41 +5117,41 @@ static void at76_rx_mgmt_deauth(struct at76_priv *dev,
 
 	at76_dbg(DBG_RX_MGMT | DBG_PROGRESS,
 	         "%s: rx DeAuth bssid %s reason x%04x destination %s",
-	         dev->netdev->name, mac2str(mgmt->addr3),
+	         priv->netdev->name, mac2str(mgmt->addr3),
 	         le16_to_cpu(resp->reason),
-	         hex2str(dev->obuf, mgmt->addr1,
-		    min((int)sizeof(dev->obuf) / 3, ETH_ALEN), ':'));
-	if (dev->istate == DISASSOCIATING ||
-	    dev->istate == AUTHENTICATING ||
-	    dev->istate == ASSOCIATING ||
-	    dev->istate == REASSOCIATING  ||
-	    dev->istate == CONNECTED) {
-		at76_assert(dev->curr_bss != NULL);
-		if (dev->curr_bss == NULL)
+	         hex2str(priv->obuf, mgmt->addr1,
+		    min((int)sizeof(priv->obuf) / 3, ETH_ALEN), ':'));
+	if (priv->istate == DISASSOCIATING ||
+	    priv->istate == AUTHENTICATING ||
+	    priv->istate == ASSOCIATING ||
+	    priv->istate == REASSOCIATING  ||
+	    priv->istate == CONNECTED) {
+		at76_assert(priv->curr_bss != NULL);
+		if (priv->curr_bss == NULL)
 			return;
 
-		if (!compare_ether_addr(mgmt->addr3, dev->curr_bss->bssid) &&
-		    (!compare_ether_addr(dev->netdev->dev_addr, mgmt->addr1) ||
+		if (!compare_ether_addr(mgmt->addr3, priv->curr_bss->bssid) &&
+		    (!compare_ether_addr(priv->netdev->dev_addr, mgmt->addr1) ||
 		     is_broadcast_ether_addr(mgmt->addr1))) {
 			/* this is a DeAuth from the BSS we are connected or
 			   trying to connect to, directed to us or broadcasted */
-			if (dev->istate == CONNECTED) {
-				at76_iwevent_bss_disconnect(dev->netdev);
+			if (priv->istate == CONNECTED) {
+				at76_iwevent_bss_disconnect(priv->netdev);
 			}
-			dev->istate = JOINING;
-			schedule_work(&dev->work_join);
-			del_timer_sync(&dev->mgmt_timer);
+			priv->istate = JOINING;
+			schedule_work(&priv->work_join);
+			del_timer_sync(&priv->mgmt_timer);
 		}
 		/* ignore DeAuth to other STA or from other BSSID */
 	} else {
 		/* ignore DeAuth in states SCANNING */
 		info("%s: DeAuth in state %d ignored",
-		     dev->netdev->name, dev->istate);
+		     priv->netdev->name, priv->istate);
 	}
 }
 
 
-static void at76_rx_mgmt_beacon(struct at76_priv *dev,
+static void at76_rx_mgmt_beacon(struct at76_priv *priv,
 				struct at76_rx_buffer *buf)
 {
 	/* beacon content */
@@ -5174,17 +5174,17 @@ static void at76_rx_mgmt_beacon(struct at76_priv *dev,
 	int keep_going = 1;
 	unsigned long flags;
 
-	spin_lock_irqsave(&dev->bss_list_spinlock, flags);
-	if (dev->istate == CONNECTED) {
+	spin_lock_irqsave(&priv->bss_list_spinlock, flags);
+	if (priv->istate == CONNECTED) {
 		/* in state CONNECTED we use the mgmt_timer to control
 		   the beacon of the BSS */
-		at76_assert(dev->curr_bss != NULL);
-		if (dev->curr_bss == NULL)
+		at76_assert(priv->curr_bss != NULL);
+		if (priv->curr_bss == NULL)
 			goto rx_mgmt_beacon_end;
-		if (!compare_ether_addr(dev->curr_bss->bssid, mgmt->addr3)) {
-			mod_timer(&dev->mgmt_timer, jiffies+BEACON_TIMEOUT*HZ);
-			dev->curr_bss->rssi = buf->rssi;
-			dev->beacons_received++;
+		if (!compare_ether_addr(priv->curr_bss->bssid, mgmt->addr3)) {
+			mod_timer(&priv->mgmt_timer, jiffies+BEACON_TIMEOUT*HZ);
+			priv->curr_bss->rssi = buf->rssi;
+			priv->beacons_received++;
 			goto rx_mgmt_beacon_end;
 		}
 	}
@@ -5192,8 +5192,8 @@ static void at76_rx_mgmt_beacon(struct at76_priv *dev,
 	/* look if we have this BSS already in the list */
 	match = NULL;
 
-	if (!list_empty(&dev->bss_list)) {
-		list_for_each(lptr, &dev->bss_list) {
+	if (!list_empty(&priv->bss_list)) {
+		list_for_each(lptr, &priv->bss_list) {
 			struct bss_info *bss_ptr =
 			    list_entry(lptr, struct bss_info, list);
 			if (!compare_ether_addr(bss_ptr->bssid, mgmt->addr3)) {
@@ -5207,13 +5207,13 @@ static void at76_rx_mgmt_beacon(struct at76_priv *dev,
 		/* haven't found the bss in the list */
 		if ((match=kmalloc(sizeof(struct bss_info), GFP_ATOMIC)) == NULL) {
 			at76_dbg(DBG_BSS_TABLE, "%s: cannot kmalloc new bss info (%zd byte)",
-		          	    dev->netdev->name, sizeof(struct bss_info));
+		          	    priv->netdev->name, sizeof(struct bss_info));
 			goto rx_mgmt_beacon_end;
 		}
 		memset(match, 0, sizeof(*match));
 		new_entry = 1;
 		/* append new struct into list */
-		list_add_tail(&match->list, &dev->bss_list);
+		list_add_tail(&match->list, &priv->bss_list);
 	}
 
 	/* we either overwrite an existing entry or append a new one
@@ -5228,7 +5228,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *dev,
 	match->link_qual = buf->link_quality;
 	match->noise_level = buf->noise_level;
 	memcpy(match->bssid, mgmt->addr3, ETH_ALEN);
-	at76_dbg(DBG_RX_BEACON, "%s: bssid %s", dev->netdev->name,
+	at76_dbg(DBG_RX_BEACON, "%s: bssid %s", priv->netdev->name,
 	         mac2str(match->bssid));
 
 	tlv = bdata->info_element;
@@ -5268,7 +5268,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *dev,
 								   string for
 								   printing */
 				at76_dbg(DBG_RX_BEACON, "%s: SSID - %s",
-				         dev->netdev->name, match->ssid);
+				         priv->netdev->name, match->ssid);
 			}
 			have_ssid = 1;
 			break;
@@ -5282,9 +5282,9 @@ static void at76_rx_mgmt_beacon(struct at76_priv *dev,
 				have_rates = 1;
 				at76_dbg(DBG_RX_BEACON,
 				         "%s: SUPPORTED RATES %s",
-				         dev->netdev->name,
-				         hex2str(dev->obuf, tlv->data,
-					    min_t(int, (sizeof(dev->obuf)-1)/2,
+				         priv->netdev->name,
+				         hex2str(priv->obuf, tlv->data,
+					    min_t(int, (sizeof(priv->obuf)-1)/2,
 						  tlv->len), '\0'));
 			}
 			break;
@@ -5294,7 +5294,7 @@ static void at76_rx_mgmt_beacon(struct at76_priv *dev,
 				match->channel = tlv->data[0];
 				have_channel = 1;
 				at76_dbg(DBG_RX_BEACON, "%s: CHANNEL - %d",
-				         dev->netdev->name, match->channel);
+				         priv->netdev->name, match->channel);
 			}
 			break;
 
@@ -5303,9 +5303,9 @@ static void at76_rx_mgmt_beacon(struct at76_priv *dev,
 		case MFIE_TYPE_IBSS_SET:
 		default:
 			at76_dbg(DBG_RX_BEACON, "%s: beacon IE id %d len %d %s",
-			         dev->netdev->name, tlv->id, tlv->len,
-			         hex2str(dev->obuf, tlv->data,
-				    min_t(int, (sizeof(dev->obuf)-1)/2,
+			         priv->netdev->name, tlv->id, tlv->len,
+			         hex2str(priv->obuf, tlv->data,
+				    min_t(int, (sizeof(priv->obuf)-1)/2,
 					  tlv->len), '\0'));
 			break;
 		}
@@ -5323,17 +5323,17 @@ static void at76_rx_mgmt_beacon(struct at76_priv *dev,
 	}
 
 	at76_dbg(DBG_RX_BEACON, "%s: Finished processing beacon data",
-	         dev->netdev->name);
+	         priv->netdev->name);
 
 	match->last_rx = jiffies; /* record last rx of beacon */
 
 rx_mgmt_beacon_end:
-	spin_unlock_irqrestore(&dev->bss_list_spinlock, flags);
+	spin_unlock_irqrestore(&priv->bss_list_spinlock, flags);
 }
 
 
 /* calc the link level from a given rx_buffer */
-static void at76_calc_level(struct at76_priv *dev, struct at76_rx_buffer *buf,
+static void at76_calc_level(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			    struct iw_quality *qual)
 {
 	int max_rssi = 42;	/* just a guess for now, might be different for other chips */
@@ -5346,25 +5346,25 @@ static void at76_calc_level(struct at76_priv *dev, struct at76_rx_buffer *buf,
 
 
 /* calc the link quality from a given rx_buffer */
-static void at76_calc_qual(struct at76_priv *dev, struct at76_rx_buffer *buf,
+static void at76_calc_qual(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			   struct iw_quality* qual)
 {
-	if ((dev->board_type == BOARDTYPE_503_INTERSIL_3861) ||
-	    (dev->board_type == BOARDTYPE_503_INTERSIL_3863)) {
+	if ((priv->board_type == BOARDTYPE_503_INTERSIL_3861) ||
+	    (priv->board_type == BOARDTYPE_503_INTERSIL_3863)) {
 		qual->qual = buf->link_quality;
 	} else {
 		unsigned long msec;
 
 		/* Update qual at most once a second */
-		msec = jiffies_to_msecs(jiffies) - dev->beacons_last_qual;
+		msec = jiffies_to_msecs(jiffies) - priv->beacons_last_qual;
 		if (msec < 1000)
 			return;
 
-		qual->qual = qual->level * dev->beacons_received *
-		    dev->beacon_period / msec;
+		qual->qual = qual->level * priv->beacons_received *
+		    priv->beacon_period / msec;
 
-		dev->beacons_last_qual = jiffies_to_msecs(jiffies);
-		dev->beacons_received = 0;
+		priv->beacons_last_qual = jiffies_to_msecs(jiffies);
+		priv->beacons_received = 0;
 	}
 	qual->qual = (qual->qual > 100) ? 100 : qual->qual;
 	qual->updated |= IW_QUAL_QUAL_UPDATED;
@@ -5372,7 +5372,7 @@ static void at76_calc_qual(struct at76_priv *dev, struct at76_rx_buffer *buf,
 
 
 /* calc the noise quality from a given rx_buffer */
-static void at76_calc_noise(struct at76_priv *dev, struct at76_rx_buffer *buf,
+static void at76_calc_noise(struct at76_priv *priv, struct at76_rx_buffer *buf,
 			    struct iw_quality *qual)
 {
 	qual->noise = 0;
@@ -5380,16 +5380,16 @@ static void at76_calc_noise(struct at76_priv *dev, struct at76_rx_buffer *buf,
 }
 
 
-static void at76_update_wstats(struct at76_priv *dev,
+static void at76_update_wstats(struct at76_priv *priv,
 			       struct at76_rx_buffer *buf)
 {
-	struct iw_quality *qual = &dev->wstats.qual;
+	struct iw_quality *qual = &priv->wstats.qual;
 
-	if (buf->rssi && dev->istate == CONNECTED) {
+	if (buf->rssi && priv->istate == CONNECTED) {
 		qual->updated = 0;
-		at76_calc_level(dev, buf, qual);
-		at76_calc_qual(dev, buf, qual);
-		at76_calc_noise(dev, buf, qual);
+		at76_calc_level(priv, buf, qual);
+		at76_calc_qual(priv, buf, qual);
+		at76_calc_noise(priv, buf, qual);
 	} else {
 		qual->qual = 0;
 		qual->level = 0;
@@ -5399,60 +5399,60 @@ static void at76_update_wstats(struct at76_priv *dev,
 }
 
 
-static void at76_rx_mgmt(struct at76_priv *dev, struct at76_rx_buffer *buf)
+static void at76_rx_mgmt(struct at76_priv *priv, struct at76_rx_buffer *buf)
 {
 	struct ieee80211_hdr_3addr *mgmt =
 	    (struct ieee80211_hdr_3addr *)buf->packet;
 	u16 subtype = le16_to_cpu(mgmt->frame_ctl) & IEEE80211_FCTL_STYPE;
 
 	/* update wstats */
-	if (dev->istate != INIT && dev->istate != SCANNING) {
+	if (priv->istate != INIT && priv->istate != SCANNING) {
 		/* jal: this is a dirty hack needed by Tim in ad-hoc mode */
-		if (dev->iw_mode == IW_MODE_ADHOC || (dev->curr_bss != NULL &&
-		     !compare_ether_addr(mgmt->addr3, dev->curr_bss->bssid))) {
+		if (priv->iw_mode == IW_MODE_ADHOC || (priv->curr_bss != NULL &&
+		     !compare_ether_addr(mgmt->addr3, priv->curr_bss->bssid))) {
 			/* Data packets always seem to have a 0 link level, so we
 			   only read link quality info from management packets.
 			   Atmel driver actually averages the present, and previous
 			   values, we just present the raw value at the moment - TJS */
-			at76_update_wstats(dev, buf);
+			at76_update_wstats(priv, buf);
 		}
 	}
 
 	at76_dbg(DBG_RX_MGMT_CONTENT, "%s rx mgmt subtype x%x %s",
-		 dev->netdev->name, subtype,
-		 hex2str(dev->obuf, mgmt,
-		     min((sizeof(dev->obuf) - 1) / 2,
+		 priv->netdev->name, subtype,
+		 hex2str(priv->obuf, mgmt,
+		     min((sizeof(priv->obuf) - 1) / 2,
 		         (size_t) le16_to_cpu(buf->wlength)), '\0'));
 
 	switch (subtype) {
 	case IEEE80211_STYPE_BEACON:
 	case IEEE80211_STYPE_PROBE_RESP:
-		at76_rx_mgmt_beacon(dev, buf);
+		at76_rx_mgmt_beacon(priv, buf);
 		break;
 
 	case IEEE80211_STYPE_ASSOC_RESP:
-		at76_rx_mgmt_assoc(dev, buf);
+		at76_rx_mgmt_assoc(priv, buf);
 		break;
 
 	case IEEE80211_STYPE_REASSOC_RESP:
-		at76_rx_mgmt_reassoc(dev, buf);
+		at76_rx_mgmt_reassoc(priv, buf);
 		break;
 
 	case IEEE80211_STYPE_DISASSOC:
-		at76_rx_mgmt_disassoc(dev, buf);
+		at76_rx_mgmt_disassoc(priv, buf);
 		break;
 
 	case IEEE80211_STYPE_AUTH:
-		at76_rx_mgmt_auth(dev, buf);
+		at76_rx_mgmt_auth(priv, buf);
 		break;
 
 	case IEEE80211_STYPE_DEAUTH:
-		at76_rx_mgmt_deauth(dev, buf);
+		at76_rx_mgmt_deauth(priv, buf);
 		break;
 
 	default:
 		info("%s: mgmt, but not beacon, subtype = %x",
-		     dev->netdev->name, subtype);
+		     priv->netdev->name, subtype);
 	}
 
 	return;
@@ -5496,8 +5496,8 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 	i802_11_hdr = (struct ieee80211_hdr_3addr *)skb->data;
 
 	dbg("%s: ENTRY skb len %d data %s", __FUNCTION__,
-	    skb->len, hex2str(dev->obuf, skb->data,
-			      min((int)sizeof(dev->obuf) / 3, 64), ' '));
+	    skb->len, hex2str(priv->obuf, skb->data,
+			      min((int)sizeof(priv->obuf) / 3, 64), ' '));
 
 	skb_pull(skb, sizeof(struct ieee80211_hdr_3addr));
 
@@ -5567,8 +5567,8 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 	    hex2str(da, eth_hdr(skb)->h_dest, ETH_ALEN, ':'),
 	    hex2str(sa, eth_hdr(skb)->h_source, ETH_ALEN, ':'),
 	    ntohs(skb->protocol), skb->len,
-	    hex2str(dev->obuf, skb->data,
-		    min((int)sizeof(dev->obuf)/3,64), ' '));
+	    hex2str(priv->obuf, skb->data,
+		    min((int)sizeof(priv->obuf)/3,64), ' '));
 }
 
 
@@ -5629,16 +5629,16 @@ static void at76_ieee80211_fixup(struct sk_buff *skb, int iw_mode)
 }
 
 
-/* check for fragmented data in dev->rx_skb. If the packet was no fragment
+/* check for fragmented data in priv->rx_skb. If the packet was no fragment
    or it was the last of a fragment set a skb containing the whole packet
    is returned for further processing. Otherwise we get NULL and are
    done and the packet is either stored inside the fragment buffer
    or thrown away. The check for rx_copybreak is moved here.
    Every returned skb starts with the ieee802_11 header and contains
    _no_ FCS at the end */
-static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
+static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 {
-	struct sk_buff *skb = dev->rx_skb;
+	struct sk_buff *skb = priv->rx_skb;
 	struct at76_rx_buffer *buf = (struct at76_rx_buffer *)skb->data;
 	struct ieee80211_hdr_3addr *i802_11_hdr =
 	    (struct ieee80211_hdr_3addr *)buf->packet;
@@ -5650,7 +5650,7 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 
 	/* length including the IEEE802.11 header, excl. the trailing FCS,
 	   excl. the struct at76_rx_buffer */
-	int length = le16_to_cpu(buf->wlength) - dev->rx_data_fcs_len;
+	int length = le16_to_cpu(buf->wlength) - priv->rx_data_fcs_len;
 
 	/* where does the data payload start in skb->data ? */
 	u8 *data = (u8 *)i802_11_hdr + sizeof(struct ieee80211_hdr_3addr);
@@ -5664,20 +5664,20 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 
 	at76_dbg(DBG_RX_FRAGS, "%s: rx data frame_ctl %04x addr2 %s seq/frag %d/%d "
 	         "length %d data %d: %s ...",
-	         dev->netdev->name, frame_ctl,
+	         priv->netdev->name, frame_ctl,
 	         mac2str(i802_11_hdr->addr2),
 	         seqnr, fragnr, length, data_len,
-	         hex2str(dev->obuf, data,
-		    min((int)(sizeof(dev->obuf) - 1) / 2, 32), '\0'));
+	         hex2str(priv->obuf, data,
+		    min((int)(sizeof(priv->obuf) - 1) / 2, 32), '\0'));
 
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: incoming skb: head %p data %p "
 	         "tail %p end %p len %d",
-	         dev->netdev->name, skb->head, skb->data, skb->tail,
+	         priv->netdev->name, skb->head, skb->data, skb->tail,
 	         skb->end, skb->len);
 
 	if (data_len < 0) {
 		/* make sure data starts in the buffer */
-		info("%s: data frame too short", dev->netdev->name);
+		info("%s: data frame too short", priv->netdev->name);
 		return NULL;
 	}
 
@@ -5685,15 +5685,15 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 		/* unfragmented packet received */
 		if (length < rx_copybreak && (skb = dev_alloc_skb(length)) != NULL) {
 			memcpy(skb_put(skb, length),
-			       dev->rx_skb->data + AT76_RX_HDRLEN, length);
+			       priv->rx_skb->data + AT76_RX_HDRLEN, length);
 		} else {
 			skb_pull(skb, AT76_RX_HDRLEN);
 			skb_trim(skb, length);
 			/* Use a new skb for the next receive */
-			dev->rx_skb = NULL;
+			priv->rx_skb = NULL;
 		}
 
-		at76_dbg(DBG_RX_FRAGS, "%s: unfragmented", dev->netdev->name);
+		at76_dbg(DBG_RX_FRAGS, "%s: unfragmented", priv->netdev->name);
 
 		return skb;
 	}
@@ -5709,7 +5709,7 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: trimmed skb: head %p data %p tail %p "
 	         "end %p len %d data %p data_len %d",
-	         dev->netdev->name, skb->head, skb->data, skb->tail,
+	         priv->netdev->name, skb->head, skb->data, skb->tail,
 	         skb->end, skb->len, data, data_len);
 
 	/* look if we've got a chain for the sender address.
@@ -5719,7 +5719,7 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 	/* determining the oldest entry doesn't cope with jiffies wrapping
 	   but I don't care to delete a young entry at these rare moments ... */
 
-	for(i=0,bptr=dev->rx_data,optr=NULL; i < NR_RX_DATA_BUF; i++,bptr++) {
+	for(i=0,bptr=priv->rx_data,optr=NULL; i < NR_RX_DATA_BUF; i++,bptr++) {
 		if (bptr->skb != NULL) {
 			if (!compare_ether_addr(i802_11_hdr->addr2, bptr->sender))
 				break;
@@ -5741,7 +5741,7 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 
 		at76_dbg(DBG_RX_FRAGS, "%s: %d. cacheentry (seq/frag=%d/%d) "
 		         "matched sender addr",
-		         dev->netdev->name, i, bptr->seqnr, bptr->fragnr);
+		         priv->netdev->name, i, bptr->seqnr, bptr->fragnr);
 
 		/* bptr points to an entry for the sender address */
 		if (bptr->seqnr == seqnr) {
@@ -5756,7 +5756,7 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 				/* for test only ??? */
 				if ((left=skb_tailroom(bptr->skb)) < data_len) {
 					info("%s: only %d byte free (need %d)",
-					    dev->netdev->name, left, data_len);
+					    priv->netdev->name, left, data_len);
 				} else
 					memcpy(skb_put(bptr->skb, data_len),
 					       data, data_len);
@@ -5767,14 +5767,14 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 					skb = bptr->skb;
 					bptr->skb = NULL; /* free the entry */
 					at76_dbg(DBG_RX_FRAGS, "%s: last frag of seq %d",
-					         dev->netdev->name, seqnr);
+					         priv->netdev->name, seqnr);
 					return skb;
 				} else
 					return NULL;
 			} else {
 				/* wrong fragment number -> ignore it */
 				at76_dbg(DBG_RX_FRAGS, "%s: frag nr does not match: %d+1 != %d",
-				         dev->netdev->name, bptr->fragnr, fragnr);
+				         priv->netdev->name, bptr->fragnr, fragnr);
 				return NULL;
 			}
 		} else {
@@ -5784,20 +5784,20 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 				   old one by this */
 				/* bptr->sender has the correct value already */
 				at76_dbg(DBG_RX_FRAGS, "%s: start of new seq %d, "
-				         "removing old seq %d", dev->netdev->name,
+				         "removing old seq %d", priv->netdev->name,
 				         seqnr, bptr->seqnr);
 				bptr->seqnr = seqnr;
 				bptr->fragnr = 0;
 				bptr->last_rx = jiffies;
-				/* swap bptr->skb and dev->rx_skb */
+				/* swap bptr->skb and priv->rx_skb */
 				skb = bptr->skb;
-				bptr->skb = dev->rx_skb;
-				dev->rx_skb = skb;
+				bptr->skb = priv->rx_skb;
+				priv->rx_skb = skb;
 			} else {
 				/* it from the middle of a new chain ->
 				   delete the old entry and skip the new one */
 				at76_dbg(DBG_RX_FRAGS, "%s: middle of new seq %d (%d) "
-				         "removing old seq %d", dev->netdev->name,
+				         "removing old seq %d", priv->netdev->name,
 				         seqnr, fragnr, bptr->seqnr);
 				dev_kfree_skb(bptr->skb);
 				bptr->skb = NULL;
@@ -5811,7 +5811,7 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 		if (fragnr != 0) {
 			/* this is not the begin of a fragment chain ... */
 			at76_dbg(DBG_RX_FRAGS, "%s: no chain for non-first fragment (%d)",
-			         dev->netdev->name, fragnr);
+			         priv->netdev->name, fragnr);
 			return NULL;
 		}
 		at76_assert(optr != NULL);
@@ -5821,19 +5821,19 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 		if (optr->skb != NULL) {
 			/* swap the skb's */
 			skb = optr->skb;
-			optr->skb = dev->rx_skb;
-			dev->rx_skb = skb;
+			optr->skb = priv->rx_skb;
+			priv->rx_skb = skb;
 
 			at76_dbg(DBG_RX_FRAGS, "%s: free old contents: sender %s seq/frag %d/%d",
-			         dev->netdev->name, mac2str(optr->sender),
+			         priv->netdev->name, mac2str(optr->sender),
 			         optr->seqnr, optr->fragnr);
 
 		} else {
-			/* take the skb from dev->rx_skb */
-			optr->skb = dev->rx_skb;
-			dev->rx_skb = NULL; /* let at76_submit_rx_urb() allocate a new skb */
+			/* take the skb from priv->rx_skb */
+			optr->skb = priv->rx_skb;
+			priv->rx_skb = NULL; /* let at76_submit_rx_urb() allocate a new skb */
 
-			at76_dbg(DBG_RX_FRAGS, "%s: use a free entry", dev->netdev->name);
+			at76_dbg(DBG_RX_FRAGS, "%s: use a free entry", priv->netdev->name);
 		}
 		memcpy(optr->sender, i802_11_hdr->addr2, ETH_ALEN);
 		optr->seqnr = seqnr;
@@ -5845,12 +5845,12 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *dev)
 }
 
 
-/* rx interrupt: we expect the complete data buffer in dev->rx_skb */
-static void at76_rx_data(struct at76_priv *dev)
+/* rx interrupt: we expect the complete data buffer in priv->rx_skb */
+static void at76_rx_data(struct at76_priv *priv)
 {
-	struct net_device *netdev = dev->netdev;
-	struct net_device_stats *stats = &dev->stats;
-	struct sk_buff *skb = dev->rx_skb;
+	struct net_device *netdev = priv->netdev;
+	struct net_device_stats *stats = &priv->stats;
+	struct sk_buff *skb = priv->rx_skb;
 	struct at76_rx_buffer *buf = (struct at76_rx_buffer *)skb->data;
 	struct ieee80211_hdr_3addr *i802_11_hdr;
 	int length = le16_to_cpu(buf->wlength);
@@ -5862,7 +5862,7 @@ static void at76_rx_data(struct at76_priv *dev)
 	if (at76_debug & DBG_RX_DATA_CONTENT)
 		at76_dbg_dumpbuf("packet", skb->data + AT76_RX_HDRLEN, length);
 
-	if ((skb = at76_check_for_rx_frags(dev)) == NULL)
+	if ((skb = at76_check_for_rx_frags(priv)) == NULL)
 		return;
 
 	/* if an skb is returned, the at76_rx_buffer and the FCS is already removed */
@@ -5881,9 +5881,9 @@ static void at76_rx_data(struct at76_priv *dev)
 	}
 
 	if (netdev->type == ARPHRD_ETHER) {
-		at76_ieee80211_to_eth(skb, dev->iw_mode);
+		at76_ieee80211_to_eth(skb, priv->iw_mode);
 	} else {
-		at76_ieee80211_fixup(skb, dev->iw_mode);
+		at76_ieee80211_fixup(skb, priv->iw_mode);
 	}
 
 	netdev->last_rx = jiffies;
@@ -5895,24 +5895,24 @@ static void at76_rx_data(struct at76_priv *dev)
 }
 
 
-static void at76_rx_monitor_mode(struct at76_priv *dev)
+static void at76_rx_monitor_mode(struct at76_priv *priv)
 {
 	struct at76_rx_radiotap *rt;
 	u8 *payload;
 	int skblen;
-	struct net_device *netdev = dev->netdev;
+	struct net_device *netdev = priv->netdev;
 	struct at76_rx_buffer *buf =
-	    (struct at76_rx_buffer *)dev->rx_skb->data;
+	    (struct at76_rx_buffer *)priv->rx_skb->data;
 	/* length including the IEEE802.11 header and the trailing FCS,
 	   but not at76_rx_buffer */
 	int length = le16_to_cpu(buf->wlength);
-	struct sk_buff *skb = dev->rx_skb;
-	struct net_device_stats *stats = &dev->stats;
+	struct sk_buff *skb = priv->rx_skb;
+	struct net_device_stats *stats = &priv->stats;
 
-	if (length < dev->rx_data_fcs_len) {
+	if (length < priv->rx_data_fcs_len) {
 		/* buffer contains no data */
 		at76_dbg(DBG_MONITOR_MODE, "%s: MONITOR MODE: rx skb without data",
-		         dev->netdev->name);
+		         priv->netdev->name);
 		return;
 	}
 
@@ -5920,7 +5920,7 @@ static void at76_rx_monitor_mode(struct at76_priv *dev)
 
 	if ((skb = dev_alloc_skb(skblen)) == NULL) {
 		err("%s: MONITOR MODE: dev_alloc_skb for radiotap header "
-		    "returned NULL", dev->netdev->name);
+		    "returned NULL", priv->netdev->name);
 		return;
 	}
 
@@ -5941,7 +5941,7 @@ static void at76_rx_monitor_mode(struct at76_priv *dev)
 	rt->rt_flags = 0;
 	if (buf->fragmentation)
 		rt->rt_flags |= IEEE80211_RADIOTAP_F_FRAG;
-	if (dev->rx_data_fcs_len)
+	if (priv->rx_data_fcs_len)
 		rt->rt_flags |= IEEE80211_RADIOTAP_F_FCS;
 
 	memcpy(payload, buf->packet, length);
@@ -5961,7 +5961,7 @@ static void at76_rx_monitor_mode(struct at76_priv *dev)
 /**
  * at76_iwspy_update - check if we spy on the sender address of buf and update stats
  */
-static void at76_iwspy_update(struct at76_priv *dev, struct at76_rx_buffer *buf)
+static void at76_iwspy_update(struct at76_priv *priv, struct at76_rx_buffer *buf)
 {
 	struct ieee80211_hdr_3addr *hdr =
 	    (struct ieee80211_hdr_3addr *)buf->packet;
@@ -5971,32 +5971,32 @@ static void at76_iwspy_update(struct at76_priv *dev, struct at76_rx_buffer *buf)
 	qual.updated = IW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;
 	qual.level = 0;
 	qual.noise = 0;
-	at76_calc_level(dev, buf, &qual);
+	at76_calc_level(priv, buf, &qual);
 
-	spin_lock_bh(&(dev->spy_spinlock));
+	spin_lock_bh(&(priv->spy_spinlock));
 
-	if (dev->spy_data.spy_number > 0) {
-		wireless_spy_update(dev->netdev, hdr->addr2, &qual);
+	if (priv->spy_data.spy_number > 0) {
+		wireless_spy_update(priv->netdev, hdr->addr2, &qual);
 	}
-	spin_unlock_bh(&(dev->spy_spinlock));
+	spin_unlock_bh(&(priv->spy_spinlock));
 }
 
 
 static void at76_rx_tasklet(unsigned long param)
 {
-	struct at76_priv *dev = (struct at76_priv *)param;
+	struct at76_priv *priv = (struct at76_priv *)param;
 	struct urb *urb;
 	struct net_device *netdev;
 	struct at76_rx_buffer *buf;
 	struct ieee80211_hdr_3addr *i802_11_hdr;
 	u16 frame_ctl;
 
-	if (!dev)
+	if (!priv)
 		return;
-	urb = dev->rx_urb;
-	netdev = dev->netdev;
+	urb = priv->rx_urb;
+	netdev = priv->netdev;
 
-	if (dev->device_unplugged) {
+	if (priv->device_unplugged) {
 		at76_dbg(DBG_DEVSTART, "device unplugged");
 		if (urb)
 			at76_dbg(DBG_DEVSTART, "urb status %d", urb->status);
@@ -6004,10 +6004,10 @@ static void at76_rx_tasklet(unsigned long param)
 	}
 
 
-	if (!urb || !dev->rx_skb || !netdev || !dev->rx_skb->data)
+	if (!urb || !priv->rx_skb || !netdev || !priv->rx_skb->data)
 		return;
 
-	buf = (struct at76_rx_buffer *)dev->rx_skb->data;
+	buf = (struct at76_rx_buffer *)priv->rx_skb->data;
 
 	if (!buf)
 		return;
@@ -6029,25 +6029,25 @@ static void at76_rx_tasklet(unsigned long param)
 	}
 
 	at76_dbg(DBG_RX_ATMEL_HDR, "%s: rx frame: rate %d rssi %d noise %d link %d %s",
-		 dev->netdev->name,
+		 priv->netdev->name,
 		 buf->rx_rate, buf->rssi, buf->noise_level,
 		 buf->link_quality,
-		 hex2str(dev->obuf, i802_11_hdr,
-			 min((int)(sizeof(dev->obuf)-1)/2,48),'\0'));
-	if (dev->istate == MONITORING) {
-		at76_rx_monitor_mode(dev);
+		 hex2str(priv->obuf, i802_11_hdr,
+			 min((int)(sizeof(priv->obuf)-1)/2,48),'\0'));
+	if (priv->istate == MONITORING) {
+		at76_rx_monitor_mode(priv);
 		goto finish;
 	}
 
 	/* there is a new bssid around, accept it: */
-	if (buf->newbss && dev->iw_mode == IW_MODE_ADHOC) {
+	if (buf->newbss && priv->iw_mode == IW_MODE_ADHOC) {
 		at76_dbg(DBG_PROGRESS, "%s: rx newbss", netdev->name);
-		schedule_work(&dev->work_new_bss);
+		schedule_work(&priv->work_new_bss);
 	}
 
 	switch (frame_ctl & IEEE80211_FCTL_FTYPE) {
 	case IEEE80211_FTYPE_DATA:
-		at76_rx_data(dev);
+		at76_rx_data(priv);
 		break;
 
 	case IEEE80211_FTYPE_MGMT:
@@ -6055,22 +6055,22 @@ static void at76_rx_tasklet(unsigned long param)
 		   other frames than management (might depend on the
 		   radio chip / firmware version !) */
 
-		at76_iwspy_update(dev, buf);
+		at76_iwspy_update(priv, buf);
 
-		at76_rx_mgmt(dev, buf);
+		at76_rx_mgmt(priv, buf);
 		break;
 
 	case IEEE80211_FTYPE_CTL:
 		at76_dbg(DBG_RX_CTRL, "%s: ignored ctrl frame: %04x",
-		         dev->netdev->name, frame_ctl);
+		         priv->netdev->name, frame_ctl);
 		break;
 
 	default:
-		info("%s: it's a frame from mars: %2x", dev->netdev->name,
+		info("%s: it's a frame from mars: %2x", priv->netdev->name,
 		     frame_ctl);
 	}
  finish:
-	at76_submit_rx_urb(dev);
+	at76_submit_rx_urb(priv);
  no_more_urb:
 	return;
 }
@@ -6080,7 +6080,7 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 					       int board_type)
 {
 	struct net_device *netdev;
-	struct at76_priv *dev = NULL;
+	struct at76_priv *priv = NULL;
 	int i;
 
 	/* allocate memory for our device state and initialize it */
@@ -6091,73 +6091,73 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 	}
 
 	SET_NETDEV_DEV(netdev, &udev->dev);
-	dev = netdev_priv(netdev);
-	memset(dev, 0, sizeof(*dev));
-
-	dev->udev = udev;
-	dev->netdev = netdev;
-
-	init_MUTEX(&dev->sem);
-	INIT_WORK(&dev->work_assoc_done, at76_work_assoc_done);
-	INIT_WORK(&dev->work_external_fw, at76_work_external_fw);
-	INIT_WORK(&dev->work_internal_fw, at76_work_internal_fw);
-	INIT_WORK(&dev->work_join, at76_work_join);
-	INIT_WORK(&dev->work_mgmt_timeout, at76_work_mgmt_timeout);
-	INIT_WORK(&dev->work_new_bss, at76_work_new_bss);
-	INIT_WORK(&dev->work_reset_device, at76_work_reset_device);
-	INIT_WORK(&dev->work_restart, at76_work_restart);
-	INIT_WORK(&dev->work_scan, at76_work_scan);
-	INIT_WORK(&dev->work_set_promisc, at76_work_set_promisc);
-	INIT_WORK(&dev->work_start_ibss, at76_work_start_ibss);
-	INIT_WORK(&dev->work_submit_rx, at76_work_submit_rx);
-
-	dev->open_count = 0;
-
-	init_timer(&dev->restart_timer);
-	dev->restart_timer.data = (unsigned long)dev;
-	dev->restart_timer.function = at76_restart_timeout;
-
-	init_timer(&dev->mgmt_timer);
-	dev->mgmt_timer.data = (unsigned long)dev;
-	dev->mgmt_timer.function = at76_mgmt_timeout;
-
-	init_timer(&dev->fw_dl_timer);
-	dev->fw_dl_timer.data = (unsigned long)dev;
-	dev->fw_dl_timer.function = at76_fw_dl_timeout;
-
-	spin_lock_init(&dev->mgmt_spinlock);
-	dev->next_mgmt_bulk = NULL;
-	dev->istate = INTFW_DOWNLOAD;
+	priv = netdev_priv(netdev);
+	memset(priv, 0, sizeof(*priv));
+
+	priv->udev = udev;
+	priv->netdev = netdev;
+
+	init_MUTEX(&priv->sem);
+	INIT_WORK(&priv->work_assoc_done, at76_work_assoc_done);
+	INIT_WORK(&priv->work_external_fw, at76_work_external_fw);
+	INIT_WORK(&priv->work_internal_fw, at76_work_internal_fw);
+	INIT_WORK(&priv->work_join, at76_work_join);
+	INIT_WORK(&priv->work_mgmt_timeout, at76_work_mgmt_timeout);
+	INIT_WORK(&priv->work_new_bss, at76_work_new_bss);
+	INIT_WORK(&priv->work_reset_device, at76_work_reset_device);
+	INIT_WORK(&priv->work_restart, at76_work_restart);
+	INIT_WORK(&priv->work_scan, at76_work_scan);
+	INIT_WORK(&priv->work_set_promisc, at76_work_set_promisc);
+	INIT_WORK(&priv->work_start_ibss, at76_work_start_ibss);
+	INIT_WORK(&priv->work_submit_rx, at76_work_submit_rx);
+
+	priv->open_count = 0;
+
+	init_timer(&priv->restart_timer);
+	priv->restart_timer.data = (unsigned long)priv;
+	priv->restart_timer.function = at76_restart_timeout;
+
+	init_timer(&priv->mgmt_timer);
+	priv->mgmt_timer.data = (unsigned long)priv;
+	priv->mgmt_timer.function = at76_mgmt_timeout;
+
+	init_timer(&priv->fw_dl_timer);
+	priv->fw_dl_timer.data = (unsigned long)priv;
+	priv->fw_dl_timer.function = at76_fw_dl_timeout;
+
+	spin_lock_init(&priv->mgmt_spinlock);
+	priv->next_mgmt_bulk = NULL;
+	priv->istate = INTFW_DOWNLOAD;
 
 	/* initialize empty BSS list */
-	dev->curr_bss = dev->new_bss = NULL;
-	INIT_LIST_HEAD(&dev->bss_list);
-	spin_lock_init(&dev->bss_list_spinlock);
+	priv->curr_bss = priv->new_bss = NULL;
+	INIT_LIST_HEAD(&priv->bss_list);
+	spin_lock_init(&priv->bss_list_spinlock);
 
-	init_timer(&dev->bss_list_timer);
-	dev->bss_list_timer.data = (unsigned long)dev;
-	dev->bss_list_timer.function = at76_bss_list_timeout;
+	init_timer(&priv->bss_list_timer);
+	priv->bss_list_timer.data = (unsigned long)priv;
+	priv->bss_list_timer.function = at76_bss_list_timeout;
 
-	spin_lock_init(&dev->spy_spinlock);
+	spin_lock_init(&priv->spy_spinlock);
 
 	/* mark all rx data entries as unused */
 	for (i = 0; i < NR_RX_DATA_BUF; i++)
-		dev->rx_data[i].skb = NULL;
+		priv->rx_data[i].skb = NULL;
 
-	dev->tasklet.func = at76_rx_tasklet;
-	dev->tasklet.data = (unsigned long)dev;
+	priv->tasklet.func = at76_rx_tasklet;
+	priv->tasklet.data = (unsigned long)priv;
 
-	dev->board_type = board_type;
+	priv->board_type = board_type;
 
-	dev->pm_mode = AT76_PM_OFF;
-	dev->pm_period = 0;
+	priv->pm_mode = AT76_PM_OFF;
+	priv->pm_period = 0;
 
-	return dev;
+	return priv;
 }
 
 
 /* Parse the firmware image */
-static int at76_parse_fw(struct at76_priv *dev, u8 *fw_data, int fw_size,
+static int at76_parse_fw(struct at76_priv *priv, u8 *fw_data, int fw_size,
 			 int board_type)
 {
 	char *str;
@@ -6169,28 +6169,28 @@ static int at76_parse_fw(struct at76_priv *dev, u8 *fw_data, int fw_size,
 	}
 
 	/* CRC currently not checked */
-	dev->board_type = le32_to_cpu(fw->board_type);
-	dev->fw_version.major = fw->major;
-	dev->fw_version.minor = fw->minor;
-	dev->fw_version.patch = fw->patch;
-	dev->fw_version.build = fw->build;
+	priv->board_type = le32_to_cpu(fw->board_type);
+	priv->fw_version.major = fw->major;
+	priv->fw_version.minor = fw->minor;
+	priv->fw_version.patch = fw->patch;
+	priv->fw_version.build = fw->build;
 	str = (char *)fw_data + le32_to_cpu(fw->str_offset);
-	dev->intfw = (u8 *)fw + le32_to_cpu(fw->int_fw_offset);
-	dev->intfw_size = le32_to_cpu(fw->int_fw_len);
-	dev->extfw = (u8 *)fw + le32_to_cpu(fw->ext_fw_offset);
-	dev->extfw_size = le32_to_cpu(fw->ext_fw_len);
+	priv->intfw = (u8 *)fw + le32_to_cpu(fw->int_fw_offset);
+	priv->intfw_size = le32_to_cpu(fw->int_fw_len);
+	priv->extfw = (u8 *)fw + le32_to_cpu(fw->ext_fw_offset);
+	priv->extfw_size = le32_to_cpu(fw->ext_fw_len);
 
 	at76_dbg(DBG_DEVSTART, "firmware board %u version %u.%u.%u#%u "
-		 "(int %x:%tx, ext %x:%tx)", dev->board_type,
-		 dev->fw_version.major, dev->fw_version.minor,
-		 dev->fw_version.patch, dev->fw_version.build,
-		 dev->intfw_size, dev->intfw - fw_data,
-		 dev->extfw_size, dev->extfw - fw_data);
+		 "(int %x:%tx, ext %x:%tx)", priv->board_type,
+		 priv->fw_version.major, priv->fw_version.minor,
+		 priv->fw_version.patch, priv->fw_version.build,
+		 priv->intfw_size, priv->intfw - fw_data,
+		 priv->extfw_size, priv->extfw - fw_data);
 	at76_dbg(DBG_DEVSTART, "firmware id %s", str);
 
-	if (dev->board_type != board_type) {
+	if (priv->board_type != board_type) {
 		err("inconsistent board types %u != %u", board_type,
-		    dev->board_type);
+		    priv->board_type);
 		return -EINVAL;
 	}
 
@@ -6202,7 +6202,7 @@ static int at76_probe(struct usb_interface *interface,
 		      const struct usb_device_id *id)
 {
 	int ret;
-	struct at76_priv *dev;
+	struct at76_priv *priv;
 	int board_type = (int)id->driver_info;
 	const char *const fw_name = firmwares[board_type].fwname;
 	const struct firmware *fw = firmwares[board_type].fw;
@@ -6225,15 +6225,15 @@ static int at76_probe(struct usb_interface *interface,
 
 	usb_get_dev(udev);
 
-	if ((dev = at76_alloc_new_device(udev, (u8) board_type)) == NULL) {
+	if ((priv = at76_alloc_new_device(udev, (u8) board_type)) == NULL) {
 		ret = -ENOMEM;
 		goto error_alloc;
 	}
 
 	op_mode = at76_get_op_mode(udev);
 
-	usb_set_intfdata(interface, dev);
-	dev->interface = interface;
+	usb_set_intfdata(interface, priv);
+	priv->interface = interface;
 
 	at76_dbg(DBG_DEVSTART, "opmode %d", op_mode);
 
@@ -6248,7 +6248,7 @@ static int at76_probe(struct usb_interface *interface,
 	}
 
 	/* parse the firmware */
-	ret = at76_parse_fw(dev, fw->data, fw->size, board_type);
+	ret = at76_parse_fw(priv, fw->data, fw->size, board_type);
 	if (ret)
 		goto error;
 
@@ -6256,8 +6256,8 @@ static int at76_probe(struct usb_interface *interface,
 	    && op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {
 		/* download internal firmware part */
 		at76_dbg(DBG_DEVSTART, "downloading internal firmware");
-		dev->istate = INTFW_DOWNLOAD;
-		schedule_work(&dev->work_internal_fw);
+		priv->istate = INTFW_DOWNLOAD;
+		schedule_work(&priv->work_internal_fw);
 	} else {
 		/* Internal firmware already inside the device.  Get firmware
 		 * version to test if external firmware is loaded.
@@ -6268,21 +6268,21 @@ static int at76_probe(struct usb_interface *interface,
 
 		/* if version >= 0.100.x.y or device with built-in flash we can
 		 * query the device for the fw version */
-		if ((dev->fw_version.major > 0 || dev->fw_version.minor >= 100)
+		if ((priv->fw_version.major > 0 || priv->fw_version.minor >= 100)
 		    || (op_mode == OPMODE_NORMAL_NIC_WITH_FLASH)) {
 			ret = at76_get_mib(udev, MIB_FW_VERSION,
-					   &dev->fw_version,
-					   sizeof(dev->fw_version));
+					   &priv->fw_version,
+					   sizeof(priv->fw_version));
 		} else {
 			/* force fw download only if the device has no flash inside */
 			force_fw_dwl = 1;
 		}
 
 		if ((force_fw_dwl) || (ret < 0)
-		    || ((dev->fw_version.major == 0)
-			&& (dev->fw_version.minor == 0)
-			&& (dev->fw_version.patch == 0)
-			&& (dev->fw_version.build == 0))) {
+		    || ((priv->fw_version.major == 0)
+			&& (priv->fw_version.minor == 0)
+			&& (priv->fw_version.patch == 0)
+			&& (priv->fw_version.build == 0))) {
 			if (force_fw_dwl)
 				at76_dbg(DBG_DEVSTART,
 					 "forced download of external firmware part");
@@ -6291,18 +6291,18 @@ static int at76_probe(struct usb_interface *interface,
 					 "cannot get firmware (ret %d) or all zeros "
 					 "- download external firmware", ret);
 
-			dev->istate = EXTFW_DOWNLOAD;
-			schedule_work(&dev->work_external_fw);
+			priv->istate = EXTFW_DOWNLOAD;
+			schedule_work(&priv->work_external_fw);
 		} else {
-			dev->istate = INIT;
-			if ((ret = at76_init_new_device(dev)) < 0)
+			priv->istate = INIT;
+			if ((ret = at76_init_new_device(priv)) < 0)
 				goto error;
 		}
 	}
 	return 0;
 
       error:
-	at76_delete_device(dev);
+	at76_delete_device(priv);
       error_alloc:
 	usb_put_dev(udev);
 	return ret;
diff --git a/at76_usb.h b/at76_usb.h
index 97f46d6..f32bb61 100644
--- a/at76_usb.h
+++ b/at76_usb.h
@@ -433,7 +433,7 @@ struct bss_info {
 	u8 noise_level;
 
 	unsigned long last_rx;	/* time (jiffies) of last beacon received */
-	u16 assoc_id;		/* if this is dev->curr_bss this is the assoc id we got
+	u16 assoc_id;		/* if this is priv->curr_bss this is the assoc id we got
 				   in a successful AssocResponse */
 };
 
@@ -525,9 +525,9 @@ struct at76_priv {
 						   before and must not remove curr_bss nor
 						   new_bss ! */
 	struct bss_info *curr_bss;	/* if istate == AUTH, ASSOC, REASSOC, JOIN or CONN 
-					   dev->bss[curr_bss] is the currently selected BSS
+					   priv->bss[curr_bss] is the currently selected BSS
 					   we operate on */
-	struct bss_info *new_bss;	/* if istate == REASSOC dev->new_bss
+	struct bss_info *new_bss;	/* if istate == REASSOC priv->new_bss
 					   is the new bss we want to reassoc to */
 
 	u8 wanted_bssid[ETH_ALEN];




From proski at gnu.org  Wed May  2 02:32:10 2007
From: proski at gnu.org (Pavel Roskin)
Date: Tue, 01 May 2007 20:32:10 -0400
Subject: [at76c503a-develop] Request or comments: driver TODO list
Message-ID: <1178065930.12812.8.camel@dv>

Pending commit
--------------

Rename "dev" to "priv" for readability.

Integrate at76_do_probe() into at76_probe().

Replace semaphore by a mutex.

Reorder code for less function prototypes.


Critical
--------

Failure in at76_init_new_device() is definite crash now.  Don't call
at76_delete_device() if it fails.  We need to separate structure
allocation and device initialization.  The later is only used if the
firmware is loaded.


Required for kernel submission
------------------------------

Monitor mode should stay on one channel.  Ideally, make it separate from
the scanning code.

Integrate timers and workqueues.

Reindent the code.  At least fix the ugly parts.

Remove module parameters that can be set by iwpriv.


Nice to do
----------

Create corresponding "get" iwpriv calls.

Don't reschedule firmware download.  This was likely just a workaround
for a bug that is fixed now.

Avoid netdev allocation without firmware.  We don't need to touch the
network layer if we are not going to register the device.

Integrate more functions.  In many cases, one function is called only in
one place, and the separation of the code is artificial.

Retest and reevaluate all locking.  Try to relax locks if safe.  In
particular, avoid locking hard irqs.


Wishlist
--------

Share firmware with the PCI driver.

Support WPA.

Port to mac80211.

-- 
Regards,
Pavel Roskin



From agx at sigxcpu.org  Wed May  2 22:48:00 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Wed, 2 May 2007 22:48:00 +0200
Subject: [at76c503a-develop] [PATCH 1/6] Merge at76_do_probe() into
	at76_probe()
In-Reply-To: <20070502000041.14011.47848.stgit@dv.roinet.com>
References: <20070502000041.14011.47848.stgit@dv.roinet.com>
Message-ID: <20070502204800.GB18221@bogon.ms20.nix>

On Tue, May 01, 2007 at 08:00:41PM -0400, Pavel Roskin wrote:
> The split was artificial, not across a logical boundary. 
> at76_do_probe() was only called by at76_probe() in one place.  Both
> functions were dealing with similar issues.  The "interface" variable
> wasn't passed to at76_do_probe(), it was calculated from altconfig.
> Reformat the resulting function.
Whole series applied and pushed out, thanks!
 -- Guido


From joerg.albert at gmx.de  Mon May  7 01:29:59 2007
From: joerg.albert at gmx.de (Joerg Albert)
Date: Mon, 07 May 2007 01:29:59 +0200
Subject: [at76c503a-develop] USB adapter hardware
Message-ID: <463E64F7.6030405@gmx.de>

Hi,

first of all, thanks to everyone here for continuing the work with the
driver!

I had (and still have) no time to do so. I still have a couple of USB
hardware I once collected:

- Addtron AWU120 (FCC ID PD5LMWU110)
- Netgear MA 101 (FCC ID PD5LMWU110)
- SMC 2662W-AR  (FCC ID HED0109WN3501AR)
- Linksys WUSB11 ver2.6 EU/LA (FCC ID PKW-WUSB11-V26) - not recognized
as an USB device anymore,
   probably due to a broken EEPROM (I've once run a modified firmware on
it).
- SMC2662W V.4 EU (USB ID 03eb:7614) - has problems with the current
driver under a 2.6.19.1 kernel
  (NETDEV WATCHDOG: eth1: transmit timed out, ...)
- Trendnet Tekram U300C (FCC ID O6M2000I) - one of the few devices with
an external flash on a PLCC socket

If anyone of the developers is interested in some of these devices I'd
be happy to send it to them.
I'd prefer to ship them to a place in Germany/Europe.

Regards,
J?rg.


From proski at gnu.org  Thu May 10 00:39:43 2007
From: proski at gnu.org (Pavel Roskin)
Date: Wed, 09 May 2007 18:39:43 -0400
Subject: [at76c503a-develop] USB adapter hardware
In-Reply-To: <463E64F7.6030405@gmx.de>
References: <463E64F7.6030405@gmx.de>
Message-ID: <1178750383.1680.27.camel@dv>

Hello, Jo

Hello, Joerg!

On Mon, 2007-05-07 at 01:29 +0200, Joerg Albert wrote:

> first of all, thanks to everyone here for continuing the work with the
> driver!

You are welcome.

> I had (and still have) no time to do so. I still have a couple of USB
> hardware I once collected:
> 
> - Addtron AWU120 (FCC ID PD5LMWU110)
> - Netgear MA 101 (FCC ID PD5LMWU110)
> - SMC 2662W-AR  (FCC ID HED0109WN3501AR)
> - Linksys WUSB11 ver2.6 EU/LA (FCC ID PKW-WUSB11-V26) - not recognized
> as an USB device anymore,
>    probably due to a broken EEPROM (I've once run a modified firmware on
> it).
> - SMC2662W V.4 EU (USB ID 03eb:7614) - has problems with the current
> driver under a 2.6.19.1 kernel
>   (NETDEV WATCHDOG: eth1: transmit timed out, ...)
> - Trendnet Tekram U300C (FCC ID O6M2000I) - one of the few devices with
> an external flash on a PLCC socket

I have Netgear MA 101 only, but I'm not planning to become the
maintainer.  I'm only doing changes that would allow us to get this
driver into the kernel.

> If anyone of the developers is interested in some of these devices I'd
> be happy to send it to them.
> I'd prefer to ship them to a place in Germany/Europe.

I think that would be Guido.  I'm in America.

Joerg, I'll really appreciate if you do just one thing for this project.
Please turn off Reply-To rewriting for this mailing list and for
at76c503a-user.

Reply-to is not recommended for the lists to which outsiders can post.
It's quite annoying to add the sender to the To: or Cc: field manually.
It kills discussions when one of the participants is not subscribed, and
the other is not careful to counteract the Reply-To rewriting every
time.

-- 
Regards,
Pavel Roskin



From joerg.albert at gmx.de  Thu May 10 10:18:30 2007
From: joerg.albert at gmx.de (=?iso-8859-1?Q?=22J=F6rg_Albert=22?=)
Date: Thu, 10 May 2007 10:18:30 +0200
Subject: [at76c503a-develop] USB adapter hardware
In-Reply-To: <1178750383.1680.27.camel@dv>
References: <463E64F7.6030405@gmx.de> <1178750383.1680.27.camel@dv>
Message-ID: <20070510081830.85920@gmx.net>

Hi Pavel,

> Joerg, I'll really appreciate if you do just one thing for this project.
> Please turn off Reply-To rewriting for this mailing list and for
> at76c503a-user.
> 
> Reply-to is not recommended for the lists to which outsiders can post.
> It's quite annoying to add the sender to the To: or Cc: field manually.
> It kills discussions when one of the participants is not subscribed, and
> the other is not careful to counteract the Reply-To rewriting every
> time.

Outsiders are not allowed to post to the list - at least that was the original configuration. Hopefully the Mailman upgrade on Berlios didn't break it. I'll try it on the announce list.

Regards,
J?rg
-- 
GMX FreeMail: 1 GB Postfach, 5 E-Mail-Adressen, 10 Free SMS.
Alle Infos und kostenlose Anmeldung: http://www.gmx.net/de/go/freemail


From proski at gnu.org  Sat May 12 00:53:52 2007
From: proski at gnu.org (Pavel Roskin)
Date: Fri, 11 May 2007 18:53:52 -0400
Subject: [at76c503a-develop] [PATCH] Update for the forthcoming Linux 2.6.22
	skb API
Message-ID: <20070511225352.7278.58853.stgit@dv.roinet.com>

Keep 2.6.21 compatibility for now.  Use SKB_WITH_OVERHEAD as an
indicator of the new API, since the kernel is not called 2.6.22 yet.

Signed-off-by: Pavel Roskin <proski at gnu.org>
---

 at76_usb.c |   36 +++++++++++++++++++++++++++++++-----
 1 files changed, 31 insertions(+), 5 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 62172ff..f59d60b 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -5538,8 +5538,13 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 #endif /* IEEE_STANDARD */
 	}
 
-	eth_hdr_p = (struct ethhdr *)(skb->data-sizeof(struct ethhdr));
-	skb->mac.raw=(unsigned char *)eth_hdr_p;
+#ifdef SKB_WITH_OVERHEAD
+	skb_set_mac_header(skb, -(int)sizeof(struct ethhdr));
+	eth_hdr_p = (struct ethhdr *)skb_mac_header(skb);
+#else
+	eth_hdr_p = (struct ethhdr *)(skb->data - sizeof(struct ethhdr));
+	skb->mac.raw = (unsigned char *)eth_hdr_p;
+#endif
 	if (build_ethhdr) {
 		/* This needs to be done in this order (eth_hdr_p->h_dest may
 		 * overlap src_addr) */
@@ -5572,6 +5577,14 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 }
 
 
+#ifndef SKB_WITH_OVERHEAD
+static inline void skb_reset_mac_header(struct sk_buff *skb)
+{
+	skb->mac.raw = skb->data;
+}
+#endif
+
+
 /* Adjust the skb to trim the hardware header and CRC, and set up skb->mac,
  * skb->protocol, etc.
  */
@@ -5583,6 +5596,7 @@ static void at76_ieee80211_fixup(struct sk_buff *skb, int iw_mode)
 	u8 *dest_addr;
 	__be16 proto = 0;
 
+	skb_reset_mac_header(skb);
 	i802_11_hdr = (struct ieee80211_hdr_3addr *)skb->data;
 	skb_pull(skb, sizeof(struct ieee80211_hdr_3addr));
 
@@ -5590,8 +5604,6 @@ static void at76_ieee80211_fixup(struct sk_buff *skb, int iw_mode)
 	    : i802_11_hdr->addr3;
 	dest_addr = i802_11_hdr->addr1;
 
-	skb->mac.raw = (unsigned char *)i802_11_hdr;
-
 	eth_hdr_p = (struct ethhdr *)skb->data;
 	if (!compare_ether_addr(eth_hdr_p->h_source, src_addr) &&
 	    !compare_ether_addr(eth_hdr_p->h_dest, dest_addr)) {
@@ -5670,10 +5682,17 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 	         hex2str(priv->obuf, data,
 		    min((int)(sizeof(priv->obuf) - 1) / 2, 32), '\0'));
 
+#ifdef SKB_WITH_OVERHEAD
+	at76_dbg(DBG_RX_FRAGS_SKB, "%s: incoming skb: head %p data %p "
+	         "tail %d end %d len %d",
+	         priv->netdev->name, skb->head, skb->data, skb->tail,
+	         skb->end, skb->len);
+#else
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: incoming skb: head %p data %p "
 	         "tail %p end %p len %d",
 	         priv->netdev->name, skb->head, skb->data, skb->tail,
 	         skb->end, skb->len);
+#endif
 
 	if (data_len < 0) {
 		/* make sure data starts in the buffer */
@@ -5707,10 +5726,17 @@ static struct sk_buff *at76_check_for_rx_frags(struct at76_priv *priv)
 	/* remove FCS at end */
 	skb_trim(skb, length);
 
+#ifdef SKB_WITH_OVERHEAD
+	at76_dbg(DBG_RX_FRAGS_SKB, "%s: trimmed skb: head %p data %p tail %d "
+	         "end %d len %d data %p data_len %d",
+	         priv->netdev->name, skb->head, skb->data, skb->tail,
+	         skb->end, skb->len, data, data_len);
+#else
 	at76_dbg(DBG_RX_FRAGS_SKB, "%s: trimmed skb: head %p data %p tail %p "
 	         "end %p len %d data %p data_len %d",
 	         priv->netdev->name, skb->head, skb->data, skb->tail,
 	         skb->end, skb->len, data, data_len);
+#endif
 
 	/* look if we've got a chain for the sender address.
 	   afterwards optr points to first free or the oldest entry,
@@ -5947,7 +5973,7 @@ static void at76_rx_monitor_mode(struct at76_priv *priv)
 	memcpy(payload, buf->packet, length);
 	skb->dev = netdev;
 	skb->ip_summed = CHECKSUM_NONE;
-	skb->mac.raw = skb->data;
+	skb_reset_mac_header(skb);
 	skb->pkt_type = PACKET_OTHERHOST;
 	skb->protocol = htons(ETH_P_80211_RAW);
 




From agx at sigxcpu.org  Sun May 13 13:47:48 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Sun, 13 May 2007 13:47:48 +0200
Subject: [at76c503a-develop] [PATCH] Update for the forthcoming Linux
	2.6.22 skb API
In-Reply-To: <20070511225352.7278.58853.stgit@dv.roinet.com>
References: <20070511225352.7278.58853.stgit@dv.roinet.com>
Message-ID: <20070513114748.GA2331@bogon.ms20.nix>

On Fri, May 11, 2007 at 06:53:52PM -0400, Pavel Roskin wrote:
> Keep 2.6.21 compatibility for now.  Use SKB_WITH_OVERHEAD as an
> indicator of the new API, since the kernel is not called 2.6.22 yet.
applied, thanks!
 -- Guido


From agx at sigxcpu.org  Sun May 13 14:01:26 2007
From: agx at sigxcpu.org (Guido Guenther)
Date: Sun, 13 May 2007 14:01:26 +0200
Subject: [at76c503a-develop] Request or comments: driver TODO list
In-Reply-To: <1178065930.12812.8.camel@dv>
References: <1178065930.12812.8.camel@dv>
Message-ID: <20070513120126.GC2331@bogon.ms20.nix>

Hi Pavel,
On Tue, May 01, 2007 at 08:32:10PM -0400, Pavel Roskin wrote:
[..snip..] 
> Required for kernel submission
> ------------------------------
> 
> Monitor mode should stay on one channel.  Ideally, make it separate from
> the scanning code.
What about dropping the "monitor mode" stuff for mainline inclusion
altogether and keeping it on a separate branch until it's fixed up?

> Integrate timers and workqueues.
yes.

> Reindent the code.  At least fix the ugly parts.
Yes, althought the formatting looks better than a couple of weeks ago
it could take a second pass, unfortunately lindent won't be of much help
here anymore.

> Remove module parameters that can be set by iwpriv.
At least this should be done, if nobody is using these parameters.

I'd be nice to have the rest of your remarks as TODO on:
http://at76c503a.berlios.de/
Any volunteers for updating the page a bit?
Cheers,
 -- Guido


