<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [at76c503a-develop] [PATCH 3/6] Reorder the functions to avoid most	forward declarations
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/at76c503a-develop/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:at76c503a-develop%40lists.berlios.de?Subject=Re%3A%20%5Bat76c503a-develop%5D%20%5BPATCH%203/6%5D%20Reorder%20the%20functions%20to%20avoid%20most%0A%09forward%20declarations&In-Reply-To=%3C20070502000051.14011.40262.stgit%40dv.roinet.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000063.html">
   <LINK REL="Next"  HREF="000064.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[at76c503a-develop] [PATCH 3/6] Reorder the functions to avoid most	forward declarations</H1>
    <B>Pavel Roskin</B> 
    <A HREF="mailto:at76c503a-develop%40lists.berlios.de?Subject=Re%3A%20%5Bat76c503a-develop%5D%20%5BPATCH%203/6%5D%20Reorder%20the%20functions%20to%20avoid%20most%0A%09forward%20declarations&In-Reply-To=%3C20070502000051.14011.40262.stgit%40dv.roinet.com%3E"
       TITLE="[at76c503a-develop] [PATCH 3/6] Reorder the functions to avoid most	forward declarations">proski at gnu.org
       </A><BR>
    <I>Wed May  2 02:00:52 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000063.html">[at76c503a-develop] [PATCH 1/6] Merge at76_do_probe() into	at76_probe()
</A></li>
        <LI>Next message: <A HREF="000064.html">[at76c503a-develop] [PATCH 4/6] Never call net_device &quot;dev&quot;,	call it &quot;netdev&quot; for readability
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65">[ date ]</a>
              <a href="thread.html#65">[ thread ]</a>
              <a href="subject.html#65">[ subject ]</a>
              <a href="author.html#65">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Always use two newlines between functions.  Re-format some function
declatrations.

Signed-off-by: Pavel Roskin &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">proski at gnu.org</A>&gt;
---

 at76_usb.c | 5317 +++++++++++++++++++++++++++++++-----------------------------
 1 files changed, 2724 insertions(+), 2593 deletions(-)

diff --git a/at76_usb.c b/at76_usb.c
index 59d9129..45d52d8 100644
--- a/at76_usb.c
+++ b/at76_usb.c
@@ -186,25 +186,6 @@ static int default_iw_mode = IW_MODE_INFRA;
 static int monitor_scan_min_time = 50;
 static int monitor_scan_max_time = 600;
 
-/* Function prototypes */
-static void at76_iwspy_update(struct at76_priv *dev, struct at76_rx_buffer *buf);
-static void at76_read_bulk_callback(struct urb *urb);
-static void at76_write_bulk_callback(struct urb *urb);
-static struct bss_info *at76_match_bss(struct at76_priv *dev,
-				       struct bss_info *curr);
-static int at76_auth_req(struct at76_priv *dev, struct bss_info *bss, int seq_nr,
-		         struct ieee80211_info_element *challenge);
-static int at76_disassoc_req(struct at76_priv *dev, struct bss_info *bss);
-static int at76_assoc_req(struct at76_priv *dev, struct bss_info *bss);
-static int at76_reassoc_req(struct at76_priv *dev, struct bss_info *curr,
-		            struct bss_info *new);
-static void at76_dump_bss_table(struct at76_priv *dev);
-static int at76_submit_rx_urb(struct at76_priv *dev);
-static int at76_startup_device(struct at76_priv *dev);
-static int at76_set_iroaming(struct at76_priv *dev, int onoff);
-static void at76_set_monitor_mode(struct at76_priv *dev);
-static int at76_init_new_device(struct at76_priv *dev);
-
 /* the supported rates of this hardware, bit7 marks a basic rate */
 static const u8 hw_rates[] = { 0x82, 0x84, 0x0b, 0x16 };
 /* The frequency of each channel in MHz */
@@ -255,6 +236,7 @@ struct dfu_ctx {
 	void *buf;
 };
 
+
 static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
 				   int block)
 {
@@ -281,6 +263,7 @@ static int at76_dfu_download_block(struct dfu_ctx *ctx, u8 *buffer, int bytes,
 	return result;
 }
 
+
 static int at76_dfu_get_status(struct dfu_ctx *ctx, struct dfu_status *status)
 {
 	int result;
@@ -297,6 +280,7 @@ static int at76_dfu_get_status(struct dfu_ctx *ctx, struct dfu_status *status)
 	return result;
 }
 
+
 static u8 at76_dfu_get_state(struct usb_device *udev, u8 *state)
 {
 	int result;
@@ -312,6 +296,7 @@ static u8 at76_dfu_get_state(struct usb_device *udev, u8 *state)
 	return result;
 }
 
+
 static inline u32 at76_get_timeout(struct dfu_status *s)
 {
 	u32 ret = (s-&gt;poll_timeout[2] &lt;&lt; 16) | (s-&gt;poll_timeout[1] &lt;&lt; 8) |
@@ -320,6 +305,7 @@ static inline u32 at76_get_timeout(struct dfu_status *s)
 	return ret;
 }
 
+
 static struct dfu_ctx *at76_dfu_alloc_ctx(struct usb_device *udev)
 {
 	struct dfu_ctx *ctx;
@@ -332,6 +318,7 @@ static struct dfu_ctx *at76_dfu_alloc_ctx(struct usb_device *udev)
 	return ctx;
 }
 
+
 /* if manifest_sync_timeout &gt; 0 use this timeout (in msec) instead of the
    one reported by the device in state MANIFEST_SYNC */
 static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
@@ -473,6 +460,7 @@ static int at76_usbdfu_download(struct usb_device *udev, u8 *dfu_buffer,
 		return 0;
 }
 
+
 /* some abbrev. for wireless events */
 static inline void at76_iwevent_scan_complete(struct net_device *dev)
 {
@@ -483,6 +471,7 @@ static inline void at76_iwevent_scan_complete(struct net_device *dev)
 	at76_dbg(DBG_WE_EVENTS, &quot;%s: SIOCGIWSCAN sent&quot;, dev-&gt;name);
 }
 
+
 static inline void at76_iwevent_bss_connect(struct net_device *dev, u8 *bssid)
 {
 	union iwreq_data wrqu;
@@ -494,6 +483,7 @@ static inline void at76_iwevent_bss_connect(struct net_device *dev, u8 *bssid)
 	at76_dbg(DBG_WE_EVENTS, &quot;%s: %s: SIOCGIWAP sent&quot;, dev-&gt;name, __FUNCTION__);
 }
 
+
 static inline void at76_iwevent_bss_disconnect(struct net_device *dev)
 {
 	union iwreq_data wrqu;
@@ -529,6 +519,7 @@ static char *hex2str(char *obuf, void *buf, int len, char delim)
 	return ret;
 }
 
+
 /* check if the given ssid is cloaked */
 static inline int at76_is_cloaked_ssid(u8 *ssid, int length)
 {
@@ -539,6 +530,7 @@ static inline int at76_is_cloaked_ssid(u8 *ssid, int length)
 	    (length &gt; 0 &amp;&amp; !memcmp(ssid, zeros, length));
 }
 
+
 static inline void at76_free_bss_list(struct at76_priv *dev)
 {
 	struct list_head *next, *ptr;
@@ -556,6 +548,7 @@ static inline void at76_free_bss_list(struct at76_priv *dev)
 	spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
 }
 
+
 static inline char *mac2str(u8 *mac)
 {
 	static char str[6 * 3];
@@ -565,22 +558,18 @@ static inline char *mac2str(u8 *mac)
 	return str;
 }
 
+
 /* led trigger */
+static int tx_activity;
 static void at76_ledtrig_tx_timerfunc(unsigned long data);
-DEFINE_LED_TRIGGER(ledtrig_tx);
 static DEFINE_TIMER(ledtrig_tx_timer, at76_ledtrig_tx_timerfunc, 0, 0);
-static int tx_activity;
-static int tx_lastactivity;
+DEFINE_LED_TRIGGER(ledtrig_tx);
 
-static void at76_ledtrig_tx_activity(void)
-{
-	tx_activity++;
-	if (!timer_pending(&amp;ledtrig_tx_timer))
-		mod_timer(&amp;ledtrig_tx_timer, jiffies + msecs_to_jiffies(250));
-}
 
 static void at76_ledtrig_tx_timerfunc(unsigned long data)
 {
+	static int tx_lastactivity;
+
 	if (tx_lastactivity != tx_activity) {
 		tx_lastactivity = tx_activity;
 		led_trigger_event(ledtrig_tx, LED_FULL);
@@ -591,6 +580,14 @@ static void at76_ledtrig_tx_timerfunc(unsigned long data)
 }
 
 
+static void at76_ledtrig_tx_activity(void)
+{
+	tx_activity++;
+	if (!timer_pending(&amp;ledtrig_tx_timer))
+		mod_timer(&amp;ledtrig_tx_timer, jiffies + msecs_to_jiffies(250));
+}
+
+
 static int at76_remap(struct usb_device *udev)
 {
 	int ret;
@@ -616,15 +613,17 @@ static int at76_get_op_mode(struct usb_device *udev)
 	return op_mode;
 }
 
+
 /* this loads a block of the second part of the firmware */
-static inline int at76_load_ext_fw_block(struct usb_device *udev,
-				         int i, void *buf, int bsize)
+static inline int at76_load_ext_fw_block(struct usb_device *udev, int i,
+					 void *buf, int bsize)
 {
 	return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			       0x0e, DEVICE_VENDOR_REQUEST_OUT,
 			       0x0802, i, buf, bsize, USB_CTRL_GET_TIMEOUT);
 }
 
+
 static inline int at76_get_hw_cfg_rfmd(struct usb_device *udev,
 				       union at76_hwcfg *buf, int buf_size)
 {
@@ -634,6 +633,7 @@ static inline int at76_get_hw_cfg_rfmd(struct usb_device *udev,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
 }
 
+
 /* Intersil boards use a different &quot;value&quot; for GetHWConfig requests */
 static inline int get_hw_cfg_intersil(struct usb_device *udev,
 				      union at76_hwcfg *buf, int buf_size)
@@ -644,6 +644,7 @@ static inline int get_hw_cfg_intersil(struct usb_device *udev,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
 }
 
+
 /* Get the hardware configuration for the adapter and place the appropriate
  * data in the appropriate fields of 'dev' (the GetHWConfig request and
  * interpretation of the result depends on the type of board we're dealing
@@ -700,6 +701,7 @@ static int at76_get_hw_config(struct at76_priv *dev)
 	return ret;
 }
 
+
 static struct reg_domain const *at76_get_reg_domain(u16 code)
 {
 	static struct reg_domain const fd_tab[] = {
@@ -726,6 +728,7 @@ static struct reg_domain const *at76_get_reg_domain(u16 code)
 	return (i &gt;= tab_len) ? &amp;unknown : &amp;fd_tab[i];
 }
 
+
 static inline int at76_get_mib(struct usb_device *udev, u16 mib, void *buf,
 			       int buf_size)
 {
@@ -735,6 +738,7 @@ static inline int at76_get_mib(struct usb_device *udev, u16 mib, void *buf,
 			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
 }
 
+
 /* Return positive number for status, negative for an error */
 static inline int at76_get_cmd_status(struct usb_device *udev, u8 cmd)
 {
@@ -750,6 +754,7 @@ static inline int at76_get_cmd_status(struct usb_device *udev, u8 cmd)
 	return stat_buf[5];
 }
 
+
 #define EXT_FW_BLOCK_SIZE 1024
 static int at76_download_external_fw(struct usb_device *udev, u8 *buf, int size)
 {
@@ -795,8 +800,9 @@ static int at76_download_external_fw(struct usb_device *udev, u8 *buf, int size)
 	return ret;
 }
 
-static int at76_set_card_command(struct usb_device *udev, int cmd,
-			         void *buf, int buf_size)
+
+static int at76_set_card_command(struct usb_device *udev, int cmd, void *buf,
+				 int buf_size)
 {
 	int ret;
 	struct at76_command *cmd_buf = kmalloc(sizeof(struct at76_command) +
@@ -821,8 +827,8 @@ static int at76_set_card_command(struct usb_device *udev, int cmd,
 	return -ENOMEM;
 }
 
-#define MAKE_CMD_STATUS_CASE(c)	case (c): return #c
 
+#define MAKE_CMD_STATUS_CASE(c)	case (c): return #c
 static const char *at76_get_cmd_status_string(u8 cmd_status)
 {
 	switch (cmd_status) {
@@ -840,6 +846,7 @@ static const char *at76_get_cmd_status_string(u8 cmd_status)
 	return &quot;UNKNOWN&quot;;
 }
 
+
 /* TODO: should timeout */
 static int at76_wait_completion(struct at76_priv *dev, int cmd)
 {
@@ -869,6 +876,7 @@ static int at76_wait_completion(struct at76_priv *dev, int cmd)
 	return status;
 }
 
+
 static int at76_set_mib(struct at76_priv *dev, struct set_mib_buffer *buf)
 {
 	struct usb_device *udev = dev-&gt;udev;
@@ -901,6 +909,7 @@ static int at76_set_mib(struct at76_priv *dev, struct set_mib_buffer *buf)
 	return ret;
 }
 
+
 /* return &lt; 0 on error, == 0 if no command sent, == 1 if cmd sent */
 static int at76_set_radio(struct at76_priv *dev, int on_off)
 {
@@ -918,6 +927,7 @@ static int at76_set_radio(struct at76_priv *dev, int on_off)
 	return ret;
 }
 
+
 /**
  * set_pm_mode - set current power save mode
  * (AT76_PM_OFF/AT76_PM_ON/AT76_PM_SMART)
@@ -940,6 +950,7 @@ static int at76_set_pm_mode(struct at76_priv *dev)
 	return ret;
 }
 
+
 /* sets the assoc id for power save mode */
 static int at76_set_associd(struct at76_priv *dev, u16 id)
 {
@@ -960,6 +971,7 @@ static int at76_set_associd(struct at76_priv *dev, u16 id)
 	return ret;
 }
 
+
 /* sets the listen interval for power save mode.
    really needed, as we have a similar parameter in the assocreq ??? */
 static int at76_set_listen_interval(struct at76_priv *dev, u16 interval)
@@ -982,6 +994,7 @@ static int at76_set_listen_interval(struct at76_priv *dev, u16 interval)
 	return ret;
 }
 
+
 static int at76_set_preamble(struct at76_priv *dev, u8 type)
 {
 	int ret = 0;
@@ -998,6 +1011,7 @@ static int at76_set_preamble(struct at76_priv *dev, u8 type)
 	return ret;
 }
 
+
 static int at76_set_frag(struct at76_priv *dev, u16 size)
 {
 	int ret = 0;
@@ -1014,6 +1028,7 @@ static int at76_set_frag(struct at76_priv *dev, u16 size)
 	return ret;
 }
 
+
 static int at76_set_rts(struct at76_priv *dev, u16 size)
 {
 	int ret = 0;
@@ -1030,6 +1045,7 @@ static int at76_set_rts(struct at76_priv *dev, u16 size)
 	return ret;
 }
 
+
 static int at76_set_autorate_fallback(struct at76_priv *dev, int onoff)
 {
 	int ret = 0;
@@ -1046,6 +1062,7 @@ static int at76_set_autorate_fallback(struct at76_priv *dev, int onoff)
 	return ret;
 }
 
+
 static int at76_add_mac_address(struct at76_priv *dev, void *addr)
 {
 	int ret = 0;
@@ -1063,6 +1080,7 @@ static int at76_add_mac_address(struct at76_priv *dev, void *addr)
 	return ret;
 }
 
+
 #if 0
 /* implemented to get promisc. mode working, but does not help.
    May still be useful for multicast eventually. */
@@ -1099,6 +1117,7 @@ static int set_group_address(struct at76_priv *dev, u8 *addr, int n)
 }
 #endif
 
+
 static int at76_dump_mib_mac_addr(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1132,6 +1151,7 @@ static int at76_dump_mib_mac_addr(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_dump_mib_mac_wep(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1177,6 +1197,7 @@ static int at76_dump_mib_mac_wep(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_dump_mib_mac_mgmt(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1232,6 +1253,7 @@ static int at76_dump_mib_mac_mgmt(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_dump_mib_mac(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1279,6 +1301,7 @@ static int at76_dump_mib_mac(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_dump_mib_phy(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1318,6 +1341,7 @@ static int at76_dump_mib_phy(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_dump_mib_local(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1347,6 +1371,7 @@ static int at76_dump_mib_local(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_get_mib_mdomain(struct at76_priv *dev, struct mib_mdomain *val)
 {
 	int ret = 0;
@@ -1373,6 +1398,7 @@ static int at76_get_mib_mdomain(struct at76_priv *dev, struct mib_mdomain *val)
 	return ret;
 }
 
+
 static void at76_dump_mib_mdomain(struct at76_priv *dev)
 {
 	char obuf1[2*14+1], obuf2[2*14+1]; /* to hexdump tx_powerlevel,
@@ -1393,8 +1419,8 @@ static void at76_dump_mib_mdomain(struct at76_priv *dev)
 		         (sizeof(obuf2) - 1) / 2, '\0'));
 }
 
-static
-int at76_get_current_bssid(struct at76_priv *dev)
+
+static int at76_get_current_bssid(struct at76_priv *dev)
 {
 	int ret = 0;
 	struct mib_mac_mgmt *mac_mgmt =
@@ -1419,6 +1445,7 @@ int at76_get_current_bssid(struct at76_priv *dev)
 	return ret;
 }
 
+
 static int at76_get_current_channel(struct at76_priv *dev)
 {
 	int ret = 0;
@@ -1440,6 +1467,7 @@ static int at76_get_current_channel(struct at76_priv *dev)
 	return ret;
 }
 
+
 /**
  * start_scan - start a scan
  *
@@ -1502,6 +1530,7 @@ static int at76_start_scan(struct at76_priv *dev, int use_essid, int ir_step)
 	return at76_set_card_command(dev-&gt;udev, CMD_SCAN, &amp;scan, sizeof(scan));
 }
 
+
 static int at76_start_ibss(struct at76_priv *dev)
 {
 	struct at76_start_bss bss;
@@ -1517,6 +1546,7 @@ static int at76_start_ibss(struct at76_priv *dev)
 				     sizeof(struct at76_start_bss));
 }
 
+
 /* idx points into dev-&gt;bss */
 static int at76_join_bss(struct at76_priv *dev, struct bss_info *ptr)
 {
@@ -1539,6 +1569,428 @@ static int at76_join_bss(struct at76_priv *dev, struct bss_info *ptr)
 				     sizeof(struct at76_join));
 }
 
+
+/* calc. the padding from txbuf-&gt;wlength (which excludes the USB TX header)
+   guess this is needed to compensate a flaw in the AT76C503A USB part ... */
+static inline int at76_calc_padding(int wlen)
+{
+	/* add the USB TX header */
+	wlen += AT76_TX_HDRLEN;
+
+	wlen = wlen % 64;
+
+	if (wlen &lt; 50)
+		return 50 - wlen;
+
+	if (wlen &gt;= 61)
+		return 64 + 50 - wlen;
+
+	return 0;
+}
+
+
+/* we are doing a lot of things here in an interrupt. Need
+   a bh handler (Watching TV with a TV card is probably
+   a good test: if you see flickers, we are doing too much.
+   Currently I do see flickers... even with our tasklet :-( )
+   Maybe because the bttv driver and usb-uhci use the same interrupt
+*/
+/* Or maybe because our BH handler is preempting bttv's BH handler.. BHs don't
+ * solve everything.. (alex) */
+static void at76_read_bulk_callback(struct urb *urb)
+{
+	struct at76_priv *priv = urb-&gt;context;
+
+	priv-&gt;rx_urb = urb;
+	tasklet_schedule(&amp;priv-&gt;tasklet);
+	return;
+}
+
+
+static void at76_write_bulk_callback(struct urb *urb)
+{
+	struct at76_priv *dev = urb-&gt;context;
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	unsigned long flags;
+	struct at76_tx_buffer *mgmt_buf;
+	int ret;
+
+	if (urb-&gt;status != 0) {
+		if ((urb-&gt;status != -ENOENT) &amp;&amp; (urb-&gt;status != -ECONNRESET)) {
+			at76_dbg(DBG_URB,
+			         &quot;%s - nonzero write bulk status received: %d&quot;,
+			         __FUNCTION__, urb-&gt;status);
+		} else
+			return; /* urb has been unlinked */
+		stats-&gt;tx_errors++;
+	} else
+		stats-&gt;tx_packets++;
+
+	spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock, flags);
+	mgmt_buf = dev-&gt;next_mgmt_bulk;
+	dev-&gt;next_mgmt_bulk = NULL;
+	spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock, flags);
+
+	if (mgmt_buf) {
+		/* we don't copy the padding bytes, but add them
+		   to the length */
+		memcpy(dev-&gt;bulk_out_buffer, mgmt_buf,
+		       le16_to_cpu(mgmt_buf-&gt;wlength) +
+		       offsetof(struct at76_tx_buffer, packet));
+		usb_fill_bulk_urb(dev-&gt;write_urb, dev-&gt;udev,
+				  usb_sndbulkpipe(dev-&gt;udev,
+						  dev-&gt;bulk_out_endpointAddr),
+				  dev-&gt;bulk_out_buffer,
+				  le16_to_cpu(mgmt_buf-&gt;wlength) +
+				  mgmt_buf-&gt;padding + AT76_TX_HDRLEN,
+				  at76_write_bulk_callback,
+				  dev);
+		ret = usb_submit_urb(dev-&gt;write_urb, GFP_ATOMIC);
+		if (ret) {
+			err(&quot;%s: %s error in tx submit urb: %d&quot;,
+			    dev-&gt;netdev-&gt;name, __FUNCTION__, ret);
+		}
+		kfree(mgmt_buf);
+	} else
+		netif_wake_queue(dev-&gt;netdev);
+}
+
+
+/* send a management frame on bulk-out.
+   txbuf-&gt;wlength must be set (in LE format !) */
+static int at76_send_mgmt_bulk(struct at76_priv *dev,
+			       struct at76_tx_buffer *txbuf)
+{
+	unsigned long flags;
+	int ret = 0;
+	int urb_status;
+	void *oldbuf = NULL;
+
+	netif_carrier_off(dev-&gt;netdev);	/* disable running netdev watchdog */
+	netif_stop_queue(dev-&gt;netdev);	/* stop tx data packets */
+
+	spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock, flags);
+
+	if ((urb_status = dev-&gt;write_urb-&gt;status) == -EINPROGRESS) {
+		oldbuf = dev-&gt;next_mgmt_bulk;	/* to kfree below */
+		dev-&gt;next_mgmt_bulk = txbuf;
+		txbuf = NULL;
+	}
+	spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock, flags);
+
+	if (oldbuf) {
+		/* a data/mgmt tx is already pending in the URB -
+		   if this is no error in some situations we must
+		   implement a queue or silently modify the old msg */
+		err(&quot;%s: %s removed pending mgmt buffer %s&quot;,
+		    dev-&gt;netdev-&gt;name, __FUNCTION__,
+		    hex2str(dev-&gt;obuf, dev-&gt;next_mgmt_bulk,
+			    min((int)(sizeof(dev-&gt;obuf)) / 3, 64), ' '));
+		kfree(dev-&gt;next_mgmt_bulk);
+	}
+
+	if (txbuf) {
+
+		txbuf-&gt;tx_rate = 0;
+		txbuf-&gt;padding = at76_calc_padding(le16_to_cpu(txbuf-&gt;wlength));
+
+		if (dev-&gt;next_mgmt_bulk) {
+			err(&quot;%s: %s URB status %d, but mgmt is pending&quot;,
+			    dev-&gt;netdev-&gt;name, __FUNCTION__, urb_status);
+		}
+
+		at76_dbg(DBG_TX_MGMT, &quot;%s: tx mgmt: wlen %d tx_rate %d pad %d %s&quot;,
+		         dev-&gt;netdev-&gt;name, le16_to_cpu(txbuf-&gt;wlength),
+		         txbuf-&gt;tx_rate, txbuf-&gt;padding,
+		         hex2str(dev-&gt;obuf, txbuf-&gt;packet,
+			    min((sizeof(dev-&gt;obuf) - 1) / 2,
+				(size_t) le16_to_cpu(txbuf-&gt;wlength)), '\0'));
+
+		/* txbuf was not consumed above -&gt; send mgmt msg immediately */
+		memcpy(dev-&gt;bulk_out_buffer, txbuf,
+		       le16_to_cpu(txbuf-&gt;wlength) + AT76_TX_HDRLEN);
+		usb_fill_bulk_urb(dev-&gt;write_urb, dev-&gt;udev,
+				  usb_sndbulkpipe(dev-&gt;udev,
+						  dev-&gt;bulk_out_endpointAddr),
+				  dev-&gt;bulk_out_buffer,
+				  le16_to_cpu(txbuf-&gt;wlength) +
+				  txbuf-&gt;padding +
+				  AT76_TX_HDRLEN,
+				  at76_write_bulk_callback,
+				  dev);
+		ret = usb_submit_urb(dev-&gt;write_urb, GFP_ATOMIC);
+		if (ret) {
+			err(&quot;%s: %s error in tx submit urb: %d&quot;,
+			    dev-&gt;netdev-&gt;name, __FUNCTION__, ret);
+		}
+		kfree(txbuf);
+	}
+	/* if (txbuf) */
+	return ret;
+}
+
+
+/* Go to the next information element */
+static inline void next_ie(struct ieee80211_info_element **ie)
+{
+	*ie = (struct ieee80211_info_element *)(&amp;(*ie)-&gt;data[(*ie)-&gt;len]);
+}
+
+
+/* challenge is the challenge string (in TLV format)
+   we got with seq_nr 2 for shared secret authentication only and
+   send in seq_nr 3 WEP encrypted to prove we have the correct WEP key;
+   otherwise it is NULL */
+static int at76_auth_req(struct at76_priv *dev, struct bss_info *bss,
+			 int seq_nr, struct ieee80211_info_element *challenge)
+{
+	struct at76_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee80211_auth *req;
+	int buf_len = (seq_nr != 3 ? AUTH_FRAME_SIZE :
+		       AUTH_FRAME_SIZE + 1 + 1 + challenge-&gt;len);
+
+	at76_assert(bss != NULL);
+	at76_assert(seq_nr != 3 || challenge != NULL);
+	tx_buffer = kmalloc(buf_len + MAX_PADDING_SIZE, GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	req = (struct ieee80211_auth *)(&amp;tx_buffer-&gt;packet);
+	mgmt = &amp;req-&gt;header;
+
+	/* make wireless header */
+	/* first auth msg is not encrypted, only the second (seq_nr == 3) */
+	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH |
+		(seq_nr == 3 ? IEEE80211_FCTL_PROTECTED : 0));
+
+	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt-&gt;addr1, bss-&gt;bssid, ETH_ALEN);
+	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
+	memcpy(mgmt-&gt;addr3, bss-&gt;bssid, ETH_ALEN);
+	mgmt-&gt;seq_ctl = cpu_to_le16(0);
+
+	req-&gt;algorithm = cpu_to_le16(dev-&gt;auth_mode);
+	req-&gt;transaction = cpu_to_le16(seq_nr);
+	req-&gt;status = cpu_to_le16(0);
+
+	if (seq_nr == 3)
+		memcpy(req-&gt;info_element, challenge, 1 + 1 + challenge-&gt;len);
+
+	/* init. at76_priv tx header */
+	tx_buffer-&gt;wlength = cpu_to_le16(buf_len - AT76_TX_HDRLEN);
+	at76_dbg(DBG_TX_MGMT, &quot;%s: AuthReq bssid %s alg %d seq_nr %d&quot;,
+	         dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3),
+	         le16_to_cpu(req-&gt;algorithm), le16_to_cpu(req-&gt;transaction));
+	if (seq_nr == 3) {
+		at76_dbg(DBG_TX_MGMT, &quot;%s: AuthReq challenge: %s ...&quot;,
+		         dev-&gt;netdev-&gt;name,
+		         hex2str(dev-&gt;obuf, req-&gt;info_element,
+		             min((int)sizeof(dev-&gt;obuf) / 3, 18), ' '));
+	}
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return at76_send_mgmt_bulk(dev, tx_buffer);
+}
+
+
+static int at76_assoc_req(struct at76_priv *dev, struct bss_info *bss)
+{
+	struct at76_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee80211_assoc_request *req;
+	struct ieee80211_info_element *tlv;
+
+	at76_assert(bss != NULL);
+
+	tx_buffer = kmalloc(ASSOCREQ_MAX_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	req = (struct ieee80211_assoc_request *)(&amp;tx_buffer-&gt;packet);
+	mgmt = &amp;req-&gt;header;
+	tlv = req-&gt;info_element;
+
+	/* make wireless header */
+	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_ASSOC_REQ);
+
+	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt-&gt;addr1, bss-&gt;bssid, ETH_ALEN);
+	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
+	memcpy(mgmt-&gt;addr3, bss-&gt;bssid, ETH_ALEN);
+	mgmt-&gt;seq_ctl = cpu_to_le16(0);
+
+	/* we must set the Privacy bit in the capabilities to assure an
+	   Agere-based AP with optional WEP transmits encrypted frames
+	   to us.  AP only set the Privacy bit in their capabilities
+	   if WEP is mandatory in the BSS! */
+	req-&gt;capability = cpu_to_le16(bss-&gt;capa |
+				      (dev-&gt;wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
+				      (dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT ?
+				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+
+	req-&gt;listen_interval = cpu_to_le16(2 * bss-&gt;beacon_interval);
+
+	/* write TLV data elements */
+
+	tlv-&gt;id = MFIE_TYPE_SSID;
+	tlv-&gt;len = bss-&gt;ssid_len;
+	memcpy(tlv-&gt;data, bss-&gt;ssid, bss-&gt;ssid_len);
+	next_ie(&amp;tlv);
+
+	tlv-&gt;id = MFIE_TYPE_RATES;
+	tlv-&gt;len = sizeof(hw_rates);
+	memcpy(tlv-&gt;data, hw_rates, sizeof(hw_rates));
+	next_ie(&amp;tlv);		/* tlv points behind the supp_rates field */
+
+	/* init. at76_priv tx header */
+	tx_buffer-&gt;wlength = cpu_to_le16((u8 *) tlv - (u8 *) mgmt);
+
+	{
+		/* output buffer for ssid and rates */
+		char orates[4 * 2 + 1];
+		int len;
+
+		tlv = req-&gt;info_element;
+		len = min_t(int, IW_ESSID_MAX_SIZE, tlv-&gt;len);
+		memcpy(dev-&gt;obuf, tlv-&gt;data, len);
+		dev-&gt;obuf[len] = '\0';
+		next_ie(&amp;tlv); /* points to IE of rates now */
+		at76_dbg(DBG_TX_MGMT, &quot;%s: AssocReq bssid %s capa x%04x ssid %s rates %s&quot;,
+		         dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3),
+		         le16_to_cpu(req-&gt;capability), dev-&gt;obuf,
+		         hex2str(orates,tlv-&gt;data,min((sizeof(orates)-1)/2,(size_t)tlv-&gt;len),
+			    '\0'));
+	}
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return at76_send_mgmt_bulk(dev, tx_buffer);
+}
+
+
+/* we are currently associated to curr_bss and
+   want to reassoc to new_bss */
+static int at76_reassoc_req(struct at76_priv *dev, struct bss_info *curr_bss,
+		            struct bss_info *new_bss)
+{
+	struct at76_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee80211_reassoc_request *req;
+	struct ieee80211_info_element *tlv;
+
+	at76_assert(curr_bss != NULL);
+	at76_assert(new_bss != NULL);
+	if (curr_bss == NULL || new_bss == NULL)
+		return -EFAULT;
+
+	tx_buffer = kmalloc(REASSOCREQ_MAX_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	req = (struct ieee80211_reassoc_request *)(&amp;tx_buffer-&gt;packet);
+	mgmt = &amp;req-&gt;header;
+	tlv = req-&gt;info_element;
+
+	/* make wireless header */
+	/* jal: encrypt this packet if wep_enabled is TRUE ??? */
+	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_REASSOC_REQ);
+	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt-&gt;addr1, new_bss-&gt;bssid, ETH_ALEN);
+	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
+	memcpy(mgmt-&gt;addr3, new_bss-&gt;bssid, ETH_ALEN);
+	mgmt-&gt;seq_ctl = cpu_to_le16(0);
+
+	/* we must set the Privacy bit in the capabilities to assure an
+	   Agere-based AP with optional WEP transmits encrypted frames
+	   to us.  AP only set the Privacy bit in their capabilities
+	   if WEP is mandatory in the BSS! */
+	req-&gt;capability = cpu_to_le16(new_bss-&gt;capa |
+				      (dev-&gt;wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
+				      (dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT ?
+				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+
+	req-&gt;listen_interval = cpu_to_le16(2 * new_bss-&gt;beacon_interval);
+
+	memcpy(req-&gt;current_ap, curr_bss-&gt;bssid, ETH_ALEN);
+
+	/* write TLV data elements */
+	tlv-&gt;id = MFIE_TYPE_SSID;
+	tlv-&gt;len = new_bss-&gt;ssid_len;
+	memcpy(tlv-&gt;data, new_bss-&gt;ssid, new_bss-&gt;ssid_len);
+	next_ie(&amp;tlv);
+
+	tlv-&gt;id = MFIE_TYPE_RATES;
+	tlv-&gt;len = sizeof(hw_rates);
+	memcpy(tlv-&gt;data, hw_rates, sizeof(hw_rates));
+	/* tlv points behind the supp_rates field */
+	next_ie(&amp;tlv);
+
+	/* init. at76_priv tx header */
+	tx_buffer-&gt;wlength = cpu_to_le16((u8 *)tlv-(u8 *)mgmt);
+
+	{
+		/* output buffer for rates and bssid */
+		char orates[4*2+1];
+		char ocurr[6*3+1];
+		tlv = req-&gt;info_element;
+		memcpy(dev-&gt;obuf, tlv-&gt;data, min(sizeof(dev-&gt;obuf),(size_t)tlv-&gt;len));
+		dev-&gt;obuf[IW_ESSID_MAX_SIZE] = '\0';
+		next_ie(&amp;tlv); /* points to IE of rates now */
+		at76_dbg(DBG_TX_MGMT, &quot;%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s&quot;,
+		         dev-&gt;netdev-&gt;name,
+		         hex2str(ocurr, req-&gt;current_ap, ETH_ALEN, ':'),
+		         mac2str(mgmt-&gt;addr3), le16_to_cpu(req-&gt;capability), dev-&gt;obuf,
+		         hex2str(orates,tlv-&gt;data,min((sizeof(orates)-1)/2,(size_t)tlv-&gt;len),
+			    '\0'));
+	}
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return at76_send_mgmt_bulk(dev, tx_buffer);
+}
+
+
+static int at76_disassoc_req(struct at76_priv *dev, struct bss_info *bss)
+{
+	struct at76_tx_buffer *tx_buffer;
+	struct ieee80211_hdr_3addr *mgmt;
+	struct ieee80211_disassoc *req;
+
+	at76_assert(bss != NULL);
+	if (bss == NULL)
+		return -EFAULT;
+
+	tx_buffer = kmalloc(DISASSOC_FRAME_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
+	if (!tx_buffer)
+		return -ENOMEM;
+
+	req = (struct ieee80211_disassoc *)(&amp;tx_buffer-&gt;packet);
+	mgmt = &amp;req-&gt;header;
+
+	/* make wireless header */
+	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_AUTH);
+	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
+	memcpy(mgmt-&gt;addr1, bss-&gt;bssid, ETH_ALEN);
+	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
+	memcpy(mgmt-&gt;addr3, bss-&gt;bssid, ETH_ALEN);
+	mgmt-&gt;seq_ctl = cpu_to_le16(0);
+
+	req-&gt;reason = 0;
+
+	/* init. at76_priv tx header */
+	tx_buffer-&gt;wlength = cpu_to_le16(DISASSOC_FRAME_SIZE - AT76_TX_HDRLEN);
+
+	at76_dbg(DBG_TX_MGMT, &quot;%s: DisAssocReq bssid %s&quot;,
+	         dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3));
+
+	/* either send immediately (if no data tx is pending
+	   or put it in pending list */
+	return at76_send_mgmt_bulk(dev, tx_buffer);
+}
+
+
 /* the firmware download timeout (after remap) */
 static void at76_fw_dl_timeout(unsigned long par)
 {
@@ -1546,6 +1998,7 @@ static void at76_fw_dl_timeout(unsigned long par)
 	schedule_work(&amp;dev-&gt;work_reset_device);
 }
 
+
 /* the restart timer timed out */
 static void at76_restart_timeout(unsigned long par)
 {
@@ -1553,6 +2006,7 @@ static void at76_restart_timeout(unsigned long par)
 	schedule_work(&amp;dev-&gt;work_restart);
 }
 
+
 /* we got to check the bss_list for old entries */
 static void at76_bss_list_timeout(unsigned long par)
 {
@@ -1580,9 +2034,41 @@ static void at76_bss_list_timeout(unsigned long par)
 	spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
 	/* restart the timer */
 	mod_timer(&amp;dev-&gt;bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
+}
+
+
+static void at76_dump_bss_table(struct at76_priv *dev)
+{
+	struct bss_info *ptr;
+	unsigned long flags;
+	struct list_head *lptr;
+	char obuf_s[3*32];
+
+	spin_lock_irqsave(&amp;dev-&gt;bss_list_spinlock, flags);
 
+	pr_debug(&quot;%s BSS table (curr=%p, new=%p):&quot;, dev-&gt;netdev-&gt;name,
+	         dev-&gt;curr_bss, dev-&gt;new_bss);
+
+	list_for_each(lptr, &amp;dev-&gt;bss_list) {
+		ptr = list_entry(lptr, struct bss_info, list);
+		pr_debug(&quot;0x%p: bssid %s channel %d ssid %s (%s)&quot;
+		         &quot; capa x%04x rates %s rssi %d link %d noise %d&quot;,
+		         ptr, mac2str(ptr-&gt;bssid),
+		         ptr-&gt;channel,
+		         ptr-&gt;ssid,
+		         hex2str(dev-&gt;obuf, ptr-&gt;ssid,
+			       min((sizeof(dev-&gt;obuf) - 1) / 2,
+				   (size_t) ptr-&gt;ssid_len), '\0'),
+		         ptr-&gt;capa,
+		         hex2str(obuf_s, ptr-&gt;rates,
+			       min(sizeof(obuf_s) / 3,
+				   (size_t) ptr-&gt;rates_len), ' '),
+		         ptr-&gt;rssi, ptr-&gt;link_qual, ptr-&gt;noise_level);
+	}
+	spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
 }
 
+
 /* we got a timeout for a infrastructure mgmt packet */
 static void at76_mgmt_timeout(unsigned long par)
 {
@@ -1590,6 +2076,7 @@ static void at76_mgmt_timeout(unsigned long par)
 	schedule_work(&amp;dev-&gt;work_mgmt_timeout);
 }
 
+
 /*
  * at76_work_mgmt_timeout_scan - expiry of management timer in istate SCANNING
  */
@@ -1689,6 +2176,7 @@ static void at76_handle_mgmt_timeout_scan(struct at76_priv *dev)
 	}
 }
 
+
 /* the deferred procedure called from at76_devent() */
 static void at76_handle_mgmt_timeout(struct at76_priv *dev)
 {
@@ -1790,402 +2278,1988 @@ static void at76_handle_mgmt_timeout(struct at76_priv *dev)
 	}
 }
 
-/* calc. the padding from txbuf-&gt;wlength (which excludes the USB TX header)
-   guess this is needed to compensate a flaw in the AT76C503A USB part ... */
-static inline int at76_calc_padding(int wlen)
+
+/* Called after successful association */
+static void at76_work_assoc_done(struct work_struct *work)
 {
-	/* add the USB TX header */
-	wlen += AT76_TX_HDRLEN;
+	struct at76_priv *dev = container_of(work, struct at76_priv,
+					     work_assoc_done);
 
-	wlen = wlen % 64;
+	down(&amp;dev-&gt;sem);
 
-	if (wlen &lt; 50)
-		return 50 - wlen;
+	at76_assert(dev-&gt;istate == ASSOCIATING || dev-&gt;istate == REASSOCIATING);
+	if (dev-&gt;iw_mode == IW_MODE_INFRA) {
+		at76_assert(dev-&gt;curr_bss != NULL);
+		if (dev-&gt;curr_bss != NULL &amp;&amp; dev-&gt;pm_mode != AT76_PM_OFF) {
+			/* calculate the listen interval in units of
+			   beacon intervals of the curr_bss */
+			u32 pm_period_beacon = (dev-&gt;pm_period &gt;&gt; 10) /
+						dev-&gt;curr_bss-&gt;beacon_interval;
 
-	if (wlen &gt;= 61)
-		return 64 + 50 - wlen;
+			pm_period_beacon = max(pm_period_beacon, 2u);
+			pm_period_beacon = min(pm_period_beacon, 0xffffu);
+
+			at76_dbg(DBG_PM, &quot;%s: pm_mode %d assoc id x%x listen int %d&quot;,
+			         dev-&gt;netdev-&gt;name, dev-&gt;pm_mode,
+			         dev-&gt;curr_bss-&gt;assoc_id, pm_period_beacon);
+
+			at76_set_associd(dev, dev-&gt;curr_bss-&gt;assoc_id);
+			at76_set_listen_interval(dev, (u16)pm_period_beacon);
+#ifdef DEBUG
+			at76_dump_mib_mac(dev);
+			at76_dump_mib_mac_mgmt(dev);
+#endif
+		}
+	}
+	at76_set_pm_mode(dev);
+
+	netif_carrier_on(dev-&gt;netdev);
+	netif_wake_queue(dev-&gt;netdev);
+	dev-&gt;istate = CONNECTED;
+	at76_iwevent_bss_connect(dev-&gt;netdev, dev-&gt;curr_bss-&gt;bssid);
+	at76_dbg(DBG_PROGRESS, &quot;%s: connected to BSSID %s&quot;,
+	         dev-&gt;netdev-&gt;name, mac2str(dev-&gt;curr_bss-&gt;bssid));
+
+	up(&amp;dev-&gt;sem);
+}
+
+
+static void at76_delete_device(struct at76_priv *dev)
+{
+	int i;
+
+	if (!dev)
+		return;
+
+	/* signal to _stop() that the device is gone */
+	dev-&gt;device_unplugged = 1;
+
+	at76_dbg(DBG_PROC_ENTRY, &quot;%s: ENTER&quot;,__FUNCTION__);
+
+	if (dev-&gt;netdev_registered) {
+		unregister_netdev(dev-&gt;netdev);
+	}
+
+	usb_put_dev(dev-&gt;udev);
+
+	/* assuming we used keventd, it must quiesce too */
+	flush_scheduled_work();
+
+	if (dev-&gt;bulk_out_buffer != NULL)
+		kfree(dev-&gt;bulk_out_buffer);
+
+	kfree(dev-&gt;ctrl_buffer);
+
+	if (dev-&gt;write_urb != NULL) {
+		usb_kill_urb(dev-&gt;write_urb);
+		usb_free_urb(dev-&gt;write_urb);
+	}
+	if (dev-&gt;read_urb != NULL) {
+		usb_kill_urb(dev-&gt;read_urb);
+		usb_free_urb(dev-&gt;read_urb);
+	}
+	if (dev-&gt;ctrl_buffer != NULL) {
+		usb_kill_urb(dev-&gt;ctrl_urb);
+		usb_free_urb(dev-&gt;ctrl_urb);
+	}
+
+	at76_dbg(DBG_PROC_ENTRY, &quot;%s: unlinked urbs&quot;, __FUNCTION__);
+
+	if (dev-&gt;rx_skb != NULL)
+		kfree_skb(dev-&gt;rx_skb);
+
+	at76_free_bss_list(dev);
+	del_timer_sync(&amp;dev-&gt;bss_list_timer);
+
+	if (dev-&gt;istate == CONNECTED) {
+		at76_iwevent_bss_disconnect(dev-&gt;netdev);
+	}
+
+	for (i = 0; i &lt; NR_RX_DATA_BUF; i++)
+		if (dev-&gt;rx_data[i].skb != NULL) {
+			dev_kfree_skb(dev-&gt;rx_data[i].skb);
+			dev-&gt;rx_data[i].skb = NULL;
+		}
+	at76_dbg(DBG_PROC_ENTRY, &quot;%s: before freeing dev/netdev&quot;, __FUNCTION__);
+	free_netdev(dev-&gt;netdev); /* dev is in netdev */
+
+	at76_dbg(DBG_PROC_ENTRY, &quot;%s: EXIT&quot;, __FUNCTION__);
+}
+
+
+static int at76_alloc_urbs(struct at76_priv *dev)
+{
+	struct usb_interface *interface = dev-&gt;interface;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_device *udev = dev-&gt;udev;
+	int i, buffer_size;
+	struct usb_host_interface *iface_desc;
+
+	at76_dbg(DBG_PROC_ENTRY, &quot;%s: ENTER&quot;, __FUNCTION__);
+
+	at76_dbg(DBG_URB, &quot;%s: NumEndpoints %d &quot;, __FUNCTION__,
+	    interface-&gt;altsetting[0].desc.bNumEndpoints);
+
+	iface_desc = interface-&gt;cur_altsetting;
+	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; i++) {
+		endpoint = &amp;iface_desc-&gt;endpoint[i].desc;
+
+		at76_dbg(DBG_URB, &quot;%s: %d. endpoint: addr x%x attr x%x&quot;,
+		    __FUNCTION__,
+		    i, endpoint-&gt;bEndpointAddress, endpoint-&gt;bmAttributes);
+
+		if ((endpoint-&gt;bEndpointAddress &amp; 0x80) &amp;&amp;
+		    ((endpoint-&gt;bmAttributes &amp; 3) == 0x02)) {
+			/* we found a bulk in endpoint */
+
+			dev-&gt;read_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!dev-&gt;read_urb) {
+				err(&quot;No free urbs available&quot;);
+				return -ENOMEM;
+			}
+			dev-&gt;bulk_in_endpointAddr = endpoint-&gt;bEndpointAddress;
+		}
+
+		if (((endpoint-&gt;bEndpointAddress &amp; 0x80) == 0x00) &amp;&amp;
+		    ((endpoint-&gt;bmAttributes &amp; 3) == 0x02)) {
+			/* we found a bulk out endpoint */
+			dev-&gt;write_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if (!dev-&gt;write_urb) {
+				err(&quot;no free urbs available&quot;);
+				return -ENOMEM;
+			}
+			buffer_size = sizeof(struct at76_tx_buffer) +
+			    MAX_PADDING_SIZE;
+			dev-&gt;bulk_out_endpointAddr = endpoint-&gt;bEndpointAddress;
+			dev-&gt;bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);
+			if (!dev-&gt;bulk_out_buffer) {
+				err(&quot;couldn't allocate bulk_out_buffer&quot;);
+				return -ENOMEM;
+			}
+			usb_fill_bulk_urb(dev-&gt;write_urb, udev,
+				          usb_sndbulkpipe(udev,
+						      endpoint-&gt;bEndpointAddress),
+				          dev-&gt;bulk_out_buffer, buffer_size,
+				          at76_write_bulk_callback, dev);
+		}
+	}
+
+	dev-&gt;ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dev-&gt;ctrl_urb) {
+		err(&quot;no free urbs available&quot;);
+		return -ENOMEM;
+	}
+	dev-&gt;ctrl_buffer = kmalloc(1024, GFP_KERNEL);
+	if (!dev-&gt;ctrl_buffer) {
+		err(&quot;couldn't allocate ctrl_buffer&quot;);
+		return -ENOMEM;
+	}
+
+	at76_dbg(DBG_PROC_ENTRY, &quot;%s: EXIT&quot;, __FUNCTION__);
 
 	return 0;
 }
 
-/* send a management frame on bulk-out.
-   txbuf-&gt;wlength must be set (in LE format !) */
-static int at76_send_mgmt_bulk(struct at76_priv *dev,
-			  struct at76_tx_buffer *txbuf)
+
+/* we only store the new mac address in netdev struct,
+   it gets set when the netdev is opened. */
+static int at76_set_mac_address(struct net_device *netdev, void *addr)
 {
+	struct sockaddr *mac = addr;
+	memcpy(netdev-&gt;dev_addr, mac-&gt;sa_data, ETH_ALEN);
+	return 1;
+}
+
+
+static struct net_device_stats *at76_get_stats(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	return &amp;dev-&gt;stats;
+}
+
+
+static struct iw_statistics *at76_get_wireless_stats(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	at76_dbg(DBG_IOCTL, &quot;RETURN qual %d level %d noise %d updated %d&quot;,
+	         dev-&gt;wstats.qual.qual, dev-&gt;wstats.qual.level,
+	         dev-&gt;wstats.qual.noise, dev-&gt;wstats.qual.updated);
+
+	return &amp;dev-&gt;wstats;
+}
+
+
+static void at76_set_multicast(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int promisc;
+
+	promisc = ((netdev-&gt;flags &amp; IFF_PROMISC) != 0);
+	if (promisc != dev-&gt;promisc) {
+		/* grmbl. This gets called in interrupt. */
+		dev-&gt;promisc = promisc;
+		schedule_work(&amp;dev-&gt;work_set_promisc);
+	}
+}
+
+
+/*******************************************************************************
+ * at76_priv implementations of iw_handler functions:
+ */
+static int at76_iw_handler_commit(struct net_device *netdev,
+				  struct iw_request_info *info,
+				  void *null, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
 	unsigned long flags;
+	at76_dbg(DBG_IOCTL, &quot;%s %s: restarting the device&quot;, netdev-&gt;name,
+	         __FUNCTION__);
+
+	/* TODO: stop any pending tx bulk urb */
+	if (dev-&gt;istate != INIT) {
+		dev-&gt;istate = INIT;
+		/* stop pending management stuff */
+		del_timer_sync(&amp;dev-&gt;mgmt_timer);
+
+		spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock, flags);
+		if (dev-&gt;next_mgmt_bulk) {
+			kfree(dev-&gt;next_mgmt_bulk);
+			dev-&gt;next_mgmt_bulk = NULL;
+		}
+		spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock, flags);
+
+		netif_carrier_off(dev-&gt;netdev);
+		netif_stop_queue(dev-&gt;netdev);
+	}
+
+	/* do the restart after two seconds to catch
+	 * following ioctl's (from more params of iwconfig)
+	 * in _one_ restart */
+	mod_timer(&amp;dev-&gt;restart_timer, jiffies + 2 * HZ);
+
+	return 0;
+}
+
+
+static int at76_iw_handler_get_name(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    char *name, char *extra)
+{
+	strcpy(name, &quot;IEEE 802.11b&quot;);
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWNAME - name %s&quot;, netdev-&gt;name, name);
+	return 0;
+}
+
+
+static int at76_iw_handler_set_freq(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_freq *freq, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int chan = -1;
+	int ret = -EIWCOMMIT;
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWFREQ - freq.m %d freq.e %d&quot;, netdev-&gt;name,
+	    freq-&gt;m, freq-&gt;e);
+
+	if ((freq-&gt;e == 0) &amp;&amp; (freq-&gt;m &lt;= 1000)) {
+		/* Setting by channel number */
+		chan = freq-&gt;m;
+	} else {
+		/* Setting by frequency - search the table */
+		int mult = 1;
+		int i;
+
+		for (i = 0; i &lt; (6 - freq-&gt;e); i++) {
+			mult *= 10;
+		}
+
+		for (i = 0; i &lt; NUM_CHANNELS; i++) {
+			if (freq-&gt;m == (channel_frequency[i] * mult))
+				chan = i + 1;
+		}
+	}
+
+	if (chan &lt; 1 || !dev-&gt;domain) {
+		/* non-positive channels are invalid
+		 * we need a domain info to set the channel
+		 * either that or an invalid frequency was
+		 * provided by the user */
+		ret = -EINVAL;
+	} else if (!dev-&gt;international_roaming) {
+		if (!(dev-&gt;domain-&gt;channel_map &amp; (1 &lt;&lt; (chan - 1)))) {
+			info(&quot;%s: channel %d not allowed for domain %s &quot;
+			     &quot;(and international_roaming is OFF)&quot;,
+			     dev-&gt;netdev-&gt;name, chan, dev-&gt;domain-&gt;name);
+			ret = -EINVAL;
+		}
+	}
+
+	if (ret == -EIWCOMMIT) {
+		dev-&gt;channel = chan;
+		at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWFREQ - ch %d&quot;, netdev-&gt;name, chan);
+	}
+
+	return ret;
+}
+
+
+static int at76_iw_handler_get_freq(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_freq *freq, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	freq-&gt;m = dev-&gt;channel;
+	freq-&gt;e = 0;
+
+	if (dev-&gt;channel) {
+		at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWFREQ - freq %ld x 10e%d&quot;,
+		         netdev-&gt;name, channel_frequency[dev-&gt;channel - 1], 6);
+	}
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWFREQ - ch %d&quot;, netdev-&gt;name, dev-&gt;channel);
+
+	return 0;
+}
+
+
+static int at76_iw_handler_set_mode(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    __u32 *mode, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWMODE - %d&quot;, netdev-&gt;name, *mode);
+
+	if ((*mode != IW_MODE_ADHOC) &amp;&amp; (*mode != IW_MODE_INFRA) &amp;&amp;
+	    (*mode != IW_MODE_MONITOR)) {
+		ret = -EINVAL;
+	} else {
+		dev-&gt;iw_mode = *mode;
+		if( dev-&gt;iw_mode != IW_MODE_INFRA)
+			dev-&gt;pm_mode = AT76_PM_OFF;
+	}
+	return ret;
+}
+
+
+static int at76_iw_handler_get_mode(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    __u32 * mode, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	*mode = dev-&gt;iw_mode;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWMODE - %d&quot;, netdev-&gt;name, *mode);
+
+	return 0;
+}
+
+
+static int at76_iw_handler_get_range(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_point *data, char *extra)
+{
+	/* inspired by atmel.c */
+	struct at76_priv *dev = netdev_priv(netdev);
+	struct iw_range *range = (struct iw_range *)extra;
+	int i;
+
+	data-&gt;length = sizeof(struct iw_range);
+	memset(range, 0, sizeof(struct iw_range));
+
+	/* TODO: range-&gt;throughput = xxxxxx; */
+
+	range-&gt;min_nwid = 0x0000;
+	range-&gt;max_nwid = 0x0000;
+
+	/* this driver doesn't maintain sensitivity information */
+	range-&gt;sensitivity = 0;
+
+	range-&gt;max_qual.qual = 100;
+	range-&gt;max_qual.level = 100;
+	range-&gt;max_qual.noise = 0;
+	range-&gt;max_qual.updated = IW_QUAL_NOISE_INVALID;
+
+	range-&gt;avg_qual.qual = 50;
+	range-&gt;avg_qual.level = 50;
+	range-&gt;avg_qual.noise = 0;
+	range-&gt;avg_qual.updated = IW_QUAL_NOISE_INVALID;
+
+	range-&gt;bitrate[0] = 1000000;
+	range-&gt;bitrate[1] = 2000000;
+	range-&gt;bitrate[2] = 5500000;
+	range-&gt;bitrate[3] = 11000000;
+	range-&gt;num_bitrates = 4;
+
+	range-&gt;min_rts = 0;
+	range-&gt;max_rts = MAX_RTS_THRESHOLD;
+
+	range-&gt;min_frag = MIN_FRAG_THRESHOLD;
+	range-&gt;max_frag = MAX_FRAG_THRESHOLD;
+
+	range-&gt;pmp_flags = IW_POWER_PERIOD;
+	range-&gt;pmt_flags = IW_POWER_ON;
+	range-&gt;pm_capa = IW_POWER_PERIOD | IW_POWER_ALL_R;
+
+	range-&gt;encoding_size[0] = WEP_SMALL_KEY_LEN;
+	range-&gt;encoding_size[1] = WEP_LARGE_KEY_LEN;
+	range-&gt;num_encoding_sizes = 2;
+	range-&gt;max_encoding_tokens = WEP_KEYS;
+
+	/* both WL-240U and Linksys WUSB11 v2.6 specify 15 dBm as output power
+	   - take this for all (ignore antenna gains) */
+	range-&gt;txpower[0] = 15;
+	range-&gt;num_txpower = 1;
+	range-&gt;txpower_capa = IW_TXPOW_DBM;
+
+	range-&gt;we_version_source = WIRELESS_EXT;
+	range-&gt;we_version_compiled = WIRELESS_EXT;
+
+	/* same as the values used in atmel.c */
+	range-&gt;retry_capa = IW_RETRY_LIMIT;
+	range-&gt;retry_flags = IW_RETRY_LIMIT;
+	range-&gt;r_time_flags = 0;
+	range-&gt;min_retry = 1;
+	range-&gt;max_retry = 255;
+
+
+	range-&gt;num_channels = NUM_CHANNELS;
+	range-&gt;num_frequency = 0;
+
+	for (i = 0; i &lt; NUM_CHANNELS; i++) {
+		/* test if channel map bit is raised */
+		if (dev-&gt;domain-&gt;channel_map &amp; (0x1 &lt;&lt; i)) {
+			range-&gt;num_frequency += 1;
+
+			range-&gt;freq[i].i = i + 1;
+			range-&gt;freq[i].m = channel_frequency[i] * 100000;
+			range-&gt;freq[i].e = 1;	/* channel frequency*100000 * 10^1 */
+		}
+	}
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWRANGE&quot;, netdev-&gt;name);
+
+	return 0;
+}
+
+
+static int at76_iw_handler_set_spy(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
 	int ret = 0;
-	int urb_status;
-	void *oldbuf = NULL;
 
-	netif_carrier_off(dev-&gt;netdev);	/* disable running netdev watchdog */
-	netif_stop_queue(dev-&gt;netdev);	/* stop tx data packets */
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWSPY - number of addresses %d&quot;,
+	         netdev-&gt;name, data-&gt;length);
 
-	spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock, flags);
+	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
+	ret = iw_handler_set_spy(dev-&gt;netdev, info, (union iwreq_data *)data,
+				 extra);
+	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
 
-	if ((urb_status = dev-&gt;write_urb-&gt;status) == -EINPROGRESS) {
-		oldbuf = dev-&gt;next_mgmt_bulk;	/* to kfree below */
-		dev-&gt;next_mgmt_bulk = txbuf;
-		txbuf = NULL;
+	return ret;
+}
+
+
+static int at76_iw_handler_get_spy(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_point *data, char *extra)
+{
+
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = 0;
+
+	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
+	ret = iw_handler_get_spy(dev-&gt;netdev, info,
+				 (union iwreq_data *)data, extra);
+	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWSPY - number of addresses %d&quot;,
+	         netdev-&gt;name, data-&gt;length);
+
+	return ret;
+}
+
+
+static int at76_iw_handler_set_thrspy(struct net_device *netdev,
+				      struct iw_request_info *info,
+				      struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWTHRSPY - number of addresses %d)&quot;,
+	         netdev-&gt;name, data-&gt;length);
+
+	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
+	ret = iw_handler_set_thrspy(netdev, info, (union iwreq_data *)data,
+				    extra);
+	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
+
+	return ret;
+}
+
+
+static int at76_iw_handler_get_thrspy(struct net_device *netdev,
+				      struct iw_request_info *info,
+				      struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret;
+
+	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
+	ret = iw_handler_get_thrspy(netdev, info, (union iwreq_data *)data,
+				    extra);
+	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWTHRSPY - number of addresses %d)&quot;,
+	         netdev-&gt;name, data-&gt;length);
+
+	return ret;
+}
+
+
+static int at76_iw_handler_set_wap(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct sockaddr *ap_addr, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWAP - wap/bssid %s&quot;, netdev-&gt;name,
+	         mac2str(ap_addr-&gt;sa_data));
+
+	/* if the incoming address == ff:ff:ff:ff:ff:ff, the user has
+	   chosen any or auto AP preference */
+	if (is_broadcast_ether_addr(ap_addr-&gt;sa_data)
+	    || is_zero_ether_addr(ap_addr-&gt;sa_data)) {
+		dev-&gt;wanted_bssid_valid = 0;
+	} else {
+		/* user wants to set a preferred AP address */
+		dev-&gt;wanted_bssid_valid = 1;
+		memcpy(dev-&gt;wanted_bssid, ap_addr-&gt;sa_data, ETH_ALEN);
 	}
-	spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock, flags);
 
-	if (oldbuf) {
-		/* a data/mgmt tx is already pending in the URB -
-		   if this is no error in some situations we must
-		   implement a queue or silently modify the old msg */
-		err(&quot;%s: %s removed pending mgmt buffer %s&quot;,
-		    dev-&gt;netdev-&gt;name, __FUNCTION__,
-		    hex2str(dev-&gt;obuf, dev-&gt;next_mgmt_bulk,
-			    min((int)(sizeof(dev-&gt;obuf)) / 3, 64), ' '));
+	return -EIWCOMMIT;
+}
+
+
+static int at76_iw_handler_get_wap(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct sockaddr *ap_addr, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	ap_addr-&gt;sa_family = ARPHRD_ETHER;
+	memcpy(ap_addr-&gt;sa_data, dev-&gt;bssid, ETH_ALEN);
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWAP - wap/bssid %s&quot;, netdev-&gt;name,
+	         mac2str(ap_addr-&gt;sa_data));
+
+	return 0;
+}
+
+
+static int at76_iw_handler_set_scan(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    union iwreq_data *wrqu, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	unsigned long flags;
+	int ret = 0;
+	struct iw_scan_req *req = NULL;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWSCAN&quot;, netdev-&gt;name);
+
+	if (!netif_running(netdev))
+		return -ENETDOWN;
+
+	/* jal: we don't allow &quot;iwlist ethX scan&quot; while we are
+	   in monitor mode */
+	if (dev-&gt;iw_mode == IW_MODE_MONITOR)
+		return -EBUSY;
+
+	/* Discard old scan results */
+	if ((jiffies - dev-&gt;last_scan) &gt; (20 * HZ))
+		dev-&gt;scan_state = SCAN_IDLE;
+	dev-&gt;last_scan = jiffies;
+
+	/* Initiate a scan command */
+	if (dev-&gt;scan_state == SCAN_IN_PROGRESS)
+		return -EBUSY;
+
+	dev-&gt;scan_state = SCAN_IN_PROGRESS;
+
+	/* stop pending management stuff */
+	del_timer_sync(&amp;(dev-&gt;mgmt_timer));
+
+	spin_lock_irqsave(&amp;(dev-&gt;mgmt_spinlock), flags);
+	if (dev-&gt;next_mgmt_bulk) {
 		kfree(dev-&gt;next_mgmt_bulk);
+		dev-&gt;next_mgmt_bulk = NULL;
 	}
+	spin_unlock_irqrestore(&amp;(dev-&gt;mgmt_spinlock), flags);
 
-	if (txbuf) {
+	if (netif_running(dev-&gt;netdev)) {
+		/* pause network activity */
+		netif_carrier_off(dev-&gt;netdev);
+		netif_stop_queue(dev-&gt;netdev);
+	}
+	/* Try to do passive or active scan if WE asks as. */
+	if (wrqu-&gt;data.length
+	    &amp;&amp; wrqu-&gt;data.length == sizeof(struct iw_scan_req)) {
+		req = (struct iw_scan_req *)extra;
 
-		txbuf-&gt;tx_rate = 0;
-		txbuf-&gt;padding = at76_calc_padding(le16_to_cpu(txbuf-&gt;wlength));
+		if (req-&gt;scan_type == IW_SCAN_TYPE_PASSIVE)
+			dev-&gt;scan_mode = SCAN_TYPE_PASSIVE;
+		else if (req-&gt;scan_type == IW_SCAN_TYPE_ACTIVE)
+			dev-&gt;scan_mode = SCAN_TYPE_ACTIVE;
 
-		if (dev-&gt;next_mgmt_bulk) {
-			err(&quot;%s: %s URB status %d, but mgmt is pending&quot;,
-			    dev-&gt;netdev-&gt;name, __FUNCTION__, urb_status);
+		/* Sanity check values? */
+		if (req-&gt;min_channel_time &gt; 0) {
+			if (dev-&gt;istate == MONITORING)
+				dev-&gt;monitor_scan_min_time =
+				    req-&gt;min_channel_time;
+			else
+				dev-&gt;scan_min_time = req-&gt;min_channel_time;
+		}
+		if (req-&gt;max_channel_time &gt; 0) {
+			if (dev-&gt;istate == MONITORING)
+				dev-&gt;monitor_scan_max_time =
+				    req-&gt;max_channel_time;
+			else
+				dev-&gt;scan_max_time = req-&gt;max_channel_time;
 		}
+	}
 
-		at76_dbg(DBG_TX_MGMT, &quot;%s: tx mgmt: wlen %d tx_rate %d pad %d %s&quot;,
-		         dev-&gt;netdev-&gt;name, le16_to_cpu(txbuf-&gt;wlength),
-		         txbuf-&gt;tx_rate, txbuf-&gt;padding,
-		         hex2str(dev-&gt;obuf, txbuf-&gt;packet,
-			    min((sizeof(dev-&gt;obuf) - 1) / 2,
-				(size_t) le16_to_cpu(txbuf-&gt;wlength)), '\0'));
+	/* change to scanning state */
+	dev-&gt;istate = SCANNING;
+	schedule_work(&amp;dev-&gt;work_scan);
 
-		/* txbuf was not consumed above -&gt; send mgmt msg immediately */
-		memcpy(dev-&gt;bulk_out_buffer, txbuf,
-		       le16_to_cpu(txbuf-&gt;wlength) + AT76_TX_HDRLEN);
-		usb_fill_bulk_urb(dev-&gt;write_urb, dev-&gt;udev,
-				  usb_sndbulkpipe(dev-&gt;udev,
-						  dev-&gt;bulk_out_endpointAddr),
-				  dev-&gt;bulk_out_buffer,
-				  le16_to_cpu(txbuf-&gt;wlength) +
-				  txbuf-&gt;padding +
-				  AT76_TX_HDRLEN,
-				  at76_write_bulk_callback,
-				  dev);
-		ret = usb_submit_urb(dev-&gt;write_urb, GFP_ATOMIC);
-		if (ret) {
-			err(&quot;%s: %s error in tx submit urb: %d&quot;,
-			    dev-&gt;netdev-&gt;name, __FUNCTION__, ret);
+	return ret;
+}
+
+
+static int at76_iw_handler_get_scan(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	unsigned long flags;
+	struct list_head *lptr, *nptr;
+	struct bss_info *curr_bss;
+	struct iw_event *iwe = kmalloc(sizeof(struct iw_event), GFP_KERNEL);
+	char *curr_val, *curr_pos = extra;
+	int i;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWSCAN&quot;, netdev-&gt;name);
+
+	if (!iwe)
+		return -ENOMEM;
+
+	if (dev-&gt;scan_state != SCAN_COMPLETED)
+		/* scan not yet finished */
+		return -EAGAIN;
+
+	spin_lock_irqsave(&amp;(dev-&gt;bss_list_spinlock), flags);
+
+	list_for_each_safe(lptr, nptr, &amp;(dev-&gt;bss_list)) {
+		curr_bss = list_entry(lptr, struct bss_info, list);
+
+		iwe-&gt;cmd = SIOCGIWAP;
+		iwe-&gt;u.ap_addr.sa_family = ARPHRD_ETHER;
+		memcpy(iwe-&gt;u.ap_addr.sa_data, curr_bss-&gt;bssid, 6);
+		curr_pos = iwe_stream_add_event(curr_pos,
+						extra + IW_SCAN_MAX_DATA, iwe,
+						IW_EV_ADDR_LEN);
+
+		iwe-&gt;u.data.length = curr_bss-&gt;ssid_len;
+		iwe-&gt;cmd = SIOCGIWESSID;
+		iwe-&gt;u.data.flags = 1;
+
+		curr_pos = iwe_stream_add_point(curr_pos,
+			extra + IW_SCAN_MAX_DATA, iwe, curr_bss-&gt;ssid);
+
+		iwe-&gt;cmd = SIOCGIWMODE;
+		iwe-&gt;u.mode = (curr_bss-&gt;capa &amp; WLAN_CAPABILITY_IBSS) ?
+		    IW_MODE_ADHOC :
+		    (curr_bss-&gt;capa &amp; WLAN_CAPABILITY_ESS) ?
+		    IW_MODE_MASTER : IW_MODE_AUTO;
+		/* IW_MODE_AUTO = 0 which I thought is
+		 * the most logical value to return in this case */
+		curr_pos = iwe_stream_add_event(curr_pos,
+						extra + IW_SCAN_MAX_DATA, iwe,
+						IW_EV_UINT_LEN);
+
+		iwe-&gt;cmd = SIOCGIWFREQ;
+		iwe-&gt;u.freq.m = curr_bss-&gt;channel;
+		iwe-&gt;u.freq.e = 0;
+		curr_pos = iwe_stream_add_event(curr_pos,
+						extra + IW_SCAN_MAX_DATA, iwe,
+						IW_EV_FREQ_LEN);
+
+		iwe-&gt;cmd = SIOCGIWENCODE;
+		if (curr_bss-&gt;capa &amp; WLAN_CAPABILITY_PRIVACY) {
+			iwe-&gt;u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+		} else {
+			iwe-&gt;u.data.flags = IW_ENCODE_DISABLED;
 		}
-		kfree(txbuf);
+		iwe-&gt;u.data.length = 0;
+		curr_pos = iwe_stream_add_point(curr_pos,
+						extra + IW_SCAN_MAX_DATA, iwe,
+						NULL);
+
+		/* Add quality statistics */
+		iwe-&gt;cmd = IWEVQUAL;
+		iwe-&gt;u.qual.noise = 0;
+		iwe-&gt;u.qual.updated =
+		    IW_QUAL_NOISE_INVALID | IW_QUAL_LEVEL_UPDATED;
+		iwe-&gt;u.qual.level = (curr_bss-&gt;rssi * 100 / 42);
+		if (iwe-&gt;u.qual.level &gt; 100)
+			iwe-&gt;u.qual.level = 100;
+		if ((dev-&gt;board_type == BOARDTYPE_503_INTERSIL_3861) ||
+		    (dev-&gt;board_type == BOARDTYPE_503_INTERSIL_3863)) {
+			iwe-&gt;u.qual.qual = curr_bss-&gt;link_qual;
+		} else {
+			iwe-&gt;u.qual.qual = 0;
+			iwe-&gt;u.qual.updated |= IW_QUAL_QUAL_INVALID;
+		}
+		/* Add new value to event */
+		curr_pos = iwe_stream_add_event(curr_pos,
+						extra + IW_SCAN_MAX_DATA, iwe,
+						IW_EV_QUAL_LEN);
+
+		/* Rate : stuffing multiple values in a single event require a bit
+		 * more of magic - Jean II */
+		curr_val = curr_pos + IW_EV_LCP_LEN;
+
+		iwe-&gt;cmd = SIOCGIWRATE;
+		/* Those two flags are ignored... */
+		iwe-&gt;u.bitrate.fixed = iwe-&gt;u.bitrate.disabled = 0;
+		/* Max 8 values */
+		for (i = 0; i &lt; curr_bss-&gt;rates_len; i++) {
+			/* Bit rate given in 500 kb/s units (+ 0x80) */
+			iwe-&gt;u.bitrate.value =
+			    ((curr_bss-&gt;rates[i] &amp; 0x7f) * 500000);
+			/* Add new value to event */
+			curr_val = iwe_stream_add_value(curr_pos, curr_val,
+							extra +
+							IW_SCAN_MAX_DATA, iwe,
+							IW_EV_PARAM_LEN);
+		}
+
+		/* Check if we added any event */
+		if ((curr_val - curr_pos) &gt; IW_EV_LCP_LEN)
+			curr_pos = curr_val;
+
+		/* more information may be sent back using IWECUSTOM */
+
 	}
-	/* if (txbuf) */
+
+	spin_unlock_irqrestore(&amp;(dev-&gt;bss_list_spinlock), flags);
+
+	data-&gt;length = (curr_pos - extra);
+	data-&gt;flags = 0;
+
+	kfree(iwe);
+	return 0;
+}
+
+
+static int at76_iw_handler_set_essid(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWESSID - %s&quot;, netdev-&gt;name, extra);
+
+	if (data-&gt;flags) {
+		memcpy(dev-&gt;essid, extra, data-&gt;length);
+		dev-&gt;essid_size = data-&gt;length;
+	} else {
+		/* Use any SSID */
+		dev-&gt;essid_size = 0;
+	}
+
+	return -EIWCOMMIT;
+}
+
+
+static int at76_iw_handler_get_essid(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_point *data, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	if (dev-&gt;essid_size) {
+		/* not the ANY ssid in dev-&gt;essid */
+		data-&gt;flags = 1;
+		data-&gt;length = dev-&gt;essid_size;
+		memcpy(extra, dev-&gt;essid, data-&gt;length);
+		extra[data-&gt;length] = '\0';
+		data-&gt;length += 1;
+	} else {
+		/* the ANY ssid was specified */
+		if (dev-&gt;istate == CONNECTED &amp;&amp; dev-&gt;curr_bss != NULL) {
+			/* report the SSID we have found */
+			data-&gt;flags = 1;
+			data-&gt;length = dev-&gt;curr_bss-&gt;ssid_len;
+			memcpy(extra, dev-&gt;curr_bss-&gt;ssid, data-&gt;length);
+			extra[dev-&gt;curr_bss-&gt;ssid_len] = '\0';
+			data-&gt;length += 1;
+		} else {
+			/* report ANY back */
+			data-&gt;flags = 0;
+			data-&gt;length = 0;
+		}
+	}
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWESSID - %s&quot;, netdev-&gt;name, extra);
+
+	return 0;
+}
+
+
+static int at76_iw_handler_set_rate(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_param *bitrate, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWRATE - %d&quot;, netdev-&gt;name, bitrate-&gt;value);
+
+	switch (bitrate-&gt;value) {
+	case -1:
+		dev-&gt;txrate = TX_RATE_AUTO;
+		break;		/* auto rate */
+	case 1000000:
+		dev-&gt;txrate = TX_RATE_1MBIT;
+		break;
+	case 2000000:
+		dev-&gt;txrate = TX_RATE_2MBIT;
+		break;
+	case 5500000:
+		dev-&gt;txrate = TX_RATE_5_5MBIT;
+		break;
+	case 11000000:
+		dev-&gt;txrate = TX_RATE_11MBIT;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
 	return ret;
+}
+
+
+static int at76_iw_handler_get_rate(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_param *bitrate, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = 0;
+
+	switch (dev-&gt;txrate) {
+		/* return max rate if RATE_AUTO */
+	case TX_RATE_AUTO:
+		bitrate-&gt;value = 11000000;
+		break;
+	case TX_RATE_1MBIT:
+		bitrate-&gt;value = 1000000;
+		break;
+	case TX_RATE_2MBIT:
+		bitrate-&gt;value = 2000000;
+		break;
+	case TX_RATE_5_5MBIT:
+		bitrate-&gt;value = 5500000;
+		break;
+	case TX_RATE_11MBIT:
+		bitrate-&gt;value = 11000000;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	bitrate-&gt;fixed = (dev-&gt;txrate != TX_RATE_AUTO);
+	bitrate-&gt;disabled = 0;
 
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWRATE - %d&quot;, netdev-&gt;name,
+	         bitrate-&gt;value);
+
+	return ret;
 }
 
-/* Go to the next information element */
-static inline void next_ie(struct ieee80211_info_element **ie)
+
+static int at76_iw_handler_set_rts(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_param *rts, char *extra)
 {
-	*ie = (struct ieee80211_info_element *)(&amp;(*ie)-&gt;data[(*ie)-&gt;len]);
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = -EIWCOMMIT;
+	int rthr = rts-&gt;value;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWRTS - value %d disabled %s&quot;,
+		 netdev-&gt;name, rts-&gt;value, (rts-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
+
+	if (rts-&gt;disabled)
+		rthr = MAX_RTS_THRESHOLD;
+
+	if ((rthr &lt; 0) || (rthr &gt; MAX_RTS_THRESHOLD)) {
+		ret = -EINVAL;
+	} else {
+		dev-&gt;rts_threshold = rthr;
+	}
+
+	return ret;
 }
 
-static int at76_disassoc_req(struct at76_priv *dev, struct bss_info *bss)
+
+static int at76_iw_handler_get_rts(struct net_device *netdev,
+				   struct iw_request_info *info,
+				   struct iw_param *rts, char *extra)
 {
-	struct at76_tx_buffer *tx_buffer;
-	struct ieee80211_hdr_3addr *mgmt;
-	struct ieee80211_disassoc *req;
+	struct at76_priv *dev = netdev_priv(netdev);
 
-	at76_assert(bss != NULL);
-	if (bss == NULL)
-		return -EFAULT;
+	rts-&gt;value = dev-&gt;rts_threshold;
+	rts-&gt;disabled = (rts-&gt;value &gt;= MAX_RTS_THRESHOLD);
+	rts-&gt;fixed = 1;
 
-	tx_buffer = kmalloc(DISASSOC_FRAME_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
-	if (!tx_buffer)
-		return -ENOMEM;
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWRTS - value %d disabled %s&quot;,
+	         netdev-&gt;name, rts-&gt;value, (rts-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
 
-	req = (struct ieee80211_disassoc *)(&amp;tx_buffer-&gt;packet);
-	mgmt = &amp;req-&gt;header;
+	return 0;
+}
 
-	/* make wireless header */
-	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_AUTH);
-	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
-	memcpy(mgmt-&gt;addr1, bss-&gt;bssid, ETH_ALEN);
-	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
-	memcpy(mgmt-&gt;addr3, bss-&gt;bssid, ETH_ALEN);
-	mgmt-&gt;seq_ctl = cpu_to_le16(0);
 
-	req-&gt;reason = 0;
+static int at76_iw_handler_set_frag(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_param *frag, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = -EIWCOMMIT;
+	int fthr = frag-&gt;value;
 
-	/* init. at76_priv tx header */
-	tx_buffer-&gt;wlength = cpu_to_le16(DISASSOC_FRAME_SIZE - AT76_TX_HDRLEN);
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWFRAG - value %d, disabled %s&quot;,
+	         netdev-&gt;name, frag-&gt;value, (frag-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
 
-	at76_dbg(DBG_TX_MGMT, &quot;%s: DisAssocReq bssid %s&quot;,
-	         dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3));
+	if (frag-&gt;disabled)
+		fthr = MAX_FRAG_THRESHOLD;
 
-	/* either send immediately (if no data tx is pending
-	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	if ((fthr &lt; MIN_FRAG_THRESHOLD) || (fthr &gt; MAX_FRAG_THRESHOLD)) {
+		ret = -EINVAL;
+	} else {
+		dev-&gt;frag_threshold = fthr &amp; ~0x1; /* get an even value */
+	}
 
+	return ret;
 }
 
-/* challenge is the challenge string (in TLV format)
-   we got with seq_nr 2 for shared secret authentication only and
-   send in seq_nr 3 WEP encrypted to prove we have the correct WEP key;
-   otherwise it is NULL */
-static int at76_auth_req(struct at76_priv *dev, struct bss_info *bss, int seq_nr,
-		    struct ieee80211_info_element *challenge)
+
+static int at76_iw_handler_get_frag(struct net_device *netdev,
+				    struct iw_request_info *info,
+				    struct iw_param *frag, char *extra)
 {
-	struct at76_tx_buffer *tx_buffer;
-	struct ieee80211_hdr_3addr *mgmt;
-	struct ieee80211_auth *req;
-	int buf_len = (seq_nr != 3 ? AUTH_FRAME_SIZE :
-		       AUTH_FRAME_SIZE + 1 + 1 + challenge-&gt;len);
+	struct at76_priv *dev = netdev_priv(netdev);
 
-	at76_assert(bss != NULL);
-	at76_assert(seq_nr != 3 || challenge != NULL);
-	tx_buffer = kmalloc(buf_len + MAX_PADDING_SIZE, GFP_ATOMIC);
-	if (!tx_buffer)
-		return -ENOMEM;
+	frag-&gt;value = dev-&gt;frag_threshold;
+	frag-&gt;disabled = (frag-&gt;value &gt;= MAX_FRAG_THRESHOLD);
+	frag-&gt;fixed = 1;
 
-	req = (struct ieee80211_auth *)(&amp;tx_buffer-&gt;packet);
-	mgmt = &amp;req-&gt;header;
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWFRAG - value %d, disabled %s&quot;,
+	         netdev-&gt;name, frag-&gt;value, (frag-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
 
-	/* make wireless header */
-	/* first auth msg is not encrypted, only the second (seq_nr == 3) */
-	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH |
-		(seq_nr == 3 ? IEEE80211_FCTL_PROTECTED : 0));
+	return 0;
+}
 
-	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
-	memcpy(mgmt-&gt;addr1, bss-&gt;bssid, ETH_ALEN);
-	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
-	memcpy(mgmt-&gt;addr3, bss-&gt;bssid, ETH_ALEN);
-	mgmt-&gt;seq_ctl = cpu_to_le16(0);
 
-	req-&gt;algorithm = cpu_to_le16(dev-&gt;auth_mode);
-	req-&gt;transaction = cpu_to_le16(seq_nr);
-	req-&gt;status = cpu_to_le16(0);
+static int at76_iw_handler_get_txpow(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_param *power, char *extra)
+{
+	power-&gt;value = 15;
+	power-&gt;fixed = 1;	/* No power control */
+	power-&gt;disabled = 0;
+	power-&gt;flags = IW_TXPOW_DBM;
 
-	if (seq_nr == 3)
-		memcpy(req-&gt;info_element, challenge, 1 + 1 + challenge-&gt;len);
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWTXPOW - txpow %d dBm&quot;, netdev-&gt;name,
+	         power-&gt;value);
 
-	/* init. at76_priv tx header */
-	tx_buffer-&gt;wlength = cpu_to_le16(buf_len - AT76_TX_HDRLEN);
-	at76_dbg(DBG_TX_MGMT, &quot;%s: AuthReq bssid %s alg %d seq_nr %d&quot;,
-	         dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3),
-	         le16_to_cpu(req-&gt;algorithm), le16_to_cpu(req-&gt;transaction));
-	if (seq_nr == 3) {
-		at76_dbg(DBG_TX_MGMT, &quot;%s: AuthReq challenge: %s ...&quot;,
-		         dev-&gt;netdev-&gt;name,
-		         hex2str(dev-&gt;obuf, req-&gt;info_element,
-		             min((int)sizeof(dev-&gt;obuf) / 3, 18), ' '));
+	return 0;
+}
+
+
+/* jal: short retry is handled by the firmware (at least 0.90.x),
+   while long retry is not (?) */
+static int at76_iw_handler_set_retry(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_param *retry, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWRETRY disabled %d  flags x%x val %d&quot;,
+	         netdev-&gt;name, retry-&gt;disabled, retry-&gt;flags, retry-&gt;value);
+
+	if (!retry-&gt;disabled &amp;&amp; (retry-&gt;flags &amp; IW_RETRY_LIMIT)) {
+		if ((retry-&gt;flags &amp; IW_RETRY_MIN) ||
+		    !(retry-&gt;flags &amp; IW_RETRY_MAX)) {
+			dev-&gt;short_retry_limit = retry-&gt;value;
+		} else
+			ret = -EINVAL;
+	} else {
+		ret = -EINVAL;
 	}
 
-	/* either send immediately (if no data tx is pending
-	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	return ret;
+}
+
+
+/* adapted (ripped) from atmel.c */
+static int at76_iw_handler_get_retry(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_param *retry, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWRETRY&quot;, netdev-&gt;name);
+
+	retry-&gt;disabled = 0;      /* Can't be disabled */
+
 
+	retry-&gt;flags = IW_RETRY_LIMIT;
+	retry-&gt;value = dev-&gt;short_retry_limit;
+
+	return 0;
 }
 
-static int at76_assoc_req(struct at76_priv *dev, struct bss_info *bss)
+
+static int at76_iw_handler_set_encode(struct net_device *netdev,
+				      struct iw_request_info *info,
+				      struct iw_point *encoding,
+				      char *extra)
 {
-	struct at76_tx_buffer *tx_buffer;
-	struct ieee80211_hdr_3addr *mgmt;
-	struct ieee80211_assoc_request *req;
-	struct ieee80211_info_element *tlv;
+	struct at76_priv *dev = netdev_priv(netdev);
+	int index = (encoding-&gt;flags &amp; IW_ENCODE_INDEX) - 1;
+	int len = encoding-&gt;length;
 
-	at76_assert(bss != NULL);
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWENCODE - enc.flags %08x &quot;
+	         &quot;pointer %p len %d&quot;, netdev-&gt;name, encoding-&gt;flags,
+	         encoding-&gt;pointer, encoding-&gt;length);
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWENCODE - old wepstate: enabled %s key_id %d &quot;
+	         &quot;auth_mode %s&quot;,
+	         netdev-&gt;name, (dev-&gt;wep_enabled) ? &quot;true&quot; : &quot;false&quot;,
+	         dev-&gt;wep_key_id,
+	         (dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ? &quot;restricted&quot; : &quot;open&quot;);
 
-	tx_buffer = kmalloc(ASSOCREQ_MAX_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
-	if (!tx_buffer)
-		return -ENOMEM;
+	/* take the old default key if index is invalid */
+	if ((index &lt; 0) || (index &gt;= WEP_KEYS))
+		index = dev-&gt;wep_key_id;
 
-	req = (struct ieee80211_assoc_request *)(&amp;tx_buffer-&gt;packet);
-	mgmt = &amp;req-&gt;header;
-	tlv = req-&gt;info_element;
+	if (len &gt; 0) {
+		if (len &gt; WEP_LARGE_KEY_LEN)
+			len = WEP_LARGE_KEY_LEN;
 
-	/* make wireless header */
-	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_ASSOC_REQ);
+		memset(dev-&gt;wep_keys[index], 0, WEP_KEY_LEN);
+		memcpy(dev-&gt;wep_keys[index], extra, len);
+		dev-&gt;wep_keys_len[index] = (len &lt;= WEP_SMALL_KEY_LEN) ?
+		    WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN;
+		dev-&gt;wep_enabled = 1;
+	}
 
-	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
-	memcpy(mgmt-&gt;addr1, bss-&gt;bssid, ETH_ALEN);
-	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
-	memcpy(mgmt-&gt;addr3, bss-&gt;bssid, ETH_ALEN);
-	mgmt-&gt;seq_ctl = cpu_to_le16(0);
+	dev-&gt;wep_key_id = index;
+	dev-&gt;wep_enabled = ((encoding-&gt;flags &amp; IW_ENCODE_DISABLED) == 0);
 
-	/* we must set the Privacy bit in the capabilities to assure an
-	   Agere-based AP with optional WEP transmits encrypted frames
-	   to us.  AP only set the Privacy bit in their capabilities
-	   if WEP is mandatory in the BSS! */
-	req-&gt;capability = cpu_to_le16(bss-&gt;capa |
-				      (dev-&gt;wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
-				      (dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT ?
-				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+	if (encoding-&gt;flags &amp; IW_ENCODE_RESTRICTED)
+		dev-&gt;auth_mode = WLAN_AUTH_SHARED_KEY;
+	if (encoding-&gt;flags &amp; IW_ENCODE_OPEN)
+		dev-&gt;auth_mode = WLAN_AUTH_OPEN;
 
-	req-&gt;listen_interval = cpu_to_le16(2 * bss-&gt;beacon_interval);
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWENCODE - new wepstate: enabled %s key_id %d &quot;
+	         &quot;key_len %d auth_mode %s&quot;,
+	         netdev-&gt;name, (dev-&gt;wep_enabled) ? &quot;true&quot; : &quot;false&quot;,
+	         dev-&gt;wep_key_id + 1, dev-&gt;wep_keys_len[dev-&gt;wep_key_id],
+	         (dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ? &quot;restricted&quot; : &quot;open&quot;);
 
-	/* write TLV data elements */
+	return -EIWCOMMIT;
+}
 
-	tlv-&gt;id = MFIE_TYPE_SSID;
-	tlv-&gt;len = bss-&gt;ssid_len;
-	memcpy(tlv-&gt;data, bss-&gt;ssid, bss-&gt;ssid_len);
-	next_ie(&amp;tlv);
 
-	tlv-&gt;id = MFIE_TYPE_RATES;
-	tlv-&gt;len = sizeof(hw_rates);
-	memcpy(tlv-&gt;data, hw_rates, sizeof(hw_rates));
-	next_ie(&amp;tlv);		/* tlv points behind the supp_rates field */
+static int at76_iw_handler_get_encode(struct net_device *netdev,
+				      struct iw_request_info *info,
+				      struct iw_point *encoding,
+				      char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int index = (encoding-&gt;flags &amp; IW_ENCODE_INDEX) - 1;
 
-	/* init. at76_priv tx header */
-	tx_buffer-&gt;wlength = cpu_to_le16((u8 *) tlv - (u8 *) mgmt);
+	if ((index &lt; 0) || (index &gt;= WEP_KEYS))
+		index = dev-&gt;wep_key_id;
 
-	{
-		/* output buffer for ssid and rates */
-		char orates[4 * 2 + 1];
-		int len;
+	encoding-&gt;flags =
+	    (dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ?
+	    IW_ENCODE_RESTRICTED : IW_ENCODE_OPEN;
 
-		tlv = req-&gt;info_element;
-		len = min_t(int, IW_ESSID_MAX_SIZE, tlv-&gt;len);
-		memcpy(dev-&gt;obuf, tlv-&gt;data, len);
-		dev-&gt;obuf[len] = '\0';
-		next_ie(&amp;tlv); /* points to IE of rates now */
-		at76_dbg(DBG_TX_MGMT, &quot;%s: AssocReq bssid %s capa x%04x ssid %s rates %s&quot;,
-		         dev-&gt;netdev-&gt;name, mac2str(mgmt-&gt;addr3),
-		         le16_to_cpu(req-&gt;capability), dev-&gt;obuf,
-		         hex2str(orates,tlv-&gt;data,min((sizeof(orates)-1)/2,(size_t)tlv-&gt;len),
-			    '\0'));
+	if (!dev-&gt;wep_enabled)
+		encoding-&gt;flags |= IW_ENCODE_DISABLED;
+
+	if (encoding-&gt;pointer) {
+		encoding-&gt;length = dev-&gt;wep_keys_len[index];
+
+		memcpy(extra, dev-&gt;wep_keys[index], dev-&gt;wep_keys_len[index]);
+
+		encoding-&gt;flags |= (index + 1);
 	}
 
-	/* either send immediately (if no data tx is pending
-	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWENCODE - enc.flags %08x &quot;
+		&quot;pointer %p len %d&quot;, netdev-&gt;name, encoding-&gt;flags,
+		encoding-&gt;pointer, encoding-&gt;length);
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWENCODE - wepstate: enabled %s key_id %d &quot;
+		&quot;key_len %d auth_mode %s&quot;,
+		netdev-&gt;name, (dev-&gt;wep_enabled) ? &quot;true&quot; : &quot;false&quot;,
+		dev-&gt;wep_key_id + 1, dev-&gt;wep_keys_len[dev-&gt;wep_key_id],
+		(dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ?
+			&quot;restricted&quot; : &quot;open&quot;);
 
+	return 0;
 }
 
-/* we are currently associated to curr_bss and
-   want to reassoc to new_bss */
-static int at76_reassoc_req(struct at76_priv *dev, struct bss_info *curr_bss,
-		            struct bss_info *new_bss)
+
+static int at76_iw_handler_set_power(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_param *prq, char *extra)
 {
-	struct at76_tx_buffer *tx_buffer;
-	struct ieee80211_hdr_3addr *mgmt;
-	struct ieee80211_reassoc_request *req;
-	struct ieee80211_info_element *tlv;
+	int err = -EIWCOMMIT;
+	struct at76_priv *dev = netdev_priv(netdev);
 
-	at76_assert(curr_bss != NULL);
-	at76_assert(new_bss != NULL);
-	if (curr_bss == NULL || new_bss == NULL)
-		return -EFAULT;
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWPOWER - disabled %s flags x%x value x%x&quot;,
+		 netdev-&gt;name, (prq-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;,
+		 prq-&gt;flags, prq-&gt;value);
 
-	tx_buffer = kmalloc(REASSOCREQ_MAX_SIZE + MAX_PADDING_SIZE, GFP_ATOMIC);
-	if (!tx_buffer)
-		return -ENOMEM;
+	if (prq-&gt;disabled) {
+		dev-&gt;pm_mode = AT76_PM_OFF;
+	} else {
+		switch (prq-&gt;flags &amp; IW_POWER_MODE) {
+                case IW_POWER_ALL_R:
+		case IW_POWER_ON:
+                        break;
+		default:
+			err = -EINVAL;
+			goto out;
+		}
+		if (prq-&gt;flags &amp; IW_POWER_PERIOD) {
+			dev-&gt;pm_period = prq-&gt;value;
+		}
+		if (prq-&gt;flags &amp; IW_POWER_TIMEOUT) {
+			err = -EINVAL;
+			goto out;
+		}
+		dev-&gt;pm_mode = AT76_PM_ON;
+	}
+out:
+	return err;
+}
 
-	req = (struct ieee80211_reassoc_request *)(&amp;tx_buffer-&gt;packet);
-	mgmt = &amp;req-&gt;header;
-	tlv = req-&gt;info_element;
 
-	/* make wireless header */
-	/* jal: encrypt this packet if wep_enabled is TRUE ??? */
-	mgmt-&gt;frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT|IEEE80211_STYPE_REASSOC_REQ);
-	mgmt-&gt;duration_id = cpu_to_le16(0x8000);
-	memcpy(mgmt-&gt;addr1, new_bss-&gt;bssid, ETH_ALEN);
-	memcpy(mgmt-&gt;addr2, dev-&gt;netdev-&gt;dev_addr, ETH_ALEN);
-	memcpy(mgmt-&gt;addr3, new_bss-&gt;bssid, ETH_ALEN);
-	mgmt-&gt;seq_ctl = cpu_to_le16(0);
+static int at76_iw_handler_get_power(struct net_device *netdev,
+				     struct iw_request_info *info,
+				     struct iw_param *power, char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
 
-	/* we must set the Privacy bit in the capabilities to assure an
-	   Agere-based AP with optional WEP transmits encrypted frames
-	   to us.  AP only set the Privacy bit in their capabilities
-	   if WEP is mandatory in the BSS! */
-	req-&gt;capability = cpu_to_le16(new_bss-&gt;capa |
-				      (dev-&gt;wep_enabled ? WLAN_CAPABILITY_PRIVACY : 0) |
-				      (dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT ?
-				       WLAN_CAPABILITY_SHORT_PREAMBLE : 0));
+	if ((power-&gt;disabled = (dev-&gt;pm_mode == AT76_PM_OFF)))
+		return 0;
+	else {
+		power-&gt;flags = IW_POWER_PERIOD;
+		power-&gt;value = dev-&gt;pm_period;
+	}
+	power-&gt;flags |= IW_POWER_ALL_R;
 
-	req-&gt;listen_interval = cpu_to_le16(2 * new_bss-&gt;beacon_interval);
+	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWPOWER - disabled %s flags x%x value x%x&quot;,
+		 netdev-&gt;name, (power-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;,
+		 power-&gt;flags, power-&gt;value);
 
-	memcpy(req-&gt;current_ap, curr_bss-&gt;bssid, ETH_ALEN);
+	return 0;
+}
 
-	/* write TLV data elements */
-	tlv-&gt;id = MFIE_TYPE_SSID;
-	tlv-&gt;len = new_bss-&gt;ssid_len;
-	memcpy(tlv-&gt;data, new_bss-&gt;ssid, new_bss-&gt;ssid_len);
-	next_ie(&amp;tlv);
 
-	tlv-&gt;id = MFIE_TYPE_RATES;
-	tlv-&gt;len = sizeof(hw_rates);
-	memcpy(tlv-&gt;data, hw_rates, sizeof(hw_rates));
-	/* tlv points behind the supp_rates field */
-	next_ie(&amp;tlv);
+/*******************************************************************************
+ * Private IOCTLS
+ */
+static int at76_iw_set_short_preamble(struct net_device *netdev,
+				      struct iw_request_info *info, char *name,
+				      char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
 
-	/* init. at76_priv tx header */
-	tx_buffer-&gt;wlength = cpu_to_le16((u8 *)tlv-(u8 *)mgmt);
+	at76_dbg(DBG_IOCTL, &quot;%s: AT76_SET_SHORT_PREAMBLE, %d&quot;,
+	         netdev-&gt;name, val);
+
+	if (val &lt; 0 || val &gt; 2) {
+		/* allow value of 2 - in the win98 driver it stands
+		   for &quot;auto preamble&quot; ...? */
+		ret = -EINVAL;
+	} else {
+		dev-&gt;preamble_type = val;
+	}
+
+	return ret;
+}
+
+
+static int at76_iw_set_debug(struct net_device *netdev,
+			     struct iw_request_info *info,
+			     struct iw_point *data, char *extra)
+{
+	char *ptr;
+	u32 val;
+
+	if (data-&gt;length &gt; 0) {
+		val = simple_strtol(extra, &amp;ptr, 0);
+
+		if (ptr == extra) {
+			val = DBG_DEFAULTS;
+		}
+
+		dbg(&quot;%s: AT76_SET_DEBUG input %d: %s -&gt; x%x&quot;,
+		       netdev-&gt;name, data-&gt;length, extra, val);
+	} else {
+		val = DBG_DEFAULTS;
+	}
+
+	dbg(&quot;%s: AT76_SET_DEBUG, old 0x%x  new 0x%x&quot;,
+	       netdev-&gt;name, at76_debug, val);
+
+	/* jal: some more output to pin down lockups */
+	dbg(&quot;%s: netif running %d queue_stopped %d carrier_ok %d&quot;,
+	       netdev-&gt;name,
+	       netif_running(netdev),
+	       netif_queue_stopped(netdev), netif_carrier_ok(netdev));
+
+	at76_debug = val;
+
+	return 0;
+}
+
+
+static int at76_iw_set_powersave_mode(struct net_device *netdev,
+				      struct iw_request_info *info, char *name,
+				      char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: AT76_SET_POWERSAVE_MODE, %d (%s)&quot;,
+	         netdev-&gt;name, val,
+	         val == AT76_PM_OFF ? &quot;active&quot; : val == AT76_PM_ON ? &quot;save&quot; :
+	         val == AT76_PM_SMART ? &quot;smart save&quot; : &quot;&lt;invalid&gt;&quot;);
+	if (val &lt; AT76_PM_OFF || val &gt; AT76_PM_SMART) {
+		ret = -EINVAL;
+	} else {
+		dev-&gt;pm_mode = val;
+	}
+
+	return ret;
+}
+
+
+static int at76_iw_set_scan_times(struct net_device *netdev,
+				  struct iw_request_info *info, char *name,
+				  char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int mint = *((int *)name);
+	int maxt = *((int *)name + 1);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: AT76_SET_SCAN_TIMES - min %d max %d&quot;,
+	         netdev-&gt;name, mint, maxt);
+	if (mint &lt;= 0 || maxt &lt;= 0 || mint &gt; maxt) {
+		ret = -EINVAL;
+	} else {
+		if (dev-&gt;istate == MONITORING) {
+			dev-&gt;monitor_scan_min_time = mint;
+			dev-&gt;monitor_scan_max_time = maxt;
+			ret = 0;
+		} else {
+			dev-&gt;scan_min_time = mint;
+			dev-&gt;scan_max_time = maxt;
+		}
+	}
+
+	return ret;
+}
+
+
+static int at76_iw_set_scan_mode(struct net_device *netdev,
+				 struct iw_request_info *info, char *name,
+				 char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: AT76_SET_SCAN_MODE - mode %s&quot;,
+		 netdev-&gt;name, (val = SCAN_TYPE_ACTIVE) ? &quot;active&quot; :
+		 (val = SCAN_TYPE_PASSIVE) ? &quot;passive&quot; : &quot;&lt;invalid&gt;&quot;);
+
+	if (val != SCAN_TYPE_ACTIVE &amp;&amp; val != SCAN_TYPE_PASSIVE) {
+		ret = -EINVAL;
+	} else {
+		dev-&gt;scan_mode = val;
+	}
+
+	return ret;
+}
+
+
+static int at76_set_iroaming(struct at76_priv *dev, int onoff)
+{
+	int ret = 0;
+
+	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
+	dev-&gt;mib_buf.type = MIB_MAC_MGMT;
+	dev-&gt;mib_buf.size = 1;
+	dev-&gt;mib_buf.index = IROAMING_OFFSET;
+	dev-&gt;mib_buf.data[0] = (dev-&gt;international_roaming ? 1 : 0);
+	ret = at76_set_mib(dev, &amp;dev-&gt;mib_buf);
+	if (ret &lt; 0) {
+		err(&quot;%s: set_mib (intl_roaming_enable) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+
+	return ret;
+}
+
+
+static int at76_iw_set_intl_roaming(struct net_device *netdev,
+				    struct iw_request_info *info, char *name,
+				    char *extra)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int val = *((int *)name);
+	int ret = -EIWCOMMIT;
+
+	at76_dbg(DBG_IOCTL, &quot;%s: AT76_SET_INTL_ROAMING - mode %s&quot;,
+	         netdev-&gt;name, (val == IR_OFF) ? &quot;off&quot; :
+	         (val == IR_ON) ? &quot;on&quot; : &quot;&lt;invalid&gt;&quot;);
+
+	if (val != IR_OFF &amp;&amp; val != IR_ON) {
+		ret = -EINVAL;
+	} else {
+		if (dev-&gt;international_roaming != val) {
+			dev-&gt;international_roaming = val;
+			at76_set_iroaming(dev, val);
+		}
+	}
+
+	return ret;
+}
+
+
+/*******************************************************************************
+ * structure that advertises the iw handlers of this driver
+ */
+static const iw_handler	at76_handlers[] =
+{
+        [SIOCSIWCOMMIT-SIOCIWFIRST] = (iw_handler) at76_iw_handler_commit,
+        [SIOCGIWNAME  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_name,
+        [SIOCSIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_freq,
+        [SIOCGIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_freq,
+        [SIOCSIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_mode,
+        [SIOCGIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_mode,
+        [SIOCGIWRANGE -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_range,
+        [SIOCSIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_spy,
+        [SIOCGIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_spy,
+        [SIOCSIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_thrspy,
+        [SIOCGIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_thrspy,
+        [SIOCSIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_wap,
+        [SIOCGIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_wap,
+        [SIOCSIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_scan,
+        [SIOCGIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_scan,
+        [SIOCSIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_essid,
+        [SIOCGIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_essid,
+        [SIOCSIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rate,
+        [SIOCGIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rate,
+        [SIOCSIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rts,
+        [SIOCGIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rts,
+        [SIOCSIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_frag,
+        [SIOCGIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_frag,
+        [SIOCGIWTXPOW -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_txpow,
+        [SIOCSIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_retry,
+        [SIOCGIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_retry,
+        [SIOCSIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_encode,
+        [SIOCGIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_encode,
+        [SIOCSIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_power,
+        [SIOCGIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_power,
+};
+
+#define AT76_SET_PRIV(h, f) [h - SIOCIWFIRSTPRIV] = (iw_handler) f
+
+/*structure that advertises the private iw handlers of this driver */
+static const iw_handler at76_priv_handlers[] = {
+	AT76_SET_PRIV(AT76_SET_SHORT_PREAMBLE, at76_iw_set_short_preamble),
+	AT76_SET_PRIV(AT76_SET_DEBUG, at76_iw_set_debug),
+	AT76_SET_PRIV(AT76_SET_POWERSAVE_MODE, at76_iw_set_powersave_mode),
+	AT76_SET_PRIV(AT76_SET_SCAN_TIMES, at76_iw_set_scan_times),
+	AT76_SET_PRIV(AT76_SET_SCAN_MODE, at76_iw_set_scan_mode),
+	AT76_SET_PRIV(AT76_SET_INTL_ROAMING, at76_iw_set_intl_roaming),
+};
+
+
+/*******************************************************************************
+ * structure that describes the private ioctls/iw handlers of this driver
+ */
+static const struct iw_priv_args at76_priv_args[] = {
+	{AT76_SET_SHORT_PREAMBLE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	 &quot;short_preamble&quot;},	/* 0 - long, 1 -short */
+
+	{AT76_SET_DEBUG,
+	 /* we must pass the new debug mask as a string,
+	  * 'cause iwpriv cannot parse hex numbers
+	  * starting with 0x :-(  */
+	 IW_PRIV_TYPE_CHAR | 10, 0,
+	 &quot;set_debug&quot;},		/* set debug value */
+
+	{AT76_SET_POWERSAVE_MODE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	 &quot;powersave_mode&quot;},	/* 1 -  active, 2 - power save,
+				   3 - smart power save */
+	{AT76_SET_SCAN_TIMES,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0,
+	 &quot;scan_times&quot;},		/* min_channel_time,
+				   max_channel_time */
+	{AT76_SET_SCAN_MODE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	 &quot;scan_mode&quot;},		/* 0 - active, 1 - passive scan */
+
+	{AT76_SET_INTL_ROAMING,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
+	 &quot;intl_roaming&quot;},
+};
+
+
+static const struct iw_handler_def at76_handler_def =
+{
+	.num_standard	= ARRAY_SIZE(at76_handlers),
+	.num_private	= ARRAY_SIZE(at76_priv_handlers),
+	.num_private_args = ARRAY_SIZE(at76_priv_args),
+	.standard	= at76_handlers,
+	.private	= at76_priv_handlers,
+	.private_args	= at76_priv_args,
+ 	.get_wireless_stats = at76_get_wireless_stats,
+};
+
+
+/* A short overview on Ethernet-II, 802.2, 802.3 and SNAP
+   (taken from <A HREF="http://www.geocities.com/billalexander/ethernet.html">http://www.geocities.com/billalexander/ethernet.html</A>):
+
+Ethernet Frame Formats:
+
+Ethernet (a.k.a. Ethernet II)
+
+        +---------+---------+---------+----------
+        |   Dst   |   Src   |  Type   |  Data...
+        +---------+---------+---------+----------
+
+         &lt;-- 6 --&gt; &lt;-- 6 --&gt; &lt;-- 2 --&gt; &lt;-46-1500-&gt;
+
+         Type 0x80 0x00 = TCP/IP
+         Type 0x06 0x00 = XNS
+         Type 0x81 0x37 = Novell NetWare
+
+
+802.3
+
+        +---------+---------+---------+----------
+        |   Dst   |   Src   | Length  | Data...
+        +---------+---------+---------+----------
+
+         &lt;-- 6 --&gt; &lt;-- 6 --&gt; &lt;-- 2 --&gt; &lt;-46-1500-&gt;
+
+802.2 (802.3 with 802.2 header)
+
+        +---------+---------+---------+-------+-------+-------+----------
+        |   Dst   |   Src   | Length  | DSAP  | SSAP  |Control| Data...
+        +---------+---------+---------+-------+-------+-------+----------
+
+                                       &lt;- 1 -&gt; &lt;- 1 -&gt; &lt;- 1 -&gt; &lt;-43-1497-&gt;
+
+SNAP (802.3 with 802.2 and SNAP headers)
+
+        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
+        |   Dst   |   Src   | Length  | 0xAA  | 0xAA  | 0x03  |  Org Code |   Type  | Data...
+        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
+
+                                                               &lt;--  3  --&gt; &lt;-- 2 --&gt; &lt;-38-1492-&gt;
+
+*/
+static const u8 snapsig[] = { 0xaa, 0xaa, 0x03 };
+
+/* RFC 1042 encapsulates Ethernet frames in 802.2 SNAP (0xaa, 0xaa, 0x03) with
+ * a SNAP OID of 0 (0x00, 0x00, 0x00) */
+static const u8 rfc1042sig[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+
+
+static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	int ret = 0;
+	int wlen;
+	int submit_len;
+	struct at76_tx_buffer *tx_buffer = dev-&gt;bulk_out_buffer;
+	struct ieee80211_hdr_3addr *i802_11_hdr =
+	    (struct ieee80211_hdr_3addr *)&amp;(tx_buffer-&gt;packet);
+	u8 *payload = tx_buffer-&gt;packet + sizeof(struct ieee80211_hdr_3addr);
+
+	if (netif_queue_stopped(netdev)) {
+		err(&quot;%s: %s called while netdev is stopped&quot;, netdev-&gt;name,
+		    __FUNCTION__);
+		/* skip this packet */
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	if (dev-&gt;write_urb-&gt;status == -EINPROGRESS) {
+		err(&quot;%s: %s called while dev-&gt;write_urb is pending for tx&quot;,
+		    netdev-&gt;name, __FUNCTION__);
+		/* skip this packet */
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	if (skb-&gt;len &lt; 2 * ETH_ALEN) {
+		err(&quot;%s: %s: skb too short (%d)&quot;, dev-&gt;netdev-&gt;name,
+		    __FUNCTION__, skb-&gt;len);
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	at76_ledtrig_tx_activity(); /* tell the ledtrigger we send a packet */
+
+	/* we can get rid of memcpy, if we set netdev-&gt;hard_header_len
+	   to 8 + sizeof(struct ieee80211_hdr_3addr), because then we have
+	   enough space
+	   at76_dbg(DBG_TX, &quot;skb-&gt;data - skb-&gt;head = %d&quot;, skb-&gt;data - skb-&gt;head); */
+
+	if (ntohs(*(__be16 *) (skb-&gt;data + 2 * ETH_ALEN)) &lt;= 1518) {
+		/* this is a 802.3 packet */
+		if (skb-&gt;data[2 * ETH_ALEN + 2] == rfc1042sig[0] &amp;&amp;
+		    skb-&gt;data[2 * ETH_ALEN + 2 + 1] == rfc1042sig[1]) {
+			/* higher layer delivered SNAP header - keep it */
+			memcpy(payload, skb-&gt;data + 2*ETH_ALEN+2, skb-&gt;len - 2*ETH_ALEN -2);
+			wlen = sizeof(struct ieee80211_hdr_3addr) + skb-&gt;len - 2*ETH_ALEN -2;
+		} else {
+			err(&quot;%s: %s: no support for non-SNAP 802.2 packets &quot;
+			    &quot;(DSAP x%02x SSAP x%02x cntrl x%02x)&quot;,
+			    dev-&gt;netdev-&gt;name, __FUNCTION__,
+			    skb-&gt;data[2 * ETH_ALEN + 2],
+			    skb-&gt;data[2 * ETH_ALEN + 2 + 1],
+			    skb-&gt;data[2 * ETH_ALEN + 2 + 2]);
+			dev_kfree_skb(skb);
+			return 0;
+		}
+	} else {
+		/* add RFC 1042 header in front */
+		memcpy(payload, rfc1042sig, sizeof(rfc1042sig));
+		memcpy(payload + sizeof(rfc1042sig),
+		       skb-&gt;data + 2*ETH_ALEN, skb-&gt;len - 2*ETH_ALEN);
+		wlen = sizeof(struct ieee80211_hdr_3addr) + sizeof(rfc1042sig) +
+			skb-&gt;len - 2*ETH_ALEN;
+	}
+
+	/* make wireless header */
+	i802_11_hdr-&gt;frame_ctl =
+	    cpu_to_le16(IEEE80211_FTYPE_DATA |
+			(dev-&gt;wep_enabled ? IEEE80211_FCTL_PROTECTED : 0) |
+			(dev-&gt;iw_mode ==
+			 IW_MODE_INFRA ? IEEE80211_FCTL_TODS : 0));
+
+	if (dev-&gt;iw_mode == IW_MODE_ADHOC) {
+		memcpy(i802_11_hdr-&gt;addr1, skb-&gt;data, ETH_ALEN);	/* destination */
+		memcpy(i802_11_hdr-&gt;addr2, skb-&gt;data + ETH_ALEN, ETH_ALEN);	/* source */
+		memcpy(i802_11_hdr-&gt;addr3, dev-&gt;bssid, ETH_ALEN);
+	} else if (dev-&gt;iw_mode == IW_MODE_INFRA) {
+		memcpy(i802_11_hdr-&gt;addr1, dev-&gt;bssid, ETH_ALEN);
+		memcpy(i802_11_hdr-&gt;addr2, skb-&gt;data + ETH_ALEN, ETH_ALEN);	/* source */
+		memcpy(i802_11_hdr-&gt;addr3, skb-&gt;data, ETH_ALEN);	/* destination */
+	}
+
+	i802_11_hdr-&gt;duration_id = cpu_to_le16(0);
+	i802_11_hdr-&gt;seq_ctl = cpu_to_le16(0);
+
+	/* setup 'Atmel' header */
+	tx_buffer-&gt;wlength = cpu_to_le16(wlen);
+	tx_buffer-&gt;tx_rate = dev-&gt;txrate;
+	/* for broadcast destination addresses, the firmware 0.100.x
+	   seems to choose the highest rate set with CMD_STARTUP in
+	   basic_rate_set replacing this value */
+
+	memset(tx_buffer-&gt;reserved, 0, 4);
+
+	tx_buffer-&gt;padding = at76_calc_padding(wlen);
+	submit_len = wlen + AT76_TX_HDRLEN + tx_buffer-&gt;padding;
 
 	{
-		/* output buffer for rates and bssid */
-		char orates[4*2+1];
-		char ocurr[6*3+1];
-		tlv = req-&gt;info_element;
-		memcpy(dev-&gt;obuf, tlv-&gt;data, min(sizeof(dev-&gt;obuf),(size_t)tlv-&gt;len));
-		dev-&gt;obuf[IW_ESSID_MAX_SIZE] = '\0';
-		next_ie(&amp;tlv); /* points to IE of rates now */
-		at76_dbg(DBG_TX_MGMT, &quot;%s: ReAssocReq curr %s new %s capa x%04x ssid %s rates %s&quot;,
+		at76_dbg(DBG_TX_DATA_CONTENT, &quot;%s skb-&gt;data %s&quot;, dev-&gt;netdev-&gt;name,
+		         hex2str(dev-&gt;obuf, skb-&gt;data,
+			    min((int)(sizeof(dev-&gt;obuf) - 1) / 2, 32), '\0'));
+		at76_dbg(DBG_TX_DATA, &quot;%s tx  wlen x%x pad x%x rate %d hdr %s&quot;,
 		         dev-&gt;netdev-&gt;name,
-		         hex2str(ocurr, req-&gt;current_ap, ETH_ALEN, ':'),
-		         mac2str(mgmt-&gt;addr3), le16_to_cpu(req-&gt;capability), dev-&gt;obuf,
-		         hex2str(orates,tlv-&gt;data,min((sizeof(orates)-1)/2,(size_t)tlv-&gt;len),
-			    '\0'));
+		         le16_to_cpu(tx_buffer-&gt;wlength),
+		         tx_buffer-&gt;padding, tx_buffer-&gt;tx_rate,
+		         hex2str(dev-&gt;obuf, i802_11_hdr,
+			    min((sizeof(dev-&gt;obuf) - 1) / 2,
+				sizeof(struct ieee80211_hdr_3addr)), '\0'));
+		at76_dbg(DBG_TX_DATA_CONTENT, &quot;%s payload %s&quot;, dev-&gt;netdev-&gt;name,
+		         hex2str(dev-&gt;obuf, payload,
+			    min((int)(sizeof(dev-&gt;obuf) - 1) / 2, 48), '\0'));
 	}
 
-	/* either send immediately (if no data tx is pending
-	   or put it in pending list */
-	return at76_send_mgmt_bulk(dev, tx_buffer);
+	/* send stuff */
+	netif_stop_queue(netdev);
+	netdev-&gt;trans_start = jiffies;
+
+	usb_fill_bulk_urb(dev-&gt;write_urb, dev-&gt;udev,
+		         usb_sndbulkpipe(dev-&gt;udev, dev-&gt;bulk_out_endpointAddr),
+		         tx_buffer, submit_len,
+		         at76_write_bulk_callback, dev);
+	ret = usb_submit_urb(dev-&gt;write_urb, GFP_ATOMIC);
+	if (ret) {
+		stats-&gt;tx_errors++;
+		err(&quot;%s: error in tx submit urb: %d&quot;, netdev-&gt;name, ret);
+		if (ret == -EINVAL)
+			err(&quot;-EINVAL: urb %p urb-&gt;hcpriv %p urb-&gt;complete %p&quot;,
+			    dev-&gt;write_urb,
+			    dev-&gt;write_urb ? dev-&gt;write_urb-&gt;hcpriv : (void *)-1,
+			    dev-&gt;write_urb ? dev-&gt;write_urb-&gt;complete : (void *)-1);
+		goto err;
+	}
+
+	stats-&gt;tx_bytes += skb-&gt;len;
+
+	dev_kfree_skb(skb);
+	return 0;
 
+ err:
+	return ret;
 }
 
-/* Called after successful association */
-static void at76_work_assoc_done(struct work_struct *work)
+
+static void at76_tx_timeout(struct net_device *netdev)
 {
-	struct at76_priv *dev = container_of(work, struct at76_priv,
-					     work_assoc_done);
+	struct at76_priv *dev = netdev_priv(netdev);
 
-	down(&amp;dev-&gt;sem);
+	if (!dev)
+		return;
+	warn(&quot;%s: tx timeout.&quot;, netdev-&gt;name);
 
-	at76_assert(dev-&gt;istate == ASSOCIATING || dev-&gt;istate == REASSOCIATING);
-	if (dev-&gt;iw_mode == IW_MODE_INFRA) {
-		at76_assert(dev-&gt;curr_bss != NULL);
-		if (dev-&gt;curr_bss != NULL &amp;&amp; dev-&gt;pm_mode != AT76_PM_OFF) {
-			/* calculate the listen interval in units of
-			   beacon intervals of the curr_bss */
-			u32 pm_period_beacon = (dev-&gt;pm_period &gt;&gt; 10) /
-						dev-&gt;curr_bss-&gt;beacon_interval;
+	usb_unlink_urb(dev-&gt;write_urb);
+	dev-&gt;stats.tx_errors++;
+}
 
-			pm_period_beacon = max(pm_period_beacon, 2u);
-			pm_period_beacon = min(pm_period_beacon, 0xffffu);
 
-			at76_dbg(DBG_PM, &quot;%s: pm_mode %d assoc id x%x listen int %d&quot;,
-			         dev-&gt;netdev-&gt;name, dev-&gt;pm_mode,
-			         dev-&gt;curr_bss-&gt;assoc_id, pm_period_beacon);
+static int at76_submit_rx_urb(struct at76_priv *dev)
+{
+	int ret, size;
+	struct sk_buff *skb = dev-&gt;rx_skb;
 
-			at76_set_associd(dev, dev-&gt;curr_bss-&gt;assoc_id);
-			at76_set_listen_interval(dev, (u16)pm_period_beacon);
+	if (dev-&gt;read_urb == NULL) {
+		err(&quot;%s: dev-&gt;read_urb is NULL&quot;, __FUNCTION__);
+		return -EFAULT;
+	}
+
+	if (skb == NULL) {
+		skb = dev_alloc_skb(sizeof(struct at76_rx_buffer));
+		if (skb == NULL) {
+			err(&quot;%s: unable to allocate rx skbuff.&quot;, dev-&gt;netdev-&gt;name);
+			ret = -ENOMEM;
+			goto exit;
+		}
+		dev-&gt;rx_skb = skb;
+	} else {
+		skb_push(skb, skb_headroom(skb));
+		skb_trim(skb, 0);
+	}
+
+	size = skb_tailroom(skb);
+	usb_fill_bulk_urb(dev-&gt;read_urb, dev-&gt;udev,
+		         usb_rcvbulkpipe(dev-&gt;udev, dev-&gt;bulk_in_endpointAddr),
+		         skb_put(skb, size), size,
+		         at76_read_bulk_callback, dev);
+	ret = usb_submit_urb(dev-&gt;read_urb, GFP_ATOMIC);
+	if (ret &lt; 0) {
+		if (ret == -ENODEV)
+			at76_dbg(DBG_DEVSTART, &quot;usb_submit_urb returned -ENODEV&quot;);
+		else
+			err(&quot;%s: rx, usb_submit_urb failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+	}
+
+exit:
+	if (ret &lt; 0) {
+		if (ret != -ENODEV) {
+			/* If we can't submit the URB, the adapter becomes completely
+			 * useless, so try again later */
+			if (--dev-&gt;nr_submit_rx_tries &gt; 0)
+				schedule_work(&amp;dev-&gt;work_submit_rx);
+			else {
+				err(&quot;%s: giving up to submit rx urb after %d failures -&quot;
+			    	    &quot; please unload the driver and/or power cycle the device&quot;,
+			    	    dev-&gt;netdev-&gt;name, NR_SUBMIT_RX_TRIES);
+			}
+		}
+	} else
+		/* reset counter to initial value */
+		dev-&gt;nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;
+	return ret;
+}
+
+
+static int at76_open(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	int ret = 0;
+
+	at76_dbg(DBG_PROC_ENTRY, &quot;at76_open entry&quot;);
+
+	if (down_interruptible(&amp;dev-&gt;sem))
+		return -EINTR;
+
+	/* if netdev-&gt;dev_addr != dev-&gt;mac_addr we must
+	   set the mac address in the device ! */
+	if (compare_ether_addr(netdev-&gt;dev_addr, dev-&gt;mac_addr)) {
+		if (at76_add_mac_address(dev, netdev-&gt;dev_addr) &gt;= 0)
+			at76_dbg(DBG_PROGRESS, &quot;%s: set new MAC addr %s&quot;,
+			         netdev-&gt;name, mac2str(netdev-&gt;dev_addr));
+	}
 #ifdef DEBUG
-			at76_dump_mib_mac(dev);
-			at76_dump_mib_mac_mgmt(dev);
+	at76_dump_mib_mac_addr(dev);
 #endif
-		}
+
+	dev-&gt;scan_state = SCAN_IDLE;
+	dev-&gt;last_scan = jiffies;
+	dev-&gt;nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;	/* init counter */
+
+	if ((ret = at76_submit_rx_urb(dev)) &lt; 0) {
+		err(&quot;%s: open: submit_rx_urb failed: %d&quot;, netdev-&gt;name, ret);
+		goto err;
 	}
-	at76_set_pm_mode(dev);
 
-	netif_carrier_on(dev-&gt;netdev);
-	netif_wake_queue(dev-&gt;netdev);
-	dev-&gt;istate = CONNECTED;
-	at76_iwevent_bss_connect(dev-&gt;netdev, dev-&gt;curr_bss-&gt;bssid);
-	at76_dbg(DBG_PROGRESS, &quot;%s: connected to BSSID %s&quot;,
-	         dev-&gt;netdev-&gt;name, mac2str(dev-&gt;curr_bss-&gt;bssid));
+	dev-&gt;open_count++;
+
+	schedule_work(&amp;dev-&gt;work_restart);
+
+	at76_dbg(DBG_PROC_ENTRY, &quot;at76_open end&quot;);
+ err:
+	up(&amp;dev-&gt;sem);
+	return ret &lt; 0 ? ret : 0;
+}
+
+
+static int at76_stop(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	unsigned long flags;
+
+	at76_dbg(DBG_DEVSTART, &quot;%s: ENTER&quot;, __FUNCTION__);
+
+	if (down_interruptible(&amp;dev-&gt;sem))
+		return -EINTR;
+
+	netif_stop_queue(netdev);
+
+	dev-&gt;istate = INIT;
+
+	if (!(dev-&gt;device_unplugged)) {
+		/* we are called by &quot;ifconfig ethX down&quot;, not because the
+		   device isn't avail. anymore */
+		at76_set_radio(dev, 0);
+
+		/* we unlink the read urb, because the _open()
+		   submits it again. _delete_device() takes care of the
+		   read_urb otherwise. */
+		usb_kill_urb(dev-&gt;read_urb);
+	}
+
+	del_timer_sync(&amp;dev-&gt;mgmt_timer);
+
+	spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock, flags);
+	if (dev-&gt;next_mgmt_bulk) {
+		kfree(dev-&gt;next_mgmt_bulk);
+		dev-&gt;next_mgmt_bulk = NULL;
+	}
+	spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock, flags);
+
+	/* free the bss_list */
+	at76_free_bss_list(dev);
+
+	at76_assert(dev-&gt;open_count &gt; 0);
+	dev-&gt;open_count--;
 
 	up(&amp;dev-&gt;sem);
+	at76_dbg(DBG_DEVSTART, &quot;%s: EXIT&quot;, __FUNCTION__);
+
+	return 0;
+}
+
+
+static void at76_ethtool_get_drvinfo(struct net_device *netdev,
+					 struct ethtool_drvinfo *info)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+
+	strncpy(info-&gt;driver, DRIVER_NAME, sizeof(info-&gt;driver) - 1);
+
+	strncpy(info-&gt;version, DRIVER_VERSION, sizeof(info-&gt;version));
+	info-&gt;version[sizeof(info-&gt;version) - 1] = '\0';
+
+	snprintf(info-&gt;bus_info, sizeof(info-&gt;bus_info) - 1, &quot;usb%d:%d&quot;,
+		 dev-&gt;udev-&gt;bus-&gt;busnum, dev-&gt;udev-&gt;devnum);
+
+	snprintf(info-&gt;fw_version, sizeof(info-&gt;fw_version) - 1,
+		 &quot;%d.%d.%d-%d&quot;,
+		 dev-&gt;fw_version.major, dev-&gt;fw_version.minor,
+		 dev-&gt;fw_version.patch, dev-&gt;fw_version.build);
+}
+
+
+static u32 at76_ethtool_get_link(struct net_device *netdev)
+{
+	struct at76_priv *dev = netdev_priv(netdev);
+	return dev-&gt;istate == CONNECTED;
 }
 
+
+static struct ethtool_ops at76_ethtool_ops = {
+	.get_drvinfo = at76_ethtool_get_drvinfo,
+	.get_link = at76_ethtool_get_link,
+};
+
+
+/**
+ * at76_init_new_device - continue device initialization after firmware download
+ *
+ * FIXME: We may have to move the register_netdev into at76_alloc_new_device,
+ * because hotplug may try to configure the netdev _before_ (or parallel to)
+ * the download of firmware
+ */
+static int at76_init_new_device(struct at76_priv *dev)
+{
+	struct net_device *netdev = dev-&gt;netdev;
+	int ret;
+
+	/* set up the endpoint information */
+	/* check out the endpoints */
+
+	dev-&gt;interface = dev-&gt;udev-&gt;actconfig-&gt;interface[0];
+
+	at76_dbg(DBG_DEVSTART, &quot;USB interface: %d endpoints&quot;,
+	         dev-&gt;interface-&gt;cur_altsetting-&gt;desc.bNumEndpoints);
+
+	if ((ret = at76_alloc_urbs(dev)) &lt; 0)
+		goto error;
+
+	/* get firmware version */
+	ret = at76_get_mib(dev-&gt;udev, MIB_FW_VERSION, &amp;dev-&gt;fw_version,
+			   sizeof(dev-&gt;fw_version));
+	if ((ret &lt; 0) || ((dev-&gt;fw_version.major == 0) &amp;&amp;
+			  (dev-&gt;fw_version.minor == 0) &amp;&amp;
+			  (dev-&gt;fw_version.patch == 0) &amp;&amp;
+			  (dev-&gt;fw_version.build == 0))) {
+		err(&quot;getting firmware failed with %d, or version is 0&quot;, ret);
+		err(&quot;this probably means that the ext. fw was not loaded correctly&quot;);
+		if(ret &gt;= 0)
+			ret = -ENODEV;
+		goto error;
+	}
+
+	/* fw 0.84 doesn't send FCS with rx data */
+	if (dev-&gt;fw_version.major == 0 &amp;&amp; dev-&gt;fw_version.minor &lt;= 84)
+		dev-&gt;rx_data_fcs_len = 0;
+	else
+		dev-&gt;rx_data_fcs_len = 4;
+
+	info(&quot;firmware version %d.%d.%d #%d (fcs_len %d)&quot;,
+	     dev-&gt;fw_version.major, dev-&gt;fw_version.minor,
+	     dev-&gt;fw_version.patch, dev-&gt;fw_version.build,
+	     dev-&gt;rx_data_fcs_len);
+
+	/* MAC address */
+	ret = at76_get_hw_config(dev);
+	if (ret &lt; 0) {
+		err(&quot;could not get MAC address&quot;);
+		goto error;
+	}
+
+	dev-&gt;domain = at76_get_reg_domain(dev-&gt;regulatory_domain);
+	/* init. netdev-&gt;dev_addr */
+	memcpy(netdev-&gt;dev_addr, dev-&gt;mac_addr, ETH_ALEN);
+	info(&quot;device's MAC %s, regulatory domain %s (id %d)&quot;,
+	     mac2str(dev-&gt;mac_addr), dev-&gt;domain-&gt;name, dev-&gt;regulatory_domain);
+
+	/* initializing */
+	dev-&gt;international_roaming = international_roaming;
+	dev-&gt;channel = DEF_CHANNEL;
+	dev-&gt;iw_mode = default_iw_mode;
+	memset(dev-&gt;essid, 0, IW_ESSID_MAX_SIZE);
+	dev-&gt;rts_threshold = DEF_RTS_THRESHOLD;
+	dev-&gt;frag_threshold = DEF_FRAG_THRESHOLD;
+	dev-&gt;short_retry_limit = DEF_SHORT_RETRY_LIMIT;
+	dev-&gt;txrate = TX_RATE_AUTO;
+	dev-&gt;preamble_type = preamble_type;
+	dev-&gt;beacon_period = 100;
+	dev-&gt;beacons_last_qual = jiffies_to_msecs(jiffies);
+	dev-&gt;auth_mode = auth_mode ? WLAN_AUTH_SHARED_KEY : WLAN_AUTH_OPEN;
+	dev-&gt;scan_min_time = scan_min_time;
+	dev-&gt;scan_max_time = scan_max_time;
+	dev-&gt;scan_mode = scan_mode;
+	dev-&gt;monitor_scan_min_time = monitor_scan_min_time;
+	dev-&gt;monitor_scan_max_time = monitor_scan_max_time;
+
+	netdev-&gt;flags &amp;= ~IFF_MULTICAST; /* not yet or never */
+	netdev-&gt;open = at76_open;
+	netdev-&gt;stop = at76_stop;
+	netdev-&gt;get_stats = at76_get_stats;
+	netdev-&gt;ethtool_ops = &amp;at76_ethtool_ops;
+
+	/* Add pointers to enable iwspy support. */
+	dev-&gt;wireless_data.spy_data = &amp;dev-&gt;spy_data;
+	netdev-&gt;wireless_data = &amp;dev-&gt;wireless_data;
+
+	netdev-&gt;hard_start_xmit = at76_tx;
+	netdev-&gt;tx_timeout = at76_tx_timeout;
+	netdev-&gt;watchdog_timeo = 2 * HZ;
+	netdev-&gt;wireless_handlers = &amp;at76_handler_def;
+	netdev-&gt;set_multicast_list = at76_set_multicast;
+	netdev-&gt;set_mac_address = at76_set_mac_address;
+
+	ret = register_netdev(dev-&gt;netdev);
+	if (ret) {
+		err(&quot;unable to register netdevice %s (status %d)!&quot;,
+		    dev-&gt;netdev-&gt;name, ret);
+		goto error;
+	}
+	info(&quot;registered %s&quot;, dev-&gt;netdev-&gt;name);
+	dev-&gt;netdev_registered = 1;
+
+	/* we let this timer run the whole time this driver instance lives */
+	mod_timer(&amp;dev-&gt;bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
+
+	return 0;
+ error:
+	at76_delete_device(dev);
+	return ret;
+}
+
+
 /* Download external firmware */
 static void at76_work_external_fw(struct work_struct *work)
 {
@@ -2226,6 +4300,7 @@ static void at76_work_external_fw(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
+
 /* Download internal firmware */
 static void at76_work_internal_fw(struct work_struct *work)
 {
@@ -2262,6 +4337,133 @@ static void at76_work_internal_fw(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
+
+static int at76_essid_matched(struct at76_priv *dev, struct bss_info *ptr)
+{
+	/* common criteria for both modi */
+
+	int ret = (dev-&gt;essid_size == 0 /* ANY ssid */  ||
+		      (dev-&gt;essid_size == ptr-&gt;ssid_len &amp;&amp;
+		       !memcmp(dev-&gt;essid, ptr-&gt;ssid, ptr-&gt;ssid_len)));
+	if (!ret)
+		at76_dbg(DBG_BSS_MATCH, &quot;%s bss table entry %p: essid didn't match&quot;,
+		         dev-&gt;netdev-&gt;name, ptr);
+	return ret;
+}
+
+
+static inline int at76_mode_matched(struct at76_priv *dev, struct bss_info *ptr)
+{
+	int ret;
+
+	if (dev-&gt;iw_mode == IW_MODE_ADHOC)
+		ret = ptr-&gt;capa &amp; WLAN_CAPABILITY_IBSS;
+	else
+		ret = ptr-&gt;capa &amp; WLAN_CAPABILITY_ESS;
+	if (!ret)
+		at76_dbg(DBG_BSS_MATCH, &quot;%s bss table entry %p: mode didn't match&quot;,
+		         dev-&gt;netdev-&gt;name, ptr);
+	return ret;
+}
+
+
+static int at76_rates_matched(struct at76_priv *dev, struct bss_info *ptr)
+{
+	int i;
+	u8 *rate;
+
+	for (i = 0, rate = ptr-&gt;rates; i &lt; ptr-&gt;rates_len; i++, rate++)
+		if (*rate &amp; 0x80) {
+			/* this is a basic rate we have to support
+			   (see IEEE802.11, ch. 7.3.2.2) */
+			if (*rate != (0x80 | hw_rates[0])
+			    &amp;&amp; *rate != (0x80 | hw_rates[1])
+			    &amp;&amp; *rate != (0x80 | hw_rates[2])
+			    &amp;&amp; *rate != (0x80 | hw_rates[3])) {
+				at76_dbg(DBG_BSS_MATCH,
+				         &quot;%s: bss table entry %p: basic rate %02x not supported&quot;,
+				         dev-&gt;netdev-&gt;name, ptr, *rate);
+				return 0;
+			}
+		}
+	/* if we use short preamble, the bss must support it */
+	if (dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT &amp;&amp;
+	    !(ptr-&gt;capa &amp; WLAN_CAPABILITY_SHORT_PREAMBLE)) {
+		at76_dbg(DBG_BSS_MATCH, &quot;%s: %p does not support short preamble&quot;,
+		         dev-&gt;netdev-&gt;name, ptr);
+		return 0;
+	} else
+		return 1;
+}
+
+
+static inline int at76_wep_matched(struct at76_priv *dev, struct bss_info *ptr)
+{
+	if (!dev-&gt;wep_enabled &amp;&amp; ptr-&gt;capa &amp; WLAN_CAPABILITY_PRIVACY) {
+		/* we have disabled WEP, but the BSS signals privacy */
+		at76_dbg(DBG_BSS_MATCH, &quot;%s: bss table entry %p: requires encryption&quot;,
+		         dev-&gt;netdev-&gt;name, ptr);
+		return 0;
+	}
+	/* otherwise if the BSS does not signal privacy it may well
+	   accept encrypted packets from us ... */
+	return 1;
+}
+
+
+static inline int at76_bssid_matched(struct at76_priv *dev,
+				     struct bss_info *ptr)
+{
+	if (!dev-&gt;wanted_bssid_valid ||
+	    !compare_ether_addr(ptr-&gt;bssid, dev-&gt;wanted_bssid)) {
+		return 1;
+	} else {
+		at76_dbg(DBG_BSS_MATCH, &quot;%s: requested bssid - %s does not match&quot;,
+			 dev-&gt;netdev-&gt;name, mac2str(dev-&gt;wanted_bssid));
+		at76_dbg(DBG_BSS_MATCH, &quot;      AP bssid - %s of bss table entry %p&quot;,
+			 mac2str(ptr-&gt;bssid), ptr);
+		return 0;
+	}
+}
+
+
+/**
+ * at76_match_bss - try to find a matching bss in dev-&gt;bss
+ *
+ * last - last bss tried
+ *
+ * last == NULL signals a new round starting with dev-&gt;bss_list.next
+ * this function must be called inside an acquired dev-&gt;bss_list_spinlock
+ * otherwise the timeout on bss may remove the newly chosen entry
+ */
+static struct bss_info *at76_match_bss(struct at76_priv *dev,
+				       struct bss_info *last)
+{
+	struct bss_info *ptr = NULL;
+	struct list_head *curr;
+
+	curr = last != NULL ? last-&gt;list.next : dev-&gt;bss_list.next;
+	while (curr != &amp;dev-&gt;bss_list) {
+		ptr = list_entry(curr, struct bss_info, list);
+		if (at76_essid_matched(dev, ptr) &amp;&amp;
+		    at76_mode_matched(dev, ptr) &amp;&amp;
+		    at76_wep_matched(dev, ptr) &amp;&amp;
+		    at76_rates_matched(dev, ptr) &amp;&amp;
+		    at76_bssid_matched(dev, ptr))
+			break;
+		curr = curr-&gt;next;
+	}
+
+	if (curr == &amp;dev-&gt;bss_list)
+		ptr = NULL;
+	/* otherwise ptr points to the struct bss_info we have chosen */
+
+	at76_dbg(DBG_BSS_TABLE, &quot;%s %s: returned %p&quot;, dev-&gt;netdev-&gt;name,
+	         __FUNCTION__, ptr);
+	return ptr;
+}
+
+
 /* Try joining a BSS */
 static void at76_work_join(struct work_struct *work)
 {
@@ -2345,6 +4547,7 @@ static void at76_work_join(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
+
 static void at76_work_mgmt_timeout(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2355,6 +4558,7 @@ static void at76_work_mgmt_timeout(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
+
 static void at76_work_new_bss(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2390,6 +4594,7 @@ static void at76_work_new_bss(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
+
 static void at76_work_reset_device(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2401,6 +4606,150 @@ static void at76_work_reset_device(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
+
+static int at76_startup_device(struct at76_priv *dev)
+{
+	struct at76_card_config *ccfg = &amp;dev-&gt;card_config;
+	int ret;
+
+	if (at76_debug &amp; DBG_PARAMS) {
+		char ossid[IW_ESSID_MAX_SIZE + 1];
+
+		/* make dev-&gt;essid printable */
+		at76_assert(dev-&gt;essid_size &lt;= IW_ESSID_MAX_SIZE);
+		memcpy(ossid, dev-&gt;essid, dev-&gt;essid_size);
+		ossid[dev-&gt;essid_size] = '\0';
+
+		dbg(&quot;%s param: ssid %s (%s) mode %s ch %d wep %s key %d keylen %d&quot;,
+		       dev-&gt;netdev-&gt;name, ossid,
+		       hex2str(dev-&gt;obuf, dev-&gt;essid,
+			       min((int)(sizeof(dev-&gt;obuf)-1)/2,
+				   IW_ESSID_MAX_SIZE), '\0'),
+		       dev-&gt;iw_mode == IW_MODE_ADHOC ? &quot;adhoc&quot; : &quot;infra&quot;,
+		       dev-&gt;channel,
+		       dev-&gt;wep_enabled ? &quot;enabled&quot; : &quot;disabled&quot;,
+		       dev-&gt;wep_key_id, dev-&gt;wep_keys_len[dev-&gt;wep_key_id]);
+		dbg(&quot;%s param: preamble %s rts %d retry %d frag %d &quot;
+		       &quot;txrate %s auth_mode %d&quot;,
+		       dev-&gt;netdev-&gt;name,
+		       dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT ? &quot;short&quot; : &quot;long&quot;,
+		       dev-&gt;rts_threshold, dev-&gt;short_retry_limit,
+		       dev-&gt;frag_threshold,
+		       dev-&gt;txrate == TX_RATE_1MBIT ? &quot;1MBit&quot; :
+		       dev-&gt;txrate == TX_RATE_2MBIT ? &quot;2MBit&quot; :
+		       dev-&gt;txrate == TX_RATE_5_5MBIT ? &quot;5.5MBit&quot; :
+		       dev-&gt;txrate == TX_RATE_11MBIT ? &quot;11MBit&quot; :
+		       dev-&gt;txrate == TX_RATE_AUTO ? &quot;auto&quot; : &quot;&lt;invalid&gt;&quot;,
+		       dev-&gt;auth_mode);
+		dbg(&quot;%s param: pm_mode %d pm_period %d auth_mode %s &quot;
+		       &quot;scan_times %d %d scan_mode %s international_roaming %d&quot;,
+		       dev-&gt;netdev-&gt;name,
+		       dev-&gt;pm_mode, dev-&gt;pm_period,
+		       dev-&gt;auth_mode == WLAN_AUTH_OPEN ?
+		       &quot;open&quot; : &quot;shared_secret&quot;,
+		       dev-&gt;scan_min_time, dev-&gt;scan_max_time,
+		       dev-&gt;scan_mode == SCAN_TYPE_ACTIVE ? &quot;active&quot; : &quot;passive&quot;,
+		       dev-&gt;international_roaming);
+	}
+
+	memset(ccfg, 0, sizeof(struct at76_card_config));
+	ccfg-&gt;promiscuous_mode = 0;
+	ccfg-&gt;short_retry_limit = dev-&gt;short_retry_limit;
+
+	if (dev-&gt;wep_enabled) {
+		if (dev-&gt;wep_keys_len[dev-&gt;wep_key_id] &gt; WEP_SMALL_KEY_LEN)
+			ccfg-&gt;encryption_type = 2;
+		else
+			ccfg-&gt;encryption_type = 1;
+
+		/* jal: always exclude unencrypted if WEP is active */
+		ccfg-&gt;exclude_unencrypted = 1;
+	} else {
+		ccfg-&gt;exclude_unencrypted = 0;
+		ccfg-&gt;encryption_type = 0;
+	}
+
+	ccfg-&gt;rts_threshold = cpu_to_le16(dev-&gt;rts_threshold);
+	ccfg-&gt;fragmentation_threshold = cpu_to_le16(dev-&gt;frag_threshold);
+
+	memcpy(ccfg-&gt;basic_rate_set, hw_rates, 4);
+	/* jal: really needed, we do a set_mib for autorate later ??? */
+	ccfg-&gt;auto_rate_fallback = (dev-&gt;txrate == TX_RATE_AUTO ? 1 : 0);
+	ccfg-&gt;channel = dev-&gt;channel;
+	ccfg-&gt;privacy_invoked = dev-&gt;wep_enabled;
+	memcpy(ccfg-&gt;current_ssid, dev-&gt;essid, IW_ESSID_MAX_SIZE);
+	ccfg-&gt;ssid_len = dev-&gt;essid_size;
+
+	ccfg-&gt;wep_default_key_id = dev-&gt;wep_key_id;
+	memcpy(ccfg-&gt;wep_default_key_value, dev-&gt;wep_keys, 4 * WEP_KEY_LEN);
+
+	ccfg-&gt;short_preamble = dev-&gt;preamble_type;
+	ccfg-&gt;beacon_period = cpu_to_le16(dev-&gt;beacon_period);
+
+	ret = at76_set_card_command(dev-&gt;udev, CMD_STARTUP, &amp;dev-&gt;card_config,
+			            sizeof(struct at76_card_config));
+	if (ret &lt; 0) {
+		err(&quot;%s: at76_set_card_command failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
+		return ret;
+	}
+
+	at76_wait_completion(dev, CMD_STARTUP);
+
+	/* remove BSSID from previous run */
+	memset(dev-&gt;bssid, 0, ETH_ALEN);
+
+	if (at76_set_radio(dev, 1) == 1)
+		at76_wait_completion(dev, CMD_RADIO);
+
+	if ((ret = at76_set_preamble(dev, dev-&gt;preamble_type)) &lt; 0)
+		return ret;
+
+	if ((ret = at76_set_frag(dev, dev-&gt;frag_threshold)) &lt; 0)
+		return ret;
+
+	if ((ret = at76_set_rts(dev, dev-&gt;rts_threshold)) &lt; 0)
+		return ret;
+
+	if ((ret = at76_set_autorate_fallback(dev, dev-&gt;txrate == TX_RATE_AUTO ? 1 : 0)) &lt; 0)
+		return ret;
+
+	if ((ret = at76_set_pm_mode(dev)) &lt; 0)
+		return ret;
+
+	if ((ret = at76_set_iroaming(dev, dev-&gt;international_roaming)) &lt; 0)
+		return ret;
+
+	if (at76_debug &amp; DBG_MIB) {
+		at76_dump_mib_mac(dev);
+		at76_dump_mib_mac_addr(dev);
+		at76_dump_mib_mac_mgmt(dev);
+		at76_dump_mib_mac_wep(dev);
+		at76_dump_mib_mdomain(dev);
+		at76_dump_mib_phy(dev);
+		at76_dump_mib_local(dev);
+	}
+
+	return 0;
+}
+
+
+/**
+ * set_monitor_mode - sets dev-&gt;netdev-&gt;type
+ */
+static void at76_set_monitor_mode(struct at76_priv *dev)
+{
+	if (dev-&gt;iw_mode == IW_MODE_MONITOR) {
+		at76_dbg(DBG_MONITOR_MODE, &quot;%s: MONITOR MODE ON&quot;,
+			 dev-&gt;netdev-&gt;name);
+		dev-&gt;netdev-&gt;type = ARPHRD_IEEE80211_RADIOTAP;
+	} else {
+		at76_dbg(DBG_MONITOR_MODE, &quot;%s: MONITOR MODE OFF&quot;,
+		         dev-&gt;netdev-&gt;name);
+		dev-&gt;netdev-&gt;type = ARPHRD_ETHER;
+	}
+}
+
+
 static void at76_work_restart(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2429,6 +4778,7 @@ static void at76_work_restart(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
+
 static void at76_work_scan(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2456,6 +4806,7 @@ static void at76_work_scan(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
+
 static void at76_work_set_promisc(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2478,6 +4829,7 @@ static void at76_work_set_promisc(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
+
 static void at76_work_start_ibss(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2526,6 +4878,7 @@ static void at76_work_start_ibss(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
+
 static void at76_work_submit_rx(struct work_struct *work)
 {
 	struct at76_priv *dev = container_of(work, struct at76_priv,
@@ -2536,159 +4889,10 @@ static void at76_work_submit_rx(struct work_struct *work)
 	up(&amp;dev-&gt;sem);
 }
 
-static int at76_essid_matched(struct at76_priv *dev, struct bss_info *ptr)
-{
-	/* common criteria for both modi */
-
-	int ret = (dev-&gt;essid_size == 0 /* ANY ssid */  ||
-		      (dev-&gt;essid_size == ptr-&gt;ssid_len &amp;&amp;
-		       !memcmp(dev-&gt;essid, ptr-&gt;ssid, ptr-&gt;ssid_len)));
-	if (!ret)
-		at76_dbg(DBG_BSS_MATCH, &quot;%s bss table entry %p: essid didn't match&quot;,
-		         dev-&gt;netdev-&gt;name, ptr);
-	return ret;
-}
-
-static inline int at76_mode_matched(struct at76_priv *dev, struct bss_info *ptr)
-{
-	int ret;
-
-	if (dev-&gt;iw_mode == IW_MODE_ADHOC)
-		ret = ptr-&gt;capa &amp; WLAN_CAPABILITY_IBSS;
-	else
-		ret = ptr-&gt;capa &amp; WLAN_CAPABILITY_ESS;
-	if (!ret)
-		at76_dbg(DBG_BSS_MATCH, &quot;%s bss table entry %p: mode didn't match&quot;,
-		         dev-&gt;netdev-&gt;name, ptr);
-	return ret;
-}
-
-static int at76_rates_matched(struct at76_priv *dev, struct bss_info *ptr)
-{
-	int i;
-	u8 *rate;
-
-	for (i = 0, rate = ptr-&gt;rates; i &lt; ptr-&gt;rates_len; i++, rate++)
-		if (*rate &amp; 0x80) {
-			/* this is a basic rate we have to support
-			   (see IEEE802.11, ch. 7.3.2.2) */
-			if (*rate != (0x80 | hw_rates[0])
-			    &amp;&amp; *rate != (0x80 | hw_rates[1])
-			    &amp;&amp; *rate != (0x80 | hw_rates[2])
-			    &amp;&amp; *rate != (0x80 | hw_rates[3])) {
-				at76_dbg(DBG_BSS_MATCH,
-				         &quot;%s: bss table entry %p: basic rate %02x not supported&quot;,
-				         dev-&gt;netdev-&gt;name, ptr, *rate);
-				return 0;
-			}
-		}
-	/* if we use short preamble, the bss must support it */
-	if (dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT &amp;&amp;
-	    !(ptr-&gt;capa &amp; WLAN_CAPABILITY_SHORT_PREAMBLE)) {
-		at76_dbg(DBG_BSS_MATCH, &quot;%s: %p does not support short preamble&quot;,
-		         dev-&gt;netdev-&gt;name, ptr);
-		return 0;
-	} else
-		return 1;
-}
-
-static inline int at76_wep_matched(struct at76_priv *dev, struct bss_info *ptr)
-{
-	if (!dev-&gt;wep_enabled &amp;&amp; ptr-&gt;capa &amp; WLAN_CAPABILITY_PRIVACY) {
-		/* we have disabled WEP, but the BSS signals privacy */
-		at76_dbg(DBG_BSS_MATCH, &quot;%s: bss table entry %p: requires encryption&quot;,
-		         dev-&gt;netdev-&gt;name, ptr);
-		return 0;
-	}
-	/* otherwise if the BSS does not signal privacy it may well
-	   accept encrypted packets from us ... */
-	return 1;
-}
-
-static inline int at76_bssid_matched(struct at76_priv *dev, struct bss_info *ptr)
-{
-	if (!dev-&gt;wanted_bssid_valid ||
-	    !compare_ether_addr(ptr-&gt;bssid, dev-&gt;wanted_bssid)) {
-		return 1;
-	} else {
-		at76_dbg(DBG_BSS_MATCH, &quot;%s: requested bssid - %s does not match&quot;,
-			 dev-&gt;netdev-&gt;name, mac2str(dev-&gt;wanted_bssid));
-		at76_dbg(DBG_BSS_MATCH, &quot;      AP bssid - %s of bss table entry %p&quot;,
-			 mac2str(ptr-&gt;bssid), ptr);
-		return 0;
-	}
-}
-
-static void at76_dump_bss_table(struct at76_priv *dev)
-{
-	struct bss_info *ptr;
-	unsigned long flags;
-	struct list_head *lptr;
-	char obuf_s[3*32];
-
-	spin_lock_irqsave(&amp;dev-&gt;bss_list_spinlock, flags);
-
-	pr_debug(&quot;%s BSS table (curr=%p, new=%p):&quot;, dev-&gt;netdev-&gt;name,
-	         dev-&gt;curr_bss, dev-&gt;new_bss);
-
-	list_for_each(lptr, &amp;dev-&gt;bss_list) {
-		ptr = list_entry(lptr, struct bss_info, list);
-		pr_debug(&quot;0x%p: bssid %s channel %d ssid %s (%s)&quot;
-		         &quot; capa x%04x rates %s rssi %d link %d noise %d&quot;,
-		         ptr, mac2str(ptr-&gt;bssid),
-		         ptr-&gt;channel,
-		         ptr-&gt;ssid,
-		         hex2str(dev-&gt;obuf, ptr-&gt;ssid,
-			       min((sizeof(dev-&gt;obuf) - 1) / 2,
-				   (size_t) ptr-&gt;ssid_len), '\0'),
-		         ptr-&gt;capa,
-		         hex2str(obuf_s, ptr-&gt;rates,
-			       min(sizeof(obuf_s) / 3,
-				   (size_t) ptr-&gt;rates_len), ' '),
-		         ptr-&gt;rssi, ptr-&gt;link_qual, ptr-&gt;noise_level);
-	}
-	spin_unlock_irqrestore(&amp;dev-&gt;bss_list_spinlock, flags);
-}
-
-/**
- * at76_match_bss - try to find a matching bss in dev-&gt;bss
- *
- * last - last bss tried
- *
- * last == NULL signals a new round starting with dev-&gt;bss_list.next
- * this function must be called inside an acquired dev-&gt;bss_list_spinlock
- * otherwise the timeout on bss may remove the newly chosen entry
- */
-static struct bss_info *at76_match_bss(struct at76_priv *dev,
-					  struct bss_info *last)
-{
-	struct bss_info *ptr = NULL;
-	struct list_head *curr;
-
-	curr = last != NULL ? last-&gt;list.next : dev-&gt;bss_list.next;
-	while (curr != &amp;dev-&gt;bss_list) {
-		ptr = list_entry(curr, struct bss_info, list);
-		if (at76_essid_matched(dev, ptr) &amp;&amp;
-		    at76_mode_matched(dev, ptr) &amp;&amp;
-		    at76_wep_matched(dev, ptr) &amp;&amp;
-		    at76_rates_matched(dev, ptr) &amp;&amp;
-		    at76_bssid_matched(dev, ptr))
-			break;
-		curr = curr-&gt;next;
-	}
-
-	if (curr == &amp;dev-&gt;bss_list)
-		ptr = NULL;
-	/* otherwise ptr points to the struct bss_info we have chosen */
-
-	at76_dbg(DBG_BSS_TABLE, &quot;%s %s: returned %p&quot;, dev-&gt;netdev-&gt;name,
-	         __FUNCTION__, ptr);
-	return ptr;
-}
-
 
 /* we got an association response */
-static void at76_rx_mgmt_assoc(struct at76_priv *dev, struct at76_rx_buffer *buf)
+static void at76_rx_mgmt_assoc(struct at76_priv *dev,
+			       struct at76_rx_buffer *buf)
 {
 	struct ieee80211_assoc_response *resp =
 	    (struct ieee80211_assoc_response *)buf-&gt;packet;
@@ -2728,7 +4932,7 @@ static void at76_rx_mgmt_assoc(struct at76_priv *dev, struct at76_rx_buffer *buf
 
 
 static void at76_rx_mgmt_reassoc(struct at76_priv *dev,
-			    struct at76_rx_buffer *buf)
+				 struct at76_rx_buffer *buf)
 {
 	struct ieee80211_assoc_response *resp =
 	    (struct ieee80211_assoc_response *)buf-&gt;packet;
@@ -2782,7 +4986,7 @@ static void at76_rx_mgmt_reassoc(struct at76_priv *dev,
 
 
 static void at76_rx_mgmt_disassoc(struct at76_priv *dev,
-			     struct at76_rx_buffer *buf)
+				  struct at76_rx_buffer *buf)
 {
 	struct ieee80211_disassoc *resp =
 	    (struct ieee80211_disassoc *)buf-&gt;packet;
@@ -2901,7 +5105,8 @@ static void at76_rx_mgmt_auth(struct at76_priv *dev, struct at76_rx_buffer *buf)
 }
 
 
-static void at76_rx_mgmt_deauth(struct at76_priv *dev, struct at76_rx_buffer *buf)
+static void at76_rx_mgmt_deauth(struct at76_priv *dev,
+				struct at76_rx_buffer *buf)
 {
 	struct ieee80211_disassoc *resp =
 	    (struct ieee80211_disassoc *)buf-&gt;packet;
@@ -2943,7 +5148,8 @@ static void at76_rx_mgmt_deauth(struct at76_priv *dev, struct at76_rx_buffer *bu
 }
 
 
-static void at76_rx_mgmt_beacon(struct at76_priv *dev, struct at76_rx_buffer *buf)
+static void at76_rx_mgmt_beacon(struct at76_priv *dev,
+				struct at76_rx_buffer *buf)
 {
 	/* beacon content */
 	struct ieee80211_beacon *bdata = (struct ieee80211_beacon *)buf-&gt;packet;
@@ -3125,7 +5331,7 @@ rx_mgmt_beacon_end:
 
 /* calc the link level from a given rx_buffer */
 static void at76_calc_level(struct at76_priv *dev, struct at76_rx_buffer *buf,
-		       struct iw_quality *qual)
+			    struct iw_quality *qual)
 {
 	int max_rssi = 42;	/* just a guess for now, might be different for other chips */
 
@@ -3137,7 +5343,8 @@ static void at76_calc_level(struct at76_priv *dev, struct at76_rx_buffer *buf,
 
 
 /* calc the link quality from a given rx_buffer */
-static void at76_calc_qual(struct at76_priv *dev, struct at76_rx_buffer *buf, struct iw_quality* qual)
+static void at76_calc_qual(struct at76_priv *dev, struct at76_rx_buffer *buf,
+			   struct iw_quality* qual)
 {
 	if ((dev-&gt;board_type == BOARDTYPE_503_INTERSIL_3861) ||
 	    (dev-&gt;board_type == BOARDTYPE_503_INTERSIL_3863)) {
@@ -3160,15 +5367,18 @@ static void at76_calc_qual(struct at76_priv *dev, struct at76_rx_buffer *buf, st
 	qual-&gt;updated |= IW_QUAL_QUAL_UPDATED;
 }
 
+
 /* calc the noise quality from a given rx_buffer */
 static void at76_calc_noise(struct at76_priv *dev, struct at76_rx_buffer *buf,
-		       struct iw_quality *qual)
+			    struct iw_quality *qual)
 {
 	qual-&gt;noise = 0;
 	qual-&gt;updated |= IW_QUAL_NOISE_INVALID;
 }
 
-static void at76_update_wstats(struct at76_priv *dev, struct at76_rx_buffer *buf)
+
+static void at76_update_wstats(struct at76_priv *dev,
+			       struct at76_rx_buffer *buf)
 {
 	struct iw_quality *qual = &amp;dev-&gt;wstats.qual;
 
@@ -3185,6 +5395,7 @@ static void at76_update_wstats(struct at76_priv *dev, struct at76_rx_buffer *buf
 	}
 }
 
+
 static void at76_rx_mgmt(struct at76_priv *dev, struct at76_rx_buffer *buf)
 {
 	struct ieee80211_hdr_3addr *mgmt =
@@ -3244,6 +5455,7 @@ static void at76_rx_mgmt(struct at76_priv *dev, struct at76_rx_buffer *buf)
 	return;
 }
 
+
 static void at76_dbg_dumpbuf(const char *tag, const u8 *buf, int size)
 {
 	int i;
@@ -3262,53 +5474,6 @@ static void at76_dbg_dumpbuf(const char *tag, const u8 *buf, int size)
 	pr_debug(&quot;\n&quot;);
 }
 
-/* A short overview on Ethernet-II, 802.2, 802.3 and SNAP
-   (taken from <A HREF="http://www.geocities.com/billalexander/ethernet.html">http://www.geocities.com/billalexander/ethernet.html</A>):
-
-Ethernet Frame Formats:
-
-Ethernet (a.k.a. Ethernet II)
-
-        +---------+---------+---------+----------
-        |   Dst   |   Src   |  Type   |  Data...
-        +---------+---------+---------+----------
-
-         &lt;-- 6 --&gt; &lt;-- 6 --&gt; &lt;-- 2 --&gt; &lt;-46-1500-&gt;
-
-         Type 0x80 0x00 = TCP/IP
-         Type 0x06 0x00 = XNS
-         Type 0x81 0x37 = Novell NetWare
-
-
-802.3
-
-        +---------+---------+---------+----------
-        |   Dst   |   Src   | Length  | Data...
-        +---------+---------+---------+----------
-
-         &lt;-- 6 --&gt; &lt;-- 6 --&gt; &lt;-- 2 --&gt; &lt;-46-1500-&gt;
-
-802.2 (802.3 with 802.2 header)
-
-        +---------+---------+---------+-------+-------+-------+----------
-        |   Dst   |   Src   | Length  | DSAP  | SSAP  |Control| Data...
-        +---------+---------+---------+-------+-------+-------+----------
-
-                                       &lt;- 1 -&gt; &lt;- 1 -&gt; &lt;- 1 -&gt; &lt;-43-1497-&gt;
-
-SNAP (802.3 with 802.2 and SNAP headers)
-
-        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
-        |   Dst   |   Src   | Length  | 0xAA  | 0xAA  | 0x03  |  Org Code |   Type  | Data...
-        +---------+---------+---------+-------+-------+-------+-----------+---------+-----------
-
-                                                               &lt;--  3  --&gt; &lt;-- 2 --&gt; &lt;-38-1492-&gt;
-
-*/
-static const u8 snapsig[] = { 0xaa, 0xaa, 0x03 };
-/* RFC 1042 encapsulates Ethernet frames in 802.2 SNAP (0xaa, 0xaa, 0x03) with
- * a SNAP OID of 0 (0x00, 0x00, 0x00) */
-static const u8 rfc1042sig[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
 
 /* Convert the 802.11 header on a packet into an ethernet-style header
  * (basically, pretend we're an ethernet card receiving ethernet packets)
@@ -3401,9 +5566,9 @@ static void at76_ieee80211_to_eth(struct sk_buff *skb, int iw_mode)
 	    ntohs(skb-&gt;protocol), skb-&gt;len,
 	    hex2str(dev-&gt;obuf, skb-&gt;data,
 		    min((int)sizeof(dev-&gt;obuf)/3,64), ' '));
-
 }
 
+
 /* Adjust the skb to trim the hardware header and CRC, and set up skb-&gt;mac,
  * skb-&gt;protocol, etc.
  */
@@ -3460,6 +5625,7 @@ static void at76_ieee80211_fixup(struct sk_buff *skb, int iw_mode)
 	}
 }
 
+
 /* check for fragmented data in dev-&gt;rx_skb. If the packet was no fragment
    or it was the last of a fragment set a skb containing the whole packet
    is returned for further processing. Otherwise we get NULL and are
@@ -3725,77 +5891,6 @@ static void at76_rx_data(struct at76_priv *dev)
 	return;
 }
 
-static int at76_submit_rx_urb(struct at76_priv *dev)
-{
-	int ret, size;
-	struct sk_buff *skb = dev-&gt;rx_skb;
-
-	if (dev-&gt;read_urb == NULL) {
-		err(&quot;%s: dev-&gt;read_urb is NULL&quot;, __FUNCTION__);
-		return -EFAULT;
-	}
-
-	if (skb == NULL) {
-		skb = dev_alloc_skb(sizeof(struct at76_rx_buffer));
-		if (skb == NULL) {
-			err(&quot;%s: unable to allocate rx skbuff.&quot;, dev-&gt;netdev-&gt;name);
-			ret = -ENOMEM;
-			goto exit;
-		}
-		dev-&gt;rx_skb = skb;
-	} else {
-		skb_push(skb, skb_headroom(skb));
-		skb_trim(skb, 0);
-	}
-
-	size = skb_tailroom(skb);
-	usb_fill_bulk_urb(dev-&gt;read_urb, dev-&gt;udev,
-		         usb_rcvbulkpipe(dev-&gt;udev, dev-&gt;bulk_in_endpointAddr),
-		         skb_put(skb, size), size,
-		         at76_read_bulk_callback, dev);
-	ret = usb_submit_urb(dev-&gt;read_urb, GFP_ATOMIC);
-	if (ret &lt; 0) {
-		if (ret == -ENODEV)
-			at76_dbg(DBG_DEVSTART, &quot;usb_submit_urb returned -ENODEV&quot;);
-		else
-			err(&quot;%s: rx, usb_submit_urb failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
-	}
-
-exit:
-	if (ret &lt; 0) {
-		if (ret != -ENODEV) {
-			/* If we can't submit the URB, the adapter becomes completely
-			 * useless, so try again later */
-			if (--dev-&gt;nr_submit_rx_tries &gt; 0)
-				schedule_work(&amp;dev-&gt;work_submit_rx);
-			else {
-				err(&quot;%s: giving up to submit rx urb after %d failures -&quot;
-			    	    &quot; please unload the driver and/or power cycle the device&quot;,
-			    	    dev-&gt;netdev-&gt;name, NR_SUBMIT_RX_TRIES);
-			}
-		}
-	} else
-		/* reset counter to initial value */
-		dev-&gt;nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;
-	return ret;
-}
-
-/* we are doing a lot of things here in an interrupt. Need
-   a bh handler (Watching TV with a TV card is probably
-   a good test: if you see flickers, we are doing too much.
-   Currently I do see flickers... even with our tasklet :-( )
-   Maybe because the bttv driver and usb-uhci use the same interrupt
-*/
-/* Or maybe because our BH handler is preempting bttv's BH handler.. BHs don't
- * solve everything.. (alex) */
-static void at76_read_bulk_callback(struct urb *urb)
-{
-	struct at76_priv *priv = urb-&gt;context;
-
-	priv-&gt;rx_urb = urb;
-	tasklet_schedule(&amp;priv-&gt;tasklet);
-	return;
-}
 
 static void at76_rx_monitor_mode(struct at76_priv *dev)
 {
@@ -3860,6 +5955,30 @@ static void at76_rx_monitor_mode(struct at76_priv *dev)
 }
 
 
+/**
+ * at76_iwspy_update - check if we spy on the sender address of buf and update stats
+ */
+static void at76_iwspy_update(struct at76_priv *dev, struct at76_rx_buffer *buf)
+{
+	struct ieee80211_hdr_3addr *hdr =
+	    (struct ieee80211_hdr_3addr *)buf-&gt;packet;
+	struct iw_quality qual;
+
+	/* We can only set the level here */
+	qual.updated = IW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;
+	qual.level = 0;
+	qual.noise = 0;
+	at76_calc_level(dev, buf, &amp;qual);
+
+	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
+
+	if (dev-&gt;spy_data.spy_number &gt; 0) {
+		wireless_spy_update(dev-&gt;netdev, hdr-&gt;addr2, &amp;qual);
+	}
+	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
+}
+
+
 static void at76_rx_tasklet(unsigned long param)
 {
 	struct at76_priv *dev = (struct at76_priv *)param;
@@ -3953,1884 +6072,6 @@ static void at76_rx_tasklet(unsigned long param)
 	return;
 }
 
-static void at76_write_bulk_callback(struct urb *urb)
-{
-	struct at76_priv *dev = urb-&gt;context;
-	struct net_device_stats *stats = &amp;dev-&gt;stats;
-	unsigned long flags;
-	struct at76_tx_buffer *mgmt_buf;
-	int ret;
-
-	if (urb-&gt;status != 0) {
-		if ((urb-&gt;status != -ENOENT) &amp;&amp; (urb-&gt;status != -ECONNRESET)) {
-			at76_dbg(DBG_URB,
-			         &quot;%s - nonzero write bulk status received: %d&quot;,
-			         __FUNCTION__, urb-&gt;status);
-		} else
-			return; /* urb has been unlinked */
-		stats-&gt;tx_errors++;
-	} else
-		stats-&gt;tx_packets++;
-
-	spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock, flags);
-	mgmt_buf = dev-&gt;next_mgmt_bulk;
-	dev-&gt;next_mgmt_bulk = NULL;
-	spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock, flags);
-
-	if (mgmt_buf) {
-		/* we don't copy the padding bytes, but add them
-		   to the length */
-		memcpy(dev-&gt;bulk_out_buffer, mgmt_buf,
-		       le16_to_cpu(mgmt_buf-&gt;wlength) +
-		       offsetof(struct at76_tx_buffer, packet));
-		usb_fill_bulk_urb(dev-&gt;write_urb, dev-&gt;udev,
-				  usb_sndbulkpipe(dev-&gt;udev,
-						  dev-&gt;bulk_out_endpointAddr),
-				  dev-&gt;bulk_out_buffer,
-				  le16_to_cpu(mgmt_buf-&gt;wlength) +
-				  mgmt_buf-&gt;padding + AT76_TX_HDRLEN,
-				  at76_write_bulk_callback,
-				  dev);
-		ret = usb_submit_urb(dev-&gt;write_urb, GFP_ATOMIC);
-		if (ret) {
-			err(&quot;%s: %s error in tx submit urb: %d&quot;,
-			    dev-&gt;netdev-&gt;name, __FUNCTION__, ret);
-		}
-		kfree(mgmt_buf);
-	} else
-		netif_wake_queue(dev-&gt;netdev);
-
-}
-
-static int at76_tx(struct sk_buff *skb, struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	struct net_device_stats *stats = &amp;dev-&gt;stats;
-	int ret = 0;
-	int wlen;
-	int submit_len;
-	struct at76_tx_buffer *tx_buffer = dev-&gt;bulk_out_buffer;
-	struct ieee80211_hdr_3addr *i802_11_hdr =
-	    (struct ieee80211_hdr_3addr *)&amp;(tx_buffer-&gt;packet);
-	u8 *payload = tx_buffer-&gt;packet + sizeof(struct ieee80211_hdr_3addr);
-
-	if (netif_queue_stopped(netdev)) {
-		err(&quot;%s: %s called while netdev is stopped&quot;, netdev-&gt;name,
-		    __FUNCTION__);
-		/* skip this packet */
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	if (dev-&gt;write_urb-&gt;status == -EINPROGRESS) {
-		err(&quot;%s: %s called while dev-&gt;write_urb is pending for tx&quot;,
-		    netdev-&gt;name, __FUNCTION__);
-		/* skip this packet */
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	if (skb-&gt;len &lt; 2 * ETH_ALEN) {
-		err(&quot;%s: %s: skb too short (%d)&quot;, dev-&gt;netdev-&gt;name,
-		    __FUNCTION__, skb-&gt;len);
-		dev_kfree_skb(skb);
-		return 0;
-	}
-
-	at76_ledtrig_tx_activity(); /* tell the ledtrigger we send a packet */
-
-	/* we can get rid of memcpy, if we set netdev-&gt;hard_header_len
-	   to 8 + sizeof(struct ieee80211_hdr_3addr), because then we have
-	   enough space
-	   at76_dbg(DBG_TX, &quot;skb-&gt;data - skb-&gt;head = %d&quot;, skb-&gt;data - skb-&gt;head); */
-
-	if (ntohs(*(__be16 *) (skb-&gt;data + 2 * ETH_ALEN)) &lt;= 1518) {
-		/* this is a 802.3 packet */
-		if (skb-&gt;data[2 * ETH_ALEN + 2] == rfc1042sig[0] &amp;&amp;
-		    skb-&gt;data[2 * ETH_ALEN + 2 + 1] == rfc1042sig[1]) {
-			/* higher layer delivered SNAP header - keep it */
-			memcpy(payload, skb-&gt;data + 2*ETH_ALEN+2, skb-&gt;len - 2*ETH_ALEN -2);
-			wlen = sizeof(struct ieee80211_hdr_3addr) + skb-&gt;len - 2*ETH_ALEN -2;
-		} else {
-			err(&quot;%s: %s: no support for non-SNAP 802.2 packets &quot;
-			    &quot;(DSAP x%02x SSAP x%02x cntrl x%02x)&quot;,
-			    dev-&gt;netdev-&gt;name, __FUNCTION__,
-			    skb-&gt;data[2 * ETH_ALEN + 2],
-			    skb-&gt;data[2 * ETH_ALEN + 2 + 1],
-			    skb-&gt;data[2 * ETH_ALEN + 2 + 2]);
-			dev_kfree_skb(skb);
-			return 0;
-		}
-	} else {
-		/* add RFC 1042 header in front */
-		memcpy(payload, rfc1042sig, sizeof(rfc1042sig));
-		memcpy(payload + sizeof(rfc1042sig),
-		       skb-&gt;data + 2*ETH_ALEN, skb-&gt;len - 2*ETH_ALEN);
-		wlen = sizeof(struct ieee80211_hdr_3addr) + sizeof(rfc1042sig) +
-			skb-&gt;len - 2*ETH_ALEN;
-	}
-
-	/* make wireless header */
-	i802_11_hdr-&gt;frame_ctl =
-	    cpu_to_le16(IEEE80211_FTYPE_DATA |
-			(dev-&gt;wep_enabled ? IEEE80211_FCTL_PROTECTED : 0) |
-			(dev-&gt;iw_mode ==
-			 IW_MODE_INFRA ? IEEE80211_FCTL_TODS : 0));
-
-	if (dev-&gt;iw_mode == IW_MODE_ADHOC) {
-		memcpy(i802_11_hdr-&gt;addr1, skb-&gt;data, ETH_ALEN);	/* destination */
-		memcpy(i802_11_hdr-&gt;addr2, skb-&gt;data + ETH_ALEN, ETH_ALEN);	/* source */
-		memcpy(i802_11_hdr-&gt;addr3, dev-&gt;bssid, ETH_ALEN);
-	} else if (dev-&gt;iw_mode == IW_MODE_INFRA) {
-		memcpy(i802_11_hdr-&gt;addr1, dev-&gt;bssid, ETH_ALEN);
-		memcpy(i802_11_hdr-&gt;addr2, skb-&gt;data + ETH_ALEN, ETH_ALEN);	/* source */
-		memcpy(i802_11_hdr-&gt;addr3, skb-&gt;data, ETH_ALEN);	/* destination */
-	}
-
-	i802_11_hdr-&gt;duration_id = cpu_to_le16(0);
-	i802_11_hdr-&gt;seq_ctl = cpu_to_le16(0);
-
-	/* setup 'Atmel' header */
-	tx_buffer-&gt;wlength = cpu_to_le16(wlen);
-	tx_buffer-&gt;tx_rate = dev-&gt;txrate;
-	/* for broadcast destination addresses, the firmware 0.100.x
-	   seems to choose the highest rate set with CMD_STARTUP in
-	   basic_rate_set replacing this value */
-
-	memset(tx_buffer-&gt;reserved, 0, 4);
-
-	tx_buffer-&gt;padding = at76_calc_padding(wlen);
-	submit_len = wlen + AT76_TX_HDRLEN + tx_buffer-&gt;padding;
-
-	{
-		at76_dbg(DBG_TX_DATA_CONTENT, &quot;%s skb-&gt;data %s&quot;, dev-&gt;netdev-&gt;name,
-		         hex2str(dev-&gt;obuf, skb-&gt;data,
-			    min((int)(sizeof(dev-&gt;obuf) - 1) / 2, 32), '\0'));
-		at76_dbg(DBG_TX_DATA, &quot;%s tx  wlen x%x pad x%x rate %d hdr %s&quot;,
-		         dev-&gt;netdev-&gt;name,
-		         le16_to_cpu(tx_buffer-&gt;wlength),
-		         tx_buffer-&gt;padding, tx_buffer-&gt;tx_rate,
-		         hex2str(dev-&gt;obuf, i802_11_hdr,
-			    min((sizeof(dev-&gt;obuf) - 1) / 2,
-				sizeof(struct ieee80211_hdr_3addr)), '\0'));
-		at76_dbg(DBG_TX_DATA_CONTENT, &quot;%s payload %s&quot;, dev-&gt;netdev-&gt;name,
-		         hex2str(dev-&gt;obuf, payload,
-			    min((int)(sizeof(dev-&gt;obuf) - 1) / 2, 48), '\0'));
-	}
-
-	/* send stuff */
-	netif_stop_queue(netdev);
-	netdev-&gt;trans_start = jiffies;
-
-	usb_fill_bulk_urb(dev-&gt;write_urb, dev-&gt;udev,
-		         usb_sndbulkpipe(dev-&gt;udev, dev-&gt;bulk_out_endpointAddr),
-		         tx_buffer, submit_len,
-		         at76_write_bulk_callback, dev);
-	ret = usb_submit_urb(dev-&gt;write_urb, GFP_ATOMIC);
-	if (ret) {
-		stats-&gt;tx_errors++;
-		err(&quot;%s: error in tx submit urb: %d&quot;, netdev-&gt;name, ret);
-		if (ret == -EINVAL)
-			err(&quot;-EINVAL: urb %p urb-&gt;hcpriv %p urb-&gt;complete %p&quot;,
-			    dev-&gt;write_urb,
-			    dev-&gt;write_urb ? dev-&gt;write_urb-&gt;hcpriv : (void *)-1,
-			    dev-&gt;write_urb ? dev-&gt;write_urb-&gt;complete : (void *)-1);
-		goto err;
-	}
-
-	stats-&gt;tx_bytes += skb-&gt;len;
-
-	dev_kfree_skb(skb);
-	return 0;
-
- err:
-	return ret;
-}
-
-static void at76_tx_timeout(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	if (!dev)
-		return;
-	warn(&quot;%s: tx timeout.&quot;, netdev-&gt;name);
-
-	usb_unlink_urb(dev-&gt;write_urb);
-	dev-&gt;stats.tx_errors++;
-}
-
-static int at76_startup_device(struct at76_priv *dev)
-{
-	struct at76_card_config *ccfg = &amp;dev-&gt;card_config;
-	int ret;
-
-	if (at76_debug &amp; DBG_PARAMS) {
-		char ossid[IW_ESSID_MAX_SIZE + 1];
-
-		/* make dev-&gt;essid printable */
-		at76_assert(dev-&gt;essid_size &lt;= IW_ESSID_MAX_SIZE);
-		memcpy(ossid, dev-&gt;essid, dev-&gt;essid_size);
-		ossid[dev-&gt;essid_size] = '\0';
-
-		dbg(&quot;%s param: ssid %s (%s) mode %s ch %d wep %s key %d keylen %d&quot;,
-		       dev-&gt;netdev-&gt;name, ossid,
-		       hex2str(dev-&gt;obuf, dev-&gt;essid,
-			       min((int)(sizeof(dev-&gt;obuf)-1)/2,
-				   IW_ESSID_MAX_SIZE), '\0'),
-		       dev-&gt;iw_mode == IW_MODE_ADHOC ? &quot;adhoc&quot; : &quot;infra&quot;,
-		       dev-&gt;channel,
-		       dev-&gt;wep_enabled ? &quot;enabled&quot; : &quot;disabled&quot;,
-		       dev-&gt;wep_key_id, dev-&gt;wep_keys_len[dev-&gt;wep_key_id]);
-		dbg(&quot;%s param: preamble %s rts %d retry %d frag %d &quot;
-		       &quot;txrate %s auth_mode %d&quot;,
-		       dev-&gt;netdev-&gt;name,
-		       dev-&gt;preamble_type == PREAMBLE_TYPE_SHORT ? &quot;short&quot; : &quot;long&quot;,
-		       dev-&gt;rts_threshold, dev-&gt;short_retry_limit,
-		       dev-&gt;frag_threshold,
-		       dev-&gt;txrate == TX_RATE_1MBIT ? &quot;1MBit&quot; :
-		       dev-&gt;txrate == TX_RATE_2MBIT ? &quot;2MBit&quot; :
-		       dev-&gt;txrate == TX_RATE_5_5MBIT ? &quot;5.5MBit&quot; :
-		       dev-&gt;txrate == TX_RATE_11MBIT ? &quot;11MBit&quot; :
-		       dev-&gt;txrate == TX_RATE_AUTO ? &quot;auto&quot; : &quot;&lt;invalid&gt;&quot;,
-		       dev-&gt;auth_mode);
-		dbg(&quot;%s param: pm_mode %d pm_period %d auth_mode %s &quot;
-		       &quot;scan_times %d %d scan_mode %s international_roaming %d&quot;,
-		       dev-&gt;netdev-&gt;name,
-		       dev-&gt;pm_mode, dev-&gt;pm_period,
-		       dev-&gt;auth_mode == WLAN_AUTH_OPEN ?
-		       &quot;open&quot; : &quot;shared_secret&quot;,
-		       dev-&gt;scan_min_time, dev-&gt;scan_max_time,
-		       dev-&gt;scan_mode == SCAN_TYPE_ACTIVE ? &quot;active&quot; : &quot;passive&quot;,
-		       dev-&gt;international_roaming);
-	}
-
-	memset(ccfg, 0, sizeof(struct at76_card_config));
-	ccfg-&gt;promiscuous_mode = 0;
-	ccfg-&gt;short_retry_limit = dev-&gt;short_retry_limit;
-
-	if (dev-&gt;wep_enabled) {
-		if (dev-&gt;wep_keys_len[dev-&gt;wep_key_id] &gt; WEP_SMALL_KEY_LEN)
-			ccfg-&gt;encryption_type = 2;
-		else
-			ccfg-&gt;encryption_type = 1;
-
-		/* jal: always exclude unencrypted if WEP is active */
-		ccfg-&gt;exclude_unencrypted = 1;
-	} else {
-		ccfg-&gt;exclude_unencrypted = 0;
-		ccfg-&gt;encryption_type = 0;
-	}
-
-	ccfg-&gt;rts_threshold = cpu_to_le16(dev-&gt;rts_threshold);
-	ccfg-&gt;fragmentation_threshold = cpu_to_le16(dev-&gt;frag_threshold);
-
-	memcpy(ccfg-&gt;basic_rate_set, hw_rates, 4);
-	/* jal: really needed, we do a set_mib for autorate later ??? */
-	ccfg-&gt;auto_rate_fallback = (dev-&gt;txrate == TX_RATE_AUTO ? 1 : 0);
-	ccfg-&gt;channel = dev-&gt;channel;
-	ccfg-&gt;privacy_invoked = dev-&gt;wep_enabled;
-	memcpy(ccfg-&gt;current_ssid, dev-&gt;essid, IW_ESSID_MAX_SIZE);
-	ccfg-&gt;ssid_len = dev-&gt;essid_size;
-
-	ccfg-&gt;wep_default_key_id = dev-&gt;wep_key_id;
-	memcpy(ccfg-&gt;wep_default_key_value, dev-&gt;wep_keys, 4 * WEP_KEY_LEN);
-
-	ccfg-&gt;short_preamble = dev-&gt;preamble_type;
-	ccfg-&gt;beacon_period = cpu_to_le16(dev-&gt;beacon_period);
-
-	ret = at76_set_card_command(dev-&gt;udev, CMD_STARTUP, &amp;dev-&gt;card_config,
-			            sizeof(struct at76_card_config));
-	if (ret &lt; 0) {
-		err(&quot;%s: at76_set_card_command failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
-		return ret;
-	}
-
-	at76_wait_completion(dev, CMD_STARTUP);
-
-	/* remove BSSID from previous run */
-	memset(dev-&gt;bssid, 0, ETH_ALEN);
-
-	if (at76_set_radio(dev, 1) == 1)
-		at76_wait_completion(dev, CMD_RADIO);
-
-	if ((ret = at76_set_preamble(dev, dev-&gt;preamble_type)) &lt; 0)
-		return ret;
-
-	if ((ret = at76_set_frag(dev, dev-&gt;frag_threshold)) &lt; 0)
-		return ret;
-
-	if ((ret = at76_set_rts(dev, dev-&gt;rts_threshold)) &lt; 0)
-		return ret;
-
-	if ((ret = at76_set_autorate_fallback(dev, dev-&gt;txrate == TX_RATE_AUTO ? 1 : 0)) &lt; 0)
-		return ret;
-
-	if ((ret = at76_set_pm_mode(dev)) &lt; 0)
-		return ret;
-
-	if ((ret = at76_set_iroaming(dev, dev-&gt;international_roaming)) &lt; 0)
-		return ret;
-
-	if (at76_debug &amp; DBG_MIB) {
-		at76_dump_mib_mac(dev);
-		at76_dump_mib_mac_addr(dev);
-		at76_dump_mib_mac_mgmt(dev);
-		at76_dump_mib_mac_wep(dev);
-		at76_dump_mib_mdomain(dev);
-		at76_dump_mib_phy(dev);
-		at76_dump_mib_local(dev);
-	}
-
-	return 0;
-}
-
-static int at76_open(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = 0;
-
-	at76_dbg(DBG_PROC_ENTRY, &quot;at76_open entry&quot;);
-
-	if (down_interruptible(&amp;dev-&gt;sem))
-		return -EINTR;
-
-	/* if netdev-&gt;dev_addr != dev-&gt;mac_addr we must
-	   set the mac address in the device ! */
-	if (compare_ether_addr(netdev-&gt;dev_addr, dev-&gt;mac_addr)) {
-		if (at76_add_mac_address(dev, netdev-&gt;dev_addr) &gt;= 0)
-			at76_dbg(DBG_PROGRESS, &quot;%s: set new MAC addr %s&quot;,
-			         netdev-&gt;name, mac2str(netdev-&gt;dev_addr));
-	}
-#ifdef DEBUG
-	at76_dump_mib_mac_addr(dev);
-#endif
-
-	dev-&gt;scan_state = SCAN_IDLE;
-	dev-&gt;last_scan = jiffies;
-	dev-&gt;nr_submit_rx_tries = NR_SUBMIT_RX_TRIES;	/* init counter */
-
-	if ((ret = at76_submit_rx_urb(dev)) &lt; 0) {
-		err(&quot;%s: open: submit_rx_urb failed: %d&quot;, netdev-&gt;name, ret);
-		goto err;
-	}
-
-	dev-&gt;open_count++;
-
-	schedule_work(&amp;dev-&gt;work_restart);
-
-	at76_dbg(DBG_PROC_ENTRY, &quot;at76_open end&quot;);
- err:
-	up(&amp;dev-&gt;sem);
-	return ret &lt; 0 ? ret : 0;
-}
-
-static int at76_stop(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	unsigned long flags;
-
-	at76_dbg(DBG_DEVSTART, &quot;%s: ENTER&quot;, __FUNCTION__);
-
-	if (down_interruptible(&amp;dev-&gt;sem))
-		return -EINTR;
-
-	netif_stop_queue(netdev);
-
-	dev-&gt;istate = INIT;
-
-	if (!(dev-&gt;device_unplugged)) {
-		/* we are called by &quot;ifconfig ethX down&quot;, not because the
-		   device isn't avail. anymore */
-		at76_set_radio(dev, 0);
-
-		/* we unlink the read urb, because the _open()
-		   submits it again. _delete_device() takes care of the
-		   read_urb otherwise. */
-		usb_kill_urb(dev-&gt;read_urb);
-	}
-
-	del_timer_sync(&amp;dev-&gt;mgmt_timer);
-
-	spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock, flags);
-	if (dev-&gt;next_mgmt_bulk) {
-		kfree(dev-&gt;next_mgmt_bulk);
-		dev-&gt;next_mgmt_bulk = NULL;
-	}
-	spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock, flags);
-
-	/* free the bss_list */
-	at76_free_bss_list(dev);
-
-	at76_assert(dev-&gt;open_count &gt; 0);
-	dev-&gt;open_count--;
-
-	up(&amp;dev-&gt;sem);
-	at76_dbg(DBG_DEVSTART, &quot;%s: EXIT&quot;, __FUNCTION__);
-
-	return 0;
-}
-
-static struct net_device_stats *at76_get_stats(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	return &amp;dev-&gt;stats;
-}
-
-static struct iw_statistics *at76_get_wireless_stats(struct net_device
-							 *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	at76_dbg(DBG_IOCTL, &quot;RETURN qual %d level %d noise %d updated %d&quot;,
-	         dev-&gt;wstats.qual.qual, dev-&gt;wstats.qual.level,
-	         dev-&gt;wstats.qual.noise, dev-&gt;wstats.qual.updated);
-
-	return &amp;dev-&gt;wstats;
-}
-
-static void at76_set_multicast(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int promisc;
-
-	promisc = ((netdev-&gt;flags &amp; IFF_PROMISC) != 0);
-	if (promisc != dev-&gt;promisc) {
-		/* grmbl. This gets called in interrupt. */
-		dev-&gt;promisc = promisc;
-		schedule_work(&amp;dev-&gt;work_set_promisc);
-	}
-}
-
-/* we only store the new mac address in netdev struct,
-   it gets set when the netdev is opened. */
-static int at76_set_mac_address(struct net_device *netdev, void *addr)
-{
-	struct sockaddr *mac = addr;
-	memcpy(netdev-&gt;dev_addr, mac-&gt;sa_data, ETH_ALEN);
-	return 1;
-}
-
-/**
- * at76_iwspy_update - check if we spy on the sender address of buf and update stats
- */
-static void at76_iwspy_update(struct at76_priv *dev, struct at76_rx_buffer *buf)
-{
-	struct ieee80211_hdr_3addr *hdr =
-	    (struct ieee80211_hdr_3addr *)buf-&gt;packet;
-	struct iw_quality qual;
-
-	/* We can only set the level here */
-	qual.updated = IW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;
-	qual.level = 0;
-	qual.noise = 0;
-	at76_calc_level(dev, buf, &amp;qual);
-
-	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
-
-	if (dev-&gt;spy_data.spy_number &gt; 0) {
-		wireless_spy_update(dev-&gt;netdev, hdr-&gt;addr2, &amp;qual);
-	}
-	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
-}
-
-
-/*******************************************************************************
- * structure that describes the private ioctls/iw handlers of this driver
- */
-static const struct iw_priv_args at76_priv_args[] = {
-	{AT76_SET_SHORT_PREAMBLE,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 &quot;short_preamble&quot;},	/* 0 - long, 1 -short */
-
-	{AT76_SET_DEBUG,
-	 /* we must pass the new debug mask as a string,
-	  * 'cause iwpriv cannot parse hex numbers
-	  * starting with 0x :-(  */
-	 IW_PRIV_TYPE_CHAR | 10, 0,
-	 &quot;set_debug&quot;},		/* set debug value */
-
-	{AT76_SET_POWERSAVE_MODE,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 &quot;powersave_mode&quot;},	/* 1 -  active, 2 - power save,
-				   3 - smart power save */
-	{AT76_SET_SCAN_TIMES,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0,
-	 &quot;scan_times&quot;},		/* min_channel_time,
-				   max_channel_time */
-	{AT76_SET_SCAN_MODE,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 &quot;scan_mode&quot;},		/* 0 - active, 1 - passive scan */
-
-	{AT76_SET_INTL_ROAMING,
-	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,
-	 &quot;intl_roaming&quot;},
-};
-
-/*******************************************************************************
- * at76_priv implementations of iw_handler functions:
- */
-static int at76_iw_handler_commit(struct net_device *netdev,
-				      struct iw_request_info *info,
-				      void *null, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	unsigned long flags;
-	at76_dbg(DBG_IOCTL, &quot;%s %s: restarting the device&quot;, netdev-&gt;name,
-	         __FUNCTION__);
-
-	/* TODO: stop any pending tx bulk urb */
-	if (dev-&gt;istate != INIT) {
-		dev-&gt;istate = INIT;
-		/* stop pending management stuff */
-		del_timer_sync(&amp;dev-&gt;mgmt_timer);
-
-		spin_lock_irqsave(&amp;dev-&gt;mgmt_spinlock, flags);
-		if (dev-&gt;next_mgmt_bulk) {
-			kfree(dev-&gt;next_mgmt_bulk);
-			dev-&gt;next_mgmt_bulk = NULL;
-		}
-		spin_unlock_irqrestore(&amp;dev-&gt;mgmt_spinlock, flags);
-
-		netif_carrier_off(dev-&gt;netdev);
-		netif_stop_queue(dev-&gt;netdev);
-	}
-
-	/* do the restart after two seconds to catch
-	 * following ioctl's (from more params of iwconfig)
-	 * in _one_ restart */
-	mod_timer(&amp;dev-&gt;restart_timer, jiffies + 2 * HZ);
-
-	return 0;
-}
-
-static int at76_iw_handler_get_name(struct net_device *netdev,
-					struct iw_request_info *info,
-					char *name, char *extra)
-{
-	strcpy(name, &quot;IEEE 802.11b&quot;);
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWNAME - name %s&quot;, netdev-&gt;name, name);
-	return 0;
-}
-
-static int at76_iw_handler_set_freq(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_freq *freq, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int chan = -1;
-	int ret = -EIWCOMMIT;
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWFREQ - freq.m %d freq.e %d&quot;, netdev-&gt;name,
-	    freq-&gt;m, freq-&gt;e);
-
-	if ((freq-&gt;e == 0) &amp;&amp; (freq-&gt;m &lt;= 1000)) {
-		/* Setting by channel number */
-		chan = freq-&gt;m;
-	} else {
-		/* Setting by frequency - search the table */
-		int mult = 1;
-		int i;
-
-		for (i = 0; i &lt; (6 - freq-&gt;e); i++) {
-			mult *= 10;
-		}
-
-		for (i = 0; i &lt; NUM_CHANNELS; i++) {
-			if (freq-&gt;m == (channel_frequency[i] * mult))
-				chan = i + 1;
-		}
-	}
-
-	if (chan &lt; 1 || !dev-&gt;domain) {
-		/* non-positive channels are invalid
-		 * we need a domain info to set the channel
-		 * either that or an invalid frequency was
-		 * provided by the user */
-		ret = -EINVAL;
-	} else if (!dev-&gt;international_roaming) {
-		if (!(dev-&gt;domain-&gt;channel_map &amp; (1 &lt;&lt; (chan - 1)))) {
-			info(&quot;%s: channel %d not allowed for domain %s &quot;
-			     &quot;(and international_roaming is OFF)&quot;,
-			     dev-&gt;netdev-&gt;name, chan, dev-&gt;domain-&gt;name);
-			ret = -EINVAL;
-		}
-	}
-
-	if (ret == -EIWCOMMIT) {
-		dev-&gt;channel = chan;
-		at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWFREQ - ch %d&quot;, netdev-&gt;name, chan);
-	}
-
-	return ret;
-}
-
-static int at76_iw_handler_get_freq(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_freq *freq, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	freq-&gt;m = dev-&gt;channel;
-	freq-&gt;e = 0;
-
-	if (dev-&gt;channel) {
-		at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWFREQ - freq %ld x 10e%d&quot;,
-		         netdev-&gt;name, channel_frequency[dev-&gt;channel - 1], 6);
-	}
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWFREQ - ch %d&quot;, netdev-&gt;name, dev-&gt;channel);
-
-	return 0;
-}
-
-static int at76_iw_handler_set_mode(struct net_device *netdev,
-					struct iw_request_info *info,
-					__u32 * mode, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWMODE - %d&quot;, netdev-&gt;name, *mode);
-
-	if ((*mode != IW_MODE_ADHOC) &amp;&amp; (*mode != IW_MODE_INFRA) &amp;&amp;
-	    (*mode != IW_MODE_MONITOR)) {
-		ret = -EINVAL;
-	} else {
-		dev-&gt;iw_mode = *mode;
-		if( dev-&gt;iw_mode != IW_MODE_INFRA)
-			dev-&gt;pm_mode = AT76_PM_OFF;
-	}
-	return ret;
-}
-
-static int at76_iw_handler_get_mode(struct net_device *netdev,
-					struct iw_request_info *info,
-					__u32 * mode, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	*mode = dev-&gt;iw_mode;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWMODE - %d&quot;, netdev-&gt;name, *mode);
-
-	return 0;
-}
-
-static int at76_iw_handler_get_range(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_point *data, char *extra)
-{
-	/* inspired by atmel.c */
-	struct at76_priv *dev = netdev_priv(netdev);
-	struct iw_range *range = (struct iw_range *)extra;
-	int i;
-
-	data-&gt;length = sizeof(struct iw_range);
-	memset(range, 0, sizeof(struct iw_range));
-
-	/* TODO: range-&gt;throughput = xxxxxx; */
-
-	range-&gt;min_nwid = 0x0000;
-	range-&gt;max_nwid = 0x0000;
-
-	/* this driver doesn't maintain sensitivity information */
-	range-&gt;sensitivity = 0;
-
-	range-&gt;max_qual.qual = 100;
-	range-&gt;max_qual.level = 100;
-	range-&gt;max_qual.noise = 0;
-	range-&gt;max_qual.updated = IW_QUAL_NOISE_INVALID;
-
-	range-&gt;avg_qual.qual = 50;
-	range-&gt;avg_qual.level = 50;
-	range-&gt;avg_qual.noise = 0;
-	range-&gt;avg_qual.updated = IW_QUAL_NOISE_INVALID;
-
-	range-&gt;bitrate[0] = 1000000;
-	range-&gt;bitrate[1] = 2000000;
-	range-&gt;bitrate[2] = 5500000;
-	range-&gt;bitrate[3] = 11000000;
-	range-&gt;num_bitrates = 4;
-
-	range-&gt;min_rts = 0;
-	range-&gt;max_rts = MAX_RTS_THRESHOLD;
-
-	range-&gt;min_frag = MIN_FRAG_THRESHOLD;
-	range-&gt;max_frag = MAX_FRAG_THRESHOLD;
-
-	range-&gt;pmp_flags = IW_POWER_PERIOD;
-	range-&gt;pmt_flags = IW_POWER_ON;
-	range-&gt;pm_capa = IW_POWER_PERIOD | IW_POWER_ALL_R;
-
-	range-&gt;encoding_size[0] = WEP_SMALL_KEY_LEN;
-	range-&gt;encoding_size[1] = WEP_LARGE_KEY_LEN;
-	range-&gt;num_encoding_sizes = 2;
-	range-&gt;max_encoding_tokens = WEP_KEYS;
-
-	/* both WL-240U and Linksys WUSB11 v2.6 specify 15 dBm as output power
-	   - take this for all (ignore antenna gains) */
-	range-&gt;txpower[0] = 15;
-	range-&gt;num_txpower = 1;
-	range-&gt;txpower_capa = IW_TXPOW_DBM;
-
-	range-&gt;we_version_source = WIRELESS_EXT;
-	range-&gt;we_version_compiled = WIRELESS_EXT;
-
-	/* same as the values used in atmel.c */
-	range-&gt;retry_capa = IW_RETRY_LIMIT;
-	range-&gt;retry_flags = IW_RETRY_LIMIT;
-	range-&gt;r_time_flags = 0;
-	range-&gt;min_retry = 1;
-	range-&gt;max_retry = 255;
-
-
-	range-&gt;num_channels = NUM_CHANNELS;
-	range-&gt;num_frequency = 0;
-
-	for (i = 0; i &lt; NUM_CHANNELS; i++) {
-		/* test if channel map bit is raised */
-		if (dev-&gt;domain-&gt;channel_map &amp; (0x1 &lt;&lt; i)) {
-			range-&gt;num_frequency += 1;
-
-			range-&gt;freq[i].i = i + 1;
-			range-&gt;freq[i].m = channel_frequency[i] * 100000;
-			range-&gt;freq[i].e = 1;	/* channel frequency*100000 * 10^1 */
-		}
-	}
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWRANGE&quot;, netdev-&gt;name);
-
-	return 0;
-}
-
-static int at76_iw_handler_set_spy(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = 0;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWSPY - number of addresses %d&quot;,
-	         netdev-&gt;name, data-&gt;length);
-
-	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
-	ret = iw_handler_set_spy(dev-&gt;netdev, info, (union iwreq_data *)data,
-				 extra);
-	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
-
-	return ret;
-}
-
-static int at76_iw_handler_get_spy(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct iw_point *data, char *extra)
-{
-
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = 0;
-
-	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
-	ret = iw_handler_get_spy(dev-&gt;netdev, info,
-				 (union iwreq_data *)data, extra);
-	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWSPY - number of addresses %d&quot;,
-	         netdev-&gt;name, data-&gt;length);
-
-	return ret;
-}
-
-static int at76_iw_handler_set_thrspy(struct net_device *netdev,
-					  struct iw_request_info *info,
-					  struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWTHRSPY - number of addresses %d)&quot;,
-	         netdev-&gt;name, data-&gt;length);
-
-	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
-	ret = iw_handler_set_thrspy(netdev, info, (union iwreq_data *)data,
-				    extra);
-	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
-
-	return ret;
-}
-
-static int at76_iw_handler_get_thrspy(struct net_device *netdev,
-					  struct iw_request_info *info,
-					  struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret;
-
-	spin_lock_bh(&amp;(dev-&gt;spy_spinlock));
-	ret = iw_handler_get_thrspy(netdev, info, (union iwreq_data *)data,
-				    extra);
-	spin_unlock_bh(&amp;(dev-&gt;spy_spinlock));
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWTHRSPY - number of addresses %d)&quot;,
-	         netdev-&gt;name, data-&gt;length);
-
-	return ret;
-}
-
-static int at76_iw_handler_set_wap(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct sockaddr *ap_addr, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWAP - wap/bssid %s&quot;, netdev-&gt;name,
-	         mac2str(ap_addr-&gt;sa_data));
-
-	/* if the incoming address == ff:ff:ff:ff:ff:ff, the user has
-	   chosen any or auto AP preference */
-	if (is_broadcast_ether_addr(ap_addr-&gt;sa_data)
-	    || is_zero_ether_addr(ap_addr-&gt;sa_data)) {
-		dev-&gt;wanted_bssid_valid = 0;
-	} else {
-		/* user wants to set a preferred AP address */
-		dev-&gt;wanted_bssid_valid = 1;
-		memcpy(dev-&gt;wanted_bssid, ap_addr-&gt;sa_data, ETH_ALEN);
-	}
-
-	return -EIWCOMMIT;
-}
-
-static int at76_iw_handler_get_wap(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct sockaddr *ap_addr, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	ap_addr-&gt;sa_family = ARPHRD_ETHER;
-	memcpy(ap_addr-&gt;sa_data, dev-&gt;bssid, ETH_ALEN);
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWAP - wap/bssid %s&quot;, netdev-&gt;name,
-	         mac2str(ap_addr-&gt;sa_data));
-
-	return 0;
-}
-
-static int at76_iw_handler_set_scan(struct net_device *netdev,
-					struct iw_request_info *info,
-					union iwreq_data *wrqu, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	unsigned long flags;
-	int ret = 0;
-	struct iw_scan_req *req = NULL;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWSCAN&quot;, netdev-&gt;name);
-
-	if (!netif_running(netdev))
-		return -ENETDOWN;
-
-	/* jal: we don't allow &quot;iwlist ethX scan&quot; while we are
-	   in monitor mode */
-	if (dev-&gt;iw_mode == IW_MODE_MONITOR)
-		return -EBUSY;
-
-	/* Discard old scan results */
-	if ((jiffies - dev-&gt;last_scan) &gt; (20 * HZ))
-		dev-&gt;scan_state = SCAN_IDLE;
-	dev-&gt;last_scan = jiffies;
-
-	/* Initiate a scan command */
-	if (dev-&gt;scan_state == SCAN_IN_PROGRESS)
-		return -EBUSY;
-
-	dev-&gt;scan_state = SCAN_IN_PROGRESS;
-
-	/* stop pending management stuff */
-	del_timer_sync(&amp;(dev-&gt;mgmt_timer));
-
-	spin_lock_irqsave(&amp;(dev-&gt;mgmt_spinlock), flags);
-	if (dev-&gt;next_mgmt_bulk) {
-		kfree(dev-&gt;next_mgmt_bulk);
-		dev-&gt;next_mgmt_bulk = NULL;
-	}
-	spin_unlock_irqrestore(&amp;(dev-&gt;mgmt_spinlock), flags);
-
-	if (netif_running(dev-&gt;netdev)) {
-		/* pause network activity */
-		netif_carrier_off(dev-&gt;netdev);
-		netif_stop_queue(dev-&gt;netdev);
-	}
-	/* Try to do passive or active scan if WE asks as. */
-	if (wrqu-&gt;data.length
-	    &amp;&amp; wrqu-&gt;data.length == sizeof(struct iw_scan_req)) {
-		req = (struct iw_scan_req *)extra;
-
-		if (req-&gt;scan_type == IW_SCAN_TYPE_PASSIVE)
-			dev-&gt;scan_mode = SCAN_TYPE_PASSIVE;
-		else if (req-&gt;scan_type == IW_SCAN_TYPE_ACTIVE)
-			dev-&gt;scan_mode = SCAN_TYPE_ACTIVE;
-
-		/* Sanity check values? */
-		if (req-&gt;min_channel_time &gt; 0) {
-			if (dev-&gt;istate == MONITORING)
-				dev-&gt;monitor_scan_min_time =
-				    req-&gt;min_channel_time;
-			else
-				dev-&gt;scan_min_time = req-&gt;min_channel_time;
-		}
-		if (req-&gt;max_channel_time &gt; 0) {
-			if (dev-&gt;istate == MONITORING)
-				dev-&gt;monitor_scan_max_time =
-				    req-&gt;max_channel_time;
-			else
-				dev-&gt;scan_max_time = req-&gt;max_channel_time;
-		}
-	}
-
-	/* change to scanning state */
-	dev-&gt;istate = SCANNING;
-	schedule_work(&amp;dev-&gt;work_scan);
-
-	return ret;
-}
-
-static int at76_iw_handler_get_scan(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	unsigned long flags;
-	struct list_head *lptr, *nptr;
-	struct bss_info *curr_bss;
-	struct iw_event *iwe = kmalloc(sizeof(struct iw_event), GFP_KERNEL);
-	char *curr_val, *curr_pos = extra;
-	int i;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWSCAN&quot;, netdev-&gt;name);
-
-	if (!iwe)
-		return -ENOMEM;
-
-	if (dev-&gt;scan_state != SCAN_COMPLETED)
-		/* scan not yet finished */
-		return -EAGAIN;
-
-	spin_lock_irqsave(&amp;(dev-&gt;bss_list_spinlock), flags);
-
-	list_for_each_safe(lptr, nptr, &amp;(dev-&gt;bss_list)) {
-		curr_bss = list_entry(lptr, struct bss_info, list);
-
-		iwe-&gt;cmd = SIOCGIWAP;
-		iwe-&gt;u.ap_addr.sa_family = ARPHRD_ETHER;
-		memcpy(iwe-&gt;u.ap_addr.sa_data, curr_bss-&gt;bssid, 6);
-		curr_pos = iwe_stream_add_event(curr_pos,
-						extra + IW_SCAN_MAX_DATA, iwe,
-						IW_EV_ADDR_LEN);
-
-		iwe-&gt;u.data.length = curr_bss-&gt;ssid_len;
-		iwe-&gt;cmd = SIOCGIWESSID;
-		iwe-&gt;u.data.flags = 1;
-
-		curr_pos = iwe_stream_add_point(curr_pos,
-			extra + IW_SCAN_MAX_DATA, iwe, curr_bss-&gt;ssid);
-
-		iwe-&gt;cmd = SIOCGIWMODE;
-		iwe-&gt;u.mode = (curr_bss-&gt;capa &amp; WLAN_CAPABILITY_IBSS) ?
-		    IW_MODE_ADHOC :
-		    (curr_bss-&gt;capa &amp; WLAN_CAPABILITY_ESS) ?
-		    IW_MODE_MASTER : IW_MODE_AUTO;
-		/* IW_MODE_AUTO = 0 which I thought is
-		 * the most logical value to return in this case */
-		curr_pos = iwe_stream_add_event(curr_pos,
-						extra + IW_SCAN_MAX_DATA, iwe,
-						IW_EV_UINT_LEN);
-
-		iwe-&gt;cmd = SIOCGIWFREQ;
-		iwe-&gt;u.freq.m = curr_bss-&gt;channel;
-		iwe-&gt;u.freq.e = 0;
-		curr_pos = iwe_stream_add_event(curr_pos,
-						extra + IW_SCAN_MAX_DATA, iwe,
-						IW_EV_FREQ_LEN);
-
-		iwe-&gt;cmd = SIOCGIWENCODE;
-		if (curr_bss-&gt;capa &amp; WLAN_CAPABILITY_PRIVACY) {
-			iwe-&gt;u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
-		} else {
-			iwe-&gt;u.data.flags = IW_ENCODE_DISABLED;
-		}
-		iwe-&gt;u.data.length = 0;
-		curr_pos = iwe_stream_add_point(curr_pos,
-						extra + IW_SCAN_MAX_DATA, iwe,
-						NULL);
-
-		/* Add quality statistics */
-		iwe-&gt;cmd = IWEVQUAL;
-		iwe-&gt;u.qual.noise = 0;
-		iwe-&gt;u.qual.updated =
-		    IW_QUAL_NOISE_INVALID | IW_QUAL_LEVEL_UPDATED;
-		iwe-&gt;u.qual.level = (curr_bss-&gt;rssi * 100 / 42);
-		if (iwe-&gt;u.qual.level &gt; 100)
-			iwe-&gt;u.qual.level = 100;
-		if ((dev-&gt;board_type == BOARDTYPE_503_INTERSIL_3861) ||
-		    (dev-&gt;board_type == BOARDTYPE_503_INTERSIL_3863)) {
-			iwe-&gt;u.qual.qual = curr_bss-&gt;link_qual;
-		} else {
-			iwe-&gt;u.qual.qual = 0;
-			iwe-&gt;u.qual.updated |= IW_QUAL_QUAL_INVALID;
-		}
-		/* Add new value to event */
-		curr_pos = iwe_stream_add_event(curr_pos,
-						extra + IW_SCAN_MAX_DATA, iwe,
-						IW_EV_QUAL_LEN);
-
-		/* Rate : stuffing multiple values in a single event require a bit
-		 * more of magic - Jean II */
-		curr_val = curr_pos + IW_EV_LCP_LEN;
-
-		iwe-&gt;cmd = SIOCGIWRATE;
-		/* Those two flags are ignored... */
-		iwe-&gt;u.bitrate.fixed = iwe-&gt;u.bitrate.disabled = 0;
-		/* Max 8 values */
-		for (i = 0; i &lt; curr_bss-&gt;rates_len; i++) {
-			/* Bit rate given in 500 kb/s units (+ 0x80) */
-			iwe-&gt;u.bitrate.value =
-			    ((curr_bss-&gt;rates[i] &amp; 0x7f) * 500000);
-			/* Add new value to event */
-			curr_val = iwe_stream_add_value(curr_pos, curr_val,
-							extra +
-							IW_SCAN_MAX_DATA, iwe,
-							IW_EV_PARAM_LEN);
-		}
-
-		/* Check if we added any event */
-		if ((curr_val - curr_pos) &gt; IW_EV_LCP_LEN)
-			curr_pos = curr_val;
-
-		/* more information may be sent back using IWECUSTOM */
-
-	}
-
-	spin_unlock_irqrestore(&amp;(dev-&gt;bss_list_spinlock), flags);
-
-	data-&gt;length = (curr_pos - extra);
-	data-&gt;flags = 0;
-
-	kfree(iwe);
-	return 0;
-}
-
-static int at76_iw_handler_set_essid(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWESSID - %s&quot;, netdev-&gt;name, extra);
-
-	if (data-&gt;flags) {
-		memcpy(dev-&gt;essid, extra, data-&gt;length);
-		dev-&gt;essid_size = data-&gt;length;
-	} else {
-		/* Use any SSID */
-		dev-&gt;essid_size = 0;
-	}
-
-	return -EIWCOMMIT;
-}
-
-static int at76_iw_handler_get_essid(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_point *data, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	if (dev-&gt;essid_size) {
-		/* not the ANY ssid in dev-&gt;essid */
-		data-&gt;flags = 1;
-		data-&gt;length = dev-&gt;essid_size;
-		memcpy(extra, dev-&gt;essid, data-&gt;length);
-		extra[data-&gt;length] = '\0';
-		data-&gt;length += 1;
-	} else {
-		/* the ANY ssid was specified */
-		if (dev-&gt;istate == CONNECTED &amp;&amp; dev-&gt;curr_bss != NULL) {
-			/* report the SSID we have found */
-			data-&gt;flags = 1;
-			data-&gt;length = dev-&gt;curr_bss-&gt;ssid_len;
-			memcpy(extra, dev-&gt;curr_bss-&gt;ssid, data-&gt;length);
-			extra[dev-&gt;curr_bss-&gt;ssid_len] = '\0';
-			data-&gt;length += 1;
-		} else {
-			/* report ANY back */
-			data-&gt;flags = 0;
-			data-&gt;length = 0;
-		}
-	}
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWESSID - %s&quot;, netdev-&gt;name, extra);
-
-	return 0;
-}
-
-static int at76_iw_handler_set_rate(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_param *bitrate, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWRATE - %d&quot;, netdev-&gt;name, bitrate-&gt;value);
-
-	switch (bitrate-&gt;value) {
-	case -1:
-		dev-&gt;txrate = TX_RATE_AUTO;
-		break;		/* auto rate */
-	case 1000000:
-		dev-&gt;txrate = TX_RATE_1MBIT;
-		break;
-	case 2000000:
-		dev-&gt;txrate = TX_RATE_2MBIT;
-		break;
-	case 5500000:
-		dev-&gt;txrate = TX_RATE_5_5MBIT;
-		break;
-	case 11000000:
-		dev-&gt;txrate = TX_RATE_11MBIT;
-		break;
-	default:
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static int at76_iw_handler_get_rate(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_param *bitrate, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = 0;
-
-	switch (dev-&gt;txrate) {
-		/* return max rate if RATE_AUTO */
-	case TX_RATE_AUTO:
-		bitrate-&gt;value = 11000000;
-		break;
-	case TX_RATE_1MBIT:
-		bitrate-&gt;value = 1000000;
-		break;
-	case TX_RATE_2MBIT:
-		bitrate-&gt;value = 2000000;
-		break;
-	case TX_RATE_5_5MBIT:
-		bitrate-&gt;value = 5500000;
-		break;
-	case TX_RATE_11MBIT:
-		bitrate-&gt;value = 11000000;
-		break;
-	default:
-		ret = -EINVAL;
-	}
-
-	bitrate-&gt;fixed = (dev-&gt;txrate != TX_RATE_AUTO);
-	bitrate-&gt;disabled = 0;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWRATE - %d&quot;, netdev-&gt;name,
-	         bitrate-&gt;value);
-
-	return ret;
-}
-
-static int at76_iw_handler_set_rts(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct iw_param *rts, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = -EIWCOMMIT;
-	int rthr = rts-&gt;value;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWRTS - value %d disabled %s&quot;,
-		 netdev-&gt;name, rts-&gt;value, (rts-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
-
-	if (rts-&gt;disabled)
-		rthr = MAX_RTS_THRESHOLD;
-
-	if ((rthr &lt; 0) || (rthr &gt; MAX_RTS_THRESHOLD)) {
-		ret = -EINVAL;
-	} else {
-		dev-&gt;rts_threshold = rthr;
-	}
-
-	return ret;
-}
-
-static int at76_iw_handler_get_rts(struct net_device *netdev,
-				       struct iw_request_info *info,
-				       struct iw_param *rts, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	rts-&gt;value = dev-&gt;rts_threshold;
-	rts-&gt;disabled = (rts-&gt;value &gt;= MAX_RTS_THRESHOLD);
-	rts-&gt;fixed = 1;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWRTS - value %d disabled %s&quot;,
-	         netdev-&gt;name, rts-&gt;value, (rts-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
-
-	return 0;
-}
-
-static int at76_iw_handler_set_frag(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_param *frag, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = -EIWCOMMIT;
-	int fthr = frag-&gt;value;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWFRAG - value %d, disabled %s&quot;,
-	         netdev-&gt;name, frag-&gt;value, (frag-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
-
-	if (frag-&gt;disabled)
-		fthr = MAX_FRAG_THRESHOLD;
-
-	if ((fthr &lt; MIN_FRAG_THRESHOLD) || (fthr &gt; MAX_FRAG_THRESHOLD)) {
-		ret = -EINVAL;
-	} else {
-		dev-&gt;frag_threshold = fthr &amp; ~0x1; /* get an even value */
-	}
-
-	return ret;
-}
-
-static int at76_iw_handler_get_frag(struct net_device *netdev,
-					struct iw_request_info *info,
-					struct iw_param *frag, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	frag-&gt;value = dev-&gt;frag_threshold;
-	frag-&gt;disabled = (frag-&gt;value &gt;= MAX_FRAG_THRESHOLD);
-	frag-&gt;fixed = 1;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWFRAG - value %d, disabled %s&quot;,
-	         netdev-&gt;name, frag-&gt;value, (frag-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;);
-
-	return 0;
-}
-
-static int at76_iw_handler_get_txpow(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_param *power, char *extra)
-{
-	power-&gt;value = 15;
-	power-&gt;fixed = 1;	/* No power control */
-	power-&gt;disabled = 0;
-	power-&gt;flags = IW_TXPOW_DBM;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWTXPOW - txpow %d dBm&quot;, netdev-&gt;name,
-	         power-&gt;value);
-
-	return 0;
-}
-
-/* jal: short retry is handled by the firmware (at least 0.90.x),
-   while long retry is not (?) */
-static int at76_iw_handler_set_retry(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_param *retry, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWRETRY disabled %d  flags x%x val %d&quot;,
-	         netdev-&gt;name, retry-&gt;disabled, retry-&gt;flags, retry-&gt;value);
-
-	if (!retry-&gt;disabled &amp;&amp; (retry-&gt;flags &amp; IW_RETRY_LIMIT)) {
-		if ((retry-&gt;flags &amp; IW_RETRY_MIN) ||
-		    !(retry-&gt;flags &amp; IW_RETRY_MAX)) {
-			dev-&gt;short_retry_limit = retry-&gt;value;
-		} else
-			ret = -EINVAL;
-	} else {
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-/* adapted (ripped) from atmel.c */
-static int at76_iw_handler_get_retry(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_param *retry, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWRETRY&quot;, netdev-&gt;name);
-
-	retry-&gt;disabled = 0;      /* Can't be disabled */
-
-
-	retry-&gt;flags = IW_RETRY_LIMIT;
-	retry-&gt;value = dev-&gt;short_retry_limit;
-
-	return 0;
-}
-
-static int at76_iw_handler_set_encode(struct net_device *netdev,
-					  struct iw_request_info *info,
-					  struct iw_point *encoding,
-					  char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int index = (encoding-&gt;flags &amp; IW_ENCODE_INDEX) - 1;
-	int len = encoding-&gt;length;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWENCODE - enc.flags %08x &quot;
-	         &quot;pointer %p len %d&quot;, netdev-&gt;name, encoding-&gt;flags,
-	         encoding-&gt;pointer, encoding-&gt;length);
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWENCODE - old wepstate: enabled %s key_id %d &quot;
-	         &quot;auth_mode %s&quot;,
-	         netdev-&gt;name, (dev-&gt;wep_enabled) ? &quot;true&quot; : &quot;false&quot;,
-	         dev-&gt;wep_key_id,
-	         (dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ? &quot;restricted&quot; : &quot;open&quot;);
-
-	/* take the old default key if index is invalid */
-	if ((index &lt; 0) || (index &gt;= WEP_KEYS))
-		index = dev-&gt;wep_key_id;
-
-	if (len &gt; 0) {
-		if (len &gt; WEP_LARGE_KEY_LEN)
-			len = WEP_LARGE_KEY_LEN;
-
-		memset(dev-&gt;wep_keys[index], 0, WEP_KEY_LEN);
-		memcpy(dev-&gt;wep_keys[index], extra, len);
-		dev-&gt;wep_keys_len[index] = (len &lt;= WEP_SMALL_KEY_LEN) ?
-		    WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN;
-		dev-&gt;wep_enabled = 1;
-	}
-
-	dev-&gt;wep_key_id = index;
-	dev-&gt;wep_enabled = ((encoding-&gt;flags &amp; IW_ENCODE_DISABLED) == 0);
-
-	if (encoding-&gt;flags &amp; IW_ENCODE_RESTRICTED)
-		dev-&gt;auth_mode = WLAN_AUTH_SHARED_KEY;
-	if (encoding-&gt;flags &amp; IW_ENCODE_OPEN)
-		dev-&gt;auth_mode = WLAN_AUTH_OPEN;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWENCODE - new wepstate: enabled %s key_id %d &quot;
-	         &quot;key_len %d auth_mode %s&quot;,
-	         netdev-&gt;name, (dev-&gt;wep_enabled) ? &quot;true&quot; : &quot;false&quot;,
-	         dev-&gt;wep_key_id + 1, dev-&gt;wep_keys_len[dev-&gt;wep_key_id],
-	         (dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ? &quot;restricted&quot; : &quot;open&quot;);
-
-	return -EIWCOMMIT;
-}
-
-static int at76_iw_handler_get_encode(struct net_device *netdev,
-					  struct iw_request_info *info,
-					  struct iw_point *encoding,
-					  char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int index = (encoding-&gt;flags &amp; IW_ENCODE_INDEX) - 1;
-
-	if ((index &lt; 0) || (index &gt;= WEP_KEYS))
-		index = dev-&gt;wep_key_id;
-
-	encoding-&gt;flags =
-	    (dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ?
-	    IW_ENCODE_RESTRICTED : IW_ENCODE_OPEN;
-
-	if (!dev-&gt;wep_enabled)
-		encoding-&gt;flags |= IW_ENCODE_DISABLED;
-
-	if (encoding-&gt;pointer) {
-		encoding-&gt;length = dev-&gt;wep_keys_len[index];
-
-		memcpy(extra, dev-&gt;wep_keys[index], dev-&gt;wep_keys_len[index]);
-
-		encoding-&gt;flags |= (index + 1);
-	}
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWENCODE - enc.flags %08x &quot;
-		&quot;pointer %p len %d&quot;, netdev-&gt;name, encoding-&gt;flags,
-		encoding-&gt;pointer, encoding-&gt;length);
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWENCODE - wepstate: enabled %s key_id %d &quot;
-		&quot;key_len %d auth_mode %s&quot;,
-		netdev-&gt;name, (dev-&gt;wep_enabled) ? &quot;true&quot; : &quot;false&quot;,
-		dev-&gt;wep_key_id + 1, dev-&gt;wep_keys_len[dev-&gt;wep_key_id],
-		(dev-&gt;auth_mode == WLAN_AUTH_SHARED_KEY) ?
-			&quot;restricted&quot; : &quot;open&quot;);
-
-	return 0;
-}
-
-static int at76_iw_handler_set_power(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_param *prq, char *extra)
-{
-	int err = -EIWCOMMIT;
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCSIWPOWER - disabled %s flags x%x value x%x&quot;,
-		 netdev-&gt;name, (prq-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;,
-		 prq-&gt;flags, prq-&gt;value);
-
-	if (prq-&gt;disabled) {
-		dev-&gt;pm_mode = AT76_PM_OFF;
-	} else {
-		switch (prq-&gt;flags &amp; IW_POWER_MODE) {
-                case IW_POWER_ALL_R:
-		case IW_POWER_ON:
-                        break;
-		default:
-			err = -EINVAL;
-			goto out;
-		}
-		if (prq-&gt;flags &amp; IW_POWER_PERIOD) {
-			dev-&gt;pm_period = prq-&gt;value;
-		}
-		if (prq-&gt;flags &amp; IW_POWER_TIMEOUT) {
-			err = -EINVAL;
-			goto out;
-		}
-		dev-&gt;pm_mode = AT76_PM_ON;
-	}
-out:
-	return err;
-}
-
-static int at76_iw_handler_get_power(struct net_device *netdev,
-					 struct iw_request_info *info,
-					 struct iw_param *power, char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	if ((power-&gt;disabled = (dev-&gt;pm_mode == AT76_PM_OFF)))
-		return 0;
-	else {
-		power-&gt;flags = IW_POWER_PERIOD;
-		power-&gt;value = dev-&gt;pm_period;
-	}
-	power-&gt;flags |= IW_POWER_ALL_R;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: SIOCGIWPOWER - disabled %s flags x%x value x%x&quot;,
-		 netdev-&gt;name, (power-&gt;disabled) ? &quot;true&quot; : &quot;false&quot;,
-		 power-&gt;flags, power-&gt;value);
-
-	return 0;
-}
-
-
-/*******************************************************************************
- * Private IOCTLS
- */
-static int at76_iw_set_short_preamble(struct net_device *netdev,
-				      struct iw_request_info *info, char *name,
-				      char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int val = *((int *)name);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: AT76_SET_SHORT_PREAMBLE, %d&quot;,
-	         netdev-&gt;name, val);
-
-	if (val &lt; 0 || val &gt; 2) {
-		/* allow value of 2 - in the win98 driver it stands
-		   for &quot;auto preamble&quot; ...? */
-		ret = -EINVAL;
-	} else {
-		dev-&gt;preamble_type = val;
-	}
-
-	return ret;
-}
-
-static int at76_iw_set_debug(struct net_device *netdev,
-			     struct iw_request_info *info,
-			     struct iw_point *data, char *extra)
-{
-	char *ptr;
-	u32 val;
-
-	if (data-&gt;length &gt; 0) {
-		val = simple_strtol(extra, &amp;ptr, 0);
-
-		if (ptr == extra) {
-			val = DBG_DEFAULTS;
-		}
-
-		dbg(&quot;%s: AT76_SET_DEBUG input %d: %s -&gt; x%x&quot;,
-		       netdev-&gt;name, data-&gt;length, extra, val);
-	} else {
-		val = DBG_DEFAULTS;
-	}
-
-	dbg(&quot;%s: AT76_SET_DEBUG, old 0x%x  new 0x%x&quot;,
-	       netdev-&gt;name, at76_debug, val);
-
-	/* jal: some more output to pin down lockups */
-	dbg(&quot;%s: netif running %d queue_stopped %d carrier_ok %d&quot;,
-	       netdev-&gt;name,
-	       netif_running(netdev),
-	       netif_queue_stopped(netdev), netif_carrier_ok(netdev));
-
-	at76_debug = val;
-
-	return 0;
-}
-
-static int at76_iw_set_powersave_mode(struct net_device *netdev,
-				      struct iw_request_info *info, char *name,
-				      char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int val = *((int *)name);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: AT76_SET_POWERSAVE_MODE, %d (%s)&quot;,
-	         netdev-&gt;name, val,
-	         val == AT76_PM_OFF ? &quot;active&quot; : val == AT76_PM_ON ? &quot;save&quot; :
-	         val == AT76_PM_SMART ? &quot;smart save&quot; : &quot;&lt;invalid&gt;&quot;);
-	if (val &lt; AT76_PM_OFF || val &gt; AT76_PM_SMART) {
-		ret = -EINVAL;
-	} else {
-		dev-&gt;pm_mode = val;
-	}
-
-	return ret;
-}
-
-static int at76_iw_set_scan_times(struct net_device *netdev,
-				  struct iw_request_info *info, char *name,
-				  char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int mint = *((int *)name);
-	int maxt = *((int *)name + 1);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: AT76_SET_SCAN_TIMES - min %d max %d&quot;,
-	         netdev-&gt;name, mint, maxt);
-	if (mint &lt;= 0 || maxt &lt;= 0 || mint &gt; maxt) {
-		ret = -EINVAL;
-	} else {
-		if (dev-&gt;istate == MONITORING) {
-			dev-&gt;monitor_scan_min_time = mint;
-			dev-&gt;monitor_scan_max_time = maxt;
-			ret = 0;
-		} else {
-			dev-&gt;scan_min_time = mint;
-			dev-&gt;scan_max_time = maxt;
-		}
-	}
-
-	return ret;
-}
-
-static int at76_iw_set_scan_mode(struct net_device *netdev,
-				 struct iw_request_info *info, char *name,
-				 char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int val = *((int *)name);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: AT76_SET_SCAN_MODE - mode %s&quot;,
-		 netdev-&gt;name, (val = SCAN_TYPE_ACTIVE) ? &quot;active&quot; :
-		 (val = SCAN_TYPE_PASSIVE) ? &quot;passive&quot; : &quot;&lt;invalid&gt;&quot;);
-
-	if (val != SCAN_TYPE_ACTIVE &amp;&amp; val != SCAN_TYPE_PASSIVE) {
-		ret = -EINVAL;
-	} else {
-		dev-&gt;scan_mode = val;
-	}
-
-	return ret;
-}
-
-static int at76_set_iroaming(struct at76_priv *dev, int onoff)
-{
-	int ret = 0;
-
-	memset(&amp;dev-&gt;mib_buf, 0, sizeof(struct set_mib_buffer));
-	dev-&gt;mib_buf.type = MIB_MAC_MGMT;
-	dev-&gt;mib_buf.size = 1;
-	dev-&gt;mib_buf.index = IROAMING_OFFSET;
-	dev-&gt;mib_buf.data[0] = (dev-&gt;international_roaming ? 1 : 0);
-	ret = at76_set_mib(dev, &amp;dev-&gt;mib_buf);
-	if (ret &lt; 0) {
-		err(&quot;%s: set_mib (intl_roaming_enable) failed: %d&quot;, dev-&gt;netdev-&gt;name, ret);
-	}
-
-	return ret;
-}
-
-static int at76_iw_set_intl_roaming(struct net_device *netdev,
-				    struct iw_request_info *info, char *name,
-				    char *extra)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	int val = *((int *)name);
-	int ret = -EIWCOMMIT;
-
-	at76_dbg(DBG_IOCTL, &quot;%s: AT76_SET_INTL_ROAMING - mode %s&quot;,
-	         netdev-&gt;name, (val == IR_OFF) ? &quot;off&quot; :
-	         (val == IR_ON) ? &quot;on&quot; : &quot;&lt;invalid&gt;&quot;);
-
-	if (val != IR_OFF &amp;&amp; val != IR_ON) {
-		ret = -EINVAL;
-	} else {
-		if (dev-&gt;international_roaming != val) {
-			dev-&gt;international_roaming = val;
-			at76_set_iroaming(dev, val);
-		}
-	}
-
-	return ret;
-}
-
-/**
- * set_monitor_mode - sets dev-&gt;netdev-&gt;type
- */
-static void at76_set_monitor_mode(struct at76_priv *dev)
-{
-	if (dev-&gt;iw_mode == IW_MODE_MONITOR) {
-		at76_dbg(DBG_MONITOR_MODE, &quot;%s: MONITOR MODE ON&quot;,
-			 dev-&gt;netdev-&gt;name);
-		dev-&gt;netdev-&gt;type = ARPHRD_IEEE80211_RADIOTAP;
-	} else {
-		at76_dbg(DBG_MONITOR_MODE, &quot;%s: MONITOR MODE OFF&quot;,
-		         dev-&gt;netdev-&gt;name);
-		dev-&gt;netdev-&gt;type = ARPHRD_ETHER;
-	}
-}
-
-
-/*******************************************************************************
- * structure that advertises the iw handlers of this driver
- */
-static const iw_handler	at76_handlers[] =
-{
-        [SIOCSIWCOMMIT-SIOCIWFIRST] = (iw_handler) at76_iw_handler_commit,
-        [SIOCGIWNAME  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_name,
-        [SIOCSIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_freq,
-        [SIOCGIWFREQ  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_freq,
-        [SIOCSIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_mode,
-        [SIOCGIWMODE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_mode,
-        [SIOCGIWRANGE -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_range,
-        [SIOCSIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_spy,
-        [SIOCGIWSPY   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_spy,
-        [SIOCSIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_thrspy,
-        [SIOCGIWTHRSPY-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_thrspy,
-        [SIOCSIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_wap,
-        [SIOCGIWAP    -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_wap,
-        [SIOCSIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_scan,
-        [SIOCGIWSCAN  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_scan,
-        [SIOCSIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_essid,
-        [SIOCGIWESSID -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_essid,
-        [SIOCSIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rate,
-        [SIOCGIWRATE  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rate,
-        [SIOCSIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_rts,
-        [SIOCGIWRTS   -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_rts,
-        [SIOCSIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_frag,
-        [SIOCGIWFRAG  -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_frag,
-        [SIOCGIWTXPOW -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_txpow,
-        [SIOCSIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_retry,
-        [SIOCGIWRETRY -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_retry,
-        [SIOCSIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_encode,
-        [SIOCGIWENCODE-SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_encode,
-        [SIOCSIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_set_power,
-        [SIOCGIWPOWER -SIOCIWFIRST] = (iw_handler) at76_iw_handler_get_power,
-};
-
-#define AT76_SET_PRIV(h, f) [h - SIOCIWFIRSTPRIV] = (iw_handler) f
-
-/*structure that advertises the private iw handlers of this driver */
-static const iw_handler at76_priv_handlers[] = {
-	AT76_SET_PRIV(AT76_SET_SHORT_PREAMBLE, at76_iw_set_short_preamble),
-	AT76_SET_PRIV(AT76_SET_DEBUG, at76_iw_set_debug),
-	AT76_SET_PRIV(AT76_SET_POWERSAVE_MODE, at76_iw_set_powersave_mode),
-	AT76_SET_PRIV(AT76_SET_SCAN_TIMES, at76_iw_set_scan_times),
-	AT76_SET_PRIV(AT76_SET_SCAN_MODE, at76_iw_set_scan_mode),
-	AT76_SET_PRIV(AT76_SET_INTL_ROAMING, at76_iw_set_intl_roaming),
-};
-
-static const struct iw_handler_def at76_handler_def =
-{
-	.num_standard	= ARRAY_SIZE(at76_handlers),
-	.num_private	= ARRAY_SIZE(at76_priv_handlers),
-	.num_private_args = ARRAY_SIZE(at76_priv_args),
-	.standard	= at76_handlers,
-	.private	= at76_priv_handlers,
-	.private_args	= at76_priv_args,
- 	.get_wireless_stats = at76_get_wireless_stats,
-};
-
-
-static void at76_ethtool_get_drvinfo(struct net_device *netdev,
-					 struct ethtool_drvinfo *info)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-
-	strncpy(info-&gt;driver, DRIVER_NAME, sizeof(info-&gt;driver) - 1);
-
-	strncpy(info-&gt;version, DRIVER_VERSION, sizeof(info-&gt;version));
-	info-&gt;version[sizeof(info-&gt;version) - 1] = '\0';
-
-	snprintf(info-&gt;bus_info, sizeof(info-&gt;bus_info) - 1, &quot;usb%d:%d&quot;,
-		 dev-&gt;udev-&gt;bus-&gt;busnum, dev-&gt;udev-&gt;devnum);
-
-	snprintf(info-&gt;fw_version, sizeof(info-&gt;fw_version) - 1,
-		 &quot;%d.%d.%d-%d&quot;,
-		 dev-&gt;fw_version.major, dev-&gt;fw_version.minor,
-		 dev-&gt;fw_version.patch, dev-&gt;fw_version.build);
-}
-
-static u32 at76_ethtool_get_link(struct net_device *netdev)
-{
-	struct at76_priv *dev = netdev_priv(netdev);
-	return dev-&gt;istate == CONNECTED;
-}
-
-static struct ethtool_ops at76_ethtool_ops = {
-	.get_drvinfo = at76_ethtool_get_drvinfo,
-	.get_link = at76_ethtool_get_link,
-};
-
-static void at76_delete_device(struct at76_priv *dev)
-{
-	int i;
-
-	if (!dev)
-		return;
-
-	/* signal to _stop() that the device is gone */
-	dev-&gt;device_unplugged = 1;
-
-	at76_dbg(DBG_PROC_ENTRY, &quot;%s: ENTER&quot;,__FUNCTION__);
-
-	if (dev-&gt;netdev_registered) {
-		unregister_netdev(dev-&gt;netdev);
-	}
-
-	usb_put_dev(dev-&gt;udev);
-
-	/* assuming we used keventd, it must quiesce too */
-	flush_scheduled_work();
-
-	if (dev-&gt;bulk_out_buffer != NULL)
-		kfree(dev-&gt;bulk_out_buffer);
-
-	kfree(dev-&gt;ctrl_buffer);
-
-	if (dev-&gt;write_urb != NULL) {
-		usb_kill_urb(dev-&gt;write_urb);
-		usb_free_urb(dev-&gt;write_urb);
-	}
-	if (dev-&gt;read_urb != NULL) {
-		usb_kill_urb(dev-&gt;read_urb);
-		usb_free_urb(dev-&gt;read_urb);
-	}
-	if (dev-&gt;ctrl_buffer != NULL) {
-		usb_kill_urb(dev-&gt;ctrl_urb);
-		usb_free_urb(dev-&gt;ctrl_urb);
-	}
-
-	at76_dbg(DBG_PROC_ENTRY, &quot;%s: unlinked urbs&quot;, __FUNCTION__);
-
-	if (dev-&gt;rx_skb != NULL)
-		kfree_skb(dev-&gt;rx_skb);
-
-	at76_free_bss_list(dev);
-	del_timer_sync(&amp;dev-&gt;bss_list_timer);
-
-	if (dev-&gt;istate == CONNECTED) {
-		at76_iwevent_bss_disconnect(dev-&gt;netdev);
-	}
-
-	for (i = 0; i &lt; NR_RX_DATA_BUF; i++)
-		if (dev-&gt;rx_data[i].skb != NULL) {
-			dev_kfree_skb(dev-&gt;rx_data[i].skb);
-			dev-&gt;rx_data[i].skb = NULL;
-		}
-	at76_dbg(DBG_PROC_ENTRY, &quot;%s: before freeing dev/netdev&quot;, __FUNCTION__);
-	free_netdev(dev-&gt;netdev); /* dev is in netdev */
-
-	at76_dbg(DBG_PROC_ENTRY, &quot;%s: EXIT&quot;, __FUNCTION__);
-}
-
-static int at76_alloc_urbs(struct at76_priv *dev)
-{
-	struct usb_interface *interface = dev-&gt;interface;
-	struct usb_endpoint_descriptor *endpoint;
-	struct usb_device *udev = dev-&gt;udev;
-	int i, buffer_size;
-	struct usb_host_interface *iface_desc;
-
-	at76_dbg(DBG_PROC_ENTRY, &quot;%s: ENTER&quot;, __FUNCTION__);
-
-	at76_dbg(DBG_URB, &quot;%s: NumEndpoints %d &quot;, __FUNCTION__,
-	    interface-&gt;altsetting[0].desc.bNumEndpoints);
-
-	iface_desc = interface-&gt;cur_altsetting;
-	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; i++) {
-		endpoint = &amp;iface_desc-&gt;endpoint[i].desc;
-
-		at76_dbg(DBG_URB, &quot;%s: %d. endpoint: addr x%x attr x%x&quot;,
-		    __FUNCTION__,
-		    i, endpoint-&gt;bEndpointAddress, endpoint-&gt;bmAttributes);
-
-		if ((endpoint-&gt;bEndpointAddress &amp; 0x80) &amp;&amp;
-		    ((endpoint-&gt;bmAttributes &amp; 3) == 0x02)) {
-			/* we found a bulk in endpoint */
-
-			dev-&gt;read_urb = usb_alloc_urb(0, GFP_KERNEL);
-			if (!dev-&gt;read_urb) {
-				err(&quot;No free urbs available&quot;);
-				return -ENOMEM;
-			}
-			dev-&gt;bulk_in_endpointAddr = endpoint-&gt;bEndpointAddress;
-		}
-
-		if (((endpoint-&gt;bEndpointAddress &amp; 0x80) == 0x00) &amp;&amp;
-		    ((endpoint-&gt;bmAttributes &amp; 3) == 0x02)) {
-			/* we found a bulk out endpoint */
-			dev-&gt;write_urb = usb_alloc_urb(0, GFP_KERNEL);
-			if (!dev-&gt;write_urb) {
-				err(&quot;no free urbs available&quot;);
-				return -ENOMEM;
-			}
-			buffer_size = sizeof(struct at76_tx_buffer) +
-			    MAX_PADDING_SIZE;
-			dev-&gt;bulk_out_endpointAddr = endpoint-&gt;bEndpointAddress;
-			dev-&gt;bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);
-			if (!dev-&gt;bulk_out_buffer) {
-				err(&quot;couldn't allocate bulk_out_buffer&quot;);
-				return -ENOMEM;
-			}
-			usb_fill_bulk_urb(dev-&gt;write_urb, udev,
-				          usb_sndbulkpipe(udev,
-						      endpoint-&gt;bEndpointAddress),
-				          dev-&gt;bulk_out_buffer, buffer_size,
-				          at76_write_bulk_callback, dev);
-		}
-	}
-
-	dev-&gt;ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!dev-&gt;ctrl_urb) {
-		err(&quot;no free urbs available&quot;);
-		return -ENOMEM;
-	}
-	dev-&gt;ctrl_buffer = kmalloc(1024, GFP_KERNEL);
-	if (!dev-&gt;ctrl_buffer) {
-		err(&quot;couldn't allocate ctrl_buffer&quot;);
-		return -ENOMEM;
-	}
-
-	at76_dbg(DBG_PROC_ENTRY, &quot;%s: EXIT&quot;, __FUNCTION__);
-
-	return 0;
-}
 
 static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 					       int board_type)
@@ -5912,122 +6153,6 @@ static struct at76_priv *at76_alloc_new_device(struct usb_device *udev,
 }
 
 
-/**
- * at76_init_new_device - continue device initialization after firmware download
- *
- * FIXME: We may have to move the register_netdev into at76_alloc_new_device,
- * because hotplug may try to configure the netdev _before_ (or parallel to)
- * the download of firmware
- */
-static int at76_init_new_device(struct at76_priv *dev)
-{
-	struct net_device *netdev = dev-&gt;netdev;
-	int ret;
-
-	/* set up the endpoint information */
-	/* check out the endpoints */
-
-	dev-&gt;interface = dev-&gt;udev-&gt;actconfig-&gt;interface[0];
-
-	at76_dbg(DBG_DEVSTART, &quot;USB interface: %d endpoints&quot;,
-	         dev-&gt;interface-&gt;cur_altsetting-&gt;desc.bNumEndpoints);
-
-	if ((ret = at76_alloc_urbs(dev)) &lt; 0)
-		goto error;
-
-	/* get firmware version */
-	ret = at76_get_mib(dev-&gt;udev, MIB_FW_VERSION, &amp;dev-&gt;fw_version,
-			   sizeof(dev-&gt;fw_version));
-	if ((ret &lt; 0) || ((dev-&gt;fw_version.major == 0) &amp;&amp;
-			  (dev-&gt;fw_version.minor == 0) &amp;&amp;
-			  (dev-&gt;fw_version.patch == 0) &amp;&amp;
-			  (dev-&gt;fw_version.build == 0))) {
-		err(&quot;getting firmware failed with %d, or version is 0&quot;, ret);
-		err(&quot;this probably means that the ext. fw was not loaded correctly&quot;);
-		if(ret &gt;= 0)
-			ret = -ENODEV;
-		goto error;
-	}
-
-	/* fw 0.84 doesn't send FCS with rx data */
-	if (dev-&gt;fw_version.major == 0 &amp;&amp; dev-&gt;fw_version.minor &lt;= 84)
-		dev-&gt;rx_data_fcs_len = 0;
-	else
-		dev-&gt;rx_data_fcs_len = 4;
-
-	info(&quot;firmware version %d.%d.%d #%d (fcs_len %d)&quot;,
-	     dev-&gt;fw_version.major, dev-&gt;fw_version.minor,
-	     dev-&gt;fw_version.patch, dev-&gt;fw_version.build,
-	     dev-&gt;rx_data_fcs_len);
-
-	/* MAC address */
-	ret = at76_get_hw_config(dev);
-	if (ret &lt; 0) {
-		err(&quot;could not get MAC address&quot;);
-		goto error;
-	}
-
-	dev-&gt;domain = at76_get_reg_domain(dev-&gt;regulatory_domain);
-	/* init. netdev-&gt;dev_addr */
-	memcpy(netdev-&gt;dev_addr, dev-&gt;mac_addr, ETH_ALEN);
-	info(&quot;device's MAC %s, regulatory domain %s (id %d)&quot;,
-	     mac2str(dev-&gt;mac_addr), dev-&gt;domain-&gt;name, dev-&gt;regulatory_domain);
-
-	/* initializing */
-	dev-&gt;international_roaming = international_roaming;
-	dev-&gt;channel = DEF_CHANNEL;
-	dev-&gt;iw_mode = default_iw_mode;
-	memset(dev-&gt;essid, 0, IW_ESSID_MAX_SIZE);
-	dev-&gt;rts_threshold = DEF_RTS_THRESHOLD;
-	dev-&gt;frag_threshold = DEF_FRAG_THRESHOLD;
-	dev-&gt;short_retry_limit = DEF_SHORT_RETRY_LIMIT;
-	dev-&gt;txrate = TX_RATE_AUTO;
-	dev-&gt;preamble_type = preamble_type;
-	dev-&gt;beacon_period = 100;
-	dev-&gt;beacons_last_qual = jiffies_to_msecs(jiffies);
-	dev-&gt;auth_mode = auth_mode ? WLAN_AUTH_SHARED_KEY : WLAN_AUTH_OPEN;
-	dev-&gt;scan_min_time = scan_min_time;
-	dev-&gt;scan_max_time = scan_max_time;
-	dev-&gt;scan_mode = scan_mode;
-	dev-&gt;monitor_scan_min_time = monitor_scan_min_time;
-	dev-&gt;monitor_scan_max_time = monitor_scan_max_time;
-
-	netdev-&gt;flags &amp;= ~IFF_MULTICAST; /* not yet or never */
-	netdev-&gt;open = at76_open;
-	netdev-&gt;stop = at76_stop;
-	netdev-&gt;get_stats = at76_get_stats;
-	netdev-&gt;ethtool_ops = &amp;at76_ethtool_ops;
-
-	/* Add pointers to enable iwspy support. */
-	dev-&gt;wireless_data.spy_data = &amp;dev-&gt;spy_data;
-	netdev-&gt;wireless_data = &amp;dev-&gt;wireless_data;
-
-	netdev-&gt;hard_start_xmit = at76_tx;
-	netdev-&gt;tx_timeout = at76_tx_timeout;
-	netdev-&gt;watchdog_timeo = 2 * HZ;
-	netdev-&gt;wireless_handlers = &amp;at76_handler_def;
-	netdev-&gt;set_multicast_list = at76_set_multicast;
-	netdev-&gt;set_mac_address = at76_set_mac_address;
-
-	ret = register_netdev(dev-&gt;netdev);
-	if (ret) {
-		err(&quot;unable to register netdevice %s (status %d)!&quot;,
-		    dev-&gt;netdev-&gt;name, ret);
-		goto error;
-	}
-	info(&quot;registered %s&quot;, dev-&gt;netdev-&gt;name);
-	dev-&gt;netdev_registered = 1;
-
-	/* we let this timer run the whole time this driver instance lives */
-	mod_timer(&amp;dev-&gt;bss_list_timer, jiffies + BSS_LIST_TIMEOUT);
-
-	return 0;
- error:
-	at76_delete_device(dev);
-	return ret;
-}
-
-
 /* Parse the firmware image */
 static int at76_parse_fw(struct at76_priv *dev, u8 *fw_data, int fw_size,
 			 int board_type)
@@ -6069,6 +6194,7 @@ static int at76_parse_fw(struct at76_priv *dev, u8 *fw_data, int fw_size,
 	return 0;
 }
 
+
 static int at76_probe(struct usb_interface *interface,
 		      const struct usb_device_id *id)
 {
@@ -6179,6 +6305,7 @@ static int at76_probe(struct usb_interface *interface,
 	return ret;
 }
 
+
 static void at76_disconnect(struct usb_interface *interface)
 {
 	struct at76_priv *priv;
@@ -6191,6 +6318,7 @@ static void at76_disconnect(struct usb_interface *interface)
 	info(DRIVER_NAME &quot; disconnected&quot;);
 }
 
+
 /* structure for registering this driver with the USB subsystem */
 static struct usb_driver at76_driver = {
 	.name = DRIVER_NAME,
@@ -6199,6 +6327,7 @@ static struct usb_driver at76_driver = {
 	.id_table = dev_table,
 };
 
+
 static int __init at76_mod_init(void)
 {
 	int result;
@@ -6215,6 +6344,7 @@ static int __init at76_mod_init(void)
 	return result;
 }
 
+
 static void __exit at76_mod_exit(void)
 {
 	int i;
@@ -6228,6 +6358,7 @@ static void __exit at76_mod_exit(void)
 	led_trigger_unregister_simple(ledtrig_tx);
 }
 
+
 module_param_named(debug, at76_debug, int, 0600);
 MODULE_PARM_DESC(debug, &quot;Debugging level&quot;);
 module_param(rx_copybreak, int, 0400);



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000063.html">[at76c503a-develop] [PATCH 1/6] Merge at76_do_probe() into	at76_probe()
</A></li>
	<LI>Next message: <A HREF="000064.html">[at76c503a-develop] [PATCH 4/6] Never call net_device &quot;dev&quot;,	call it &quot;netdev&quot; for readability
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65">[ date ]</a>
              <a href="thread.html#65">[ thread ]</a>
              <a href="subject.html#65">[ subject ]</a>
              <a href="author.html#65">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/at76c503a-develop">More information about the at76c503a-develop
mailing list</a><br>
</body></html>
